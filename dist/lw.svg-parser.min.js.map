{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///lw.svg-parser.min.js","webpack:///webpack/bootstrap fea28de34ee0b0e2d9ee","webpack:///../~/lw.svg-path/dist/lw.svg-path.js","webpack:///./parser.js","webpack:///./tag.js","webpack:///./tagparser.js","webpack:///../~/clipper-lib/clipper.js","webpack:///../~/lw.svg-curves/dist/lw.svg-curves.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","t","n","i","e","o","TypeError","Object","defineProperty","value","length","enumerable","configurable","writable","key","prototype","x","parseFloat","y","isNaN","console","error","Error","r","points","forEach","push","arguments","X","parseInt","Y","addPoint","getPoint","isEqual","isClosed","map","Path","Point","default","_classCallCheck","instance","Constructor","Parser","undefined","_createClass","defineProperties","target","props","descriptor","protoProps","staticProps","_tag","_tagparser","settings","element","editor","document","defs","tags","traceSettings","assign","linear","step","resolution","segmentLength","supportedTags","parseTags","includes","skipTags","excludes","onTag","onTagContext","input","loadFromString","File","loadFromFile","XMLDocument","loadFromXMLDocument","Element","loadFromElement","Promise","reject","_this","resolve","nodeName","textContent","getElementsByTagName","_this2","documentElement","then","catch","_this3","_parseEditor","parser","DOMParser","XMLDoc","parseFromString","name","version","fingerprint","match","_this4","reader","FileReader","onload","event","result","onerror","readAsText","_this5","load","parse","_parseElement","applyMatrix","tag","callback","context","_this6","_onTag","parent","_this7","Tag","indexOf","_skipTag","tagParser","TagParser","childTag","childNodes","childNode","addChild","children","message","warn","attr","_interopRequireDefault","obj","__esModule","_lw","_clipperLib","_clipperLib2","DEG_TO_RAD","Math","PI","toLowerCase","layer","attrs","paths","matrix","path","point","shapes","setMatrix","keys","setAttr","defaultValue","getAttr","getLayerName","clearPath","close","relative","il","addMatrix","angle","cos","sin","tan","transform","shape","outer","holes","hole","fillRule","PolyFillType","pftNonZero","pftEvenOdd","cPolyTree","PolyTree","cClipper","Clipper","clipperScale","clipperPaths","getClipperPoints","AddPaths","PolyType","ptSubject","Execute","ClipType","ctUnion","PolyTreeToPaths","polygones","SimplifyPolygons","Clear","StrictlySimple","toPath","fromClipperPoints","exPolygons","JS","PolyTreeToExPolygons","exPolygon","_lw2","currentCommand","lastCommand","pathData","handler","_parseTagAttrs","attributes","viewBox","getNamedItem","_normalizeTagAttrPoints","style","some","_normalizeTagAttr","replace","split","nodeValue","colorsAttrs","attrName","_parseViewBoxAttr","_parseTransformAttr","trim","_skipTagAttr","_normalizeTagAttrUnit","_normalizeTagAttrRange","_normalizeTagAttrPreserveAspectRatio","ratio","stringValue","floatValue","fontSize","_parseNumbers","min","max","filter","params","defer","align","meet","slice","rawParams","substr","width","height","scaleX","scaleY","translateX","translateY","preserveAspectRatio","newWidth","newHeight","translate","scale","transformAttr","transformations","pop","type","raw","func","tagTransform","apply","newPath","closePath","addPoints","title","description","useTag","setLayerName","_path","shift","concat","_polyline","w","h","rx","ry","dx","dy","cx","cy","num","splice","join","dAttr","commands","parseError","toUpperCase","_clearPath","_newPath","_addPoints","_closePath","every","_paths","p1","rl","x1","y1","x2","y2","p2","p3","p4","tracer","CubicBezier","coords","trace","QuadricBezier","large","sweep","Arc","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","BigInteger","a","b","ClipperLib","biginteger_used","fromInt","fromNumber","fromString","nbi","am1","j","v","floor","am2","xl","xh","l","am3","int2char","BI_RM","charAt","intAt","s","BI_RC","charCodeAt","bnpCopyTo","bnpFromInt","DV","nbv","bnpFromString","k","fromRadix","mi","sh","DB","clamp","ZERO","subTo","bnpClamp","DM","bnToString","negate","toString","toRadix","d","km","bnNegate","bnAbs","bnCompareTo","nbits","bnBitLength","bnpDLShiftTo","bnpDRShiftTo","bnpLShiftTo","bs","cbs","bm","ds","bnpRShiftTo","bnpSubTo","bnpMultiplyTo","abs","am","bnpSquareTo","bnpDivRemTo","q","pm","pt","copyTo","ts","ms","nsh","lShiftTo","ys","y0","yt","F1","F2","d1","FV","d2","dlShiftTo","compareTo","ONE","qd","drShiftTo","rShiftTo","bnMod","divRemTo","Classic","cConvert","mod","cRevert","cReduce","cMulTo","multiplyTo","reduce","cSqrTo","squareTo","bnpInvDigit","Montgomery","mp","invDigit","mpl","mph","um","mt2","montConvert","montRevert","montReduce","u0","montSqrTo","montMulTo","bnpIsEven","bnpExp","z","r2","g","convert","sqrTo","mulTo","revert","bnModPowInt","isEven","exp","bnClone","bnIntValue","bnByteValue","bnShortValue","bnpChunkSize","LN2","log","bnSigNum","bnpToRadix","signum","cs","chunkSize","pow","intValue","bnpFromRadix","dMultiply","dAddOffset","bnpFromNumber","testBit","bitwiseTo","shiftLeft","op_or","isProbablePrime","bitLength","Array","nextBytes","bnToByteArray","bnEquals","bnMin","bnMax","bnpBitwiseTo","op","f","op_and","bnAnd","bnOr","op_xor","bnXor","op_andnot","bnAndNot","bnNot","bnShiftLeft","bnShiftRight","lbit","bnGetLowestSetBit","cbit","bnBitCount","bnTestBit","bnpChangeBit","bnSetBit","changeBit","bnClearBit","bnFlipBit","bnpAddTo","bnAdd","addTo","bnSubtract","bnMultiply","bnSquare","bnDivide","bnRemainder","bnDivideAndRemainder","bnpDMultiply","bnpDAddOffset","NullExp","nNop","nMulTo","nSqrTo","bnPow","bnpMultiplyLowerTo","bnpMultiplyUpperTo","Barrett","q3","mu","divide","barrettConvert","barrettRevert","barrettReduce","multiplyUpperTo","multiplyLowerTo","barrettSqrTo","barrettMulTo","bnModPow","k1","g2","is1","bnGCD","clone","getLowestSetBit","bnpModInt","bnModInverse","ac","u","subtract","add","bnIsProbablePrime","lowprimes","lplim","modInt","millerRabin","bnpMillerRabin","n1","shiftRight","random","modPow","modPowInt","use_int32","use_xyz","use_lines","isNode","window","self","navigator_appName","nav","navigator","userAgent","appName","browser","chrome","chromium","safari","firefox","firefox17","firefox15","firefox3","opera","msie10","msie9","msie8","msie7","msie","dbits","canary","j_lm","BI_FP","rr","vv","byteValue","shortValue","toByteArray","equals","and","or","xor","andNot","not","bitCount","setBit","clearBit","flipBit","multiply","remainder","divideAndRemainder","modInverse","gcd","square","Int128","IsNegative","op_Equality","val1","val2","op_Inequality","op_GreaterThan","op_LessThan","op_Addition","lhs","rhs","op_Subtraction","Int128Mul","op_Division","ToDouble","Inherit","ce","ce2","$baseCtor","getOwnPropertyNames","getOwnPropertyDescriptor","Paths","DoublePoint","DoublePoint0","DoublePoint1","dp","DoublePoint2","PolyNode","m_Parent","m_polygon","m_Index","m_jointype","m_endtype","m_Childs","IsOpen","IsHoleNode","node","ChildCount","Contour","AddChild","Child","cnt","GetNext","GetNextSiblingUp","Childs","Parent","IsHole","m_AllPolys","ilen","GetFirst","Total","Math_Abs_Int64","Math_Abs_Int32","Math_Abs_Double","Math_Max_Int32_Int32","Cast_Int32","Cast_Int64","ceil","Number","toInteger","PI2","IntPoint","alen","Z","Round","IntPoint0","IntPoint1","IntPoint1dp","IntPoint2","IntPoint3","IntRect","left","top","right","bottom","ir","IntRect0","IntRect1","IntRect4","ctIntersection","ctDifference","ctXor","ptClip","pftPositive","pftNegative","JoinType","jtSquare","jtRound","jtMiter","EndType","etOpenSquare","etOpenRound","etOpenButt","etClosedLine","etClosedPolygon","EdgeSide","esLeft","esRight","Direction","dRightToLeft","dLeftToRight","TEdge","Bot","Curr","Top","Delta","Dx","PolyTyp","Side","WindDelta","WindCnt","WindCnt2","OutIdx","Next","Prev","NextInLML","NextInAEL","PrevInAEL","NextInSEL","PrevInSEL","IntersectNode","Edge1","Edge2","Pt","MyIntersectNodeSort","Compare","node1","node2","LocalMinima","LeftBound","RightBound","Scanbeam","OutRec","Idx","FirstLeft","Pts","BottomPt","OutPt","Join","OutPt1","OutPt2","OffPt","ClipperBase","m_MinimaList","m_CurrentLM","m_edges","m_UseFullRange","m_HasOpenPaths","PreserveCollinear","horizontal","Skip","Unassigned","tolerance","loRange","hiRange","near_zero","val","IsHorizontal","PointIsVertex","pp","pp2","PointOnLineSegment","linePt1","linePt2","UseFullRange","PointOnPolygon","SlopesEqual","e1","e2","pt1","pt2","pt3","pt4","SlopesEqual3","SlopesEqual4","SlopesEqual5","DisposeLocalMinimaList","jlen","tmpLm","RangeTest","useFullRange","Value","InitEdge","eNext","ePrev","InitEdge2","polyType","SetDx","FindNextLocMin","E","E2","ProcessBound","LeftBoundIsForward","EStart","Horz","Result","locMin","InsertLocalMinima","ReverseHorizontal","AddPath","pg","Closed","highI","edges","IsFlat","$1","eStart","eLoopStop","Pt2IsBetweenPt1AndPt3","RemoveEdge","leftBoundIsForward","EMin","ppg","closed","newLm","PopLocalMinima","tmp","Reset","lm","InitOptions","m_PolyOuts","m_ClipType","m_Scanbeam","m_ActiveEdges","m_SortedEdges","m_IntersectList","m_IntersectNodeComparer","m_ExecuteLocked","m_ClipFillType","m_SubjFillType","m_Joins","m_GhostJoins","m_UsingPolyTree","ReverseSolution","ZFillFunction","ioReverseSolution","ioStrictlySimple","ioPreserveCollinear","DisposeAllPolyPts","DisposeScanbeamList","sb2","InsertScanbeam","newSb","ispolytree","clipType","solution","subjFillType","clipFillType","succeeded","ExecuteInternal","BuildResult","polytree","BuildResult2","FixHoleLinkage","outRec","orfl","botY","PopScanbeam","InsertLocalMinimaIntoAEL","ProcessHorizontals","topY","ProcessIntersections","ProcessEdgesAtTopOfScanbeam","Area","ReversePolyPtLinks","JoinCommonEdges","FixupOutPolygon","DoSimplePolygons","DisposeOutRec","index","AddJoin","Op1","Op2","AddGhostJoin","Op","SetZ","lb","rb","InsertEdgeIntoAEL","SetWindingCount","IsContributing","AddOutPt","AddLocalMinPoly","AddEdgeToSEL","HorzSegmentsOverlap","IntersectEdges","edge","startEdge","E2InsertsBeforeE1","TopX","IsEvenOddFillType","IsEvenOddAltFillType","pft","pft2","Inside","CopyAELToSEL","SwapPositionsInAEL","edge1","edge2","next","prev","SwapPositionsInSEL","AddLocalMaxPoly","AppendPolygon","prevE","outPt","CreateOutRec","ToFront","newOp","SetHoleState","SwapPoints","seg1a","seg1b","seg2a","seg2b","isHole","GetDx","FirstIsBottomPt","btmPt1","btmPt2","dx1p","dx1n","dx2p","dx2n","GetBottomPt","dups","GetLowermostRec","outRec1","outRec2","bPt1","bPt2","Param1RightOfParam2","GetOutRec","idx","outrec","holeStateRec","side","p1_lft","p1_rt","p2_lft","p2_rt","OKIdx","ObsoleteIdx","pp1","SwapSides","SwapPolyIndexes","outIdx","e1Contributing","e2Contributing","oldE1WindCnt","e1FillType","e2FillType","e1FillType2","e2FillType2","e1Wc","e2Wc","e1Wc2","e2Wc2","DeleteFromAEL","AelPrev","AelNext","DeleteFromSEL","SelPrev","SelNext","UpdateEdgeIntoAEL","isTopOfScanbeam","horzEdge","ProcessHorizontal","GetHorzDirection","HorzEdge","$var","Left","Right","Dir","dir","horzLeft","horzRight","eLastHorz","eMaxPair","GetMaximaPair","IsLastHorz","GetNextInAEL","op1","eNextHorz","op2","IsMinima","IsMaxima","IsIntermediate","BuildIntersectList","FixupIntersectionOrder","ProcessIntersectList","$$e2","isModified","IntersectPoint","newNode","EdgesAdjacent","inode","IntersectNodeSort","sort","iNode","R1","round","R2","R3","R4","currentY","ip","b1","b2","IsMaximaEdge","DoMaxima","ReversePaths","polys","len","reverse","Orientation","poly","PointCount","pts","polyg","pn","lastOK","DupOutPt","InsertAfter","GetOverlap","a1","a2","$val","JoinHorz","op1b","op2b","DiscardLeft","Dir1","Dir2","JoinPoints","isHorizontal","reverse1","reverse2","DiscardLeftSide","Reverse1","Reverse2","GetBounds","GetBounds2","ops","opStart","PointInPolygon","ipNext","startOp","ptx","pty","poly0x","poly0y","poly1x","poly1y","Poly2ContainsPoly1","outPt1","outPt2","res","FixupFirstLefts1","OldOutRec","NewOutRec","firstLeft","ParseFirstLeft","FixupFirstLefts2","$i2","$t2","$l2","UpdateOutPtIdxs","oRec","op3","op4","outrec2","SimplifyPolygon","fillType","DistanceSqrd","DistanceFromLineSqrd","ln1","ln2","A","B","C","SlopesNearCollinear","distSqrd","PointsAreClose","ExcludeOp","CleanPolygon","distance","outPts","CleanPolygons","Minkowski","pattern","IsSum","IsClosed","delta","polyCnt","pathCnt","quads","quad","MinkowskiSum","path_or_paths","pathIsClosed","TranslatePath","outPath","MinkowskiDiff","poly1","poly2","AddPolyNodeToPaths","NodeType","ntAny","polynode","nt","ntOpen","ntClosed","$i3","$t3","$l3","OpenPathsFromPolyTree","ClosedPathsFromPolyTree","ClipperOffset","miterLimit","arcTolerance","def_arc_tolerance","m_destPolys","m_srcPoly","m_destPoly","m_normals","m_delta","m_sinA","m_sin","m_cos","m_miterLim","m_StepsPerRad","m_lowest","m_polyNodes","MiterLimit","ArcTolerance","two_pi","joinType","endType","FixOrientations","GetUnitNormal","sqrt","DoOffset","steps","acos","OffsetPoint","DoSquare","DoRound","X2","clpr","outerNode","jointype","cosA","DoMiter","atan2","err","alert","AreaOfPolygon","AreaOfPolygons","area","BoundsOfPath","BoundsOfPaths","bounds","Clean","polygon","isPolygons","Clone","k_length","results","plen","Lighten","P","rem","addlast","bxax","byay","ax","ay","toleranceSq","PerimeterOfPath","perimeter","p1x","p1y","p2x","p2y","PerimeterOfPaths","ScaleDownPath","ScaleDownPaths","ScaleUpPath","ScaleUpPaths","ExPolygons","ExPolygon","AddOuterPolyNodeToExPolygons","expolygons","ep","childs","childs2","ExPolygonsToPaths","ReferenceError","create","constructor","setPrototypeOf","__proto__","Function","getPrototypeOf","get","arcLength","arcLengthMap","getPointAtT","_approximateLength","_addPoint","_postTrace","getPath","radians","__addPoint","center","startAngle","sweepAngle","init","_B1","_B2","_B3","_B4","_C1","unshift"],"mappings":"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","file":"lw.svg-parser.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"SVGParser\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SVGParser\"] = factory();\n\telse\n\t\troot[\"SVGParser\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"SVGParser\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SVGParser\"] = factory();\n\telse\n\t\troot[\"SVGParser\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(2);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t!function(t,n){ true?module.exports=n():\"function\"==typeof define&&define.amd?define(\"SVGPath\",[],n):\"object\"==typeof exports?exports.SVGPath=n():t.SVGPath=n()}(this,function(){return function(t){function n(i){if(e[i])return e[i].exports;var o=e[i]={exports:{},id:i,loaded:!1};return t[i].call(o.exports,o,o.exports,n),o.loaded=!0,o.exports}var e={};return n.m=t,n.c=e,n.p=\"\",n(0)}([function(t,n,e){t.exports=e(1)},function(t,n){\"use strict\";function e(t,n){if(!(t instanceof n))throw new TypeError(\"Cannot call a class as a function\")}Object.defineProperty(n,\"__esModule\",{value:!0});var i=function(){function t(t,n){for(var e=0;e<n.length;e++){var i=n[e];i.enumerable=i.enumerable||!1,i.configurable=!0,\"value\"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(n,e,i){return e&&t(n.prototype,e),i&&t(n,i),n}}(),o=function(){function t(n,i){if(e(this,t),this.x=parseFloat(n),this.y=parseFloat(i),isNaN(this.x)||isNaN(this.y))throw console.error(\"new Point(\",n,i,\")\"),new Error(\"Invalid input: x and y params must be float.\")}return i(t,[{key:\"isEqual\",value:function(t){return this.x===t.x&&this.y===t.y}}]),t}(),r=function(){function t(){e(this,t),this.points=[],this.length=0}return i(t,[{key:\"getPoints\",value:function(){return this.points}},{key:\"getFlattenPoints\",value:function(){var t=[];return this.points.forEach(function(n){return t.push(n.x,n.y)}),t}},{key:\"getClipperPoints\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,n=[];return this.points.forEach(function(e){return n.push({X:parseInt(e.x*t),Y:parseInt(e.y*t)})}),n}},{key:\"fromClipperPoints\",value:function(t){var n=this,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return this.points=[],t.forEach(function(t){return n.addPoint(parseFloat(t.X*e),parseFloat(t.Y*e))}),this}},{key:\"getPoint\",value:function(t){return this.points[t<0?this.length+t:t]||null}},{key:\"addPoint\",value:function(t,n){this.points.push(new o(t,n)),this.length=this.points.length}},{key:\"addPoints\",value:function(t){for(var n=0,e=t.length;n<e;n+=2)this.addPoint(t[n],t[n+1])}},{key:\"isClosed\",value:function(){var t=this.getPoint(0);return t&&t.isEqual(this.getPoint(-1))}},{key:\"close\",value:function(){if(!this.isClosed()&&this.length>2){var t=this.getPoint(0);return this.addPoint(t.x,t.y),!0}return!1}},{key:\"transform\",value:function(t){this.points=this.points.map(function(n){return new o(t[0]*n.x+t[2]*n.y+t[4],t[1]*n.x+t[3]*n.y+t[5])})}}]),t}();n.Path=r,n.Point=o,n.default=r}])});\n\t//# sourceMappingURL=lw.svg-path.js.map\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.Parser = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Imports\n\t\n\t\n\tvar _tag = __webpack_require__(3);\n\t\n\tvar _tagparser = __webpack_require__(4);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t// SVG parser class\n\tvar Parser = function () {\n\t    // Class constructor...\n\t    function Parser(settings) {\n\t        _classCallCheck(this, Parser);\n\t\n\t        // Defaults settings\n\t        settings = settings || {};\n\t\n\t        // Init properties\n\t        this.element = null; // XML document Element object\n\t        this.editor = null; // Editor info { name, version, fingerprint }\n\t        this.document = null; // Document info { width, height, viewBox }\n\t        this.defs = null; // Defined <defs> (DOM) nodes list by id\n\t        this.tags = null; // Tag objects hierarchy\n\t\n\t        // Trace settings (Arc, Bezier)\n\t        this.traceSettings = Object.assign({\n\t            linear: true, // Linear trace mode\n\t            step: 0.01, // Step resolution if linear mode = false\n\t            resolution: 100, // Number of segments we use to approximate arc length\n\t            segmentLength: 1 }, settings.traceSettings || {});\n\t\n\t        // Supported tags by this lib\n\t        this.supportedTags = ['svg', 'g', 'defs', 'use', 'line', 'polyline', 'polygon', 'rect', 'circle', 'ellipse', 'path', 'title', 'desc', 'image', 'text'];\n\t\n\t        // Tags list to includes/excludes\n\t        this.parseTags = settings.includes || this.supportedTags;\n\t        this.skipTags = settings.excludes || ['#text', '#comment']; // silent (no warning)\n\t\n\t        // User onTag callback ?\n\t        settings.onTag && this.onTag(settings.onTag, settings.onTagContext);\n\t    }\n\t\n\t    // Load raw XML string, XMLDocument, Element or File object\n\t\n\t\n\t    _createClass(Parser, [{\n\t        key: 'load',\n\t        value: function load(input) {\n\t            // Load raw XML string\n\t            if (typeof input === 'string') {\n\t                return this.loadFromString(input);\n\t            }\n\t\n\t            // Load File object\n\t            if (input instanceof File) {\n\t                return this.loadFromFile(input);\n\t            }\n\t\n\t            // Load XMLDocument object\n\t            if (input instanceof XMLDocument) {\n\t                return this.loadFromXMLDocument(input);\n\t            }\n\t\n\t            // Load Element object\n\t            if (input instanceof Element) {\n\t                return this.loadFromElement(input);\n\t            }\n\t\n\t            // Return rejected promise with an Error object\n\t            return Promise.reject(new Error('Unsupported input format.'));\n\t        }\n\t\n\t        // Load from Element object\n\t\n\t    }, {\n\t        key: 'loadFromElement',\n\t        value: function loadFromElement(input) {\n\t            var _this = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (!(input instanceof Element)) {\n\t                    reject(new Error('Input param must be a Element object.'));\n\t                }\n\t\n\t                // Parser error\n\t                if (input.nodeName === 'parsererror') {\n\t                    // FF\n\t                    reject(new Error(input.textContent));\n\t                }\n\t\n\t                if (input.nodeName === 'html' && input.getElementsByTagName('parsererror')) {\n\t                    // Chrome\n\t                    reject(new Error(input.getElementsByTagName('parsererror')[0].textContent));\n\t                }\n\t\n\t                // Set document element\n\t                _this.element = input;\n\t\n\t                // Resolve promise\n\t                resolve(input);\n\t            });\n\t        }\n\t\n\t        // Load from XMLDocument object\n\t\n\t    }, {\n\t        key: 'loadFromXMLDocument',\n\t        value: function loadFromXMLDocument(input) {\n\t            var _this2 = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (!(input instanceof XMLDocument)) {\n\t                    reject(new Error('Input param must be a XMLDocument object.'));\n\t                }\n\t\n\t                // Load from Element...\n\t                _this2.loadFromElement(input.documentElement).then(resolve).catch(reject);\n\t            });\n\t        }\n\t\n\t        // Load raw XML string\n\t\n\t    }, {\n\t        key: 'loadFromString',\n\t        value: function loadFromString(input) {\n\t            var _this3 = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (typeof input !== 'string') {\n\t                    reject(new Error('Input param must be a string.'));\n\t                }\n\t\n\t                // Parse svg editor\n\t                _this3._parseEditor(input);\n\t\n\t                // Parse string as DOM object\n\t                var parser = new DOMParser();\n\t                var XMLDoc = parser.parseFromString(input, 'text/xml');\n\t\n\t                // Load from XMLDocument...\n\t                _this3.loadFromXMLDocument(XMLDoc).then(resolve).catch(reject);\n\t            });\n\t        }\n\t\n\t        // Try to get the svg editor from input string\n\t\n\t    }, {\n\t        key: '_parseEditor',\n\t        value: function _parseEditor(input) {\n\t            // Reset editor\n\t            this.editor = {\n\t                name: 'unknown',\n\t                version: null,\n\t                fingerprint: null\n\t            };\n\t\n\t            // Fingerprint matches\n\t            var fingerprint = void 0;\n\t\n\t            // Inkscape\n\t            fingerprint = input.match(/<!-- Created with Inkscape .*-->/i);\n\t\n\t            if (fingerprint) {\n\t                this.editor.name = 'inkscape';\n\t                this.editor.fingerprint = fingerprint[0];\n\t\n\t                return this.editor;\n\t            }\n\t\n\t            // Illustrator\n\t            fingerprint = input.match(/<!-- Generator: Adobe Illustrator ([0-9\\.]+), .*-->/i);\n\t\n\t            if (fingerprint) {\n\t                this.editor.name = 'illustrator';\n\t                this.editor.version = fingerprint[1];\n\t                this.editor.fingerprint = fingerprint[0];\n\t\n\t                return this.editor;\n\t            }\n\t\n\t            // Return default\n\t            return this.editor;\n\t        }\n\t\n\t        // Load from File object\n\t\n\t    }, {\n\t        key: 'loadFromFile',\n\t        value: function loadFromFile(input) {\n\t            var _this4 = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (!(input instanceof File)) {\n\t                    reject(new Error('Input param must be a File object.'));\n\t                }\n\t\n\t                // Create file reader\n\t                var reader = new FileReader();\n\t\n\t                // Register reader events handlers\n\t                reader.onload = function (event) {\n\t                    _this4.loadFromString(event.target.result).then(resolve).catch(reject);\n\t                };\n\t\n\t                reader.onerror = function (event) {\n\t                    reject(new Error('Error reading file : ' + input.name));\n\t                };\n\t\n\t                // Finally read input file as text\n\t                reader.readAsText(input);\n\t            });\n\t        }\n\t\n\t        // Parse the (loaded) element\n\t\n\t    }, {\n\t        key: 'parse',\n\t        value: function parse(input) {\n\t            var _this5 = this;\n\t\n\t            // Reset properties\n\t            this.document = null;\n\t            this.defs = {};\n\t            this.tags = null;\n\t\n\t            // Load input if provided\n\t            if (input) {\n\t                return new Promise(function (resolve, reject) {\n\t                    _this5.load(input).then(function () {\n\t                        resolve(_this5.parse());\n\t                    }).catch(reject);\n\t                });\n\t            }\n\t\n\t            // Start parsing element\n\t            return new Promise(function (resolve, reject) {\n\t                // If no element is loaded\n\t                if (!_this5.element) {\n\t                    reject(new Error('No element is loaded, call the load method before.'));\n\t                }\n\t\n\t                // Parse the main Element (recursive)\n\t                _this5.tags = _this5._parseElement(_this5.element);\n\t\n\t                if (!_this5.tags) {\n\t                    reject(new Error('No supported tags found.'));\n\t                }\n\t\n\t                // Apply matrix (recursive)\n\t                _this5.tags.applyMatrix();\n\t\n\t                // Resolve the promise\n\t                resolve(_this5.tags);\n\t            });\n\t        }\n\t\n\t        // On tag callback\n\t\n\t    }, {\n\t        key: '_onTag',\n\t        value: function _onTag(tag) {}\n\t        //console.info('onTag:', tag)\n\t\n\t\n\t        // Register on tag callback\n\t\n\t    }, {\n\t        key: 'onTag',\n\t        value: function onTag(callback, context) {\n\t            var _this6 = this;\n\t\n\t            this._onTag = function (tag) {\n\t                return callback.call(context || _this6, tag);\n\t            };\n\t        }\n\t\n\t        // Parse the provided Element and return an Tag collection (recursive)\n\t\n\t    }, {\n\t        key: '_parseElement',\n\t        value: function _parseElement(element, parent) {\n\t            var _this7 = this;\n\t\n\t            // Create base tag object\n\t            var tag = new _tag.Tag(element, parent);\n\t\n\t            // Exluded tag ?\n\t            if (this.skipTags.indexOf(tag.name) !== -1) {\n\t                return null; // silent\n\t            }\n\t\n\t            // Supported tag ?\n\t            if (this.parseTags.indexOf(tag.name) === -1) {\n\t                return this._skipTag(tag, 'unsupported');\n\t            }\n\t\n\t            // Parse the tag\n\t            var tagParser = new _tagparser.TagParser(tag, this);\n\t\n\t            if (!tagParser.parse()) {\n\t                return false;\n\t            }\n\t\n\t            // Call the on tag callback\n\t            this._onTag(tag);\n\t\n\t            // Parse child nodes\n\t            var childTag = void 0;\n\t\n\t            element.childNodes.forEach(function (childNode) {\n\t                // Parse child element\n\t                if (childTag = _this7._parseElement(childNode, tag)) {\n\t                    tag.addChild(childTag);\n\t                }\n\t            });\n\t\n\t            // Empty group\n\t            if (['svg', 'g'].indexOf(tag.name) !== -1 && !tag.children.length) {\n\t                return this._skipTag(tag, 'empty');\n\t            }\n\t\n\t            // Return tag object\n\t            return tag;\n\t        }\n\t\n\t        // Log skip tag warning message\n\t\n\t    }, {\n\t        key: '_skipTag',\n\t        value: function _skipTag(tag, message) {\n\t            console.warn('Skip tag :', message + ':', tag);\n\t            return false;\n\t        }\n\t\n\t        // Log skip tag attribute warning message\n\t\n\t    }, {\n\t        key: '_skipTagAttr',\n\t        value: function _skipTagAttr(tag, attr, message) {\n\t            console.warn('Skip tag attribute :', message + ':', attr, tag);\n\t            return false;\n\t        }\n\t    }]);\n\t\n\t    return Parser;\n\t}();\n\t\n\t// Exports\n\t\n\t\n\texports.Parser = Parser;\n\texports.default = Parser;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.Tag = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _lw = __webpack_require__(1);\n\t\n\tvar _clipperLib = __webpack_require__(5);\n\t\n\tvar _clipperLib2 = _interopRequireDefault(_clipperLib);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar DEG_TO_RAD = Math.PI / 180;\n\t\n\t// SVG tag class\n\t\n\tvar Tag = function () {\n\t    // Class constructor...\n\t    function Tag(element, parent) {\n\t        var _this = this;\n\t\n\t        _classCallCheck(this, Tag);\n\t\n\t        // Init properties\n\t        this.element = element;\n\t        this.name = element.nodeName.toLowerCase();\n\t        this.parent = parent || null;\n\t        this.layer = null;\n\t        this.attrs = {};\n\t        this.children = [];\n\t        this.paths = [];\n\t        this.matrix = null;\n\t        this.path = new _lw.Path();\n\t        this.point = new _lw.Point(0, 0);\n\t        this.shapes = [];\n\t\n\t        // Add first path\n\t        this.paths.push(this.path);\n\t\n\t        // Set the matrix\n\t        this.setMatrix(this.parent && this.parent.matrix);\n\t\n\t        // Clone parent attributes\n\t        if (this.parent && (this.parent.name === 'g' || this.parent.name === 'svg')) {\n\t            (function () {\n\t                // Inherit layer name\n\t                _this.layer = _this.parent.layer;\n\t\n\t                // Inherit parent attributes\n\t                var excludes = ['transform', 'width', 'height'];\n\t\n\t                if (_this.name !== 'g' && _this.name !== 'svg') {\n\t                    excludes.push('viewBox');\n\t                }\n\t\n\t                Object.keys(_this.parent.attrs).forEach(function (key) {\n\t                    if (excludes.indexOf(key) === -1) {\n\t                        _this.setAttr(key, _this.parent.attrs[key]);\n\t                    }\n\t                });\n\t            })();\n\t        }\n\t    }\n\t\n\t    _createClass(Tag, [{\n\t        key: 'setAttr',\n\t        value: function setAttr(name, value) {\n\t            this.attrs[name] = value;\n\t        }\n\t    }, {\n\t        key: 'getAttr',\n\t        value: function getAttr(name, defaultValue) {\n\t            return this.attrs[name] !== undefined ? this.attrs[name] : defaultValue !== undefined ? defaultValue : null;\n\t        }\n\t    }, {\n\t        key: 'getLayerName',\n\t        value: function getLayerName() {\n\t            if (this.name === 'g') {\n\t                return this.getAttr('inkscape:label', this.getAttr('id', null));\n\t            }\n\t        }\n\t    }, {\n\t        key: 'setLayerName',\n\t        value: function setLayerName(name) {\n\t            if (this.name === 'g') {\n\t                this.layer = name || this.getLayerName();\n\t            }\n\t        }\n\t    }, {\n\t        key: 'addChild',\n\t        value: function addChild(childTag) {\n\t            this.children.push(childTag);\n\t        }\n\t    }, {\n\t        key: 'clearPath',\n\t        value: function clearPath() {\n\t            this.path = new _lw.Path();\n\t        }\n\t    }, {\n\t        key: 'newPath',\n\t        value: function newPath() {\n\t            if (this.path.length > 0) {\n\t                this.clearPath();\n\t                this.paths.push(this.path);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'closePath',\n\t        value: function closePath() {\n\t            return this.path.close();\n\t        }\n\t    }, {\n\t        key: 'addPoint',\n\t        value: function addPoint(x, y, relative) {\n\t            // Relative from the last point\n\t            if (relative) {\n\t                x += this.point.x;\n\t                y += this.point.y;\n\t            }\n\t\n\t            // Add current point\n\t            this.path.addPoint(x, y);\n\t\n\t            // Update current point\n\t            this.point = this.path.getPoint(-1);\n\t        }\n\t    }, {\n\t        key: 'addPoints',\n\t        value: function addPoints(points, relative) {\n\t            // For each couple of points\n\t            for (var i = 0, il = points.length; i < il; i += 2) {\n\t                this.addPoint(points[i], points[i + 1], relative);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'setMatrix',\n\t        value: function setMatrix(matrix) {\n\t            this.matrix = matrix || [1, 0, 0, 1, 0, 0];\n\t        }\n\t    }, {\n\t        key: 'addMatrix',\n\t        value: function addMatrix(matrix) {\n\t            this.matrix = [this.matrix[0] * matrix[0] + this.matrix[2] * matrix[1], this.matrix[1] * matrix[0] + this.matrix[3] * matrix[1], this.matrix[0] * matrix[2] + this.matrix[2] * matrix[3], this.matrix[1] * matrix[2] + this.matrix[3] * matrix[3], this.matrix[0] * matrix[4] + this.matrix[2] * matrix[5] + this.matrix[4], this.matrix[1] * matrix[4] + this.matrix[3] * matrix[5] + this.matrix[5]];\n\t        }\n\t    }, {\n\t        key: 'translate',\n\t        value: function translate(x, y) {\n\t            y = y === undefined ? 0 : y;\n\t            this.addMatrix([1, 0, 0, 1, x, y]);\n\t        }\n\t    }, {\n\t        key: 'rotate',\n\t        value: function rotate(angle, x, y) {\n\t            angle = angle * DEG_TO_RAD;\n\t\n\t            if (arguments.length == 2) {\n\t                this.addMatrix([1, 0, 0, 1, x, y]);\n\t            }\n\t\n\t            this.addMatrix([Math.cos(angle), Math.sin(angle), -Math.sin(angle), Math.cos(angle), 0, 0]);\n\t\n\t            if (arguments.length == 2) {\n\t                this.addMatrix([1, 0, 0, 1, -x, -y]);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'scale',\n\t        value: function scale(x, y) {\n\t            y = y === undefined ? x : y;\n\t            this.addMatrix([x, 0, 0, y, 0, 0]);\n\t        }\n\t    }, {\n\t        key: 'skewX',\n\t        value: function skewX(angle) {\n\t            this.addMatrix([1, 0, Math.tan(angle * DEG_TO_RAD), 1, 0, 0]);\n\t        }\n\t    }, {\n\t        key: 'skewY',\n\t        value: function skewY(angle) {\n\t            this.addMatrix([1, Math.tan(angle * DEG_TO_RAD), 0, 1, 0, 0]);\n\t        }\n\t    }, {\n\t        key: 'applyMatrix',\n\t        value: function applyMatrix(matrix) {\n\t            var _this2 = this;\n\t\n\t            matrix && this.addMatrix(matrix);\n\t\n\t            this.paths.forEach(function (path) {\n\t                path.transform(_this2.matrix);\n\t            });\n\t\n\t            this.shapes.forEach(function (shape) {\n\t                shape.outer.transform(_this2.matrix);\n\t                shape.holes.forEach(function (hole) {\n\t                    hole.transform(_this2.matrix);\n\t                });\n\t            });\n\t\n\t            this.setMatrix(null);\n\t\n\t            this.children.forEach(function (tag) {\n\t                tag.applyMatrix(matrix);\n\t            });\n\t        }\n\t    }, {\n\t        key: 'getPaths',\n\t        value: function getPaths() {\n\t            return this.paths;\n\t        }\n\t    }, {\n\t        key: 'getShapes',\n\t        value: function getShapes() {\n\t            // No shapes...\n\t            if (this.getAttr('fill', 'none') === 'none' || !this.paths[0].length) {\n\t                return this.shapes;\n\t            }\n\t\n\t            // Get fill rule\n\t            var fillRule = this.getAttr('fill-rule', 'nonzero');\n\t            fillRule = fillRule === 'nonzero' ? _clipperLib2.default.PolyFillType.pftNonZero : _clipperLib2.default.PolyFillType.pftEvenOdd;\n\t\n\t            // Create clipper path\n\t            var cPolyTree = new _clipperLib2.default.PolyTree();\n\t            var cClipper = new _clipperLib2.default.Clipper();\n\t            var clipperScale = 10000000;\n\t            var clipperPaths = [];\n\t\n\t            this.paths.forEach(function (path) {\n\t                clipperPaths.push(path.getClipperPoints(clipperScale));\n\t            });\n\t\n\t            cClipper.AddPaths(clipperPaths, _clipperLib2.default.PolyType.ptSubject, true);\n\t            cClipper.Execute(_clipperLib2.default.ClipType.ctUnion, cPolyTree, fillRule, fillRule);\n\t\n\t            var paths = _clipperLib2.default.Clipper.PolyTreeToPaths(cPolyTree);\n\t            var polygones = _clipperLib2.default.Clipper.SimplifyPolygons(paths, fillRule);\n\t\n\t            // Single path (no hole)\n\t            if (this.paths.length > 1) {\n\t                cClipper.Clear();\n\t                cClipper.StrictlySimple = true;\n\t                cPolyTree = new _clipperLib2.default.PolyTree();\n\t                cClipper.AddPaths(polygones, _clipperLib2.default.PolyType.ptSubject, true);\n\t                cClipper.Execute(_clipperLib2.default.ClipType.ctUnion, cPolyTree, fillRule, fillRule);\n\t            }\n\t\n\t            // PolyTree to ExPolygons\n\t            var toPath = function toPath(path) {\n\t                return new _lw.Path().fromClipperPoints(path, 1 / clipperScale);\n\t            };\n\t            var exPolygons = _clipperLib2.default.JS.PolyTreeToExPolygons(cPolyTree);\n\t            this.shapes = exPolygons.map(function (exPolygon) {\n\t                return {\n\t                    outer: toPath(exPolygon.outer),\n\t                    holes: exPolygon.holes.map(toPath)\n\t                };\n\t            });\n\t\n\t            // Return shapes...\n\t            return this.shapes;\n\t        }\n\t    }]);\n\t\n\t    return Tag;\n\t}();\n\t\n\t// Exports\n\t\n\t\n\texports.Tag = Tag;\n\texports.default = Tag;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.TagParser = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _lw = __webpack_require__(6);\n\t\n\tvar _lw2 = __webpack_require__(1);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t// SVG tag parser\n\tvar TagParser = function () {\n\t    // Class constructor...\n\t    function TagParser(tag, parser) {\n\t        _classCallCheck(this, TagParser);\n\t\n\t        // Init properties\n\t        this.tag = tag;\n\t        this.parser = parser;\n\t        this.currentCommand = null;\n\t        this.lastCommand = null;\n\t        this.pathData = null;\n\t        this.traceSettings = parser.traceSettings;\n\t    }\n\t\n\t    _createClass(TagParser, [{\n\t        key: 'parse',\n\t        value: function parse() {\n\t            // Get internal parser from node name\n\t            var handler = this['_' + this.tag.name];\n\t\n\t            // Implemented tag handler?\n\t            if (!handler || typeof handler !== 'function') {\n\t                return this.parser._skipTag(this.tag, 'not yet implemented');\n\t            }\n\t\n\t            // Parse tag attributes\n\t            this._parseTagAttrs();\n\t\n\t            // Parse tag\n\t            return handler.call(this);\n\t        }\n\t\n\t        // Parse the tag attributes\n\t\n\t    }, {\n\t        key: '_parseTagAttrs',\n\t        value: function _parseTagAttrs() {\n\t            var _this = this;\n\t\n\t            // Get tag attributes\n\t            var attrs = this.tag.element.attributes;\n\t\n\t            if (!attrs) {\n\t                return null;\n\t            }\n\t\n\t            // Get viewBox attribute if any\n\t            var viewBox = attrs.getNamedItem('viewBox');\n\t\n\t            if (viewBox) {\n\t                this.tag.setAttr('viewBox', this._normalizeTagAttrPoints(viewBox));\n\t            }\n\t\n\t            // For each attribute\n\t            var attr = void 0,\n\t                value = void 0,\n\t                style = void 0;\n\t\n\t            Object.keys(attrs).some(function (key) {\n\t                // Current attribute\n\t                attr = attrs[key];\n\t\n\t                // Normalize attribute value\n\t                value = _this._normalizeTagAttr(attr);\n\t\n\t                if (value === false) {\n\t                    return false; // continue\n\t                }\n\t\n\t                // Special case\n\t                if (attr.nodeName === 'style') {\n\t                    style = value;\n\t                } else {\n\t                    // Set new attribute name/value\n\t                    _this.tag.setAttr(attr.nodeName, value);\n\t                }\n\t            });\n\t\n\t            // If style attribute (override tag attributes)\n\t            // TODO get/parse global style and override this one...\n\t            style && style.replace(/;$/, '').split(';').some(function (attr) {\n\t                // Current style\n\t                attr = attr.split(':');\n\t                attr = { nodeName: attr[0], nodeValue: attr[1] };\n\t\n\t                // Normalize attribute value\n\t                value = _this._normalizeTagAttr(attr);\n\t\n\t                if (value === false) {\n\t                    return false; // continue\n\t                }\n\t\n\t                // Set new attribute name/value\n\t                _this.tag.setAttr(attr.nodeName, value);\n\t            });\n\t\n\t            // Set inherited color\n\t            var colorsAttrs = ['fill', 'stroke', 'color'];\n\t\n\t            colorsAttrs.forEach(function (attrName) {\n\t                if (_this.tag.getAttr(attrName) === 'inherit') {\n\t                    _this.tag.setAttr(attrName, _this.tag.parent.getAttr(attrName, 'none'));\n\t                }\n\t            });\n\t\n\t            // Parse viewBox attribute\n\t            this._parseViewBoxAttr();\n\t\n\t            // Parse transform attribute\n\t            this._parseTransformAttr();\n\t        }\n\t\n\t        // Normalize tag attribute\n\t\n\t    }, {\n\t        key: '_normalizeTagAttr',\n\t        value: function _normalizeTagAttr(attr) {\n\t            // Normalize whitespaces\n\t            var value = attr.nodeValue.replace(/(\\r?\\n|\\r)+/gm, ' ') // Remove all new line chars\n\t            .replace(/\\s+/gm, ' ') // Reduce multiple whitespaces\n\t            .trim(); // Remove trailing whitespaces\n\t\n\t            if (!value.length) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'empty');\n\t            }\n\t\n\t            // Filters\n\t            switch (attr.nodeName) {\n\t                // Normalize size unit -> to px\n\t                case 'x':\n\t                case 'y':\n\t                case 'width':\n\t                case 'height':\n\t                    value = this._normalizeTagAttrUnit(attr);\n\t                    break;\n\t\n\t                case 'x1':\n\t                case 'y1':\n\t                case 'x2':\n\t                case 'y2':\n\t                case 'r':\n\t                case 'rx':\n\t                case 'ry':\n\t                case 'cx':\n\t                case 'cy':\n\t                case 'font-size':\n\t                case 'stroke-width':\n\t                    value = this._normalizeTagAttrUnit(attr, true);\n\t                    break;\n\t\n\t                // Normalize points attribute\n\t                case 'points':\n\t                    //case 'viewBox':\n\t                    value = this._normalizeTagAttrPoints(attr);\n\t                    break;\n\t\n\t                case 'viewBox':\n\t                    value = false;\n\t                    break;\n\t\n\t                // Range limit to [0 - 1]\n\t                case 'opacity':\n\t                case 'fill-opacity':\n\t                case 'stroke-opacity':\n\t                    value = this._normalizeTagAttrRange(attr, 0, 1);\n\t                    break;\n\t\n\t                case 'preserveAspectRatio':\n\t                    value = this._normalizeTagAttrPreserveAspectRatio(attr);\n\t                    break;\n\t            }\n\t\n\t            // Return normalized value\n\t            return value;\n\t        }\n\t\n\t        // Normalize attribute unit to px\n\t\n\t    }, {\n\t        key: '_normalizeTagAttrUnit',\n\t        value: function _normalizeTagAttrUnit(attr, ratio) {\n\t            var stringValue = attr.nodeValue.toLowerCase();\n\t            var floatValue = parseFloat(stringValue);\n\t\n\t            if (isNaN(floatValue)) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'only numeric value allowed');\n\t            }\n\t\n\t            if (stringValue.indexOf('mm') !== -1) {\n\t                return floatValue * 3.5433070869;\n\t            }\n\t\n\t            if (stringValue.indexOf('cm') !== -1) {\n\t                return floatValue * 35.433070869;\n\t            }\n\t\n\t            if (stringValue.indexOf('in') !== -1) {\n\t                return floatValue * 90.0;\n\t            }\n\t\n\t            if (stringValue.indexOf('pt') !== -1) {\n\t                return floatValue * 1.25;\n\t            }\n\t\n\t            if (stringValue.indexOf('pc') !== -1) {\n\t                return floatValue * 15.0;\n\t            }\n\t\n\t            if (stringValue.indexOf('%') !== -1) {\n\t                var viewBox = this.tag.getAttr('viewBox', this.tag.parent && this.tag.parent.getAttr('viewBox'));\n\t\n\t                switch (attr.nodeName) {\n\t                    case 'x':\n\t                    case 'width':\n\t                        floatValue *= viewBox[2] / 100;\n\t                        break;\n\t                    case 'y':\n\t                    case 'height':\n\t                        floatValue *= viewBox[3] / 100;\n\t                        break;\n\t                }\n\t            }\n\t\n\t            if (stringValue.indexOf('em') !== -1) {\n\t                var fontSize = this.tag.getAttr('font-size', 16);\n\t\n\t                switch (attr.nodeName) {\n\t                    case 'x':\n\t                    case 'y':\n\t                    case 'width':\n\t                    case 'height':\n\t                        floatValue *= fontSize;\n\t                        break;\n\t                }\n\t            }\n\t\n\t            return floatValue;\n\t        }\n\t\n\t        // Normalize points attribute\n\t\n\t    }, {\n\t        key: '_normalizeTagAttrPoints',\n\t        value: function _normalizeTagAttrPoints(attr) {\n\t            var points = this._parseNumbers(attr.nodeValue);\n\t\n\t            if (points === false) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'only numeric values are allowed');\n\t            }\n\t\n\t            if (!points.length) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'empty points list');\n\t            }\n\t\n\t            if (points.length % 0) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'the number of points must be even');\n\t            }\n\t\n\t            return points;\n\t        }\n\t\n\t        // Normalize range attribute like \"opacity\"\n\t\n\t    }, {\n\t        key: '_normalizeTagAttrRange',\n\t        value: function _normalizeTagAttrRange(attr, min, max) {\n\t            var stringValue = attr.nodeValue.trim();\n\t            var floatValue = parseFloat(stringValue);\n\t\n\t            if (isNaN(floatValue)) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'only numeric values are allowed');\n\t            }\n\t\n\t            if (floatValue < min || floatValue > max) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'out of range [' + min + ', ' + max + ']');\n\t            }\n\t\n\t            return floatValue;\n\t        }\n\t\n\t        // Parse points string as numbers array\n\t\n\t    }, {\n\t        key: '_parseNumbers',\n\t        value: function _parseNumbers(points) {\n\t            // http://stackoverflow.com/questions/638565/parsing-scientific-notation-sensibly\n\t            if (typeof points === 'string') {\n\t                points = points.split(/([+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)?/g).filter(function (point) {\n\t                    return point && ['', ','].indexOf(point.trim()) === -1;\n\t                });\n\t            }\n\t\n\t            // Normalize to float values\n\t            points = points.map(parseFloat);\n\t\n\t            // Test if all numbers is valid\n\t            if (points.some(isNaN)) {\n\t                return false;\n\t            }\n\t\n\t            return points;\n\t        }\n\t\n\t        // Normalize the preserveAspectRatio attribute\n\t\n\t    }, {\n\t        key: '_normalizeTagAttrPreserveAspectRatio',\n\t        value: function _normalizeTagAttrPreserveAspectRatio(attr) {\n\t            var params = {\n\t                defer: false,\n\t                align: 'none',\n\t                meet: true,\n\t                slice: false\n\t            };\n\t\n\t            var rawParams = attr.nodeValue;\n\t\n\t            if (rawParams.indexOf('defer') === 0) {\n\t                rawParams = rawParams.substr(6);\n\t                params.defer = true;\n\t            }\n\t\n\t            rawParams = rawParams.split(' ');\n\t            params.align = rawParams[0];\n\t            params.meet = rawParams[1] || 'meet';\n\t            params.meet = params.meet === 'meet';\n\t            params.slice = !params.meet;\n\t\n\t            return params;\n\t        }\n\t\n\t        // Parse viewBox attribute and set transformations\n\t\n\t    }, {\n\t        key: '_parseViewBoxAttr',\n\t        value: function _parseViewBoxAttr() {\n\t            // Get viewBox attribute\n\t            var viewBox = this.tag.getAttr('viewBox', null);\n\t\n\t            // No viewBox...\n\t            if (viewBox === null) {\n\t                return null;\n\t            }\n\t\n\t            // Update size attributes\n\t            var width = this.tag.getAttr('width', viewBox[2]);\n\t            var height = this.tag.getAttr('height', viewBox[3]);\n\t\n\t            this.tag.setAttr('width', width);\n\t            this.tag.setAttr('height', height);\n\t\n\t            // Scale to match viewBox\n\t            // TODO clip path if preserveAspectRatio.slice\n\t            var scaleX = width / viewBox[2];\n\t            var scaleY = height / viewBox[3];\n\t            var translateX = viewBox[0];\n\t            var translateY = viewBox[1];\n\t\n\t            var preserveAspectRatio = this.tag.getAttr('preserveAspectRatio', 'meet xMidYMid');\n\t\n\t            if (preserveAspectRatio) {\n\t                var newWidth = void 0,\n\t                    newHeight = void 0;\n\t\n\t                if (preserveAspectRatio.meet) {\n\t                    if (scaleX > scaleY) {\n\t                        scaleX = scaleY;\n\t                        newWidth = viewBox[2] * scaleX;\n\t                    } else if (scaleX < scaleY) {\n\t                        scaleY = scaleX;\n\t                        newHeight = viewBox[3] * scaleY;\n\t                    }\n\t                } else if (preserveAspectRatio.slice) {\n\t                    if (scaleX < scaleY) {\n\t                        scaleX = scaleY;\n\t                        newWidth = viewBox[2] * scaleX;\n\t                    } else if (scaleX > scaleY) {\n\t                        scaleY = scaleX;\n\t                        newHeight = viewBox[3] * scaleY;\n\t                    }\n\t                }\n\t\n\t                if (newWidth !== undefined) {\n\t                    if (preserveAspectRatio.align === 'xMidYMid') {\n\t                        this.tag.translate((width - newWidth) / 2, 0);\n\t                    } else if (preserveAspectRatio.align === 'xMaxYMax') {\n\t                        this.tag.translate(width - newWidth, 0);\n\t                    }\n\t                } else if (newHeight !== undefined) {\n\t                    if (preserveAspectRatio.align === 'xMidYMid') {\n\t                        this.tag.translate(0, (height - newHeight) / 2);\n\t                    } else if (preserveAspectRatio.align === 'xMaxYMax') {\n\t                        this.tag.translate(0, height - newHeight);\n\t                    }\n\t                }\n\t            }\n\t\n\t            this.tag.scale(scaleX, scaleY);\n\t            this.tag.translate(-translateX, -translateY);\n\t        }\n\t\n\t        // Parse transform attribute and set transformations\n\t\n\t    }, {\n\t        key: '_parseTransformAttr',\n\t        value: function _parseTransformAttr() {\n\t            var _this2 = this;\n\t\n\t            // Get transform attribute\n\t            var transformAttr = this.tag.getAttr('transform', null);\n\t\n\t            // No transformation...\n\t            if (transformAttr === null || !transformAttr.length) {\n\t                return null;\n\t            }\n\t\n\t            // Parse attribute (split group on closing parenthesis)\n\t            var transformations = transformAttr.split(')');\n\t\n\t            // Remove last entry due to last \")\" found\n\t            transformations.pop();\n\t\n\t            // For each transformation\n\t            var transform = void 0,\n\t                type = void 0,\n\t                params = void 0;\n\t\n\t            transformations.some(function (raw) {\n\t                // Split name and value on opening parenthesis\n\t                transform = raw.split('(');\n\t\n\t                // Invalid parts number\n\t                if (transform.length !== 2) {\n\t                    return _this2.parser._skipTagAttr(_this2.tag, transformAttr, 'malformed'); // continue\n\t                }\n\t\n\t                type = transform[0].trim();\n\t\n\t                // Quik hack 1/2\n\t                var func = type;\n\t                if (func === 'matrix') {\n\t                    func = 'addMatrix';\n\t                }\n\t\n\t                // Get tag transform method\n\t                var tagTransform = _this2.tag[func];\n\t\n\t                if (typeof tagTransform !== 'function') {\n\t                    return _this2.parser._skipTagAttr(_this2.tag, transformAttr, 'unsupported transform type :' + type);\n\t                }\n\t\n\t                params = transform[1].trim();\n\t                params = _this2._parseNumbers(params);\n\t\n\t                // Skip empty value\n\t                if (!params.length) {\n\t                    return _this2.parser._skipTagAttr(_this2.tag, transformAttr, 'malformed transform type :' + type);\n\t                }\n\t\n\t                // Quik hack 2/2\n\t                if (func == 'addMatrix') {\n\t                    params = [params];\n\t                }\n\t\n\t                // Call tag transform method like \"tag.translate(param1, ..., paramN)\"\n\t                tagTransform.apply(_this2.tag, params);\n\t            });\n\t        }\n\t    }, {\n\t        key: '_newPath',\n\t        value: function _newPath() {\n\t            this.tag.newPath();\n\t        }\n\t    }, {\n\t        key: '_clearPath',\n\t        value: function _clearPath() {\n\t            this.tag.clearPath();\n\t        }\n\t    }, {\n\t        key: '_closePath',\n\t        value: function _closePath() {\n\t            return this.tag.closePath();\n\t        }\n\t    }, {\n\t        key: '_addPoints',\n\t        value: function _addPoints(points, relative) {\n\t            if (!points.length) {\n\t                return this.parser._skipTag(this.tag, 'empty points list');\n\t            }\n\t\n\t            if (points.length % 0) {\n\t                return this.parser._skipTag(this.tag, 'the number of points must be even');\n\t            }\n\t\n\t            relative = arguments.length < 2 && this.currentCommand.relative;\n\t\n\t            this.tag.addPoints(points, relative);\n\t            return true;\n\t        }\n\t\n\t        // SVG specs at https://www.w3.org/TR/SVG11/\n\t\n\t    }, {\n\t        key: '_svg',\n\t        value: function _svg() {\n\t            // Only parse the root SVG tag as main document\n\t            if (this.parser.document) {\n\t                // Handled tag\n\t                return true;\n\t            }\n\t\n\t            // Get the document size\n\t            var width = this.tag.getAttr('width');\n\t            var height = this.tag.getAttr('height');\n\t\n\t            // Invalid size\n\t            if (!width || width < 0 || !height || height < 0) {\n\t                throw new Error('Invalid document size: ' + width + ' / ' + height);\n\t            }\n\t\n\t            // Set document size\n\t            this.parser.document = {\n\t                width: width,\n\t                height: height\n\t            };\n\t\n\t            // Get document viewBox or set default to document size\n\t            var viewBox = this.tag.getAttr('viewBox', [0, 0, width, height]);\n\t\n\t            this.parser.document.viewBox = {\n\t                x: viewBox[0],\n\t                y: viewBox[1],\n\t                width: viewBox[2],\n\t                height: viewBox[3]\n\t            };\n\t\n\t            // Check inkscape version\n\t            if (this.parser.editor.name === 'inkscape') {\n\t                this.parser.editor.version = this.tag.getAttr('inkscape:version');\n\t            }\n\t\n\t            // Handled tag\n\t            return true;\n\t        }\n\t    }, {\n\t        key: '_title',\n\t        value: function _title() {\n\t            // Register the first encountered title tag as document title\n\t            if (this.parser.document && !this.parser.document.title) {\n\t                this.parser.document.title = this.tag.element.textContent;\n\t            }\n\t\n\t            // Skipped tag\n\t            return false;\n\t        }\n\t    }, {\n\t        key: '_desc',\n\t        value: function _desc() {\n\t            // Register the first encountered desc tag as document description\n\t            if (this.parser.document && !this.parser.document.description) {\n\t                this.parser.document.description = this.tag.element.textContent;\n\t            }\n\t\n\t            // Skipped tag\n\t            return false;\n\t        }\n\t    }, {\n\t        key: '_image',\n\t        value: function _image() {\n\t            // console.log(this.tag.getAttr('xlink:href'))\n\t            // Handled tag\n\t            return true;\n\t        }\n\t    }, {\n\t        key: '_text',\n\t        value: function _text() {\n\t            // console.log(this.tag.element.textContent)\n\t            // Handled tag\n\t            return true;\n\t        }\n\t    }, {\n\t        key: '_defs',\n\t        value: function _defs() {\n\t            var _this3 = this;\n\t\n\t            // Register all child element with an id attribute\n\t            this.tag.element.childNodes.forEach(function (childNode) {\n\t                childNode.id && (_this3.parser.defs[childNode.id] = childNode);\n\t            });\n\t\n\t            // Skipped tag\n\t            return false;\n\t        }\n\t    }, {\n\t        key: '_use',\n\t        value: function _use() {\n\t            // Get the target id\n\t            var target = this.tag.getAttr('xlink:href').replace(/^#/, '');\n\t\n\t            // Try to get the defined element\n\t            var element = this.parser.defs[target];\n\t\n\t            if (!element) {\n\t                return this.parser._skipTag(this.tag, 'undefined reference [' + target + ']');\n\t            }\n\t\n\t            // Parse the defined element and set new parent from <use> tag parent\n\t            var useTag = this.parser._parseElement(element, this.tag.parent);\n\t\n\t            if (!useTag) {\n\t                return this.parser._skipTag(this.tag, 'empty reference [' + target + ']');\n\t            }\n\t\n\t            // Set matrix from real parent (<use>)\n\t            useTag.setMatrix(this.tag.matrix);\n\t\n\t            // Replace the use tag with new one\n\t            this.tag.parent.addChild(useTag);\n\t\n\t            // Skipped tag\n\t            return false;\n\t        }\n\t    }, {\n\t        key: '_g',\n\t        value: function _g() {\n\t            // Set the tag layer name\n\t            this.tag.setLayerName();\n\t\n\t            // Handled tag\n\t            return true;\n\t        }\n\t    }, {\n\t        key: '_line',\n\t        value: function _line() {\n\t            // Handled tag\n\t            return this._path(['M', this.tag.getAttr('x1'), this.tag.getAttr('y1'), 'L', this.tag.getAttr('x2'), this.tag.getAttr('y2')]);\n\t        }\n\t    }, {\n\t        key: '_polyline',\n\t        value: function _polyline() {\n\t            var close = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\t\n\t            var points = this.tag.getAttr('points');\n\t            var path = ['M', points.shift(), points.shift(), 'L'];\n\t\n\t            path = path.concat(points);\n\t            close && path.push('Z');\n\t\n\t            // Handled tag\n\t            return this._path(path);\n\t        }\n\t    }, {\n\t        key: '_polygon',\n\t        value: function _polygon() {\n\t            // Handled like polyline but closed\n\t            return this._polyline(true);\n\t        }\n\t    }, {\n\t        key: '_rect',\n\t        value: function _rect() {\n\t            // Get rectangle attributes\n\t            var w = this.tag.getAttr('width');\n\t            var h = this.tag.getAttr('height');\n\t            var x = this.tag.getAttr('x', 0);\n\t            var y = this.tag.getAttr('y', 0);\n\t            var rx = this.tag.getAttr('rx', null);\n\t            var ry = this.tag.getAttr('ry', null);\n\t\n\t            // Simple rect\n\t            if (!rx && !ry) {\n\t                // Handled tag\n\t                return this._path(['M', x, y, 'h', w, 'v', h, 'h', -w, 'z']);\n\t            }\n\t\n\t            // If a properly specified value is provided for rx, but not for ry,\n\t            // then set both rx and ry to the value of rx and vis-vera...\n\t            if (rx === null) rx = ry;\n\t            if (ry === null) ry = rx;\n\t\n\t            // A negative value is an error\n\t            if (rx === null || rx === null || rx < 0 || ry < 0) {\n\t                // Skip tag\n\t                return this.parser._skipTag(this.tag, 'negative value for \"rx/ry\" not allowed');\n\t            }\n\t\n\t            // If rx is greater than half of width, then set rx to half of width.\n\t            // If ry is greater than half of height, then set ry to half of height.\n\t            if (rx > w / 2) rx = w / 2;\n\t            if (ry > h / 2) ry = h / 2;\n\t\n\t            var dx = rx * 2;\n\t            var dy = ry * 2;\n\t\n\t            // Handled tag\n\t            return this._path(['M', x + rx, y, 'h', w - dx, 'c', rx, 0, rx, ry, rx, ry, 'v', h - dy, 'c', 0, ry, -rx, ry, -rx, ry, 'h', -w + dx, 'c', -rx, 0, -rx, -ry, -rx, -ry, 'v', -h + dy, 'c', 0, 0, 0, -ry, rx, -ry, 'z']);\n\t        }\n\t    }, {\n\t        key: '_circle',\n\t        value: function _circle() {\n\t            var r = this.tag.getAttr('r', 0);\n\t\n\t            if (r <= 0) {\n\t                // Skipped tag\n\t                return false;\n\t            }\n\t\n\t            var cx = this.tag.getAttr('cx', 0);\n\t            var cy = this.tag.getAttr('cy', 0);\n\t\n\t            // Handled tag\n\t            return this._path(['M', cx - r, cy, 'A', r, r, 0, 0, 0, cx, cy + r, 'A', r, r, 0, 0, 0, cx + r, cy, 'A', r, r, 0, 0, 0, cx, cy - r, 'A', r, r, 0, 0, 0, cx - r, cy, 'Z']);\n\t        }\n\t    }, {\n\t        key: '_ellipse',\n\t        value: function _ellipse() {\n\t            var rx = this.tag.getAttr('rx', 0);\n\t            var ry = this.tag.getAttr('ry', 0);\n\t\n\t            if (rx <= 0 || ry <= 0) {\n\t                // Skipped tag\n\t                return false;\n\t            }\n\t\n\t            var cx = this.tag.getAttr('cx', 0);\n\t            var cy = this.tag.getAttr('cy', 0);\n\t\n\t            // Handled tag\n\t            return this._path(['M', cx - rx, cy, 'A', rx, ry, 0, 0, 0, cx, cy + ry, 'A', rx, ry, 0, 0, 0, cx + rx, cy, 'A', rx, ry, 0, 0, 0, cx, cy - ry, 'A', rx, ry, 0, 0, 0, cx - rx, cy, 'Z']);\n\t        }\n\t    }, {\n\t        key: '_paths',\n\t        value: function _paths(type, num, points) {\n\t            if (points.length > num) {\n\t                var handler = void 0,\n\t                    result = true;\n\t\n\t                while (result && points.length) {\n\t                    handler = this['_path' + type];\n\t                    result = handler.call(this, points.splice(0, num));\n\t                }\n\t\n\t                return result;\n\t            }\n\t\n\t            return null;\n\t        }\n\t    }, {\n\t        key: '_path',\n\t        value: function _path(path) {\n\t            var _this4 = this;\n\t\n\t            // Provided path\n\t            if (path && typeof path !== 'string') {\n\t                path = path.join(' ');\n\t            }\n\t\n\t            // Get the paths data attribute value\n\t            var dAttr = path || this.tag.getAttr('d', null);\n\t\n\t            if (!dAttr) {\n\t                // Skipped tag\n\t                return false;\n\t            }\n\t\n\t            // Split on each commands\n\t            var commands = dAttr.match(/([M|Z|L|H|V|C|S|Q|T|A]+([^M|Z|L|H|V|C|S|Q|T|A]+)?)/gi);\n\t\n\t            if (!commands) {\n\t                return this.parser._skipTag(this.tag, 'malformed \"d\" attribute');\n\t            }\n\t\n\t            // For each command...\n\t            this.currentCommand = {\n\t                raw: null,\n\t                type: null,\n\t                params: null,\n\t                relative: null\n\t            };\n\t            this.lastCommand = this.currentCommand;\n\t            this.pathData = {};\n\t\n\t            var handler = null;\n\t            var parseError = false;\n\t\n\t            commands.some(function (raw) {\n\t                // Remove trailing whitespaces\n\t                raw = raw.trim();\n\t\n\t                // Extract command char and params\n\t                _this4.currentCommand.raw = raw;\n\t                _this4.currentCommand.type = raw[0].toUpperCase();\n\t                _this4.currentCommand.params = raw.substr(1).trim();\n\t                _this4.currentCommand.relative = _this4.currentCommand.type !== raw[0];\n\t\n\t                // Get path handler from command char\n\t                handler = _this4['_path' + _this4.currentCommand.type];\n\t\n\t                if (!handler || typeof handler !== 'function') {\n\t                    _this4.parser._skipTag(_this4.tag, 'unsupported path command [' + raw[0] + ']');\n\t                    return parseError = true; // break\n\t                }\n\t\n\t                // Extract all numbers from arguments string\n\t                _this4.currentCommand.params = _this4._parseNumbers(_this4.currentCommand.params);\n\t\n\t                if (_this4.currentCommand.params === false) {\n\t                    _this4.parser._skipTag(_this4.tag, 'only numeric values are allowed in [' + _this4.currentCommand.raw + ']');\n\t                    return parseError = true; // break\n\t                }\n\t\n\t                // Execute command parser\n\t                if (!handler.call(_this4, _this4.currentCommand.params)) {\n\t                    return parseError = true; // break\n\t                }\n\t\n\t                // Update last command\n\t                _this4.lastCommand = {};\n\t\n\t                Object.keys(_this4.currentCommand).forEach(function (key) {\n\t                    _this4.lastCommand[key] = _this4.currentCommand[key];\n\t                });\n\t            });\n\t\n\t            // Skip tag\n\t            if (parseError) {\n\t                this._clearPath();\n\t                return false;\n\t            }\n\t\n\t            // Handled tag\n\t            return true;\n\t        }\n\t    }, {\n\t        key: '_pathM',\n\t        value: function _pathM(points) {\n\t            // New path\n\t            this._newPath();\n\t\n\t            // Set the current point (start of new path)\n\t            // If is followed by multiple pairs of coordinates,\n\t            // the subsequent pairs are treated as implicit lineto commands.\n\t            return this._addPoints(points);\n\t        }\n\t    }, {\n\t        key: '_pathZ',\n\t        value: function _pathZ() {\n\t            this._closePath();\n\t            return true;\n\t        }\n\t    }, {\n\t        key: '_pathL',\n\t        value: function _pathL(points) {\n\t            return this._addPoints(points);\n\t        }\n\t    }, {\n\t        key: '_pathH',\n\t        value: function _pathH(points) {\n\t            var _this5 = this;\n\t\n\t            return points.every(function (x) {\n\t                return _this5._addPoints([x, _this5.currentCommand.relative ? 0 : _this5.tag.point.y]);\n\t            });\n\t        }\n\t    }, {\n\t        key: '_pathV',\n\t        value: function _pathV(points) {\n\t            var _this6 = this;\n\t\n\t            return points.every(function (y) {\n\t                return _this6._addPoints([_this6.currentCommand.relative ? 0 : _this6.tag.point.x, y]);\n\t            });\n\t        }\n\t    }, {\n\t        key: '_pathC',\n\t        value: function _pathC(points) {\n\t            // Multiple paths\n\t            var result = this._paths('C', 6, points);\n\t\n\t            if (result !== null) {\n\t                return result;\n\t            }\n\t\n\t            // Single path\n\t            var p1 = this.tag.point;\n\t            var rl = this.currentCommand.relative;\n\t\n\t            var x1 = points[0] + (rl ? p1.x : 0);\n\t            var y1 = points[1] + (rl ? p1.y : 0);\n\t            var x2 = points[2] + (rl ? p1.x : 0);\n\t            var y2 = points[3] + (rl ? p1.y : 0);\n\t            var x = points[4] + (rl ? p1.x : 0);\n\t            var y = points[5] + (rl ? p1.y : 0);\n\t\n\t            this.pathData.x2 = x2;\n\t            this.pathData.y2 = y2;\n\t\n\t            var p2 = new _lw2.Point(x1, y1);\n\t            var p3 = new _lw2.Point(x2, y2);\n\t            var p4 = new _lw2.Point(x, y);\n\t\n\t            //console.log('C', p1, p2, p3, p4)\n\t\n\t            // p1  : starting point\n\t            // p2  : control point\n\t            // p3  : control point\n\t            // p4  : end point\n\t            var tracer = new _lw.CubicBezier(this.traceSettings);\n\t            var coords = tracer.trace({ p1: p1, p2: p2, p3: p3, p4: p4 }); // => [x,y, x,y, ...]\n\t            // let tracer = trace(CubicBezier, this.traceSettings)\n\t            // let coords = tracer({ p1, p2, p3, p4 })\n\t\n\t            // Trace the line\n\t            return this._addPoints(coords, false);\n\t        }\n\t    }, {\n\t        key: '_pathS',\n\t        value: function _pathS(points) {\n\t            // Multiple paths\n\t            var result = this._paths('S', 4, points);\n\t\n\t            if (result !== null) {\n\t                return result;\n\t            }\n\t\n\t            // Single path\n\t            var p1 = this.tag.point;\n\t            var rl = this.currentCommand.relative;\n\t\n\t            var x1 = p1.x;\n\t            var y1 = p1.y;\n\t\n\t            if (this.lastCommand.type === 'S' || this.lastCommand.type === 'C') {\n\t                x1 -= this.pathData.x2 - x1;\n\t                y1 -= this.pathData.y2 - y1;\n\t            }\n\t\n\t            var x2 = points[0] + (rl ? p1.x : 0);\n\t            var y2 = points[1] + (rl ? p1.y : 0);\n\t            var x = points[2] + (rl ? p1.x : 0);\n\t            var y = points[3] + (rl ? p1.y : 0);\n\t\n\t            this.pathData.x2 = x2;\n\t            this.pathData.y2 = y2;\n\t\n\t            var p2 = new _lw2.Point(x1, y1);\n\t            var p3 = new _lw2.Point(x2, y2);\n\t            var p4 = new _lw2.Point(x, y);\n\t\n\t            //console.log('S', p1, p2, p3, p4)\n\t\n\t            // p1  : starting point\n\t            // p2  : control point\n\t            // p3  : control point\n\t            // p4  : end point\n\t            var tracer = new _lw.CubicBezier(this.traceSettings);\n\t            var coords = tracer.trace({ p1: p1, p2: p2, p3: p3, p4: p4 }); // => [x,y, x,y, ...]\n\t            // let tracer = trace(CubicBezier, this.traceSettings)\n\t            // let coords = tracer({ p1, p2, p3, p4 })\n\t\n\t            // Trace the line\n\t            return this._addPoints(coords, false);\n\t        }\n\t    }, {\n\t        key: '_pathQ',\n\t        value: function _pathQ(points) {\n\t            // Multiple paths\n\t            var result = this._paths('Q', 4, points);\n\t\n\t            if (result !== null) {\n\t                return result;\n\t            }\n\t\n\t            // Single path\n\t            var p1 = this.tag.point;\n\t            var rl = this.currentCommand.relative;\n\t\n\t            var x1 = points[0] + (rl ? p1.x : 0);\n\t            var y1 = points[1] + (rl ? p1.y : 0);\n\t            var x = points[2] + (rl ? p1.x : 0);\n\t            var y = points[3] + (rl ? p1.y : 0);\n\t\n\t            this.pathData.x1 = x1;\n\t            this.pathData.y1 = y1;\n\t\n\t            var p2 = new _lw2.Point(x1, y1);\n\t            var p3 = new _lw2.Point(x, y);\n\t\n\t            //console.log('Q', p1, p2, p3)\n\t\n\t            // p1  : starting point\n\t            // p2  : control point\n\t            // p3  : end point\n\t            var tracer = new _lw.QuadricBezier(this.traceSettings);\n\t            var coords = tracer.trace({ p1: p1, p2: p2, p3: p3 }); // => [x,y, x,y, ...]\n\t\n\t            // Trace the line\n\t            return this._addPoints(coords, false);\n\t        }\n\t    }, {\n\t        key: '_pathT',\n\t        value: function _pathT(points) {\n\t            // Multiple paths\n\t            var result = this._paths('T', 2, points);\n\t\n\t            if (result !== null) {\n\t                return result;\n\t            }\n\t\n\t            // Single path\n\t            var p1 = this.tag.point;\n\t            var rl = this.currentCommand.relative;\n\t\n\t            var x1 = p1.x;\n\t            var y1 = p1.y;\n\t\n\t            if (this.lastCommand.type === 'Q' || this.lastCommand.type === 'T') {\n\t                x1 -= this.pathData.x1 - x1;\n\t                y1 -= this.pathData.y1 - y1;\n\t            }\n\t\n\t            var x = points[0] + (rl ? p1.x : 0);\n\t            var y = points[1] + (rl ? p1.y : 0);\n\t\n\t            this.pathData.x1 = x1;\n\t            this.pathData.y1 = y1;\n\t\n\t            var p2 = new _lw2.Point(x1, y1);\n\t            var p3 = new _lw2.Point(x, y);\n\t\n\t            //console.log('T', p1, p2, p3)\n\t\n\t            // p1  : starting point\n\t            // p2  : control point\n\t            // p3  : end point\n\t            var tracer = new _lw.QuadricBezier(this.traceSettings);\n\t            var coords = tracer.trace({ p1: p1, p2: p2, p3: p3 }); // => [x,y, x,y, ...]\n\t\n\t            // Trace the line\n\t            return this._addPoints(coords, false);\n\t        }\n\t    }, {\n\t        key: '_pathA',\n\t        value: function _pathA(points) {\n\t            // Multiple paths\n\t            var result = this._paths('A', 7, points);\n\t\n\t            if (result !== null) {\n\t                return result;\n\t            }\n\t\n\t            // Single path\n\t            var rl = this.currentCommand.relative;\n\t            var p1 = this.tag.point;\n\t            var rx = points[0];\n\t            var ry = points[1];\n\t            var angle = points[2];\n\t            var large = !!points[3];\n\t            var sweep = !!points[4];\n\t            var x = points[5] + (rl ? p1.x : 0);\n\t            var y = points[6] + (rl ? p1.y : 0);\n\t            var p2 = new _lw2.Point(x, y);\n\t\n\t            //console.log('A', p1, rx, ry, angle, large, sweep, p2)\n\t\n\t            var tracer = new _lw.Arc(this.traceSettings);\n\t            var coords = tracer.trace({ p1: p1, rx: rx, ry: ry, angle: angle, large: large, sweep: sweep, p2: p2 }); // => [x,y, x,y, ...]\n\t\n\t            // Trace the line\n\t            return this._addPoints(coords, false);\n\t        }\n\t    }]);\n\t\n\t    return TagParser;\n\t}();\n\t\n\t// Exports\n\t\n\t\n\texports.TagParser = TagParser;\n\texports.default = TagParser;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;// rev 482\n\t/********************************************************************************\n\t *                                                                              *\n\t * Author    :  Angus Johnson                                                   *\n\t * Version   :  6.2.1                                                          *\n\t * Date      :  31 October 2014                                                 *\n\t * Website   :  http://www.angusj.com                                           *\n\t * Copyright :  Angus Johnson 2010-2014                                         *\n\t *                                                                              *\n\t * License:                                                                     *\n\t * Use, modification & distribution is subject to Boost Software License Ver 1. *\n\t * http://www.boost.org/LICENSE_1_0.txt                                         *\n\t *                                                                              *\n\t * Attributions:                                                                *\n\t * The code in this library is an extension of Bala Vatti's clipping algorithm: *\n\t * \"A generic solution to polygon clipping\"                                     *\n\t * Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *\n\t * http://portal.acm.org/citation.cfm?id=129906                                 *\n\t *                                                                              *\n\t * Computer graphics and geometric modeling: implementation and algorithms      *\n\t * By Max K. Agoston                                                            *\n\t * Springer; 1 edition (January 4, 2005)                                        *\n\t * http://books.google.com/books?q=vatti+clipping+agoston                       *\n\t *                                                                              *\n\t * See also:                                                                    *\n\t * \"Polygon Offsetting by Computing Winding Numbers\"                            *\n\t * Paper no. DETC2005-85513 pp. 565-575                                         *\n\t * ASME 2005 International Design Engineering Technical Conferences             *\n\t * and Computers and Information in Engineering Conference (IDETC/CIE2005)      *\n\t * September 24-28, 2005 , Long Beach, California, USA                          *\n\t * http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *\n\t *                                                                              *\n\t *******************************************************************************/\n\t/*******************************************************************************\n\t *                                                                              *\n\t * Author    :  Timo                                                            *\n\t * Version   :  6.2.1.0                                                         *\n\t * Date      :  17 June 2016                                                 *\n\t *                                                                              *\n\t * This is a translation of the C# Clipper library to Javascript.               *\n\t * Int128 struct of C# is implemented using JSBN of Tom Wu.                     *\n\t * Because Javascript lacks support for 64-bit integers, the space              *\n\t * is a little more restricted than in C# version.                              *\n\t *                                                                              *\n\t * C# version has support for coordinate space:                                 *\n\t * +-4611686018427387903 ( sqrt(2^127 -1)/2 )                                   *\n\t * while Javascript version has support for space:                              *\n\t * +-4503599627370495 ( sqrt(2^106 -1)/2 )                                      *\n\t *                                                                              *\n\t * Tom Wu's JSBN proved to be the fastest big integer library:                  *\n\t * http://jsperf.com/big-integer-library-test                                   *\n\t *                                                                              *\n\t * This class can be made simpler when (if ever) 64-bit integer support comes.  *\n\t *                                                                              *\n\t *******************************************************************************/\n\t/*******************************************************************************\n\t *                                                                              *\n\t * Basic JavaScript BN library - subset useful for RSA encryption.              *\n\t * http://www-cs-students.stanford.edu/~tjw/jsbn/                               *\n\t * Copyright (c) 2005  Tom Wu                                                   *\n\t * All Rights Reserved.                                                         *\n\t * See \"LICENSE\" for details:                                                   *\n\t * http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE                        *\n\t *                                                                              *\n\t *******************************************************************************/\n\t(function ()\n\t{\n\t  \"use strict\";\n\t  //use_int32: When enabled 32bit ints are used instead of 64bit ints. This\n\t  //improve performance but coordinate values are limited to the range +/- 46340\n\t  var use_int32 = false;\n\t  //use_xyz: adds a Z member to IntPoint. Adds a minor cost to performance.\n\t  var use_xyz = false;\n\t  //UseLines: Enables open path clipping. Adds a very minor cost to performance.\n\t  var use_lines = true;\n\t\n\t  var ClipperLib = {};\n\t  var isNode = false;\n\t  if (typeof module !== 'undefined' && module.exports)\n\t  {\n\t    module.exports = ClipperLib;\n\t    isNode = true;\n\t  }\n\t  else\n\t  {\n\t    if (true) {\n\t      !(__WEBPACK_AMD_DEFINE_FACTORY__ = (ClipperLib), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t    if (typeof (document) !== \"undefined\") window.ClipperLib = ClipperLib;\n\t    else self['ClipperLib'] = ClipperLib;\n\t  }\n\t  var navigator_appName;\n\t  if (!isNode)\n\t  {\n\t    var nav = navigator.userAgent.toString().toLowerCase();\n\t    navigator_appName = navigator.appName;\n\t  }\n\t  else\n\t  {\n\t    var nav = \"chrome\"; // Node.js uses Chrome's V8 engine\n\t    navigator_appName = \"Netscape\"; // Firefox, Chrome and Safari returns \"Netscape\", so Node.js should also\n\t  }\n\t  // Browser test to speedup performance critical functions\n\t  var browser = {};\n\t  if (nav.indexOf(\"chrome\") != -1 && nav.indexOf(\"chromium\") == -1) browser.chrome = 1;\n\t  else browser.chrome = 0;\n\t  if (nav.indexOf(\"chromium\") != -1) browser.chromium = 1;\n\t  else browser.chromium = 0;\n\t  if (nav.indexOf(\"safari\") != -1 && nav.indexOf(\"chrome\") == -1 && nav.indexOf(\"chromium\") == -1) browser.safari = 1;\n\t  else browser.safari = 0;\n\t  if (nav.indexOf(\"firefox\") != -1) browser.firefox = 1;\n\t  else browser.firefox = 0;\n\t  if (nav.indexOf(\"firefox/17\") != -1) browser.firefox17 = 1;\n\t  else browser.firefox17 = 0;\n\t  if (nav.indexOf(\"firefox/15\") != -1) browser.firefox15 = 1;\n\t  else browser.firefox15 = 0;\n\t  if (nav.indexOf(\"firefox/3\") != -1) browser.firefox3 = 1;\n\t  else browser.firefox3 = 0;\n\t  if (nav.indexOf(\"opera\") != -1) browser.opera = 1;\n\t  else browser.opera = 0;\n\t  if (nav.indexOf(\"msie 10\") != -1) browser.msie10 = 1;\n\t  else browser.msie10 = 0;\n\t  if (nav.indexOf(\"msie 9\") != -1) browser.msie9 = 1;\n\t  else browser.msie9 = 0;\n\t  if (nav.indexOf(\"msie 8\") != -1) browser.msie8 = 1;\n\t  else browser.msie8 = 0;\n\t  if (nav.indexOf(\"msie 7\") != -1) browser.msie7 = 1;\n\t  else browser.msie7 = 0;\n\t  if (nav.indexOf(\"msie \") != -1) browser.msie = 1;\n\t  else browser.msie = 0;\n\t  ClipperLib.biginteger_used = null;\n\t\n\t  // Copyright (c) 2005  Tom Wu\n\t  // All Rights Reserved.\n\t  // See \"LICENSE\" for details.\n\t  // Basic JavaScript BN library - subset useful for RSA encryption.\n\t  // Bits per digit\n\t  var dbits;\n\t  // JavaScript engine analysis\n\t  var canary = 0xdeadbeefcafe;\n\t  var j_lm = ((canary & 0xffffff) == 0xefcafe);\n\t  // (public) Constructor\n\t  function BigInteger(a, b, c)\n\t  {\n\t    // This test variable can be removed,\n\t    // but at least for performance tests it is useful piece of knowledge\n\t    // This is the only ClipperLib related variable in BigInteger library\n\t    ClipperLib.biginteger_used = 1;\n\t    if (a != null)\n\t      if (\"number\" == typeof a && \"undefined\" == typeof (b)) this.fromInt(a); // faster conversion\n\t      else if (\"number\" == typeof a) this.fromNumber(a, b, c);\n\t    else if (b == null && \"string\" != typeof a) this.fromString(a, 256);\n\t    else this.fromString(a, b);\n\t  }\n\t  // return new, unset BigInteger\n\t  function nbi()\n\t  {\n\t    return new BigInteger(null,undefined,undefined);\n\t  }\n\t  // am: Compute w_j += (x*this_i), propagate carries,\n\t  // c is initial carry, returns final carry.\n\t  // c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n\t  // We need to select the fastest one that works in this environment.\n\t  // am1: use a single mult and divide to get the high bits,\n\t  // max digit bits should be 26 because\n\t  // max internal value = 2*dvalue^2-2*dvalue (< 2^53)\n\t  function am1(i, x, w, j, c, n)\n\t  {\n\t    while (--n >= 0)\n\t    {\n\t      var v = x * this[i++] + w[j] + c;\n\t      c = Math.floor(v / 0x4000000);\n\t      w[j++] = v & 0x3ffffff;\n\t    }\n\t    return c;\n\t  }\n\t  // am2 avoids a big mult-and-extract completely.\n\t  // Max digit bits should be <= 30 because we do bitwise ops\n\t  // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\n\t  function am2(i, x, w, j, c, n)\n\t  {\n\t    var xl = x & 0x7fff,\n\t      xh = x >> 15;\n\t    while (--n >= 0)\n\t    {\n\t      var l = this[i] & 0x7fff;\n\t      var h = this[i++] >> 15;\n\t      var m = xh * l + h * xl;\n\t      l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);\n\t      c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);\n\t      w[j++] = l & 0x3fffffff;\n\t    }\n\t    return c;\n\t  }\n\t  // Alternately, set max digit bits to 28 since some\n\t  // browsers slow down when dealing with 32-bit numbers.\n\t  function am3(i, x, w, j, c, n)\n\t  {\n\t    var xl = x & 0x3fff,\n\t      xh = x >> 14;\n\t    while (--n >= 0)\n\t    {\n\t      var l = this[i] & 0x3fff;\n\t      var h = this[i++] >> 14;\n\t      var m = xh * l + h * xl;\n\t      l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;\n\t      c = (l >> 28) + (m >> 14) + xh * h;\n\t      w[j++] = l & 0xfffffff;\n\t    }\n\t    return c;\n\t  }\n\t  if (j_lm && (navigator_appName == \"Microsoft Internet Explorer\"))\n\t  {\n\t    BigInteger.prototype.am = am2;\n\t    dbits = 30;\n\t  }\n\t  else if (j_lm && (navigator_appName != \"Netscape\"))\n\t  {\n\t    BigInteger.prototype.am = am1;\n\t    dbits = 26;\n\t  }\n\t  else\n\t  { // Mozilla/Netscape seems to prefer am3\n\t    BigInteger.prototype.am = am3;\n\t    dbits = 28;\n\t  }\n\t  BigInteger.prototype.DB = dbits;\n\t  BigInteger.prototype.DM = ((1 << dbits) - 1);\n\t  BigInteger.prototype.DV = (1 << dbits);\n\t  var BI_FP = 52;\n\t  BigInteger.prototype.FV = Math.pow(2, BI_FP);\n\t  BigInteger.prototype.F1 = BI_FP - dbits;\n\t  BigInteger.prototype.F2 = 2 * dbits - BI_FP;\n\t  // Digit conversions\n\t  var BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\t  var BI_RC = new Array();\n\t  var rr, vv;\n\t  rr = \"0\".charCodeAt(0);\n\t  for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\n\t  rr = \"a\".charCodeAt(0);\n\t  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\t  rr = \"A\".charCodeAt(0);\n\t  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\t\n\t  function int2char(n)\n\t  {\n\t    return BI_RM.charAt(n);\n\t  }\n\t\n\t  function intAt(s, i)\n\t  {\n\t    var c = BI_RC[s.charCodeAt(i)];\n\t    return (c == null) ? -1 : c;\n\t  }\n\t  // (protected) copy this to r\n\t  function bnpCopyTo(r)\n\t  {\n\t    for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];\n\t    r.t = this.t;\n\t    r.s = this.s;\n\t  }\n\t  // (protected) set from integer value x, -DV <= x < DV\n\t  function bnpFromInt(x)\n\t  {\n\t    this.t = 1;\n\t    this.s = (x < 0) ? -1 : 0;\n\t    if (x > 0) this[0] = x;\n\t    else if (x < -1) this[0] = x + this.DV;\n\t    else this.t = 0;\n\t  }\n\t  // return bigint initialized to value\n\t  function nbv(i)\n\t  {\n\t    var r = nbi();\n\t    r.fromInt(i);\n\t    return r;\n\t  }\n\t  // (protected) set from string and radix\n\t  function bnpFromString(s, b)\n\t  {\n\t    var k;\n\t    if (b == 16) k = 4;\n\t    else if (b == 8) k = 3;\n\t    else if (b == 256) k = 8; // byte array\n\t    else if (b == 2) k = 1;\n\t    else if (b == 32) k = 5;\n\t    else if (b == 4) k = 2;\n\t    else\n\t    {\n\t      this.fromRadix(s, b);\n\t      return;\n\t    }\n\t    this.t = 0;\n\t    this.s = 0;\n\t    var i = s.length,\n\t      mi = false,\n\t      sh = 0;\n\t    while (--i >= 0)\n\t    {\n\t      var x = (k == 8) ? s[i] & 0xff : intAt(s, i);\n\t      if (x < 0)\n\t      {\n\t        if (s.charAt(i) == \"-\") mi = true;\n\t        continue;\n\t      }\n\t      mi = false;\n\t      if (sh == 0)\n\t        this[this.t++] = x;\n\t      else if (sh + k > this.DB)\n\t      {\n\t        this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;\n\t        this[this.t++] = (x >> (this.DB - sh));\n\t      }\n\t      else\n\t        this[this.t - 1] |= x << sh;\n\t      sh += k;\n\t      if (sh >= this.DB) sh -= this.DB;\n\t    }\n\t    if (k == 8 && (s[0] & 0x80) != 0)\n\t    {\n\t      this.s = -1;\n\t      if (sh > 0) this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;\n\t    }\n\t    this.clamp();\n\t    if (mi) BigInteger.ZERO.subTo(this, this);\n\t  }\n\t  // (protected) clamp off excess high words\n\t  function bnpClamp()\n\t  {\n\t    var c = this.s & this.DM;\n\t    while (this.t > 0 && this[this.t - 1] == c)--this.t;\n\t  }\n\t  // (public) return string representation in given radix\n\t  function bnToString(b)\n\t  {\n\t    if (this.s < 0) return \"-\" + this.negate().toString(b);\n\t    var k;\n\t    if (b == 16) k = 4;\n\t    else if (b == 8) k = 3;\n\t    else if (b == 2) k = 1;\n\t    else if (b == 32) k = 5;\n\t    else if (b == 4) k = 2;\n\t    else return this.toRadix(b);\n\t    var km = (1 << k) - 1,\n\t      d, m = false,\n\t      r = \"\",\n\t      i = this.t;\n\t    var p = this.DB - (i * this.DB) % k;\n\t    if (i-- > 0)\n\t    {\n\t      if (p < this.DB && (d = this[i] >> p) > 0)\n\t      {\n\t        m = true;\n\t        r = int2char(d);\n\t      }\n\t      while (i >= 0)\n\t      {\n\t        if (p < k)\n\t        {\n\t          d = (this[i] & ((1 << p) - 1)) << (k - p);\n\t          d |= this[--i] >> (p += this.DB - k);\n\t        }\n\t        else\n\t        {\n\t          d = (this[i] >> (p -= k)) & km;\n\t          if (p <= 0)\n\t          {\n\t            p += this.DB;\n\t            --i;\n\t          }\n\t        }\n\t        if (d > 0) m = true;\n\t        if (m) r += int2char(d);\n\t      }\n\t    }\n\t    return m ? r : \"0\";\n\t  }\n\t  // (public) -this\n\t  function bnNegate()\n\t  {\n\t    var r = nbi();\n\t    BigInteger.ZERO.subTo(this, r);\n\t    return r;\n\t  }\n\t  // (public) |this|\n\t  function bnAbs()\n\t  {\n\t    return (this.s < 0) ? this.negate() : this;\n\t  }\n\t  // (public) return + if this > a, - if this < a, 0 if equal\n\t  function bnCompareTo(a)\n\t  {\n\t    var r = this.s - a.s;\n\t    if (r != 0) return r;\n\t    var i = this.t;\n\t    r = i - a.t;\n\t    if (r != 0) return (this.s < 0) ? -r : r;\n\t    while (--i >= 0)\n\t      if ((r = this[i] - a[i]) != 0) return r;\n\t    return 0;\n\t  }\n\t  // returns bit length of the integer x\n\t  function nbits(x)\n\t  {\n\t    var r = 1,\n\t      t;\n\t    if ((t = x >>> 16) != 0)\n\t    {\n\t      x = t;\n\t      r += 16;\n\t    }\n\t    if ((t = x >> 8) != 0)\n\t    {\n\t      x = t;\n\t      r += 8;\n\t    }\n\t    if ((t = x >> 4) != 0)\n\t    {\n\t      x = t;\n\t      r += 4;\n\t    }\n\t    if ((t = x >> 2) != 0)\n\t    {\n\t      x = t;\n\t      r += 2;\n\t    }\n\t    if ((t = x >> 1) != 0)\n\t    {\n\t      x = t;\n\t      r += 1;\n\t    }\n\t    return r;\n\t  }\n\t  // (public) return the number of bits in \"this\"\n\t  function bnBitLength()\n\t  {\n\t    if (this.t <= 0) return 0;\n\t    return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));\n\t  }\n\t  // (protected) r = this << n*DB\n\t  function bnpDLShiftTo(n, r)\n\t  {\n\t    var i;\n\t    for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];\n\t    for (i = n - 1; i >= 0; --i) r[i] = 0;\n\t    r.t = this.t + n;\n\t    r.s = this.s;\n\t  }\n\t  // (protected) r = this >> n*DB\n\t  function bnpDRShiftTo(n, r)\n\t  {\n\t    for (var i = n; i < this.t; ++i) r[i - n] = this[i];\n\t    r.t = Math.max(this.t - n, 0);\n\t    r.s = this.s;\n\t  }\n\t  // (protected) r = this << n\n\t  function bnpLShiftTo(n, r)\n\t  {\n\t    var bs = n % this.DB;\n\t    var cbs = this.DB - bs;\n\t    var bm = (1 << cbs) - 1;\n\t    var ds = Math.floor(n / this.DB),\n\t      c = (this.s << bs) & this.DM,\n\t      i;\n\t    for (i = this.t - 1; i >= 0; --i)\n\t    {\n\t      r[i + ds + 1] = (this[i] >> cbs) | c;\n\t      c = (this[i] & bm) << bs;\n\t    }\n\t    for (i = ds - 1; i >= 0; --i) r[i] = 0;\n\t    r[ds] = c;\n\t    r.t = this.t + ds + 1;\n\t    r.s = this.s;\n\t    r.clamp();\n\t  }\n\t  // (protected) r = this >> n\n\t  function bnpRShiftTo(n, r)\n\t  {\n\t    r.s = this.s;\n\t    var ds = Math.floor(n / this.DB);\n\t    if (ds >= this.t)\n\t    {\n\t      r.t = 0;\n\t      return;\n\t    }\n\t    var bs = n % this.DB;\n\t    var cbs = this.DB - bs;\n\t    var bm = (1 << bs) - 1;\n\t    r[0] = this[ds] >> bs;\n\t    for (var i = ds + 1; i < this.t; ++i)\n\t    {\n\t      r[i - ds - 1] |= (this[i] & bm) << cbs;\n\t      r[i - ds] = this[i] >> bs;\n\t    }\n\t    if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;\n\t    r.t = this.t - ds;\n\t    r.clamp();\n\t  }\n\t  // (protected) r = this - a\n\t  function bnpSubTo(a, r)\n\t  {\n\t    var i = 0,\n\t      c = 0,\n\t      m = Math.min(a.t, this.t);\n\t    while (i < m)\n\t    {\n\t      c += this[i] - a[i];\n\t      r[i++] = c & this.DM;\n\t      c >>= this.DB;\n\t    }\n\t    if (a.t < this.t)\n\t    {\n\t      c -= a.s;\n\t      while (i < this.t)\n\t      {\n\t        c += this[i];\n\t        r[i++] = c & this.DM;\n\t        c >>= this.DB;\n\t      }\n\t      c += this.s;\n\t    }\n\t    else\n\t    {\n\t      c += this.s;\n\t      while (i < a.t)\n\t      {\n\t        c -= a[i];\n\t        r[i++] = c & this.DM;\n\t        c >>= this.DB;\n\t      }\n\t      c -= a.s;\n\t    }\n\t    r.s = (c < 0) ? -1 : 0;\n\t    if (c < -1) r[i++] = this.DV + c;\n\t    else if (c > 0) r[i++] = c;\n\t    r.t = i;\n\t    r.clamp();\n\t  }\n\t  // (protected) r = this * a, r != this,a (HAC 14.12)\n\t  // \"this\" should be the larger one if appropriate.\n\t  function bnpMultiplyTo(a, r)\n\t  {\n\t    var x = this.abs(),\n\t      y = a.abs();\n\t    var i = x.t;\n\t    r.t = i + y.t;\n\t    while (--i >= 0) r[i] = 0;\n\t    for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);\n\t    r.s = 0;\n\t    r.clamp();\n\t    if (this.s != a.s) BigInteger.ZERO.subTo(r, r);\n\t  }\n\t  // (protected) r = this^2, r != this (HAC 14.16)\n\t  function bnpSquareTo(r)\n\t  {\n\t    var x = this.abs();\n\t    var i = r.t = 2 * x.t;\n\t    while (--i >= 0) r[i] = 0;\n\t    for (i = 0; i < x.t - 1; ++i)\n\t    {\n\t      var c = x.am(i, x[i], r, 2 * i, 0, 1);\n\t      if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV)\n\t      {\n\t        r[i + x.t] -= x.DV;\n\t        r[i + x.t + 1] = 1;\n\t      }\n\t    }\n\t    if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);\n\t    r.s = 0;\n\t    r.clamp();\n\t  }\n\t  // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n\t  // r != q, this != m.  q or r may be null.\n\t  function bnpDivRemTo(m, q, r)\n\t  {\n\t    var pm = m.abs();\n\t    if (pm.t <= 0) return;\n\t    var pt = this.abs();\n\t    if (pt.t < pm.t)\n\t    {\n\t      if (q != null) q.fromInt(0);\n\t      if (r != null) this.copyTo(r);\n\t      return;\n\t    }\n\t    if (r == null) r = nbi();\n\t    var y = nbi(),\n\t      ts = this.s,\n\t      ms = m.s;\n\t    var nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus\n\t    if (nsh > 0)\n\t    {\n\t      pm.lShiftTo(nsh, y);\n\t      pt.lShiftTo(nsh, r);\n\t    }\n\t    else\n\t    {\n\t      pm.copyTo(y);\n\t      pt.copyTo(r);\n\t    }\n\t    var ys = y.t;\n\t    var y0 = y[ys - 1];\n\t    if (y0 == 0) return;\n\t    var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);\n\t    var d1 = this.FV / yt,\n\t      d2 = (1 << this.F1) / yt,\n\t      e = 1 << this.F2;\n\t    var i = r.t,\n\t      j = i - ys,\n\t      t = (q == null) ? nbi() : q;\n\t    y.dlShiftTo(j, t);\n\t    if (r.compareTo(t) >= 0)\n\t    {\n\t      r[r.t++] = 1;\n\t      r.subTo(t, r);\n\t    }\n\t    BigInteger.ONE.dlShiftTo(ys, t);\n\t    t.subTo(y, y); // \"negative\" y so we can replace sub with am later\n\t    while (y.t < ys) y[y.t++] = 0;\n\t    while (--j >= 0)\n\t    {\n\t      // Estimate quotient digit\n\t      var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);\n\t      if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd)\n\t      { // Try it out\n\t        y.dlShiftTo(j, t);\n\t        r.subTo(t, r);\n\t        while (r[i] < --qd) r.subTo(t, r);\n\t      }\n\t    }\n\t    if (q != null)\n\t    {\n\t      r.drShiftTo(ys, q);\n\t      if (ts != ms) BigInteger.ZERO.subTo(q, q);\n\t    }\n\t    r.t = ys;\n\t    r.clamp();\n\t    if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder\n\t    if (ts < 0) BigInteger.ZERO.subTo(r, r);\n\t  }\n\t  // (public) this mod a\n\t  function bnMod(a)\n\t  {\n\t    var r = nbi();\n\t    this.abs().divRemTo(a, null, r);\n\t    if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);\n\t    return r;\n\t  }\n\t  // Modular reduction using \"classic\" algorithm\n\t  function Classic(m)\n\t  {\n\t    this.m = m;\n\t  }\n\t\n\t  function cConvert(x)\n\t  {\n\t    if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n\t    else return x;\n\t  }\n\t\n\t  function cRevert(x)\n\t  {\n\t    return x;\n\t  }\n\t\n\t  function cReduce(x)\n\t  {\n\t    x.divRemTo(this.m, null, x);\n\t  }\n\t\n\t  function cMulTo(x, y, r)\n\t  {\n\t    x.multiplyTo(y, r);\n\t    this.reduce(r);\n\t  }\n\t\n\t  function cSqrTo(x, r)\n\t  {\n\t    x.squareTo(r);\n\t    this.reduce(r);\n\t  }\n\t  Classic.prototype.convert = cConvert;\n\t  Classic.prototype.revert = cRevert;\n\t  Classic.prototype.reduce = cReduce;\n\t  Classic.prototype.mulTo = cMulTo;\n\t  Classic.prototype.sqrTo = cSqrTo;\n\t  // (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n\t  // justification:\n\t  //         xy == 1 (mod m)\n\t  //         xy =  1+km\n\t  //   xy(2-xy) = (1+km)(1-km)\n\t  // x[y(2-xy)] = 1-k^2m^2\n\t  // x[y(2-xy)] == 1 (mod m^2)\n\t  // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n\t  // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n\t  // JS multiply \"overflows\" differently from C/C++, so care is needed here.\n\t  function bnpInvDigit()\n\t  {\n\t    if (this.t < 1) return 0;\n\t    var x = this[0];\n\t    if ((x & 1) == 0) return 0;\n\t    var y = x & 3; // y == 1/x mod 2^2\n\t    y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4\n\t    y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8\n\t    y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16\n\t    // last step - calculate inverse mod DV directly;\n\t    // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n\t    y = (y * (2 - x * y % this.DV)) % this.DV; // y == 1/x mod 2^dbits\n\t    // we really want the negative inverse, and -DV < y < DV\n\t    return (y > 0) ? this.DV - y : -y;\n\t  }\n\t  // Montgomery reduction\n\t  function Montgomery(m)\n\t  {\n\t    this.m = m;\n\t    this.mp = m.invDigit();\n\t    this.mpl = this.mp & 0x7fff;\n\t    this.mph = this.mp >> 15;\n\t    this.um = (1 << (m.DB - 15)) - 1;\n\t    this.mt2 = 2 * m.t;\n\t  }\n\t  // xR mod m\n\t  function montConvert(x)\n\t  {\n\t    var r = nbi();\n\t    x.abs().dlShiftTo(this.m.t, r);\n\t    r.divRemTo(this.m, null, r);\n\t    if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);\n\t    return r;\n\t  }\n\t  // x/R mod m\n\t  function montRevert(x)\n\t  {\n\t    var r = nbi();\n\t    x.copyTo(r);\n\t    this.reduce(r);\n\t    return r;\n\t  }\n\t  // x = x/R mod m (HAC 14.32)\n\t  function montReduce(x)\n\t  {\n\t    while (x.t <= this.mt2) // pad x so am has enough room later\n\t      x[x.t++] = 0;\n\t    for (var i = 0; i < this.m.t; ++i)\n\t    {\n\t      // faster way of calculating u0 = x[i]*mp mod DV\n\t      var j = x[i] & 0x7fff;\n\t      var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;\n\t      // use am to combine the multiply-shift-add into one call\n\t      j = i + this.m.t;\n\t      x[j] += this.m.am(0, u0, x, i, 0, this.m.t);\n\t      // propagate carry\n\t      while (x[j] >= x.DV)\n\t      {\n\t        x[j] -= x.DV;\n\t        x[++j]++;\n\t      }\n\t    }\n\t    x.clamp();\n\t    x.drShiftTo(this.m.t, x);\n\t    if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n\t  }\n\t  // r = \"x^2/R mod m\"; x != r\n\t  function montSqrTo(x, r)\n\t  {\n\t    x.squareTo(r);\n\t    this.reduce(r);\n\t  }\n\t  // r = \"xy/R mod m\"; x,y != r\n\t  function montMulTo(x, y, r)\n\t  {\n\t    x.multiplyTo(y, r);\n\t    this.reduce(r);\n\t  }\n\t  Montgomery.prototype.convert = montConvert;\n\t  Montgomery.prototype.revert = montRevert;\n\t  Montgomery.prototype.reduce = montReduce;\n\t  Montgomery.prototype.mulTo = montMulTo;\n\t  Montgomery.prototype.sqrTo = montSqrTo;\n\t  // (protected) true iff this is even\n\t  function bnpIsEven()\n\t  {\n\t    return ((this.t > 0) ? (this[0] & 1) : this.s) == 0;\n\t  }\n\t  // (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\n\t  function bnpExp(e, z)\n\t  {\n\t    if (e > 0xffffffff || e < 1) return BigInteger.ONE;\n\t    var r = nbi(),\n\t      r2 = nbi(),\n\t      g = z.convert(this),\n\t      i = nbits(e) - 1;\n\t    g.copyTo(r);\n\t    while (--i >= 0)\n\t    {\n\t      z.sqrTo(r, r2);\n\t      if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);\n\t      else\n\t      {\n\t        var t = r;\n\t        r = r2;\n\t        r2 = t;\n\t      }\n\t    }\n\t    return z.revert(r);\n\t  }\n\t  // (public) this^e % m, 0 <= e < 2^32\n\t  function bnModPowInt(e, m)\n\t  {\n\t    var z;\n\t    if (e < 256 || m.isEven()) z = new Classic(m);\n\t    else z = new Montgomery(m);\n\t    return this.exp(e, z);\n\t  }\n\t  // protected\n\t  BigInteger.prototype.copyTo = bnpCopyTo;\n\t  BigInteger.prototype.fromInt = bnpFromInt;\n\t  BigInteger.prototype.fromString = bnpFromString;\n\t  BigInteger.prototype.clamp = bnpClamp;\n\t  BigInteger.prototype.dlShiftTo = bnpDLShiftTo;\n\t  BigInteger.prototype.drShiftTo = bnpDRShiftTo;\n\t  BigInteger.prototype.lShiftTo = bnpLShiftTo;\n\t  BigInteger.prototype.rShiftTo = bnpRShiftTo;\n\t  BigInteger.prototype.subTo = bnpSubTo;\n\t  BigInteger.prototype.multiplyTo = bnpMultiplyTo;\n\t  BigInteger.prototype.squareTo = bnpSquareTo;\n\t  BigInteger.prototype.divRemTo = bnpDivRemTo;\n\t  BigInteger.prototype.invDigit = bnpInvDigit;\n\t  BigInteger.prototype.isEven = bnpIsEven;\n\t  BigInteger.prototype.exp = bnpExp;\n\t  // public\n\t  BigInteger.prototype.toString = bnToString;\n\t  BigInteger.prototype.negate = bnNegate;\n\t  BigInteger.prototype.abs = bnAbs;\n\t  BigInteger.prototype.compareTo = bnCompareTo;\n\t  BigInteger.prototype.bitLength = bnBitLength;\n\t  BigInteger.prototype.mod = bnMod;\n\t  BigInteger.prototype.modPowInt = bnModPowInt;\n\t  // \"constants\"\n\t  BigInteger.ZERO = nbv(0);\n\t  BigInteger.ONE = nbv(1);\n\t  // Copyright (c) 2005-2009  Tom Wu\n\t  // All Rights Reserved.\n\t  // See \"LICENSE\" for details.\n\t  // Extended JavaScript BN functions, required for RSA private ops.\n\t  // Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\n\t  // Version 1.2: square() API, isProbablePrime fix\n\t  // (public)\n\t  function bnClone()\n\t  {\n\t    var r = nbi();\n\t    this.copyTo(r);\n\t    return r;\n\t  }\n\t  // (public) return value as integer\n\t  function bnIntValue()\n\t  {\n\t    if (this.s < 0)\n\t    {\n\t      if (this.t == 1) return this[0] - this.DV;\n\t      else if (this.t == 0) return -1;\n\t    }\n\t    else if (this.t == 1) return this[0];\n\t    else if (this.t == 0) return 0;\n\t    // assumes 16 < DB < 32\n\t    return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];\n\t  }\n\t  // (public) return value as byte\n\t  function bnByteValue()\n\t  {\n\t    return (this.t == 0) ? this.s : (this[0] << 24) >> 24;\n\t  }\n\t  // (public) return value as short (assumes DB>=16)\n\t  function bnShortValue()\n\t  {\n\t    return (this.t == 0) ? this.s : (this[0] << 16) >> 16;\n\t  }\n\t  // (protected) return x s.t. r^x < DV\n\t  function bnpChunkSize(r)\n\t  {\n\t    return Math.floor(Math.LN2 * this.DB / Math.log(r));\n\t  }\n\t  // (public) 0 if this == 0, 1 if this > 0\n\t  function bnSigNum()\n\t  {\n\t    if (this.s < 0) return -1;\n\t    else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n\t    else return 1;\n\t  }\n\t  // (protected) convert to radix string\n\t  function bnpToRadix(b)\n\t  {\n\t    if (b == null) b = 10;\n\t    if (this.signum() == 0 || b < 2 || b > 36) return \"0\";\n\t    var cs = this.chunkSize(b);\n\t    var a = Math.pow(b, cs);\n\t    var d = nbv(a),\n\t      y = nbi(),\n\t      z = nbi(),\n\t      r = \"\";\n\t    this.divRemTo(d, y, z);\n\t    while (y.signum() > 0)\n\t    {\n\t      r = (a + z.intValue()).toString(b).substr(1) + r;\n\t      y.divRemTo(d, y, z);\n\t    }\n\t    return z.intValue().toString(b) + r;\n\t  }\n\t  // (protected) convert from radix string\n\t  function bnpFromRadix(s, b)\n\t  {\n\t    this.fromInt(0);\n\t    if (b == null) b = 10;\n\t    var cs = this.chunkSize(b);\n\t    var d = Math.pow(b, cs),\n\t      mi = false,\n\t      j = 0,\n\t      w = 0;\n\t    for (var i = 0; i < s.length; ++i)\n\t    {\n\t      var x = intAt(s, i);\n\t      if (x < 0)\n\t      {\n\t        if (s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\n\t        continue;\n\t      }\n\t      w = b * w + x;\n\t      if (++j >= cs)\n\t      {\n\t        this.dMultiply(d);\n\t        this.dAddOffset(w, 0);\n\t        j = 0;\n\t        w = 0;\n\t      }\n\t    }\n\t    if (j > 0)\n\t    {\n\t      this.dMultiply(Math.pow(b, j));\n\t      this.dAddOffset(w, 0);\n\t    }\n\t    if (mi) BigInteger.ZERO.subTo(this, this);\n\t  }\n\t  // (protected) alternate constructor\n\t  function bnpFromNumber(a, b, c)\n\t  {\n\t    if (\"number\" == typeof b)\n\t    {\n\t      // new BigInteger(int,int,RNG)\n\t      if (a < 2) this.fromInt(1);\n\t      else\n\t      {\n\t        this.fromNumber(a, c);\n\t        if (!this.testBit(a - 1)) // force MSB set\n\t          this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);\n\t        if (this.isEven()) this.dAddOffset(1, 0); // force odd\n\t        while (!this.isProbablePrime(b))\n\t        {\n\t          this.dAddOffset(2, 0);\n\t          if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);\n\t        }\n\t      }\n\t    }\n\t    else\n\t    {\n\t      // new BigInteger(int,RNG)\n\t      var x = new Array(),\n\t        t = a & 7;\n\t      x.length = (a >> 3) + 1;\n\t      b.nextBytes(x);\n\t      if (t > 0) x[0] &= ((1 << t) - 1);\n\t      else x[0] = 0;\n\t      this.fromString(x, 256);\n\t    }\n\t  }\n\t  // (public) convert to bigendian byte array\n\t  function bnToByteArray()\n\t  {\n\t    var i = this.t,\n\t      r = new Array();\n\t    r[0] = this.s;\n\t    var p = this.DB - (i * this.DB) % 8,\n\t      d, k = 0;\n\t    if (i-- > 0)\n\t    {\n\t      if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)\n\t        r[k++] = d | (this.s << (this.DB - p));\n\t      while (i >= 0)\n\t      {\n\t        if (p < 8)\n\t        {\n\t          d = (this[i] & ((1 << p) - 1)) << (8 - p);\n\t          d |= this[--i] >> (p += this.DB - 8);\n\t        }\n\t        else\n\t        {\n\t          d = (this[i] >> (p -= 8)) & 0xff;\n\t          if (p <= 0)\n\t          {\n\t            p += this.DB;\n\t            --i;\n\t          }\n\t        }\n\t        if ((d & 0x80) != 0) d |= -256;\n\t        if (k == 0 && (this.s & 0x80) != (d & 0x80))++k;\n\t        if (k > 0 || d != this.s) r[k++] = d;\n\t      }\n\t    }\n\t    return r;\n\t  }\n\t\n\t  function bnEquals(a)\n\t  {\n\t    return (this.compareTo(a) == 0);\n\t  }\n\t\n\t  function bnMin(a)\n\t  {\n\t    return (this.compareTo(a) < 0) ? this : a;\n\t  }\n\t\n\t  function bnMax(a)\n\t  {\n\t    return (this.compareTo(a) > 0) ? this : a;\n\t  }\n\t  // (protected) r = this op a (bitwise)\n\t  function bnpBitwiseTo(a, op, r)\n\t  {\n\t    var i, f, m = Math.min(a.t, this.t);\n\t    for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);\n\t    if (a.t < this.t)\n\t    {\n\t      f = a.s & this.DM;\n\t      for (i = m; i < this.t; ++i) r[i] = op(this[i], f);\n\t      r.t = this.t;\n\t    }\n\t    else\n\t    {\n\t      f = this.s & this.DM;\n\t      for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);\n\t      r.t = a.t;\n\t    }\n\t    r.s = op(this.s, a.s);\n\t    r.clamp();\n\t  }\n\t  // (public) this & a\n\t  function op_and(x, y)\n\t  {\n\t    return x & y;\n\t  }\n\t\n\t  function bnAnd(a)\n\t  {\n\t    var r = nbi();\n\t    this.bitwiseTo(a, op_and, r);\n\t    return r;\n\t  }\n\t  // (public) this | a\n\t  function op_or(x, y)\n\t  {\n\t    return x | y;\n\t  }\n\t\n\t  function bnOr(a)\n\t  {\n\t    var r = nbi();\n\t    this.bitwiseTo(a, op_or, r);\n\t    return r;\n\t  }\n\t  // (public) this ^ a\n\t  function op_xor(x, y)\n\t  {\n\t    return x ^ y;\n\t  }\n\t\n\t  function bnXor(a)\n\t  {\n\t    var r = nbi();\n\t    this.bitwiseTo(a, op_xor, r);\n\t    return r;\n\t  }\n\t  // (public) this & ~a\n\t  function op_andnot(x, y)\n\t  {\n\t    return x & ~y;\n\t  }\n\t\n\t  function bnAndNot(a)\n\t  {\n\t    var r = nbi();\n\t    this.bitwiseTo(a, op_andnot, r);\n\t    return r;\n\t  }\n\t  // (public) ~this\n\t  function bnNot()\n\t  {\n\t    var r = nbi();\n\t    for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];\n\t    r.t = this.t;\n\t    r.s = ~this.s;\n\t    return r;\n\t  }\n\t  // (public) this << n\n\t  function bnShiftLeft(n)\n\t  {\n\t    var r = nbi();\n\t    if (n < 0) this.rShiftTo(-n, r);\n\t    else this.lShiftTo(n, r);\n\t    return r;\n\t  }\n\t  // (public) this >> n\n\t  function bnShiftRight(n)\n\t  {\n\t    var r = nbi();\n\t    if (n < 0) this.lShiftTo(-n, r);\n\t    else this.rShiftTo(n, r);\n\t    return r;\n\t  }\n\t  // return index of lowest 1-bit in x, x < 2^31\n\t  function lbit(x)\n\t  {\n\t    if (x == 0) return -1;\n\t    var r = 0;\n\t    if ((x & 0xffff) == 0)\n\t    {\n\t      x >>= 16;\n\t      r += 16;\n\t    }\n\t    if ((x & 0xff) == 0)\n\t    {\n\t      x >>= 8;\n\t      r += 8;\n\t    }\n\t    if ((x & 0xf) == 0)\n\t    {\n\t      x >>= 4;\n\t      r += 4;\n\t    }\n\t    if ((x & 3) == 0)\n\t    {\n\t      x >>= 2;\n\t      r += 2;\n\t    }\n\t    if ((x & 1) == 0)++r;\n\t    return r;\n\t  }\n\t  // (public) returns index of lowest 1-bit (or -1 if none)\n\t  function bnGetLowestSetBit()\n\t  {\n\t    for (var i = 0; i < this.t; ++i)\n\t      if (this[i] != 0) return i * this.DB + lbit(this[i]);\n\t    if (this.s < 0) return this.t * this.DB;\n\t    return -1;\n\t  }\n\t  // return number of 1 bits in x\n\t  function cbit(x)\n\t  {\n\t    var r = 0;\n\t    while (x != 0)\n\t    {\n\t      x &= x - 1;\n\t      ++r;\n\t    }\n\t    return r;\n\t  }\n\t  // (public) return number of set bits\n\t  function bnBitCount()\n\t  {\n\t    var r = 0,\n\t      x = this.s & this.DM;\n\t    for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);\n\t    return r;\n\t  }\n\t  // (public) true iff nth bit is set\n\t  function bnTestBit(n)\n\t  {\n\t    var j = Math.floor(n / this.DB);\n\t    if (j >= this.t) return (this.s != 0);\n\t    return ((this[j] & (1 << (n % this.DB))) != 0);\n\t  }\n\t  // (protected) this op (1<<n)\n\t  function bnpChangeBit(n, op)\n\t  {\n\t    var r = BigInteger.ONE.shiftLeft(n);\n\t    this.bitwiseTo(r, op, r);\n\t    return r;\n\t  }\n\t  // (public) this | (1<<n)\n\t  function bnSetBit(n)\n\t  {\n\t    return this.changeBit(n, op_or);\n\t  }\n\t  // (public) this & ~(1<<n)\n\t  function bnClearBit(n)\n\t  {\n\t    return this.changeBit(n, op_andnot);\n\t  }\n\t  // (public) this ^ (1<<n)\n\t  function bnFlipBit(n)\n\t  {\n\t    return this.changeBit(n, op_xor);\n\t  }\n\t  // (protected) r = this + a\n\t  function bnpAddTo(a, r)\n\t  {\n\t    var i = 0,\n\t      c = 0,\n\t      m = Math.min(a.t, this.t);\n\t    while (i < m)\n\t    {\n\t      c += this[i] + a[i];\n\t      r[i++] = c & this.DM;\n\t      c >>= this.DB;\n\t    }\n\t    if (a.t < this.t)\n\t    {\n\t      c += a.s;\n\t      while (i < this.t)\n\t      {\n\t        c += this[i];\n\t        r[i++] = c & this.DM;\n\t        c >>= this.DB;\n\t      }\n\t      c += this.s;\n\t    }\n\t    else\n\t    {\n\t      c += this.s;\n\t      while (i < a.t)\n\t      {\n\t        c += a[i];\n\t        r[i++] = c & this.DM;\n\t        c >>= this.DB;\n\t      }\n\t      c += a.s;\n\t    }\n\t    r.s = (c < 0) ? -1 : 0;\n\t    if (c > 0) r[i++] = c;\n\t    else if (c < -1) r[i++] = this.DV + c;\n\t    r.t = i;\n\t    r.clamp();\n\t  }\n\t  // (public) this + a\n\t  function bnAdd(a)\n\t  {\n\t    var r = nbi();\n\t    this.addTo(a, r);\n\t    return r;\n\t  }\n\t  // (public) this - a\n\t  function bnSubtract(a)\n\t  {\n\t    var r = nbi();\n\t    this.subTo(a, r);\n\t    return r;\n\t  }\n\t  // (public) this * a\n\t  function bnMultiply(a)\n\t  {\n\t    var r = nbi();\n\t    this.multiplyTo(a, r);\n\t    return r;\n\t  }\n\t  // (public) this^2\n\t  function bnSquare()\n\t  {\n\t    var r = nbi();\n\t    this.squareTo(r);\n\t    return r;\n\t  }\n\t  // (public) this / a\n\t  function bnDivide(a)\n\t  {\n\t    var r = nbi();\n\t    this.divRemTo(a, r, null);\n\t    return r;\n\t  }\n\t  // (public) this % a\n\t  function bnRemainder(a)\n\t  {\n\t    var r = nbi();\n\t    this.divRemTo(a, null, r);\n\t    return r;\n\t  }\n\t  // (public) [this/a,this%a]\n\t  function bnDivideAndRemainder(a)\n\t  {\n\t    var q = nbi(),\n\t      r = nbi();\n\t    this.divRemTo(a, q, r);\n\t    return new Array(q, r);\n\t  }\n\t  // (protected) this *= n, this >= 0, 1 < n < DV\n\t  function bnpDMultiply(n)\n\t  {\n\t    this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);\n\t    ++this.t;\n\t    this.clamp();\n\t  }\n\t  // (protected) this += n << w words, this >= 0\n\t  function bnpDAddOffset(n, w)\n\t  {\n\t    if (n == 0) return;\n\t    while (this.t <= w) this[this.t++] = 0;\n\t    this[w] += n;\n\t    while (this[w] >= this.DV)\n\t    {\n\t      this[w] -= this.DV;\n\t      if (++w >= this.t) this[this.t++] = 0;\n\t      ++this[w];\n\t    }\n\t  }\n\t  // A \"null\" reducer\n\t  function NullExp()\n\t  {}\n\t\n\t  function nNop(x)\n\t  {\n\t    return x;\n\t  }\n\t\n\t  function nMulTo(x, y, r)\n\t  {\n\t    x.multiplyTo(y, r);\n\t  }\n\t\n\t  function nSqrTo(x, r)\n\t  {\n\t    x.squareTo(r);\n\t  }\n\t  NullExp.prototype.convert = nNop;\n\t  NullExp.prototype.revert = nNop;\n\t  NullExp.prototype.mulTo = nMulTo;\n\t  NullExp.prototype.sqrTo = nSqrTo;\n\t  // (public) this^e\n\t  function bnPow(e)\n\t  {\n\t    return this.exp(e, new NullExp());\n\t  }\n\t  // (protected) r = lower n words of \"this * a\", a.t <= n\n\t  // \"this\" should be the larger one if appropriate.\n\t  function bnpMultiplyLowerTo(a, n, r)\n\t  {\n\t    var i = Math.min(this.t + a.t, n);\n\t    r.s = 0; // assumes a,this >= 0\n\t    r.t = i;\n\t    while (i > 0) r[--i] = 0;\n\t    var j;\n\t    for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);\n\t    for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);\n\t    r.clamp();\n\t  }\n\t  // (protected) r = \"this * a\" without lower n words, n > 0\n\t  // \"this\" should be the larger one if appropriate.\n\t  function bnpMultiplyUpperTo(a, n, r)\n\t  {\n\t    --n;\n\t    var i = r.t = this.t + a.t - n;\n\t    r.s = 0; // assumes a,this >= 0\n\t    while (--i >= 0) r[i] = 0;\n\t    for (i = Math.max(n - this.t, 0); i < a.t; ++i)\n\t      r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);\n\t    r.clamp();\n\t    r.drShiftTo(1, r);\n\t  }\n\t  // Barrett modular reduction\n\t  function Barrett(m)\n\t  {\n\t    // setup Barrett\n\t    this.r2 = nbi();\n\t    this.q3 = nbi();\n\t    BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);\n\t    this.mu = this.r2.divide(m);\n\t    this.m = m;\n\t  }\n\t\n\t  function barrettConvert(x)\n\t  {\n\t    if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);\n\t    else if (x.compareTo(this.m) < 0) return x;\n\t    else\n\t    {\n\t      var r = nbi();\n\t      x.copyTo(r);\n\t      this.reduce(r);\n\t      return r;\n\t    }\n\t  }\n\t\n\t  function barrettRevert(x)\n\t  {\n\t    return x;\n\t  }\n\t  // x = x mod m (HAC 14.42)\n\t  function barrettReduce(x)\n\t  {\n\t    x.drShiftTo(this.m.t - 1, this.r2);\n\t    if (x.t > this.m.t + 1)\n\t    {\n\t      x.t = this.m.t + 1;\n\t      x.clamp();\n\t    }\n\t    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);\n\t    this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);\n\t    while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);\n\t    x.subTo(this.r2, x);\n\t    while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n\t  }\n\t  // r = x^2 mod m; x != r\n\t  function barrettSqrTo(x, r)\n\t  {\n\t    x.squareTo(r);\n\t    this.reduce(r);\n\t  }\n\t  // r = x*y mod m; x,y != r\n\t  function barrettMulTo(x, y, r)\n\t  {\n\t    x.multiplyTo(y, r);\n\t    this.reduce(r);\n\t  }\n\t  Barrett.prototype.convert = barrettConvert;\n\t  Barrett.prototype.revert = barrettRevert;\n\t  Barrett.prototype.reduce = barrettReduce;\n\t  Barrett.prototype.mulTo = barrettMulTo;\n\t  Barrett.prototype.sqrTo = barrettSqrTo;\n\t  // (public) this^e % m (HAC 14.85)\n\t  function bnModPow(e, m)\n\t  {\n\t    var i = e.bitLength(),\n\t      k, r = nbv(1),\n\t      z;\n\t    if (i <= 0) return r;\n\t    else if (i < 18) k = 1;\n\t    else if (i < 48) k = 3;\n\t    else if (i < 144) k = 4;\n\t    else if (i < 768) k = 5;\n\t    else k = 6;\n\t    if (i < 8)\n\t      z = new Classic(m);\n\t    else if (m.isEven())\n\t      z = new Barrett(m);\n\t    else\n\t      z = new Montgomery(m);\n\t    // precomputation\n\t    var g = new Array(),\n\t      n = 3,\n\t      k1 = k - 1,\n\t      km = (1 << k) - 1;\n\t    g[1] = z.convert(this);\n\t    if (k > 1)\n\t    {\n\t      var g2 = nbi();\n\t      z.sqrTo(g[1], g2);\n\t      while (n <= km)\n\t      {\n\t        g[n] = nbi();\n\t        z.mulTo(g2, g[n - 2], g[n]);\n\t        n += 2;\n\t      }\n\t    }\n\t    var j = e.t - 1,\n\t      w, is1 = true,\n\t      r2 = nbi(),\n\t      t;\n\t    i = nbits(e[j]) - 1;\n\t    while (j >= 0)\n\t    {\n\t      if (i >= k1) w = (e[j] >> (i - k1)) & km;\n\t      else\n\t      {\n\t        w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);\n\t        if (j > 0) w |= e[j - 1] >> (this.DB + i - k1);\n\t      }\n\t      n = k;\n\t      while ((w & 1) == 0)\n\t      {\n\t        w >>= 1;\n\t        --n;\n\t      }\n\t      if ((i -= n) < 0)\n\t      {\n\t        i += this.DB;\n\t        --j;\n\t      }\n\t      if (is1)\n\t      { // ret == 1, don't bother squaring or multiplying it\n\t        g[w].copyTo(r);\n\t        is1 = false;\n\t      }\n\t      else\n\t      {\n\t        while (n > 1)\n\t        {\n\t          z.sqrTo(r, r2);\n\t          z.sqrTo(r2, r);\n\t          n -= 2;\n\t        }\n\t        if (n > 0) z.sqrTo(r, r2);\n\t        else\n\t        {\n\t          t = r;\n\t          r = r2;\n\t          r2 = t;\n\t        }\n\t        z.mulTo(r2, g[w], r);\n\t      }\n\t      while (j >= 0 && (e[j] & (1 << i)) == 0)\n\t      {\n\t        z.sqrTo(r, r2);\n\t        t = r;\n\t        r = r2;\n\t        r2 = t;\n\t        if (--i < 0)\n\t        {\n\t          i = this.DB - 1;\n\t          --j;\n\t        }\n\t      }\n\t    }\n\t    return z.revert(r);\n\t  }\n\t  // (public) gcd(this,a) (HAC 14.54)\n\t  function bnGCD(a)\n\t  {\n\t    var x = (this.s < 0) ? this.negate() : this.clone();\n\t    var y = (a.s < 0) ? a.negate() : a.clone();\n\t    if (x.compareTo(y) < 0)\n\t    {\n\t      var t = x;\n\t      x = y;\n\t      y = t;\n\t    }\n\t    var i = x.getLowestSetBit(),\n\t      g = y.getLowestSetBit();\n\t    if (g < 0) return x;\n\t    if (i < g) g = i;\n\t    if (g > 0)\n\t    {\n\t      x.rShiftTo(g, x);\n\t      y.rShiftTo(g, y);\n\t    }\n\t    while (x.signum() > 0)\n\t    {\n\t      if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);\n\t      if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);\n\t      if (x.compareTo(y) >= 0)\n\t      {\n\t        x.subTo(y, x);\n\t        x.rShiftTo(1, x);\n\t      }\n\t      else\n\t      {\n\t        y.subTo(x, y);\n\t        y.rShiftTo(1, y);\n\t      }\n\t    }\n\t    if (g > 0) y.lShiftTo(g, y);\n\t    return y;\n\t  }\n\t  // (protected) this % n, n < 2^26\n\t  function bnpModInt(n)\n\t  {\n\t    if (n <= 0) return 0;\n\t    var d = this.DV % n,\n\t      r = (this.s < 0) ? n - 1 : 0;\n\t    if (this.t > 0)\n\t      if (d == 0) r = this[0] % n;\n\t      else\n\t        for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;\n\t    return r;\n\t  }\n\t  // (public) 1/this % m (HAC 14.61)\n\t  function bnModInverse(m)\n\t  {\n\t    var ac = m.isEven();\n\t    if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n\t    var u = m.clone(),\n\t      v = this.clone();\n\t    var a = nbv(1),\n\t      b = nbv(0),\n\t      c = nbv(0),\n\t      d = nbv(1);\n\t    while (u.signum() != 0)\n\t    {\n\t      while (u.isEven())\n\t      {\n\t        u.rShiftTo(1, u);\n\t        if (ac)\n\t        {\n\t          if (!a.isEven() || !b.isEven())\n\t          {\n\t            a.addTo(this, a);\n\t            b.subTo(m, b);\n\t          }\n\t          a.rShiftTo(1, a);\n\t        }\n\t        else if (!b.isEven()) b.subTo(m, b);\n\t        b.rShiftTo(1, b);\n\t      }\n\t      while (v.isEven())\n\t      {\n\t        v.rShiftTo(1, v);\n\t        if (ac)\n\t        {\n\t          if (!c.isEven() || !d.isEven())\n\t          {\n\t            c.addTo(this, c);\n\t            d.subTo(m, d);\n\t          }\n\t          c.rShiftTo(1, c);\n\t        }\n\t        else if (!d.isEven()) d.subTo(m, d);\n\t        d.rShiftTo(1, d);\n\t      }\n\t      if (u.compareTo(v) >= 0)\n\t      {\n\t        u.subTo(v, u);\n\t        if (ac) a.subTo(c, a);\n\t        b.subTo(d, b);\n\t      }\n\t      else\n\t      {\n\t        v.subTo(u, v);\n\t        if (ac) c.subTo(a, c);\n\t        d.subTo(b, d);\n\t      }\n\t    }\n\t    if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n\t    if (d.compareTo(m) >= 0) return d.subtract(m);\n\t    if (d.signum() < 0) d.addTo(m, d);\n\t    else return d;\n\t    if (d.signum() < 0) return d.add(m);\n\t    else return d;\n\t  }\n\t  var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\n\t  var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];\n\t  // (public) test primality with certainty >= 1-.5^t\n\t  function bnIsProbablePrime(t)\n\t  {\n\t    var i, x = this.abs();\n\t    if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1])\n\t    {\n\t      for (i = 0; i < lowprimes.length; ++i)\n\t        if (x[0] == lowprimes[i]) return true;\n\t      return false;\n\t    }\n\t    if (x.isEven()) return false;\n\t    i = 1;\n\t    while (i < lowprimes.length)\n\t    {\n\t      var m = lowprimes[i],\n\t        j = i + 1;\n\t      while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n\t      m = x.modInt(m);\n\t      while (i < j)\n\t        if (m % lowprimes[i++] == 0) return false;\n\t    }\n\t    return x.millerRabin(t);\n\t  }\n\t  // (protected) true if probably prime (HAC 4.24, Miller-Rabin)\n\t  function bnpMillerRabin(t)\n\t  {\n\t    var n1 = this.subtract(BigInteger.ONE);\n\t    var k = n1.getLowestSetBit();\n\t    if (k <= 0) return false;\n\t    var r = n1.shiftRight(k);\n\t    t = (t + 1) >> 1;\n\t    if (t > lowprimes.length) t = lowprimes.length;\n\t    var a = nbi();\n\t    for (var i = 0; i < t; ++i)\n\t    {\n\t      //Pick bases at random, instead of starting at 2\n\t      a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);\n\t      var y = a.modPow(r, this);\n\t      if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0)\n\t      {\n\t        var j = 1;\n\t        while (j++ < k && y.compareTo(n1) != 0)\n\t        {\n\t          y = y.modPowInt(2, this);\n\t          if (y.compareTo(BigInteger.ONE) == 0) return false;\n\t        }\n\t        if (y.compareTo(n1) != 0) return false;\n\t      }\n\t    }\n\t    return true;\n\t  }\n\t  // protected\n\t  BigInteger.prototype.chunkSize = bnpChunkSize;\n\t  BigInteger.prototype.toRadix = bnpToRadix;\n\t  BigInteger.prototype.fromRadix = bnpFromRadix;\n\t  BigInteger.prototype.fromNumber = bnpFromNumber;\n\t  BigInteger.prototype.bitwiseTo = bnpBitwiseTo;\n\t  BigInteger.prototype.changeBit = bnpChangeBit;\n\t  BigInteger.prototype.addTo = bnpAddTo;\n\t  BigInteger.prototype.dMultiply = bnpDMultiply;\n\t  BigInteger.prototype.dAddOffset = bnpDAddOffset;\n\t  BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\n\t  BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\n\t  BigInteger.prototype.modInt = bnpModInt;\n\t  BigInteger.prototype.millerRabin = bnpMillerRabin;\n\t  // public\n\t  BigInteger.prototype.clone = bnClone;\n\t  BigInteger.prototype.intValue = bnIntValue;\n\t  BigInteger.prototype.byteValue = bnByteValue;\n\t  BigInteger.prototype.shortValue = bnShortValue;\n\t  BigInteger.prototype.signum = bnSigNum;\n\t  BigInteger.prototype.toByteArray = bnToByteArray;\n\t  BigInteger.prototype.equals = bnEquals;\n\t  BigInteger.prototype.min = bnMin;\n\t  BigInteger.prototype.max = bnMax;\n\t  BigInteger.prototype.and = bnAnd;\n\t  BigInteger.prototype.or = bnOr;\n\t  BigInteger.prototype.xor = bnXor;\n\t  BigInteger.prototype.andNot = bnAndNot;\n\t  BigInteger.prototype.not = bnNot;\n\t  BigInteger.prototype.shiftLeft = bnShiftLeft;\n\t  BigInteger.prototype.shiftRight = bnShiftRight;\n\t  BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\n\t  BigInteger.prototype.bitCount = bnBitCount;\n\t  BigInteger.prototype.testBit = bnTestBit;\n\t  BigInteger.prototype.setBit = bnSetBit;\n\t  BigInteger.prototype.clearBit = bnClearBit;\n\t  BigInteger.prototype.flipBit = bnFlipBit;\n\t  BigInteger.prototype.add = bnAdd;\n\t  BigInteger.prototype.subtract = bnSubtract;\n\t  BigInteger.prototype.multiply = bnMultiply;\n\t  BigInteger.prototype.divide = bnDivide;\n\t  BigInteger.prototype.remainder = bnRemainder;\n\t  BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\n\t  BigInteger.prototype.modPow = bnModPow;\n\t  BigInteger.prototype.modInverse = bnModInverse;\n\t  BigInteger.prototype.pow = bnPow;\n\t  BigInteger.prototype.gcd = bnGCD;\n\t  BigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n\t  // JSBN-specific extension\n\t  BigInteger.prototype.square = bnSquare;\n\t  var Int128 = BigInteger;\n\t  // BigInteger interfaces not implemented in jsbn:\n\t  // BigInteger(int signum, byte[] magnitude)\n\t  // double doubleValue()\n\t  // float floatValue()\n\t  // int hashCode()\n\t  // long longValue()\n\t  // static BigInteger valueOf(long val)\n\t  // Helper functions to make BigInteger functions callable with two parameters\n\t  // as in original C# Clipper\n\t  Int128.prototype.IsNegative = function ()\n\t  {\n\t    if (this.compareTo(Int128.ZERO) == -1) return true;\n\t    else return false;\n\t  };\n\t  Int128.op_Equality = function (val1, val2)\n\t  {\n\t    if (val1.compareTo(val2) == 0) return true;\n\t    else return false;\n\t  };\n\t  Int128.op_Inequality = function (val1, val2)\n\t  {\n\t    if (val1.compareTo(val2) != 0) return true;\n\t    else return false;\n\t  };\n\t  Int128.op_GreaterThan = function (val1, val2)\n\t  {\n\t    if (val1.compareTo(val2) > 0) return true;\n\t    else return false;\n\t  };\n\t  Int128.op_LessThan = function (val1, val2)\n\t  {\n\t    if (val1.compareTo(val2) < 0) return true;\n\t    else return false;\n\t  };\n\t  Int128.op_Addition = function (lhs, rhs)\n\t  {\n\t    return new Int128(lhs).add(new Int128(rhs));\n\t  };\n\t  Int128.op_Subtraction = function (lhs, rhs)\n\t  {\n\t    return new Int128(lhs).subtract(new Int128(rhs));\n\t  };\n\t  Int128.Int128Mul = function (lhs, rhs)\n\t  {\n\t    return new Int128(lhs).multiply(new Int128(rhs));\n\t  };\n\t  Int128.op_Division = function (lhs, rhs)\n\t  {\n\t    return lhs.divide(rhs);\n\t  };\n\t  Int128.prototype.ToDouble = function ()\n\t  {\n\t    return parseFloat(this.toString()); // This could be something faster\n\t  };\n\t  // end of Int128 section\n\t  /*\n\t  // Uncomment the following two lines if you want to use Int128 outside ClipperLib\n\t  if (typeof(document) !== \"undefined\") window.Int128 = Int128;\n\t  else self.Int128 = Int128;\n\t  */\n\t\n\t\n\t  // ---------------------------------------------\n\t  // Here starts the actual Clipper library:\n\t  // Helper function to support Inheritance in Javascript\n\t\tvar Inherit = function (ce, ce2)\n\t\t{\n\t\t\tvar p;\n\t\t\tif (typeof (Object.getOwnPropertyNames) == 'undefined')\n\t\t\t{\n\t\t\t\tfor (p in ce2.prototype)\n\t\t\t\t\tif (typeof (ce.prototype[p]) == 'undefined' || ce.prototype[p] == Object.prototype[p]) ce.prototype[p] = ce2.prototype[p];\n\t\t\t\tfor (p in ce2)\n\t\t\t\t\tif (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];\n\t\t\t\tce.$baseCtor = ce2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar props = Object.getOwnPropertyNames(ce2.prototype);\n\t\t\t\tfor (var i = 0; i < props.length; i++)\n\t\t\t\t\tif (typeof (Object.getOwnPropertyDescriptor(ce.prototype, props[i])) == 'undefined') Object.defineProperty(ce.prototype, props[i], Object.getOwnPropertyDescriptor(ce2.prototype, props[i]));\n\t\t\t\tfor (p in ce2)\n\t\t\t\t\tif (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];\n\t\t\t\tce.$baseCtor = ce2;\n\t\t\t}\n\t\t};\n\t  ClipperLib.Path = function ()\n\t  {\n\t    return [];\n\t  };\n\t  ClipperLib.Paths = function ()\n\t  {\n\t    return []; // Was previously [[]], but caused problems when pushed\n\t  };\n\t  // Preserves the calling way of original C# Clipper\n\t  // Is essential due to compatibility, because DoublePoint is public class in original C# version\n\t  ClipperLib.DoublePoint = function ()\n\t  {\n\t    var a = arguments;\n\t    this.X = 0;\n\t    this.Y = 0;\n\t    // public DoublePoint(DoublePoint dp)\n\t    // public DoublePoint(IntPoint ip)\n\t    if (a.length == 1)\n\t    {\n\t      this.X = a[0].X;\n\t      this.Y = a[0].Y;\n\t    }\n\t    else if (a.length == 2)\n\t    {\n\t      this.X = a[0];\n\t      this.Y = a[1];\n\t    }\n\t  }; // This is internal faster function when called without arguments\n\t  ClipperLib.DoublePoint0 = function ()\n\t  {\n\t    this.X = 0;\n\t    this.Y = 0;\n\t  };\n\t  // This is internal faster function when called with 1 argument (dp or ip)\n\t  ClipperLib.DoublePoint1 = function (dp)\n\t  {\n\t    this.X = dp.X;\n\t    this.Y = dp.Y;\n\t  };\n\t  // This is internal faster function when called with 2 arguments (x and y)\n\t  ClipperLib.DoublePoint2 = function (x, y)\n\t  {\n\t    this.X = x;\n\t    this.Y = y;\n\t  };\n\t  // PolyTree & PolyNode start\n\t  // -------------------------------\n\t  ClipperLib.PolyNode = function ()\n\t  {\n\t    this.m_Parent = null;\n\t    this.m_polygon = new ClipperLib.Path();\n\t    this.m_Index = 0;\n\t    this.m_jointype = 0;\n\t    this.m_endtype = 0;\n\t    this.m_Childs = [];\n\t    this.IsOpen = false;\n\t  };\n\t  ClipperLib.PolyNode.prototype.IsHoleNode = function ()\n\t  {\n\t    var result = true;\n\t    var node = this.m_Parent;\n\t    while (node !== null)\n\t    {\n\t      result = !result;\n\t      node = node.m_Parent;\n\t    }\n\t    return result;\n\t  };\n\t  ClipperLib.PolyNode.prototype.ChildCount = function ()\n\t  {\n\t    return this.m_Childs.length;\n\t  };\n\t  ClipperLib.PolyNode.prototype.Contour = function ()\n\t  {\n\t    return this.m_polygon;\n\t  };\n\t  ClipperLib.PolyNode.prototype.AddChild = function (Child)\n\t  {\n\t    var cnt = this.m_Childs.length;\n\t    this.m_Childs.push(Child);\n\t    Child.m_Parent = this;\n\t    Child.m_Index = cnt;\n\t  };\n\t  ClipperLib.PolyNode.prototype.GetNext = function ()\n\t  {\n\t    if (this.m_Childs.length > 0)\n\t      return this.m_Childs[0];\n\t    else\n\t      return this.GetNextSiblingUp();\n\t  };\n\t  ClipperLib.PolyNode.prototype.GetNextSiblingUp = function ()\n\t  {\n\t    if (this.m_Parent === null)\n\t      return null;\n\t    else if (this.m_Index == this.m_Parent.m_Childs.length - 1)\n\t      return this.m_Parent.GetNextSiblingUp();\n\t    else\n\t      return this.m_Parent.m_Childs[this.m_Index + 1];\n\t  };\n\t  ClipperLib.PolyNode.prototype.Childs = function ()\n\t  {\n\t    return this.m_Childs;\n\t  };\n\t  ClipperLib.PolyNode.prototype.Parent = function ()\n\t  {\n\t    return this.m_Parent;\n\t  };\n\t  ClipperLib.PolyNode.prototype.IsHole = function ()\n\t  {\n\t    return this.IsHoleNode();\n\t  };\n\t  // PolyTree : PolyNode\n\t  ClipperLib.PolyTree = function ()\n\t  {\n\t    this.m_AllPolys = [];\n\t    ClipperLib.PolyNode.call(this);\n\t  };\n\t  ClipperLib.PolyTree.prototype.Clear = function ()\n\t  {\n\t    for (var i = 0, ilen = this.m_AllPolys.length; i < ilen; i++)\n\t      this.m_AllPolys[i] = null;\n\t    this.m_AllPolys.length = 0;\n\t    this.m_Childs.length = 0;\n\t  };\n\t  ClipperLib.PolyTree.prototype.GetFirst = function ()\n\t  {\n\t    if (this.m_Childs.length > 0)\n\t      return this.m_Childs[0];\n\t    else\n\t      return null;\n\t  };\n\t  ClipperLib.PolyTree.prototype.Total = function ()\n\t  {\n\t\t\tvar result = this.m_AllPolys.length;\n\t\t\t//with negative offsets, ignore the hidden outer polygon ...\n\t\t\tif (result > 0 && this.m_Childs[0] != this.m_AllPolys[0]) result--;\n\t\t\treturn result;\n\t  };\n\t  Inherit(ClipperLib.PolyTree, ClipperLib.PolyNode);\n\t  // -------------------------------\n\t  // PolyTree & PolyNode end\n\t  ClipperLib.Math_Abs_Int64 = ClipperLib.Math_Abs_Int32 = ClipperLib.Math_Abs_Double = function (a)\n\t  {\n\t    return Math.abs(a);\n\t  };\n\t  ClipperLib.Math_Max_Int32_Int32 = function (a, b)\n\t  {\n\t    return Math.max(a, b);\n\t  };\n\t  /*\n\t  -----------------------------------\n\t  cast_32 speedtest: http://jsperf.com/truncate-float-to-integer/2\n\t  -----------------------------------\n\t  */\n\t  if (browser.msie || browser.opera || browser.safari) ClipperLib.Cast_Int32 = function (a)\n\t  {\n\t    return a | 0;\n\t  };\n\t  else ClipperLib.Cast_Int32 = function (a)\n\t  { // eg. browser.chrome || browser.chromium || browser.firefox\n\t    return~~ a;\n\t  };\n\t  /*\n\t  --------------------------\n\t  cast_64 speedtests: http://jsperf.com/truncate-float-to-integer\n\t  Chrome: bitwise_not_floor\n\t  Firefox17: toInteger (typeof test)\n\t  IE9: bitwise_or_floor\n\t  IE7 and IE8: to_parseint\n\t  Chromium: to_floor_or_ceil\n\t  Firefox3: to_floor_or_ceil\n\t  Firefox15: to_floor_or_ceil\n\t  Opera: to_floor_or_ceil\n\t  Safari: to_floor_or_ceil\n\t  --------------------------\n\t  */\n\t  if (browser.chrome) ClipperLib.Cast_Int64 = function (a)\n\t  {\n\t    if (a < -2147483648 || a > 2147483647)\n\t      return a < 0 ? Math.ceil(a) : Math.floor(a);\n\t    else return~~ a;\n\t  };\n\t  else if (browser.firefox && typeof (Number.toInteger) == \"function\") ClipperLib.Cast_Int64 = function (a)\n\t  {\n\t    return Number.toInteger(a);\n\t  };\n\t  else if (browser.msie7 || browser.msie8) ClipperLib.Cast_Int64 = function (a)\n\t  {\n\t    return parseInt(a, 10);\n\t  };\n\t  else if (browser.msie) ClipperLib.Cast_Int64 = function (a)\n\t  {\n\t    if (a < -2147483648 || a > 2147483647)\n\t      return a < 0 ? Math.ceil(a) : Math.floor(a);\n\t    return a | 0;\n\t  };\n\t  // eg. browser.chromium || browser.firefox || browser.opera || browser.safari\n\t  else ClipperLib.Cast_Int64 = function (a)\n\t  {\n\t    return a < 0 ? Math.ceil(a) : Math.floor(a);\n\t  };\n\t  ClipperLib.Clear = function (a)\n\t  {\n\t    a.length = 0;\n\t  };\n\t  //ClipperLib.MaxSteps = 64; // How many steps at maximum in arc in BuildArc() function\n\t  ClipperLib.PI = 3.141592653589793;\n\t  ClipperLib.PI2 = 2 * 3.141592653589793;\n\t  ClipperLib.IntPoint = function ()\n\t  {\n\t    var a = arguments,\n\t      alen = a.length;\n\t    this.X = 0;\n\t    this.Y = 0;\n\t    if (use_xyz)\n\t    {\n\t      this.Z = 0;\n\t      if (alen == 3) // public IntPoint(cInt x, cInt y, cInt z = 0)\n\t      {\n\t        this.X = a[0];\n\t        this.Y = a[1];\n\t        this.Z = a[2];\n\t      }\n\t      else if (alen == 2) // public IntPoint(cInt x, cInt y)\n\t      {\n\t        this.X = a[0];\n\t        this.Y = a[1];\n\t        this.Z = 0;\n\t      }\n\t      else if (alen == 1)\n\t      {\n\t        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n\t        {\n\t          var dp = a[0];\n\t          this.X = ClipperLib.Clipper.Round(dp.X);\n\t          this.Y = ClipperLib.Clipper.Round(dp.Y);\n\t          this.Z = 0;\n\t        }\n\t        else // public IntPoint(IntPoint pt)\n\t        {\n\t          var pt = a[0];\n\t          if (typeof (pt.Z) == \"undefined\") pt.Z = 0;\n\t          this.X = pt.X;\n\t          this.Y = pt.Y;\n\t          this.Z = pt.Z;\n\t        }\n\t      }\n\t      else // public IntPoint()\n\t      {\n\t        this.X = 0;\n\t        this.Y = 0;\n\t        this.Z = 0;\n\t      }\n\t    }\n\t    else // if (!use_xyz)\n\t    {\n\t      if (alen == 2) // public IntPoint(cInt X, cInt Y)\n\t      {\n\t        this.X = a[0];\n\t        this.Y = a[1];\n\t      }\n\t      else if (alen == 1)\n\t      {\n\t        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n\t        {\n\t          var dp = a[0];\n\t          this.X = ClipperLib.Clipper.Round(dp.X);\n\t          this.Y = ClipperLib.Clipper.Round(dp.Y);\n\t        }\n\t        else // public IntPoint(IntPoint pt)\n\t        {\n\t          var pt = a[0];\n\t          this.X = pt.X;\n\t          this.Y = pt.Y;\n\t        }\n\t      }\n\t      else // public IntPoint(IntPoint pt)\n\t      {\n\t        this.X = 0;\n\t        this.Y = 0;\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.IntPoint.op_Equality = function (a, b)\n\t  {\n\t    //return a == b;\n\t    return a.X == b.X && a.Y == b.Y;\n\t  };\n\t  ClipperLib.IntPoint.op_Inequality = function (a, b)\n\t  {\n\t    //return a != b;\n\t    return a.X != b.X || a.Y != b.Y;\n\t  };\n\t  /*\n\t  ClipperLib.IntPoint.prototype.Equals = function (obj)\n\t  {\n\t    if (obj === null)\n\t        return false;\n\t    if (obj instanceof ClipperLib.IntPoint)\n\t    {\n\t        var a = Cast(obj, ClipperLib.IntPoint);\n\t        return (this.X == a.X) && (this.Y == a.Y);\n\t    }\n\t    else\n\t        return false;\n\t  };\n\t*/\n\t  if (use_xyz)\n\t  {\n\t    ClipperLib.IntPoint0 = function ()\n\t    {\n\t      this.X = 0;\n\t      this.Y = 0;\n\t      this.Z = 0;\n\t    };\n\t    ClipperLib.IntPoint1 = function (pt)\n\t    {\n\t      this.X = pt.X;\n\t      this.Y = pt.Y;\n\t      this.Z = pt.Z;\n\t    };\n\t    ClipperLib.IntPoint1dp = function (dp)\n\t    {\n\t      this.X = ClipperLib.Clipper.Round(dp.X);\n\t      this.Y = ClipperLib.Clipper.Round(dp.Y);\n\t      this.Z = 0;\n\t    };\n\t    ClipperLib.IntPoint2 = function (x, y)\n\t    {\n\t      this.X = x;\n\t      this.Y = y;\n\t      this.Z = 0;\n\t    };\n\t    ClipperLib.IntPoint3 = function (x, y, z)\n\t    {\n\t      this.X = x;\n\t      this.Y = y;\n\t      this.Z = z;\n\t    };\n\t  }\n\t  else // if (!use_xyz)\n\t  {\n\t    ClipperLib.IntPoint0 = function ()\n\t    {\n\t      this.X = 0;\n\t      this.Y = 0;\n\t    };\n\t    ClipperLib.IntPoint1 = function (pt)\n\t    {\n\t      this.X = pt.X;\n\t      this.Y = pt.Y;\n\t    };\n\t    ClipperLib.IntPoint1dp = function (dp)\n\t    {\n\t      this.X = ClipperLib.Clipper.Round(dp.X);\n\t      this.Y = ClipperLib.Clipper.Round(dp.Y);\n\t    };\n\t    ClipperLib.IntPoint2 = function (x, y)\n\t    {\n\t      this.X = x;\n\t      this.Y = y;\n\t    };\n\t  }\n\t  ClipperLib.IntRect = function ()\n\t  {\n\t    var a = arguments,\n\t      alen = a.length;\n\t    if (alen == 4) // function (l, t, r, b)\n\t    {\n\t      this.left = a[0];\n\t      this.top = a[1];\n\t      this.right = a[2];\n\t      this.bottom = a[3];\n\t    }\n\t    else if (alen == 1) // function (ir)\n\t    {\n\t      this.left = ir.left;\n\t      this.top = ir.top;\n\t      this.right = ir.right;\n\t      this.bottom = ir.bottom;\n\t    }\n\t    else // function ()\n\t    {\n\t      this.left = 0;\n\t      this.top = 0;\n\t      this.right = 0;\n\t      this.bottom = 0;\n\t    }\n\t  };\n\t  ClipperLib.IntRect0 = function ()\n\t  {\n\t    this.left = 0;\n\t    this.top = 0;\n\t    this.right = 0;\n\t    this.bottom = 0;\n\t  };\n\t  ClipperLib.IntRect1 = function (ir)\n\t  {\n\t    this.left = ir.left;\n\t    this.top = ir.top;\n\t    this.right = ir.right;\n\t    this.bottom = ir.bottom;\n\t  };\n\t  ClipperLib.IntRect4 = function (l, t, r, b)\n\t  {\n\t    this.left = l;\n\t    this.top = t;\n\t    this.right = r;\n\t    this.bottom = b;\n\t  };\n\t  ClipperLib.ClipType = {\n\t    ctIntersection: 0,\n\t    ctUnion: 1,\n\t    ctDifference: 2,\n\t    ctXor: 3\n\t  };\n\t  ClipperLib.PolyType = {\n\t    ptSubject: 0,\n\t    ptClip: 1\n\t  };\n\t  ClipperLib.PolyFillType = {\n\t    pftEvenOdd: 0,\n\t    pftNonZero: 1,\n\t    pftPositive: 2,\n\t    pftNegative: 3\n\t  };\n\t  ClipperLib.JoinType = {\n\t    jtSquare: 0,\n\t    jtRound: 1,\n\t    jtMiter: 2\n\t  };\n\t  ClipperLib.EndType = {\n\t    etOpenSquare: 0,\n\t    etOpenRound: 1,\n\t    etOpenButt: 2,\n\t    etClosedLine: 3,\n\t    etClosedPolygon: 4\n\t  };\n\t  ClipperLib.EdgeSide = {\n\t    esLeft: 0,\n\t    esRight: 1\n\t  };\n\t  ClipperLib.Direction = {\n\t    dRightToLeft: 0,\n\t    dLeftToRight: 1\n\t  };\n\t  ClipperLib.TEdge = function ()\n\t  {\n\t    this.Bot = new ClipperLib.IntPoint();\n\t    this.Curr = new ClipperLib.IntPoint();\n\t    this.Top = new ClipperLib.IntPoint();\n\t    this.Delta = new ClipperLib.IntPoint();\n\t    this.Dx = 0;\n\t    this.PolyTyp = ClipperLib.PolyType.ptSubject;\n\t    this.Side = ClipperLib.EdgeSide.esLeft;\n\t    this.WindDelta = 0;\n\t    this.WindCnt = 0;\n\t    this.WindCnt2 = 0;\n\t    this.OutIdx = 0;\n\t    this.Next = null;\n\t    this.Prev = null;\n\t    this.NextInLML = null;\n\t    this.NextInAEL = null;\n\t    this.PrevInAEL = null;\n\t    this.NextInSEL = null;\n\t    this.PrevInSEL = null;\n\t  };\n\t  ClipperLib.IntersectNode = function ()\n\t  {\n\t    this.Edge1 = null;\n\t    this.Edge2 = null;\n\t    this.Pt = new ClipperLib.IntPoint();\n\t  };\n\t  ClipperLib.MyIntersectNodeSort = function () {};\n\t  ClipperLib.MyIntersectNodeSort.Compare = function (node1, node2)\n\t  {\n\t    var i = node2.Pt.Y - node1.Pt.Y;\n\t    if (i > 0) return 1;\n\t    else if (i < 0) return -1;\n\t    else return 0;\n\t  };\n\t\n\t  ClipperLib.LocalMinima = function ()\n\t  {\n\t    this.Y = 0;\n\t    this.LeftBound = null;\n\t    this.RightBound = null;\n\t    this.Next = null;\n\t  };\n\t  ClipperLib.Scanbeam = function ()\n\t  {\n\t    this.Y = 0;\n\t    this.Next = null;\n\t  };\n\t  ClipperLib.OutRec = function ()\n\t  {\n\t    this.Idx = 0;\n\t    this.IsHole = false;\n\t    this.IsOpen = false;\n\t    this.FirstLeft = null;\n\t    this.Pts = null;\n\t    this.BottomPt = null;\n\t    this.PolyNode = null;\n\t  };\n\t  ClipperLib.OutPt = function ()\n\t  {\n\t    this.Idx = 0;\n\t    this.Pt = new ClipperLib.IntPoint();\n\t    this.Next = null;\n\t    this.Prev = null;\n\t  };\n\t  ClipperLib.Join = function ()\n\t  {\n\t    this.OutPt1 = null;\n\t    this.OutPt2 = null;\n\t    this.OffPt = new ClipperLib.IntPoint();\n\t  };\n\t  ClipperLib.ClipperBase = function ()\n\t  {\n\t    this.m_MinimaList = null;\n\t    this.m_CurrentLM = null;\n\t    this.m_edges = new Array();\n\t    this.m_UseFullRange = false;\n\t    this.m_HasOpenPaths = false;\n\t    this.PreserveCollinear = false;\n\t    this.m_MinimaList = null;\n\t    this.m_CurrentLM = null;\n\t    this.m_UseFullRange = false;\n\t    this.m_HasOpenPaths = false;\n\t  };\n\t  // Ranges are in original C# too high for Javascript (in current state 2013 september):\n\t  // protected const double horizontal = -3.4E+38;\n\t  // internal const cInt loRange = 0x3FFFFFFF; // = 1073741823 = sqrt(2^63 -1)/2\n\t  // internal const cInt hiRange = 0x3FFFFFFFFFFFFFFFL; // = 4611686018427387903 = sqrt(2^127 -1)/2\n\t  // So had to adjust them to more suitable for Javascript.\n\t  // If JS some day supports truly 64-bit integers, then these ranges can be as in C#\n\t  // and biginteger library can be more simpler (as then 128bit can be represented as two 64bit numbers)\n\t  ClipperLib.ClipperBase.horizontal = -9007199254740992; //-2^53\n\t  ClipperLib.ClipperBase.Skip = -2;\n\t  ClipperLib.ClipperBase.Unassigned = -1;\n\t  ClipperLib.ClipperBase.tolerance = 1E-20;\n\t  if (use_int32)\n\t  {\n\t    ClipperLib.ClipperBase.loRange = 0x7FFF;\n\t    ClipperLib.ClipperBase.hiRange = 0x7FFF;\n\t  }\n\t  else\n\t  {\n\t    ClipperLib.ClipperBase.loRange = 47453132; // sqrt(2^53 -1)/2\n\t    ClipperLib.ClipperBase.hiRange = 4503599627370495; // sqrt(2^106 -1)/2\n\t  }\n\t\n\t  ClipperLib.ClipperBase.near_zero = function (val)\n\t  {\n\t    return (val > -ClipperLib.ClipperBase.tolerance) && (val < ClipperLib.ClipperBase.tolerance);\n\t  };\n\t  ClipperLib.ClipperBase.IsHorizontal = function (e)\n\t  {\n\t    return e.Delta.Y === 0;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.PointIsVertex = function (pt, pp)\n\t  {\n\t    var pp2 = pp;\n\t    do {\n\t      if (ClipperLib.IntPoint.op_Equality(pp2.Pt, pt))\n\t        return true;\n\t      pp2 = pp2.Next;\n\t    }\n\t    while (pp2 != pp)\n\t    return false;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.PointOnLineSegment = function (pt, linePt1, linePt2, UseFullRange)\n\t  {\n\t    if (UseFullRange)\n\t      return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) ||\n\t        ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) ||\n\t        (((pt.X > linePt1.X) == (pt.X < linePt2.X)) &&\n\t        ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) &&\n\t        (Int128.op_Equality(Int128.Int128Mul((pt.X - linePt1.X), (linePt2.Y - linePt1.Y)),\n\t          Int128.Int128Mul((linePt2.X - linePt1.X), (pt.Y - linePt1.Y)))));\n\t    else\n\t      return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) || ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) || (((pt.X > linePt1.X) == (pt.X < linePt2.X)) && ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) && ((pt.X - linePt1.X) * (linePt2.Y - linePt1.Y) == (linePt2.X - linePt1.X) * (pt.Y - linePt1.Y)));\n\t  };\n\t  ClipperLib.ClipperBase.prototype.PointOnPolygon = function (pt, pp, UseFullRange)\n\t  {\n\t    var pp2 = pp;\n\t    while (true)\n\t    {\n\t      if (this.PointOnLineSegment(pt, pp2.Pt, pp2.Next.Pt, UseFullRange))\n\t        return true;\n\t      pp2 = pp2.Next;\n\t      if (pp2 == pp)\n\t        break;\n\t    }\n\t    return false;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.SlopesEqual = ClipperLib.ClipperBase.SlopesEqual = function ()\n\t  {\n\t    var a = arguments,\n\t      alen = a.length;\n\t    var e1, e2, pt1, pt2, pt3, pt4, UseFullRange;\n\t    if (alen == 3) // function (e1, e2, UseFullRange)\n\t    {\n\t      e1 = a[0];\n\t      e2 = a[1];\n\t      UseFullRange = a[2];\n\t      if (UseFullRange)\n\t        return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n\t      else\n\t        return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n\t    }\n\t    else if (alen == 4) // function (pt1, pt2, pt3, UseFullRange)\n\t    {\n\t      pt1 = a[0];\n\t      pt2 = a[1];\n\t      pt3 = a[2];\n\t      UseFullRange = a[3];\n\t      if (UseFullRange)\n\t        return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n\t      else\n\t        return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n\t    }\n\t    else // function (pt1, pt2, pt3, pt4, UseFullRange)\n\t    {\n\t      pt1 = a[0];\n\t      pt2 = a[1];\n\t      pt3 = a[2];\n\t      pt4 = a[3];\n\t      UseFullRange = a[4];\n\t      if (UseFullRange)\n\t        return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n\t      else\n\t        return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n\t    }\n\t  };\n\t  ClipperLib.ClipperBase.SlopesEqual3 = function (e1, e2, UseFullRange)\n\t  {\n\t    if (UseFullRange)\n\t      return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n\t    else\n\t      return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n\t  };\n\t  ClipperLib.ClipperBase.SlopesEqual4 = function (pt1, pt2, pt3, UseFullRange)\n\t  {\n\t    if (UseFullRange)\n\t      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n\t    else\n\t      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n\t  };\n\t  ClipperLib.ClipperBase.SlopesEqual5 = function (pt1, pt2, pt3, pt4, UseFullRange)\n\t  {\n\t    if (UseFullRange)\n\t      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n\t    else\n\t      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.Clear = function ()\n\t  {\n\t    this.DisposeLocalMinimaList();\n\t    for (var i = 0, ilen = this.m_edges.length; i < ilen; ++i)\n\t    {\n\t      for (var j = 0, jlen = this.m_edges[i].length; j < jlen; ++j)\n\t        this.m_edges[i][j] = null;\n\t      ClipperLib.Clear(this.m_edges[i]);\n\t    }\n\t    ClipperLib.Clear(this.m_edges);\n\t    this.m_UseFullRange = false;\n\t    this.m_HasOpenPaths = false;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.DisposeLocalMinimaList = function ()\n\t  {\n\t    while (this.m_MinimaList !== null)\n\t    {\n\t      var tmpLm = this.m_MinimaList.Next;\n\t      this.m_MinimaList = null;\n\t      this.m_MinimaList = tmpLm;\n\t    }\n\t    this.m_CurrentLM = null;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.RangeTest = function (Pt, useFullRange)\n\t  {\n\t    if (useFullRange.Value)\n\t    {\n\t      if (Pt.X > ClipperLib.ClipperBase.hiRange || Pt.Y > ClipperLib.ClipperBase.hiRange || -Pt.X > ClipperLib.ClipperBase.hiRange || -Pt.Y > ClipperLib.ClipperBase.hiRange)\n\t        ClipperLib.Error(\"Coordinate outside allowed range in RangeTest().\");\n\t    }\n\t    else if (Pt.X > ClipperLib.ClipperBase.loRange || Pt.Y > ClipperLib.ClipperBase.loRange || -Pt.X > ClipperLib.ClipperBase.loRange || -Pt.Y > ClipperLib.ClipperBase.loRange)\n\t    {\n\t      useFullRange.Value = true;\n\t      this.RangeTest(Pt, useFullRange);\n\t    }\n\t  };\n\t  ClipperLib.ClipperBase.prototype.InitEdge = function (e, eNext, ePrev, pt)\n\t  {\n\t    e.Next = eNext;\n\t    e.Prev = ePrev;\n\t    //e.Curr = pt;\n\t    e.Curr.X = pt.X;\n\t    e.Curr.Y = pt.Y;\n\t    e.OutIdx = -1;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.InitEdge2 = function (e, polyType)\n\t  {\n\t    if (e.Curr.Y >= e.Next.Curr.Y)\n\t    {\n\t      //e.Bot = e.Curr;\n\t      e.Bot.X = e.Curr.X;\n\t      e.Bot.Y = e.Curr.Y;\n\t      //e.Top = e.Next.Curr;\n\t      e.Top.X = e.Next.Curr.X;\n\t      e.Top.Y = e.Next.Curr.Y;\n\t    }\n\t    else\n\t    {\n\t      //e.Top = e.Curr;\n\t      e.Top.X = e.Curr.X;\n\t      e.Top.Y = e.Curr.Y;\n\t      //e.Bot = e.Next.Curr;\n\t      e.Bot.X = e.Next.Curr.X;\n\t      e.Bot.Y = e.Next.Curr.Y;\n\t    }\n\t    this.SetDx(e);\n\t    e.PolyTyp = polyType;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.FindNextLocMin = function (E)\n\t  {\n\t    var E2;\n\t    for (;;)\n\t    {\n\t      while (ClipperLib.IntPoint.op_Inequality(E.Bot, E.Prev.Bot) || ClipperLib.IntPoint.op_Equality(E.Curr, E.Top))\n\t        E = E.Next;\n\t      if (E.Dx != ClipperLib.ClipperBase.horizontal && E.Prev.Dx != ClipperLib.ClipperBase.horizontal)\n\t        break;\n\t      while (E.Prev.Dx == ClipperLib.ClipperBase.horizontal)\n\t        E = E.Prev;\n\t      E2 = E;\n\t      while (E.Dx == ClipperLib.ClipperBase.horizontal)\n\t        E = E.Next;\n\t      if (E.Top.Y == E.Prev.Bot.Y)\n\t        continue;\n\t      //ie just an intermediate horz.\n\t      if (E2.Prev.Bot.X < E.Bot.X)\n\t        E = E2;\n\t      break;\n\t    }\n\t    return E;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.ProcessBound = function (E, LeftBoundIsForward)\n\t  {\n\t    var EStart;\n\t    var Result = E;\n\t    var Horz;\n\t\n\t      if (Result.OutIdx == ClipperLib.ClipperBase.Skip)\n\t      {\n\t        //check if there are edges beyond the skip edge in the bound and if so\n\t        //create another LocMin and calling ProcessBound once more ...\n\t        E = Result;\n\t        if (LeftBoundIsForward)\n\t        {\n\t          while (E.Top.Y == E.Next.Bot.Y) E = E.Next;\n\t          while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Prev;\n\t        }\n\t        else\n\t        {\n\t          while (E.Top.Y == E.Prev.Bot.Y) E = E.Prev;\n\t          while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Next;\n\t        }\n\t        if (E == Result)\n\t        {\n\t          if (LeftBoundIsForward) Result = E.Next;\n\t          else Result = E.Prev;\n\t        }\n\t        else\n\t        {\n\t          //there are more edges in the bound beyond result starting with E\n\t          if (LeftBoundIsForward)\n\t            E = Result.Next;\n\t          else\n\t            E = Result.Prev;\n\t          var locMin = new ClipperLib.LocalMinima();\n\t          locMin.Next = null;\n\t          locMin.Y = E.Bot.Y;\n\t          locMin.LeftBound = null;\n\t          locMin.RightBound = E;\n\t          E.WindDelta = 0;\n\t          Result = this.ProcessBound(E, LeftBoundIsForward);\n\t          this.InsertLocalMinima(locMin);\n\t        }\n\t        return Result;\n\t      }\n\t\n\t      if (E.Dx == ClipperLib.ClipperBase.horizontal)\n\t      {\n\t        //We need to be careful with open paths because this may not be a\n\t        //true local minima (ie E may be following a skip edge).\n\t        //Also, consecutive horz. edges may start heading left before going right.\n\t        if (LeftBoundIsForward) EStart = E.Prev;\n\t        else EStart = E.Next;\n\t        if (EStart.OutIdx != ClipperLib.ClipperBase.Skip)\n\t        {\n\t          if (EStart.Dx == ClipperLib.ClipperBase.horizontal) //ie an adjoining horizontal skip edge\n\t          {\n\t            if (EStart.Bot.X != E.Bot.X && EStart.Top.X != E.Bot.X)\n\t              this.ReverseHorizontal(E);\n\t          }\n\t          else if (EStart.Bot.X != E.Bot.X)\n\t            this.ReverseHorizontal(E);\n\t        }\n\t      }\n\t\n\t      EStart = E;\n\t      if (LeftBoundIsForward)\n\t      {\n\t        while (Result.Top.Y == Result.Next.Bot.Y && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n\t          Result = Result.Next;\n\t        if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n\t        {\n\t          //nb: at the top of a bound, horizontals are added to the bound\n\t          //only when the preceding edge attaches to the horizontal's left vertex\n\t          //unless a Skip edge is encountered when that becomes the top divide\n\t          Horz = Result;\n\t          while (Horz.Prev.Dx == ClipperLib.ClipperBase.horizontal)\n\t            Horz = Horz.Prev;\n\t          if (Horz.Prev.Top.X == Result.Next.Top.X)\n\t          {\n\t            if (!LeftBoundIsForward)\n\t              Result = Horz.Prev;\n\t          }\n\t          else if (Horz.Prev.Top.X > Result.Next.Top.X)\n\t            Result = Horz.Prev;\n\t        }\n\t        while (E != Result)\n\t        {\n\t          E.NextInLML = E.Next;\n\t          if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)\n\t            this.ReverseHorizontal(E);\n\t          E = E.Next;\n\t        }\n\t        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)\n\t          this.ReverseHorizontal(E);\n\t        Result = Result.Next;\n\t        //move to the edge just beyond current bound\n\t      }\n\t      else\n\t      {\n\t        while (Result.Top.Y == Result.Prev.Bot.Y && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)\n\t          Result = Result.Prev;\n\t        if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)\n\t        {\n\t          Horz = Result;\n\t          while (Horz.Next.Dx == ClipperLib.ClipperBase.horizontal)\n\t            Horz = Horz.Next;\n\t          if (Horz.Next.Top.X == Result.Prev.Top.X)\n\t          {\n\t            if (!LeftBoundIsForward)\n\t              Result = Horz.Next;\n\t          }\n\t          else if (Horz.Next.Top.X > Result.Prev.Top.X)\n\t            Result = Horz.Next;\n\t        }\n\t        while (E != Result)\n\t        {\n\t          E.NextInLML = E.Prev;\n\t          if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)\n\t            this.ReverseHorizontal(E);\n\t          E = E.Prev;\n\t        }\n\t        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)\n\t          this.ReverseHorizontal(E);\n\t        Result = Result.Prev;\n\t        //move to the edge just beyond current bound\n\t      }\n\t\n\t    return Result;\n\t  };\n\t\n\t  ClipperLib.ClipperBase.prototype.AddPath = function (pg, polyType, Closed)\n\t  {\n\t    if (use_lines)\n\t    {\n\t      if (!Closed && polyType == ClipperLib.PolyType.ptClip)\n\t        ClipperLib.Error(\"AddPath: Open paths must be subject.\");\n\t    }\n\t    else\n\t    {\n\t      if (!Closed)\n\t        ClipperLib.Error(\"AddPath: Open paths have been disabled.\");\n\t    }\n\t    var highI = pg.length - 1;\n\t    if (Closed)\n\t      while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[0])))\n\t    --highI;\n\t    while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[highI - 1])))\n\t    --highI;\n\t    if ((Closed && highI < 2) || (!Closed && highI < 1))\n\t      return false;\n\t    //create a new edge array ...\n\t    var edges = new Array();\n\t    for (var i = 0; i <= highI; i++)\n\t      edges.push(new ClipperLib.TEdge());\n\t    var IsFlat = true;\n\t    //1. Basic (first) edge initialization ...\n\t\n\t    //edges[1].Curr = pg[1];\n\t    edges[1].Curr.X = pg[1].X;\n\t    edges[1].Curr.Y = pg[1].Y;\n\t\n\t    var $1 = {Value: this.m_UseFullRange};\n\t    this.RangeTest(pg[0], $1);\n\t    this.m_UseFullRange = $1.Value;\n\t\n\t    $1.Value = this.m_UseFullRange;\n\t    this.RangeTest(pg[highI], $1);\n\t    this.m_UseFullRange = $1.Value;\n\t\n\t    this.InitEdge(edges[0], edges[1], edges[highI], pg[0]);\n\t    this.InitEdge(edges[highI], edges[0], edges[highI - 1], pg[highI]);\n\t    for (var i = highI - 1; i >= 1; --i)\n\t    {\n\t      $1.Value = this.m_UseFullRange;\n\t      this.RangeTest(pg[i], $1);\n\t      this.m_UseFullRange = $1.Value;\n\t\n\t      this.InitEdge(edges[i], edges[i + 1], edges[i - 1], pg[i]);\n\t    }\n\t\n\t    var eStart = edges[0];\n\t    //2. Remove duplicate vertices, and (when closed) collinear edges ...\n\t    var E = eStart,\n\t      eLoopStop = eStart;\n\t    for (;;)\n\t    {\n\t    //console.log(E.Next, eStart);\n\t    \t//nb: allows matching start and end points when not Closed ...\n\t      if (E.Curr == E.Next.Curr && (Closed || E.Next != eStart))\n\t      {\n\t        if (E == E.Next)\n\t          break;\n\t        if (E == eStart)\n\t          eStart = E.Next;\n\t        E = this.RemoveEdge(E);\n\t        eLoopStop = E;\n\t        continue;\n\t      }\n\t      if (E.Prev == E.Next)\n\t        break;\n\t      else if (Closed && ClipperLib.ClipperBase.SlopesEqual(E.Prev.Curr, E.Curr, E.Next.Curr, this.m_UseFullRange) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(E.Prev.Curr, E.Curr, E.Next.Curr)))\n\t      {\n\t        //Collinear edges are allowed for open paths but in closed paths\n\t        //the default is to merge adjacent collinear edges into a single edge.\n\t        //However, if the PreserveCollinear property is enabled, only overlapping\n\t        //collinear edges (ie spikes) will be removed from closed paths.\n\t        if (E == eStart)\n\t          eStart = E.Next;\n\t        E = this.RemoveEdge(E);\n\t        E = E.Prev;\n\t        eLoopStop = E;\n\t        continue;\n\t      }\n\t      E = E.Next;\n\t      if ((E == eLoopStop) || (!Closed && E.Next == eStart)) break;\n\t    }\n\t    if ((!Closed && (E == E.Next)) || (Closed && (E.Prev == E.Next)))\n\t      return false;\n\t    if (!Closed)\n\t    {\n\t      this.m_HasOpenPaths = true;\n\t      eStart.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n\t    }\n\t    //3. Do second stage of edge initialization ...\n\t    E = eStart;\n\t    do {\n\t      this.InitEdge2(E, polyType);\n\t      E = E.Next;\n\t      if (IsFlat && E.Curr.Y != eStart.Curr.Y)\n\t        IsFlat = false;\n\t    }\n\t    while (E != eStart)\n\t    //4. Finally, add edge bounds to LocalMinima list ...\n\t    //Totally flat paths must be handled differently when adding them\n\t    //to LocalMinima list to avoid endless loops etc ...\n\t    if (IsFlat)\n\t    {\n\t      if (Closed)\n\t        return false;\n\t      E.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n\t      if (E.Prev.Bot.X < E.Prev.Top.X)\n\t        this.ReverseHorizontal(E.Prev);\n\t      var locMin = new ClipperLib.LocalMinima();\n\t      locMin.Next = null;\n\t      locMin.Y = E.Bot.Y;\n\t      locMin.LeftBound = null;\n\t      locMin.RightBound = E;\n\t      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n\t      locMin.RightBound.WindDelta = 0;\n\t      while (E.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n\t      {\n\t        E.NextInLML = E.Next;\n\t        if (E.Bot.X != E.Prev.Top.X)\n\t          this.ReverseHorizontal(E);\n\t        E = E.Next;\n\t      }\n\t      this.InsertLocalMinima(locMin);\n\t      this.m_edges.push(edges);\n\t      return true;\n\t    }\n\t    this.m_edges.push(edges);\n\t    var leftBoundIsForward;\n\t    var EMin = null;\n\t\n\t\t\t//workaround to avoid an endless loop in the while loop below when\n\t    //open paths have matching start and end points ...\n\t    if(ClipperLib.IntPoint.op_Equality(E.Prev.Bot, E.Prev.Top))\n\t    \tE = E.Next;\n\t\n\t    for (;;)\n\t    {\n\t      E = this.FindNextLocMin(E);\n\t      if (E == EMin)\n\t        break;\n\t      else if (EMin == null)\n\t        EMin = E;\n\t      //E and E.Prev now share a local minima (left aligned if horizontal).\n\t      //Compare their slopes to find which starts which bound ...\n\t      var locMin = new ClipperLib.LocalMinima();\n\t      locMin.Next = null;\n\t      locMin.Y = E.Bot.Y;\n\t      if (E.Dx < E.Prev.Dx)\n\t      {\n\t        locMin.LeftBound = E.Prev;\n\t        locMin.RightBound = E;\n\t        leftBoundIsForward = false;\n\t        //Q.nextInLML = Q.prev\n\t      }\n\t      else\n\t      {\n\t        locMin.LeftBound = E;\n\t        locMin.RightBound = E.Prev;\n\t        leftBoundIsForward = true;\n\t        //Q.nextInLML = Q.next\n\t      }\n\t      locMin.LeftBound.Side = ClipperLib.EdgeSide.esLeft;\n\t      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n\t      if (!Closed)\n\t        locMin.LeftBound.WindDelta = 0;\n\t      else if (locMin.LeftBound.Next == locMin.RightBound)\n\t        locMin.LeftBound.WindDelta = -1;\n\t      else\n\t        locMin.LeftBound.WindDelta = 1;\n\t      locMin.RightBound.WindDelta = -locMin.LeftBound.WindDelta;\n\t      E = this.ProcessBound(locMin.LeftBound, leftBoundIsForward);\n\t      if (E.OutIdx == ClipperLib.ClipperBase.Skip)\n\t      \tE = this.ProcessBound(E, leftBoundIsForward);\n\t      var E2 = this.ProcessBound(locMin.RightBound, !leftBoundIsForward);\n\t      if (E2.OutIdx == ClipperLib.ClipperBase.Skip) E2 = this.ProcessBound(E2, !leftBoundIsForward);\n\t      if (locMin.LeftBound.OutIdx == ClipperLib.ClipperBase.Skip)\n\t        locMin.LeftBound = null;\n\t      else if (locMin.RightBound.OutIdx == ClipperLib.ClipperBase.Skip)\n\t        locMin.RightBound = null;\n\t      this.InsertLocalMinima(locMin);\n\t      if (!leftBoundIsForward)\n\t        E = E2;\n\t    }\n\t    return true;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.AddPaths = function (ppg, polyType, closed)\n\t  {\n\t    //  console.log(\"-------------------------------------------\");\n\t    //  console.log(JSON.stringify(ppg));\n\t    var result = false;\n\t    for (var i = 0, ilen = ppg.length; i < ilen; ++i)\n\t      if (this.AddPath(ppg[i], polyType, closed))\n\t        result = true;\n\t    return result;\n\t  };\n\t  //------------------------------------------------------------------------------\n\t  ClipperLib.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3 = function (pt1, pt2, pt3)\n\t  {\n\t    if ((ClipperLib.IntPoint.op_Equality(pt1, pt3)) || (ClipperLib.IntPoint.op_Equality(pt1, pt2)) ||       (ClipperLib.IntPoint.op_Equality(pt3, pt2)))\n\t\n\t   //if ((pt1 == pt3) || (pt1 == pt2) || (pt3 == pt2))\n\t   return false;\n\t\n\t    else if (pt1.X != pt3.X)\n\t      return (pt2.X > pt1.X) == (pt2.X < pt3.X);\n\t    else\n\t      return (pt2.Y > pt1.Y) == (pt2.Y < pt3.Y);\n\t  };\n\t  ClipperLib.ClipperBase.prototype.RemoveEdge = function (e)\n\t  {\n\t    //removes e from double_linked_list (but without removing from memory)\n\t    e.Prev.Next = e.Next;\n\t    e.Next.Prev = e.Prev;\n\t    var result = e.Next;\n\t    e.Prev = null; //flag as removed (see ClipperBase.Clear)\n\t    return result;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.SetDx = function (e)\n\t  {\n\t    e.Delta.X = (e.Top.X - e.Bot.X);\n\t    e.Delta.Y = (e.Top.Y - e.Bot.Y);\n\t    if (e.Delta.Y === 0) e.Dx = ClipperLib.ClipperBase.horizontal;\n\t    else e.Dx = (e.Delta.X) / (e.Delta.Y);\n\t  };\n\t  ClipperLib.ClipperBase.prototype.InsertLocalMinima = function (newLm)\n\t  {\n\t    if (this.m_MinimaList === null)\n\t    {\n\t      this.m_MinimaList = newLm;\n\t    }\n\t    else if (newLm.Y >= this.m_MinimaList.Y)\n\t    {\n\t      newLm.Next = this.m_MinimaList;\n\t      this.m_MinimaList = newLm;\n\t    }\n\t    else\n\t    {\n\t      var tmpLm = this.m_MinimaList;\n\t      while (tmpLm.Next !== null && (newLm.Y < tmpLm.Next.Y))\n\t        tmpLm = tmpLm.Next;\n\t      newLm.Next = tmpLm.Next;\n\t      tmpLm.Next = newLm;\n\t    }\n\t  };\n\t  ClipperLib.ClipperBase.prototype.PopLocalMinima = function ()\n\t  {\n\t    if (this.m_CurrentLM === null)\n\t      return;\n\t    this.m_CurrentLM = this.m_CurrentLM.Next;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.ReverseHorizontal = function (e)\n\t  {\n\t    //swap horizontal edges' top and bottom x's so they follow the natural\n\t    //progression of the bounds - ie so their xbots will align with the\n\t    //adjoining lower edge. [Helpful in the ProcessHorizontal() method.]\n\t    var tmp = e.Top.X;\n\t    e.Top.X = e.Bot.X;\n\t    e.Bot.X = tmp;\n\t    if (use_xyz)\n\t    {\n\t      tmp = e.Top.Z;\n\t      e.Top.Z = e.Bot.Z;\n\t      e.Bot.Z = tmp;\n\t    }\n\t  };\n\t  ClipperLib.ClipperBase.prototype.Reset = function ()\n\t  {\n\t    this.m_CurrentLM = this.m_MinimaList;\n\t    if (this.m_CurrentLM == null)\n\t      return;\n\t    //ie nothing to process\n\t    //reset all edges ...\n\t    var lm = this.m_MinimaList;\n\t    while (lm != null)\n\t    {\n\t      var e = lm.LeftBound;\n\t      if (e != null)\n\t      {\n\t        //e.Curr = e.Bot;\n\t        e.Curr.X = e.Bot.X;\n\t        e.Curr.Y = e.Bot.Y;\n\t        e.Side = ClipperLib.EdgeSide.esLeft;\n\t        e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n\t      }\n\t      e = lm.RightBound;\n\t      if (e != null)\n\t      {\n\t        //e.Curr = e.Bot;\n\t        e.Curr.X = e.Bot.X;\n\t        e.Curr.Y = e.Bot.Y;\n\t        e.Side = ClipperLib.EdgeSide.esRight;\n\t        e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n\t      }\n\t      lm = lm.Next;\n\t    }\n\t  };\n\t  ClipperLib.Clipper = function (InitOptions) // public Clipper(int InitOptions = 0)\n\t  {\n\t    if (typeof (InitOptions) == \"undefined\") InitOptions = 0;\n\t    this.m_PolyOuts = null;\n\t    this.m_ClipType = ClipperLib.ClipType.ctIntersection;\n\t    this.m_Scanbeam = null;\n\t    this.m_ActiveEdges = null;\n\t    this.m_SortedEdges = null;\n\t    this.m_IntersectList = null;\n\t    this.m_IntersectNodeComparer = null;\n\t    this.m_ExecuteLocked = false;\n\t    this.m_ClipFillType = ClipperLib.PolyFillType.pftEvenOdd;\n\t    this.m_SubjFillType = ClipperLib.PolyFillType.pftEvenOdd;\n\t    this.m_Joins = null;\n\t    this.m_GhostJoins = null;\n\t    this.m_UsingPolyTree = false;\n\t    this.ReverseSolution = false;\n\t    this.StrictlySimple = false;\n\t    ClipperLib.ClipperBase.call(this);\n\t    this.m_Scanbeam = null;\n\t    this.m_ActiveEdges = null;\n\t    this.m_SortedEdges = null;\n\t    this.m_IntersectList = new Array();\n\t    this.m_IntersectNodeComparer = ClipperLib.MyIntersectNodeSort.Compare;\n\t    this.m_ExecuteLocked = false;\n\t    this.m_UsingPolyTree = false;\n\t    this.m_PolyOuts = new Array();\n\t    this.m_Joins = new Array();\n\t    this.m_GhostJoins = new Array();\n\t    this.ReverseSolution = (1 & InitOptions) !== 0;\n\t    this.StrictlySimple = (2 & InitOptions) !== 0;\n\t    this.PreserveCollinear = (4 & InitOptions) !== 0;\n\t    if (use_xyz)\n\t    {\n\t      this.ZFillFunction = null; // function (IntPoint vert1, IntPoint vert2, ref IntPoint intersectPt);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.ioReverseSolution = 1;\n\t  ClipperLib.Clipper.ioStrictlySimple = 2;\n\t  ClipperLib.Clipper.ioPreserveCollinear = 4;\n\t\n\t  ClipperLib.Clipper.prototype.Clear = function ()\n\t  {\n\t    if (this.m_edges.length === 0)\n\t      return;\n\t    //avoids problems with ClipperBase destructor\n\t    this.DisposeAllPolyPts();\n\t    ClipperLib.ClipperBase.prototype.Clear.call(this);\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.DisposeScanbeamList = function ()\n\t  {\n\t    while (this.m_Scanbeam !== null)\n\t    {\n\t      var sb2 = this.m_Scanbeam.Next;\n\t      this.m_Scanbeam = null;\n\t      this.m_Scanbeam = sb2;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.Reset = function ()\n\t  {\n\t    ClipperLib.ClipperBase.prototype.Reset.call(this);\n\t    this.m_Scanbeam = null;\n\t    this.m_ActiveEdges = null;\n\t    this.m_SortedEdges = null;\n\t\n\t    var lm = this.m_MinimaList;\n\t    while (lm !== null)\n\t    {\n\t      this.InsertScanbeam(lm.Y);\n\t      lm = lm.Next;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.InsertScanbeam = function (Y)\n\t  {\n\t    if (this.m_Scanbeam === null)\n\t    {\n\t      this.m_Scanbeam = new ClipperLib.Scanbeam();\n\t      this.m_Scanbeam.Next = null;\n\t      this.m_Scanbeam.Y = Y;\n\t    }\n\t    else if (Y > this.m_Scanbeam.Y)\n\t    {\n\t      var newSb = new ClipperLib.Scanbeam();\n\t      newSb.Y = Y;\n\t      newSb.Next = this.m_Scanbeam;\n\t      this.m_Scanbeam = newSb;\n\t    }\n\t    else\n\t    {\n\t      var sb2 = this.m_Scanbeam;\n\t      while (sb2.Next !== null && (Y <= sb2.Next.Y))\n\t        sb2 = sb2.Next;\n\t      if (Y == sb2.Y)\n\t        return;\n\t      //ie ignores duplicates\n\t      var newSb = new ClipperLib.Scanbeam();\n\t      newSb.Y = Y;\n\t      newSb.Next = sb2.Next;\n\t      sb2.Next = newSb;\n\t    }\n\t  };\n\t  // ************************************\n\t  ClipperLib.Clipper.prototype.Execute = function ()\n\t  {\n\t    var a = arguments,\n\t      alen = a.length,\n\t      ispolytree = a[1] instanceof ClipperLib.PolyTree;\n\t    if (alen == 4 && !ispolytree) // function (clipType, solution, subjFillType, clipFillType)\n\t    {\n\t      var clipType = a[0],\n\t        solution = a[1],\n\t        subjFillType = a[2],\n\t        clipFillType = a[3];\n\t      if (this.m_ExecuteLocked)\n\t        return false;\n\t      if (this.m_HasOpenPaths)\n\t        ClipperLib.Error(\"Error: PolyTree struct is need for open path clipping.\");\n\t      this.m_ExecuteLocked = true;\n\t      ClipperLib.Clear(solution);\n\t      this.m_SubjFillType = subjFillType;\n\t      this.m_ClipFillType = clipFillType;\n\t      this.m_ClipType = clipType;\n\t      this.m_UsingPolyTree = false;\n\t      try\n\t      {\n\t        var succeeded = this.ExecuteInternal();\n\t        //build the return polygons ...\n\t        if (succeeded) this.BuildResult(solution);\n\t      }\n\t      finally\n\t      {\n\t        this.DisposeAllPolyPts();\n\t        this.m_ExecuteLocked = false;\n\t      }\n\t      return succeeded;\n\t    }\n\t    else if (alen == 4 && ispolytree) // function (clipType, polytree, subjFillType, clipFillType)\n\t    {\n\t      var clipType = a[0],\n\t        polytree = a[1],\n\t        subjFillType = a[2],\n\t        clipFillType = a[3];\n\t      if (this.m_ExecuteLocked)\n\t        return false;\n\t      this.m_ExecuteLocked = true;\n\t      this.m_SubjFillType = subjFillType;\n\t      this.m_ClipFillType = clipFillType;\n\t      this.m_ClipType = clipType;\n\t      this.m_UsingPolyTree = true;\n\t      try\n\t      {\n\t        var succeeded = this.ExecuteInternal();\n\t        //build the return polygons ...\n\t        if (succeeded) this.BuildResult2(polytree);\n\t      }\n\t      finally\n\t      {\n\t        this.DisposeAllPolyPts();\n\t        this.m_ExecuteLocked = false;\n\t      }\n\t      return succeeded;\n\t    }\n\t    else if (alen == 2 && !ispolytree) // function (clipType, solution)\n\t    {\n\t      var clipType = a[0],\n\t        solution = a[1];\n\t      return this.Execute(clipType, solution, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n\t    }\n\t    else if (alen == 2 && ispolytree) // function (clipType, polytree)\n\t    {\n\t      var clipType = a[0],\n\t        polytree = a[1];\n\t      return this.Execute(clipType, polytree, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.FixHoleLinkage = function (outRec)\n\t  {\n\t    //skip if an outermost polygon or\n\t    //already already points to the correct FirstLeft ...\n\t    if (outRec.FirstLeft === null || (outRec.IsHole != outRec.FirstLeft.IsHole && outRec.FirstLeft.Pts !== null))\n\t      return;\n\t    var orfl = outRec.FirstLeft;\n\t    while (orfl !== null && ((orfl.IsHole == outRec.IsHole) || orfl.Pts === null))\n\t      orfl = orfl.FirstLeft;\n\t    outRec.FirstLeft = orfl;\n\t  };\n\t  ClipperLib.Clipper.prototype.ExecuteInternal = function ()\n\t  {\n\t    try\n\t    {\n\t      this.Reset();\n\t      if (this.m_CurrentLM === null)\n\t        return false;\n\t      var botY = this.PopScanbeam();\n\t      do {\n\t        this.InsertLocalMinimaIntoAEL(botY);\n\t        ClipperLib.Clear(this.m_GhostJoins);\n\t        this.ProcessHorizontals(false);\n\t        if (this.m_Scanbeam === null)\n\t          break;\n\t        var topY = this.PopScanbeam();\n\t        if (!this.ProcessIntersections(topY)) return false;\n\t\n\t        this.ProcessEdgesAtTopOfScanbeam(topY);\n\t        botY = topY;\n\t      }\n\t      while (this.m_Scanbeam !== null || this.m_CurrentLM !== null)\n\t      //fix orientations ...\n\t      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t      {\n\t        var outRec = this.m_PolyOuts[i];\n\t        if (outRec.Pts === null || outRec.IsOpen)\n\t          continue;\n\t        if ((outRec.IsHole ^ this.ReverseSolution) == (this.Area(outRec) > 0))\n\t          this.ReversePolyPtLinks(outRec.Pts);\n\t      }\n\t      this.JoinCommonEdges();\n\t      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t      {\n\t        var outRec = this.m_PolyOuts[i];\n\t        if (outRec.Pts !== null && !outRec.IsOpen)\n\t          this.FixupOutPolygon(outRec);\n\t      }\n\t      if (this.StrictlySimple)\n\t        this.DoSimplePolygons();\n\t      return true;\n\t    }\n\t    finally\n\t    {\n\t      ClipperLib.Clear(this.m_Joins);\n\t      ClipperLib.Clear(this.m_GhostJoins);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.PopScanbeam = function ()\n\t  {\n\t    var Y = this.m_Scanbeam.Y;\n\t    this.m_Scanbeam = this.m_Scanbeam.Next;\n\t    return Y;\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.DisposeAllPolyPts = function ()\n\t  {\n\t    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; ++i)\n\t      this.DisposeOutRec(i);\n\t    ClipperLib.Clear(this.m_PolyOuts);\n\t  };\n\t  ClipperLib.Clipper.prototype.DisposeOutRec = function (index)\n\t  {\n\t    var outRec = this.m_PolyOuts[index];\n\t    outRec.Pts = null;\n\t    outRec = null;\n\t    this.m_PolyOuts[index] = null;\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.AddJoin = function (Op1, Op2, OffPt)\n\t  {\n\t    var j = new ClipperLib.Join();\n\t    j.OutPt1 = Op1;\n\t    j.OutPt2 = Op2;\n\t    //j.OffPt = OffPt;\n\t    j.OffPt.X = OffPt.X;\n\t    j.OffPt.Y = OffPt.Y;\n\t    this.m_Joins.push(j);\n\t  };\n\t  ClipperLib.Clipper.prototype.AddGhostJoin = function (Op, OffPt)\n\t  {\n\t    var j = new ClipperLib.Join();\n\t    j.OutPt1 = Op;\n\t    //j.OffPt = OffPt;\n\t    j.OffPt.X = OffPt.X;\n\t    j.OffPt.Y = OffPt.Y;\n\t    this.m_GhostJoins.push(j);\n\t  };\n\t  if (use_xyz)\n\t  {\n\t    ClipperLib.Clipper.prototype.SetZ = function (pt, e1, e2)\n\t    {\n\t      if (this.ZFillFunction !== null)\n\t      {\n\t        if (pt.Z != 0 || this.ZFillFunction === null) return;\n\t        else if (ClipperLib.IntPoint.op_Equality(pt, e1.Bot)) pt.Z = e1.Bot.Z;\n\t        else if (ClipperLib.IntPoint.op_Equality(pt, e1.Top)) pt.Z = e1.Top.Z;\n\t        else if (ClipperLib.IntPoint.op_Equality(pt, e2.Bot)) pt.Z = e2.Bot.Z;\n\t        else if (ClipperLib.IntPoint.op_Equality(pt, e2.Top)) pt.Z = e2.Top.Z;\n\t        else ZFillFunction(e1.Bot, e1.Top, e2.Bot, e2.Top, pt);\n\t      }\n\t    };\n\t\n\t    //------------------------------------------------------------------------------\n\t  }\n\t\n\t  ClipperLib.Clipper.prototype.InsertLocalMinimaIntoAEL = function (botY)\n\t  {\n\t    while (this.m_CurrentLM !== null && (this.m_CurrentLM.Y == botY))\n\t    {\n\t      var lb = this.m_CurrentLM.LeftBound;\n\t      var rb = this.m_CurrentLM.RightBound;\n\t      this.PopLocalMinima();\n\t      var Op1 = null;\n\t      if (lb === null)\n\t      {\n\t        this.InsertEdgeIntoAEL(rb, null);\n\t        this.SetWindingCount(rb);\n\t        if (this.IsContributing(rb))\n\t          Op1 = this.AddOutPt(rb, rb.Bot);\n\t      }\n\t      else if (rb == null)\n\t      {\n\t        this.InsertEdgeIntoAEL(lb, null);\n\t        this.SetWindingCount(lb);\n\t        if (this.IsContributing(lb))\n\t          Op1 = this.AddOutPt(lb, lb.Bot);\n\t        this.InsertScanbeam(lb.Top.Y);\n\t      }\n\t      else\n\t      {\n\t        this.InsertEdgeIntoAEL(lb, null);\n\t        this.InsertEdgeIntoAEL(rb, lb);\n\t        this.SetWindingCount(lb);\n\t        rb.WindCnt = lb.WindCnt;\n\t        rb.WindCnt2 = lb.WindCnt2;\n\t        if (this.IsContributing(lb))\n\t          Op1 = this.AddLocalMinPoly(lb, rb, lb.Bot);\n\t        this.InsertScanbeam(lb.Top.Y);\n\t      }\n\t      if (rb != null)\n\t      {\n\t        if (ClipperLib.ClipperBase.IsHorizontal(rb))\n\t          this.AddEdgeToSEL(rb);\n\t        else\n\t          this.InsertScanbeam(rb.Top.Y);\n\t      }\n\t      if (lb == null || rb == null) continue;\n\t      //if output polygons share an Edge with a horizontal rb, they'll need joining later ...\n\t      if (Op1 !== null && ClipperLib.ClipperBase.IsHorizontal(rb) && this.m_GhostJoins.length > 0 && rb.WindDelta !== 0)\n\t      {\n\t        for (var i = 0, ilen = this.m_GhostJoins.length; i < ilen; i++)\n\t        {\n\t          //if the horizontal Rb and a 'ghost' horizontal overlap, then convert\n\t          //the 'ghost' join to a real join ready for later ...\n\t          var j = this.m_GhostJoins[i];\n\t\n\t\t\t\t\t\tif (this.HorzSegmentsOverlap(j.OutPt1.Pt.X, j.OffPt.X, rb.Bot.X, rb.Top.X))\n\t            this.AddJoin(j.OutPt1, Op1, j.OffPt);\n\t        }\n\t      }\n\t      if (lb.OutIdx >= 0 && lb.PrevInAEL !== null &&\n\t        lb.PrevInAEL.Curr.X == lb.Bot.X &&\n\t        lb.PrevInAEL.OutIdx >= 0 &&\n\t        ClipperLib.ClipperBase.SlopesEqual(lb.PrevInAEL, lb, this.m_UseFullRange) &&\n\t        lb.WindDelta !== 0 && lb.PrevInAEL.WindDelta !== 0)\n\t      {\n\t        var Op2 = this.AddOutPt(lb.PrevInAEL, lb.Bot);\n\t        this.AddJoin(Op1, Op2, lb.Top);\n\t      }\n\t      if (lb.NextInAEL != rb)\n\t      {\n\t        if (rb.OutIdx >= 0 && rb.PrevInAEL.OutIdx >= 0 &&\n\t          ClipperLib.ClipperBase.SlopesEqual(rb.PrevInAEL, rb, this.m_UseFullRange) &&\n\t          rb.WindDelta !== 0 && rb.PrevInAEL.WindDelta !== 0)\n\t        {\n\t          var Op2 = this.AddOutPt(rb.PrevInAEL, rb.Bot);\n\t          this.AddJoin(Op1, Op2, rb.Top);\n\t        }\n\t        var e = lb.NextInAEL;\n\t        if (e !== null)\n\t          while (e != rb)\n\t          {\n\t            //nb: For calculating winding counts etc, IntersectEdges() assumes\n\t            //that param1 will be to the right of param2 ABOVE the intersection ...\n\t            this.IntersectEdges(rb, e, lb.Curr, false);\n\t            //order important here\n\t            e = e.NextInAEL;\n\t          }\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.InsertEdgeIntoAEL = function (edge, startEdge)\n\t  {\n\t    if (this.m_ActiveEdges === null)\n\t    {\n\t      edge.PrevInAEL = null;\n\t      edge.NextInAEL = null;\n\t      this.m_ActiveEdges = edge;\n\t    }\n\t    else if (startEdge === null && this.E2InsertsBeforeE1(this.m_ActiveEdges, edge))\n\t    {\n\t      edge.PrevInAEL = null;\n\t      edge.NextInAEL = this.m_ActiveEdges;\n\t      this.m_ActiveEdges.PrevInAEL = edge;\n\t      this.m_ActiveEdges = edge;\n\t    }\n\t    else\n\t    {\n\t      if (startEdge === null)\n\t        startEdge = this.m_ActiveEdges;\n\t      while (startEdge.NextInAEL !== null && !this.E2InsertsBeforeE1(startEdge.NextInAEL, edge))\n\t        startEdge = startEdge.NextInAEL;\n\t      edge.NextInAEL = startEdge.NextInAEL;\n\t      if (startEdge.NextInAEL !== null)\n\t        startEdge.NextInAEL.PrevInAEL = edge;\n\t      edge.PrevInAEL = startEdge;\n\t      startEdge.NextInAEL = edge;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.E2InsertsBeforeE1 = function (e1, e2)\n\t  {\n\t    if (e2.Curr.X == e1.Curr.X)\n\t    {\n\t      if (e2.Top.Y > e1.Top.Y)\n\t        return e2.Top.X < ClipperLib.Clipper.TopX(e1, e2.Top.Y);\n\t      else\n\t        return e1.Top.X > ClipperLib.Clipper.TopX(e2, e1.Top.Y);\n\t    }\n\t    else\n\t      return e2.Curr.X < e1.Curr.X;\n\t  };\n\t  ClipperLib.Clipper.prototype.IsEvenOddFillType = function (edge)\n\t  {\n\t    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t      return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n\t    else\n\t      return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n\t  };\n\t  ClipperLib.Clipper.prototype.IsEvenOddAltFillType = function (edge)\n\t  {\n\t    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t      return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n\t    else\n\t      return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n\t  };\n\t  ClipperLib.Clipper.prototype.IsContributing = function (edge)\n\t  {\n\t    var pft, pft2;\n\t    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t    {\n\t      pft = this.m_SubjFillType;\n\t      pft2 = this.m_ClipFillType;\n\t    }\n\t    else\n\t    {\n\t      pft = this.m_ClipFillType;\n\t      pft2 = this.m_SubjFillType;\n\t    }\n\t    switch (pft)\n\t    {\n\t    case ClipperLib.PolyFillType.pftEvenOdd:\n\t      if (edge.WindDelta === 0 && edge.WindCnt != 1)\n\t        return false;\n\t      break;\n\t    case ClipperLib.PolyFillType.pftNonZero:\n\t      if (Math.abs(edge.WindCnt) != 1)\n\t        return false;\n\t      break;\n\t    case ClipperLib.PolyFillType.pftPositive:\n\t      if (edge.WindCnt != 1)\n\t        return false;\n\t      break;\n\t    default:\n\t      if (edge.WindCnt != -1)\n\t        return false;\n\t      break;\n\t    }\n\t    switch (this.m_ClipType)\n\t    {\n\t    case ClipperLib.ClipType.ctIntersection:\n\t      switch (pft2)\n\t      {\n\t      case ClipperLib.PolyFillType.pftEvenOdd:\n\t      case ClipperLib.PolyFillType.pftNonZero:\n\t        return (edge.WindCnt2 !== 0);\n\t      case ClipperLib.PolyFillType.pftPositive:\n\t        return (edge.WindCnt2 > 0);\n\t      default:\n\t        return (edge.WindCnt2 < 0);\n\t      }\n\t    case ClipperLib.ClipType.ctUnion:\n\t      switch (pft2)\n\t      {\n\t      case ClipperLib.PolyFillType.pftEvenOdd:\n\t      case ClipperLib.PolyFillType.pftNonZero:\n\t        return (edge.WindCnt2 === 0);\n\t      case ClipperLib.PolyFillType.pftPositive:\n\t        return (edge.WindCnt2 <= 0);\n\t      default:\n\t        return (edge.WindCnt2 >= 0);\n\t      }\n\t    case ClipperLib.ClipType.ctDifference:\n\t      if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t        switch (pft2)\n\t        {\n\t        case ClipperLib.PolyFillType.pftEvenOdd:\n\t        case ClipperLib.PolyFillType.pftNonZero:\n\t          return (edge.WindCnt2 === 0);\n\t        case ClipperLib.PolyFillType.pftPositive:\n\t          return (edge.WindCnt2 <= 0);\n\t        default:\n\t          return (edge.WindCnt2 >= 0);\n\t        }\n\t      else\n\t        switch (pft2)\n\t        {\n\t        case ClipperLib.PolyFillType.pftEvenOdd:\n\t        case ClipperLib.PolyFillType.pftNonZero:\n\t          return (edge.WindCnt2 !== 0);\n\t        case ClipperLib.PolyFillType.pftPositive:\n\t          return (edge.WindCnt2 > 0);\n\t        default:\n\t          return (edge.WindCnt2 < 0);\n\t        }\n\t    case ClipperLib.ClipType.ctXor:\n\t      if (edge.WindDelta === 0)\n\t        switch (pft2)\n\t        {\n\t        case ClipperLib.PolyFillType.pftEvenOdd:\n\t        case ClipperLib.PolyFillType.pftNonZero:\n\t          return (edge.WindCnt2 === 0);\n\t        case ClipperLib.PolyFillType.pftPositive:\n\t          return (edge.WindCnt2 <= 0);\n\t        default:\n\t          return (edge.WindCnt2 >= 0);\n\t        }\n\t      else\n\t        return true;\n\t    }\n\t    return true;\n\t  };\n\t  ClipperLib.Clipper.prototype.SetWindingCount = function (edge)\n\t  {\n\t    var e = edge.PrevInAEL;\n\t    //find the edge of the same polytype that immediately preceeds 'edge' in AEL\n\t    while (e !== null && ((e.PolyTyp != edge.PolyTyp) || (e.WindDelta === 0)))\n\t      e = e.PrevInAEL;\n\t    if (e === null)\n\t    {\n\t      edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n\t      edge.WindCnt2 = 0;\n\t      e = this.m_ActiveEdges;\n\t      //ie get ready to calc WindCnt2\n\t    }\n\t    else if (edge.WindDelta === 0 && this.m_ClipType != ClipperLib.ClipType.ctUnion)\n\t    {\n\t      edge.WindCnt = 1;\n\t      edge.WindCnt2 = e.WindCnt2;\n\t      e = e.NextInAEL;\n\t      //ie get ready to calc WindCnt2\n\t    }\n\t    else if (this.IsEvenOddFillType(edge))\n\t    {\n\t      //EvenOdd filling ...\n\t      if (edge.WindDelta === 0)\n\t      {\n\t        //are we inside a subj polygon ...\n\t        var Inside = true;\n\t        var e2 = e.PrevInAEL;\n\t        while (e2 !== null)\n\t        {\n\t          if (e2.PolyTyp == e.PolyTyp && e2.WindDelta !== 0)\n\t            Inside = !Inside;\n\t          e2 = e2.PrevInAEL;\n\t        }\n\t        edge.WindCnt = (Inside ? 0 : 1);\n\t      }\n\t      else\n\t      {\n\t        edge.WindCnt = edge.WindDelta;\n\t      }\n\t      edge.WindCnt2 = e.WindCnt2;\n\t      e = e.NextInAEL;\n\t      //ie get ready to calc WindCnt2\n\t    }\n\t    else\n\t    {\n\t      //nonZero, Positive or Negative filling ...\n\t      if (e.WindCnt * e.WindDelta < 0)\n\t      {\n\t        //prev edge is 'decreasing' WindCount (WC) toward zero\n\t        //so we're outside the previous polygon ...\n\t        if (Math.abs(e.WindCnt) > 1)\n\t        {\n\t          //outside prev poly but still inside another.\n\t          //when reversing direction of prev poly use the same WC\n\t          if (e.WindDelta * edge.WindDelta < 0)\n\t            edge.WindCnt = e.WindCnt;\n\t          else\n\t            edge.WindCnt = e.WindCnt + edge.WindDelta;\n\t        }\n\t        else\n\t          edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n\t      }\n\t      else\n\t      {\n\t        //prev edge is 'increasing' WindCount (WC) away from zero\n\t        //so we're inside the previous polygon ...\n\t        if (edge.WindDelta === 0)\n\t          edge.WindCnt = (e.WindCnt < 0 ? e.WindCnt - 1 : e.WindCnt + 1);\n\t        else if (e.WindDelta * edge.WindDelta < 0)\n\t          edge.WindCnt = e.WindCnt;\n\t        else\n\t          edge.WindCnt = e.WindCnt + edge.WindDelta;\n\t      }\n\t      edge.WindCnt2 = e.WindCnt2;\n\t      e = e.NextInAEL;\n\t      //ie get ready to calc WindCnt2\n\t    }\n\t    //update WindCnt2 ...\n\t    if (this.IsEvenOddAltFillType(edge))\n\t    {\n\t      //EvenOdd filling ...\n\t      while (e != edge)\n\t      {\n\t        if (e.WindDelta !== 0)\n\t          edge.WindCnt2 = (edge.WindCnt2 === 0 ? 1 : 0);\n\t        e = e.NextInAEL;\n\t      }\n\t    }\n\t    else\n\t    {\n\t      //nonZero, Positive or Negative filling ...\n\t      while (e != edge)\n\t      {\n\t        edge.WindCnt2 += e.WindDelta;\n\t        e = e.NextInAEL;\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.AddEdgeToSEL = function (edge)\n\t  {\n\t    //SEL pointers in PEdge are reused to build a list of horizontal edges.\n\t    //However, we don't need to worry about order with horizontal edge processing.\n\t    if (this.m_SortedEdges === null)\n\t    {\n\t      this.m_SortedEdges = edge;\n\t      edge.PrevInSEL = null;\n\t      edge.NextInSEL = null;\n\t    }\n\t    else\n\t    {\n\t      edge.NextInSEL = this.m_SortedEdges;\n\t      edge.PrevInSEL = null;\n\t      this.m_SortedEdges.PrevInSEL = edge;\n\t      this.m_SortedEdges = edge;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.CopyAELToSEL = function ()\n\t  {\n\t    var e = this.m_ActiveEdges;\n\t    this.m_SortedEdges = e;\n\t    while (e !== null)\n\t    {\n\t      e.PrevInSEL = e.PrevInAEL;\n\t      e.NextInSEL = e.NextInAEL;\n\t      e = e.NextInAEL;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.SwapPositionsInAEL = function (edge1, edge2)\n\t  {\n\t    //check that one or other edge hasn't already been removed from AEL ...\n\t    if (edge1.NextInAEL == edge1.PrevInAEL || edge2.NextInAEL == edge2.PrevInAEL)\n\t      return;\n\t    if (edge1.NextInAEL == edge2)\n\t    {\n\t      var next = edge2.NextInAEL;\n\t      if (next !== null)\n\t        next.PrevInAEL = edge1;\n\t      var prev = edge1.PrevInAEL;\n\t      if (prev !== null)\n\t        prev.NextInAEL = edge2;\n\t      edge2.PrevInAEL = prev;\n\t      edge2.NextInAEL = edge1;\n\t      edge1.PrevInAEL = edge2;\n\t      edge1.NextInAEL = next;\n\t    }\n\t    else if (edge2.NextInAEL == edge1)\n\t    {\n\t      var next = edge1.NextInAEL;\n\t      if (next !== null)\n\t        next.PrevInAEL = edge2;\n\t      var prev = edge2.PrevInAEL;\n\t      if (prev !== null)\n\t        prev.NextInAEL = edge1;\n\t      edge1.PrevInAEL = prev;\n\t      edge1.NextInAEL = edge2;\n\t      edge2.PrevInAEL = edge1;\n\t      edge2.NextInAEL = next;\n\t    }\n\t    else\n\t    {\n\t      var next = edge1.NextInAEL;\n\t      var prev = edge1.PrevInAEL;\n\t      edge1.NextInAEL = edge2.NextInAEL;\n\t      if (edge1.NextInAEL !== null)\n\t        edge1.NextInAEL.PrevInAEL = edge1;\n\t      edge1.PrevInAEL = edge2.PrevInAEL;\n\t      if (edge1.PrevInAEL !== null)\n\t        edge1.PrevInAEL.NextInAEL = edge1;\n\t      edge2.NextInAEL = next;\n\t      if (edge2.NextInAEL !== null)\n\t        edge2.NextInAEL.PrevInAEL = edge2;\n\t      edge2.PrevInAEL = prev;\n\t      if (edge2.PrevInAEL !== null)\n\t        edge2.PrevInAEL.NextInAEL = edge2;\n\t    }\n\t    if (edge1.PrevInAEL === null)\n\t      this.m_ActiveEdges = edge1;\n\t    else if (edge2.PrevInAEL === null)\n\t      this.m_ActiveEdges = edge2;\n\t  };\n\t  ClipperLib.Clipper.prototype.SwapPositionsInSEL = function (edge1, edge2)\n\t  {\n\t    if (edge1.NextInSEL === null && edge1.PrevInSEL === null)\n\t      return;\n\t    if (edge2.NextInSEL === null && edge2.PrevInSEL === null)\n\t      return;\n\t    if (edge1.NextInSEL == edge2)\n\t    {\n\t      var next = edge2.NextInSEL;\n\t      if (next !== null)\n\t        next.PrevInSEL = edge1;\n\t      var prev = edge1.PrevInSEL;\n\t      if (prev !== null)\n\t        prev.NextInSEL = edge2;\n\t      edge2.PrevInSEL = prev;\n\t      edge2.NextInSEL = edge1;\n\t      edge1.PrevInSEL = edge2;\n\t      edge1.NextInSEL = next;\n\t    }\n\t    else if (edge2.NextInSEL == edge1)\n\t    {\n\t      var next = edge1.NextInSEL;\n\t      if (next !== null)\n\t        next.PrevInSEL = edge2;\n\t      var prev = edge2.PrevInSEL;\n\t      if (prev !== null)\n\t        prev.NextInSEL = edge1;\n\t      edge1.PrevInSEL = prev;\n\t      edge1.NextInSEL = edge2;\n\t      edge2.PrevInSEL = edge1;\n\t      edge2.NextInSEL = next;\n\t    }\n\t    else\n\t    {\n\t      var next = edge1.NextInSEL;\n\t      var prev = edge1.PrevInSEL;\n\t      edge1.NextInSEL = edge2.NextInSEL;\n\t      if (edge1.NextInSEL !== null)\n\t        edge1.NextInSEL.PrevInSEL = edge1;\n\t      edge1.PrevInSEL = edge2.PrevInSEL;\n\t      if (edge1.PrevInSEL !== null)\n\t        edge1.PrevInSEL.NextInSEL = edge1;\n\t      edge2.NextInSEL = next;\n\t      if (edge2.NextInSEL !== null)\n\t        edge2.NextInSEL.PrevInSEL = edge2;\n\t      edge2.PrevInSEL = prev;\n\t      if (edge2.PrevInSEL !== null)\n\t        edge2.PrevInSEL.NextInSEL = edge2;\n\t    }\n\t    if (edge1.PrevInSEL === null)\n\t      this.m_SortedEdges = edge1;\n\t    else if (edge2.PrevInSEL === null)\n\t      this.m_SortedEdges = edge2;\n\t  };\n\t  ClipperLib.Clipper.prototype.AddLocalMaxPoly = function (e1, e2, pt)\n\t  {\n\t    this.AddOutPt(e1, pt);\n\t    if (e2.WindDelta == 0) this.AddOutPt(e2, pt);\n\t    if (e1.OutIdx == e2.OutIdx)\n\t    {\n\t      e1.OutIdx = -1;\n\t      e2.OutIdx = -1;\n\t    }\n\t    else if (e1.OutIdx < e2.OutIdx)\n\t      this.AppendPolygon(e1, e2);\n\t    else\n\t      this.AppendPolygon(e2, e1);\n\t  };\n\t  ClipperLib.Clipper.prototype.AddLocalMinPoly = function (e1, e2, pt)\n\t  {\n\t    var result;\n\t    var e, prevE;\n\t    if (ClipperLib.ClipperBase.IsHorizontal(e2) || (e1.Dx > e2.Dx))\n\t    {\n\t      result = this.AddOutPt(e1, pt);\n\t      e2.OutIdx = e1.OutIdx;\n\t      e1.Side = ClipperLib.EdgeSide.esLeft;\n\t      e2.Side = ClipperLib.EdgeSide.esRight;\n\t      e = e1;\n\t      if (e.PrevInAEL == e2)\n\t        prevE = e2.PrevInAEL;\n\t      else\n\t        prevE = e.PrevInAEL;\n\t    }\n\t    else\n\t    {\n\t      result = this.AddOutPt(e2, pt);\n\t      e1.OutIdx = e2.OutIdx;\n\t      e1.Side = ClipperLib.EdgeSide.esRight;\n\t      e2.Side = ClipperLib.EdgeSide.esLeft;\n\t      e = e2;\n\t      if (e.PrevInAEL == e1)\n\t        prevE = e1.PrevInAEL;\n\t      else\n\t        prevE = e.PrevInAEL;\n\t    }\n\t    if (prevE !== null && prevE.OutIdx >= 0 && (ClipperLib.Clipper.TopX(prevE, pt.Y) == ClipperLib.Clipper.TopX(e, pt.Y)) && ClipperLib.ClipperBase.SlopesEqual(e, prevE, this.m_UseFullRange) && (e.WindDelta !== 0) && (prevE.WindDelta !== 0))\n\t    {\n\t      var outPt = this.AddOutPt(prevE, pt);\n\t      this.AddJoin(result, outPt, e.Top);\n\t    }\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.prototype.CreateOutRec = function ()\n\t  {\n\t    var result = new ClipperLib.OutRec();\n\t    result.Idx = -1;\n\t    result.IsHole = false;\n\t    result.IsOpen = false;\n\t    result.FirstLeft = null;\n\t    result.Pts = null;\n\t    result.BottomPt = null;\n\t    result.PolyNode = null;\n\t    this.m_PolyOuts.push(result);\n\t    result.Idx = this.m_PolyOuts.length - 1;\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.prototype.AddOutPt = function (e, pt)\n\t  {\n\t    var ToFront = (e.Side == ClipperLib.EdgeSide.esLeft);\n\t    if (e.OutIdx < 0)\n\t    {\n\t      var outRec = this.CreateOutRec();\n\t      outRec.IsOpen = (e.WindDelta === 0);\n\t      var newOp = new ClipperLib.OutPt();\n\t      outRec.Pts = newOp;\n\t      newOp.Idx = outRec.Idx;\n\t      //newOp.Pt = pt;\n\t      newOp.Pt.X = pt.X;\n\t      newOp.Pt.Y = pt.Y;\n\t      newOp.Next = newOp;\n\t      newOp.Prev = newOp;\n\t      if (!outRec.IsOpen)\n\t        this.SetHoleState(e, outRec);\n\t      e.OutIdx = outRec.Idx;\n\t      //nb: do this after SetZ !\n\t      return newOp;\n\t    }\n\t    else\n\t    {\n\t      var outRec = this.m_PolyOuts[e.OutIdx];\n\t      //OutRec.Pts is the 'Left-most' point & OutRec.Pts.Prev is the 'Right-most'\n\t      var op = outRec.Pts;\n\t      if (ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Pt))\n\t        return op;\n\t      else if (!ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Prev.Pt))\n\t        return op.Prev;\n\t      var newOp = new ClipperLib.OutPt();\n\t      newOp.Idx = outRec.Idx;\n\t      //newOp.Pt = pt;\n\t      newOp.Pt.X = pt.X;\n\t      newOp.Pt.Y = pt.Y;\n\t      newOp.Next = op;\n\t      newOp.Prev = op.Prev;\n\t      newOp.Prev.Next = newOp;\n\t      op.Prev = newOp;\n\t      if (ToFront)\n\t        outRec.Pts = newOp;\n\t      return newOp;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.SwapPoints = function (pt1, pt2)\n\t  {\n\t    var tmp = new ClipperLib.IntPoint(pt1.Value);\n\t    //pt1.Value = pt2.Value;\n\t    pt1.Value.X = pt2.Value.X;\n\t    pt1.Value.Y = pt2.Value.Y;\n\t    //pt2.Value = tmp;\n\t    pt2.Value.X = tmp.X;\n\t    pt2.Value.Y = tmp.Y;\n\t  };\n\t  ClipperLib.Clipper.prototype.HorzSegmentsOverlap = function (seg1a, seg1b, seg2a, seg2b)\n\t\t{\n\t\t\tvar tmp;\n\t\t\tif (seg1a > seg1b)\n\t\t\t{\n\t\t\t\ttmp = seg1a;\n\t\t\t\tseg1a = seg1b;\n\t\t\t\tseg1b = tmp;\n\t\t\t}\n\t\t\tif (seg2a > seg2b)\n\t\t\t{\n\t\t\t\ttmp = seg2a;\n\t\t\t\tseg2a = seg2b;\n\t\t\t\tseg2b = tmp;\n\t\t\t}\n\t\t\treturn (seg1a < seg2b) && (seg2a < seg1b);\n\t\t}\n\t\n\t  ClipperLib.Clipper.prototype.SetHoleState = function (e, outRec)\n\t  {\n\t    var isHole = false;\n\t    var e2 = e.PrevInAEL;\n\t    while (e2 !== null)\n\t    {\n\t      if (e2.OutIdx >= 0 && e2.WindDelta != 0)\n\t      {\n\t        isHole = !isHole;\n\t        if (outRec.FirstLeft === null)\n\t          outRec.FirstLeft = this.m_PolyOuts[e2.OutIdx];\n\t      }\n\t      e2 = e2.PrevInAEL;\n\t    }\n\t    if (isHole)\n\t      outRec.IsHole = true;\n\t  };\n\t  ClipperLib.Clipper.prototype.GetDx = function (pt1, pt2)\n\t  {\n\t    if (pt1.Y == pt2.Y)\n\t      return ClipperLib.ClipperBase.horizontal;\n\t    else\n\t      return (pt2.X - pt1.X) / (pt2.Y - pt1.Y);\n\t  };\n\t  ClipperLib.Clipper.prototype.FirstIsBottomPt = function (btmPt1, btmPt2)\n\t  {\n\t    var p = btmPt1.Prev;\n\t    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))\n\t      p = p.Prev;\n\t    var dx1p = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n\t    p = btmPt1.Next;\n\t    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))\n\t      p = p.Next;\n\t    var dx1n = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n\t    p = btmPt2.Prev;\n\t    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))\n\t      p = p.Prev;\n\t    var dx2p = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n\t    p = btmPt2.Next;\n\t    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))\n\t      p = p.Next;\n\t    var dx2n = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n\t    return (dx1p >= dx2p && dx1p >= dx2n) || (dx1n >= dx2p && dx1n >= dx2n);\n\t  };\n\t  ClipperLib.Clipper.prototype.GetBottomPt = function (pp)\n\t  {\n\t    var dups = null;\n\t    var p = pp.Next;\n\t    while (p != pp)\n\t    {\n\t      if (p.Pt.Y > pp.Pt.Y)\n\t      {\n\t        pp = p;\n\t        dups = null;\n\t      }\n\t      else if (p.Pt.Y == pp.Pt.Y && p.Pt.X <= pp.Pt.X)\n\t      {\n\t        if (p.Pt.X < pp.Pt.X)\n\t        {\n\t          dups = null;\n\t          pp = p;\n\t        }\n\t        else\n\t        {\n\t          if (p.Next != pp && p.Prev != pp)\n\t            dups = p;\n\t        }\n\t      }\n\t      p = p.Next;\n\t    }\n\t    if (dups !== null)\n\t    {\n\t      //there appears to be at least 2 vertices at bottomPt so ...\n\t      while (dups != p)\n\t      {\n\t        if (!this.FirstIsBottomPt(p, dups))\n\t          pp = dups;\n\t        dups = dups.Next;\n\t        while (ClipperLib.IntPoint.op_Inequality(dups.Pt, pp.Pt))\n\t          dups = dups.Next;\n\t      }\n\t    }\n\t    return pp;\n\t  };\n\t  ClipperLib.Clipper.prototype.GetLowermostRec = function (outRec1, outRec2)\n\t  {\n\t    //work out which polygon fragment has the correct hole state ...\n\t    if (outRec1.BottomPt === null)\n\t      outRec1.BottomPt = this.GetBottomPt(outRec1.Pts);\n\t    if (outRec2.BottomPt === null)\n\t      outRec2.BottomPt = this.GetBottomPt(outRec2.Pts);\n\t    var bPt1 = outRec1.BottomPt;\n\t    var bPt2 = outRec2.BottomPt;\n\t    if (bPt1.Pt.Y > bPt2.Pt.Y)\n\t      return outRec1;\n\t    else if (bPt1.Pt.Y < bPt2.Pt.Y)\n\t      return outRec2;\n\t    else if (bPt1.Pt.X < bPt2.Pt.X)\n\t      return outRec1;\n\t    else if (bPt1.Pt.X > bPt2.Pt.X)\n\t      return outRec2;\n\t    else if (bPt1.Next == bPt1)\n\t      return outRec2;\n\t    else if (bPt2.Next == bPt2)\n\t      return outRec1;\n\t    else if (this.FirstIsBottomPt(bPt1, bPt2))\n\t      return outRec1;\n\t    else\n\t      return outRec2;\n\t  };\n\t  ClipperLib.Clipper.prototype.Param1RightOfParam2 = function (outRec1, outRec2)\n\t  {\n\t    do {\n\t      outRec1 = outRec1.FirstLeft;\n\t      if (outRec1 == outRec2)\n\t        return true;\n\t    }\n\t    while (outRec1 !== null)\n\t    return false;\n\t  };\n\t  ClipperLib.Clipper.prototype.GetOutRec = function (idx)\n\t  {\n\t    var outrec = this.m_PolyOuts[idx];\n\t    while (outrec != this.m_PolyOuts[outrec.Idx])\n\t      outrec = this.m_PolyOuts[outrec.Idx];\n\t    return outrec;\n\t  };\n\t  ClipperLib.Clipper.prototype.AppendPolygon = function (e1, e2)\n\t  {\n\t    //get the start and ends of both output polygons ...\n\t    var outRec1 = this.m_PolyOuts[e1.OutIdx];\n\t    var outRec2 = this.m_PolyOuts[e2.OutIdx];\n\t    var holeStateRec;\n\t    if (this.Param1RightOfParam2(outRec1, outRec2))\n\t      holeStateRec = outRec2;\n\t    else if (this.Param1RightOfParam2(outRec2, outRec1))\n\t      holeStateRec = outRec1;\n\t    else\n\t      holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\t    var p1_lft = outRec1.Pts;\n\t    var p1_rt = p1_lft.Prev;\n\t    var p2_lft = outRec2.Pts;\n\t    var p2_rt = p2_lft.Prev;\n\t    var side;\n\t    //join e2 poly onto e1 poly and delete pointers to e2 ...\n\t    if (e1.Side == ClipperLib.EdgeSide.esLeft)\n\t    {\n\t      if (e2.Side == ClipperLib.EdgeSide.esLeft)\n\t      {\n\t        //z y x a b c\n\t        this.ReversePolyPtLinks(p2_lft);\n\t        p2_lft.Next = p1_lft;\n\t        p1_lft.Prev = p2_lft;\n\t        p1_rt.Next = p2_rt;\n\t        p2_rt.Prev = p1_rt;\n\t        outRec1.Pts = p2_rt;\n\t      }\n\t      else\n\t      {\n\t        //x y z a b c\n\t        p2_rt.Next = p1_lft;\n\t        p1_lft.Prev = p2_rt;\n\t        p2_lft.Prev = p1_rt;\n\t        p1_rt.Next = p2_lft;\n\t        outRec1.Pts = p2_lft;\n\t      }\n\t      side = ClipperLib.EdgeSide.esLeft;\n\t    }\n\t    else\n\t    {\n\t      if (e2.Side == ClipperLib.EdgeSide.esRight)\n\t      {\n\t        //a b c z y x\n\t        this.ReversePolyPtLinks(p2_lft);\n\t        p1_rt.Next = p2_rt;\n\t        p2_rt.Prev = p1_rt;\n\t        p2_lft.Next = p1_lft;\n\t        p1_lft.Prev = p2_lft;\n\t      }\n\t      else\n\t      {\n\t        //a b c x y z\n\t        p1_rt.Next = p2_lft;\n\t        p2_lft.Prev = p1_rt;\n\t        p1_lft.Prev = p2_rt;\n\t        p2_rt.Next = p1_lft;\n\t      }\n\t      side = ClipperLib.EdgeSide.esRight;\n\t    }\n\t    outRec1.BottomPt = null;\n\t    if (holeStateRec == outRec2)\n\t    {\n\t      if (outRec2.FirstLeft != outRec1)\n\t        outRec1.FirstLeft = outRec2.FirstLeft;\n\t      outRec1.IsHole = outRec2.IsHole;\n\t    }\n\t    outRec2.Pts = null;\n\t    outRec2.BottomPt = null;\n\t    outRec2.FirstLeft = outRec1;\n\t    var OKIdx = e1.OutIdx;\n\t    var ObsoleteIdx = e2.OutIdx;\n\t    e1.OutIdx = -1;\n\t    //nb: safe because we only get here via AddLocalMaxPoly\n\t    e2.OutIdx = -1;\n\t    var e = this.m_ActiveEdges;\n\t    while (e !== null)\n\t    {\n\t      if (e.OutIdx == ObsoleteIdx)\n\t      {\n\t        e.OutIdx = OKIdx;\n\t        e.Side = side;\n\t        break;\n\t      }\n\t      e = e.NextInAEL;\n\t    }\n\t    outRec2.Idx = outRec1.Idx;\n\t  };\n\t  ClipperLib.Clipper.prototype.ReversePolyPtLinks = function (pp)\n\t  {\n\t    if (pp === null)\n\t      return;\n\t    var pp1;\n\t    var pp2;\n\t    pp1 = pp;\n\t    do {\n\t      pp2 = pp1.Next;\n\t      pp1.Next = pp1.Prev;\n\t      pp1.Prev = pp2;\n\t      pp1 = pp2;\n\t    }\n\t    while (pp1 != pp)\n\t  };\n\t  ClipperLib.Clipper.SwapSides = function (edge1, edge2)\n\t  {\n\t    var side = edge1.Side;\n\t    edge1.Side = edge2.Side;\n\t    edge2.Side = side;\n\t  };\n\t  ClipperLib.Clipper.SwapPolyIndexes = function (edge1, edge2)\n\t  {\n\t    var outIdx = edge1.OutIdx;\n\t    edge1.OutIdx = edge2.OutIdx;\n\t    edge2.OutIdx = outIdx;\n\t  };\n\t  ClipperLib.Clipper.prototype.IntersectEdges = function (e1, e2, pt)\n\t  {\n\t    //e1 will be to the left of e2 BELOW the intersection. Therefore e1 is before\n\t    //e2 in AEL except when e1 is being inserted at the intersection point ...\n\t    var e1Contributing = (e1.OutIdx >= 0);\n\t    var e2Contributing = (e2.OutIdx >= 0);\n\t\n\t    if (use_xyz)\n\t    \tthis.SetZ(pt, e1, e2);\n\t\n\t    if (use_lines)\n\t    {\n\t      //if either edge is on an OPEN path ...\n\t      if (e1.WindDelta === 0 || e2.WindDelta === 0)\n\t      {\n\t        //ignore subject-subject open path intersections UNLESS they\n\t        //are both open paths, AND they are both 'contributing maximas' ...\n\t\t\t\t\tif (e1.WindDelta == 0 && e2.WindDelta == 0) return;\n\t        //if intersecting a subj line with a subj poly ...\n\t        else if (e1.PolyTyp == e2.PolyTyp &&\n\t          e1.WindDelta != e2.WindDelta && this.m_ClipType == ClipperLib.ClipType.ctUnion)\n\t        {\n\t          if (e1.WindDelta === 0)\n\t          {\n\t            if (e2Contributing)\n\t            {\n\t              this.AddOutPt(e1, pt);\n\t              if (e1Contributing)\n\t                e1.OutIdx = -1;\n\t            }\n\t          }\n\t          else\n\t          {\n\t            if (e1Contributing)\n\t            {\n\t              this.AddOutPt(e2, pt);\n\t              if (e2Contributing)\n\t                e2.OutIdx = -1;\n\t            }\n\t          }\n\t        }\n\t        else if (e1.PolyTyp != e2.PolyTyp)\n\t        {\n\t          if ((e1.WindDelta === 0) && Math.abs(e2.WindCnt) == 1 &&\n\t            (this.m_ClipType != ClipperLib.ClipType.ctUnion || e2.WindCnt2 === 0))\n\t          {\n\t            this.AddOutPt(e1, pt);\n\t            if (e1Contributing)\n\t              e1.OutIdx = -1;\n\t          }\n\t          else if ((e2.WindDelta === 0) && (Math.abs(e1.WindCnt) == 1) &&\n\t            (this.m_ClipType != ClipperLib.ClipType.ctUnion || e1.WindCnt2 === 0))\n\t          {\n\t            this.AddOutPt(e2, pt);\n\t            if (e2Contributing)\n\t              e2.OutIdx = -1;\n\t          }\n\t        }\n\t        return;\n\t      }\n\t    }\n\t    //update winding counts...\n\t    //assumes that e1 will be to the Right of e2 ABOVE the intersection\n\t    if (e1.PolyTyp == e2.PolyTyp)\n\t    {\n\t      if (this.IsEvenOddFillType(e1))\n\t      {\n\t        var oldE1WindCnt = e1.WindCnt;\n\t        e1.WindCnt = e2.WindCnt;\n\t        e2.WindCnt = oldE1WindCnt;\n\t      }\n\t      else\n\t      {\n\t        if (e1.WindCnt + e2.WindDelta === 0)\n\t          e1.WindCnt = -e1.WindCnt;\n\t        else\n\t          e1.WindCnt += e2.WindDelta;\n\t        if (e2.WindCnt - e1.WindDelta === 0)\n\t          e2.WindCnt = -e2.WindCnt;\n\t        else\n\t          e2.WindCnt -= e1.WindDelta;\n\t      }\n\t    }\n\t    else\n\t    {\n\t      if (!this.IsEvenOddFillType(e2))\n\t        e1.WindCnt2 += e2.WindDelta;\n\t      else\n\t        e1.WindCnt2 = (e1.WindCnt2 === 0) ? 1 : 0;\n\t      if (!this.IsEvenOddFillType(e1))\n\t        e2.WindCnt2 -= e1.WindDelta;\n\t      else\n\t        e2.WindCnt2 = (e2.WindCnt2 === 0) ? 1 : 0;\n\t    }\n\t    var e1FillType, e2FillType, e1FillType2, e2FillType2;\n\t    if (e1.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t    {\n\t      e1FillType = this.m_SubjFillType;\n\t      e1FillType2 = this.m_ClipFillType;\n\t    }\n\t    else\n\t    {\n\t      e1FillType = this.m_ClipFillType;\n\t      e1FillType2 = this.m_SubjFillType;\n\t    }\n\t    if (e2.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t    {\n\t      e2FillType = this.m_SubjFillType;\n\t      e2FillType2 = this.m_ClipFillType;\n\t    }\n\t    else\n\t    {\n\t      e2FillType = this.m_ClipFillType;\n\t      e2FillType2 = this.m_SubjFillType;\n\t    }\n\t    var e1Wc, e2Wc;\n\t    switch (e1FillType)\n\t    {\n\t    case ClipperLib.PolyFillType.pftPositive:\n\t      e1Wc = e1.WindCnt;\n\t      break;\n\t    case ClipperLib.PolyFillType.pftNegative:\n\t      e1Wc = -e1.WindCnt;\n\t      break;\n\t    default:\n\t      e1Wc = Math.abs(e1.WindCnt);\n\t      break;\n\t    }\n\t    switch (e2FillType)\n\t    {\n\t    case ClipperLib.PolyFillType.pftPositive:\n\t      e2Wc = e2.WindCnt;\n\t      break;\n\t    case ClipperLib.PolyFillType.pftNegative:\n\t      e2Wc = -e2.WindCnt;\n\t      break;\n\t    default:\n\t      e2Wc = Math.abs(e2.WindCnt);\n\t      break;\n\t    }\n\t    if (e1Contributing && e2Contributing)\n\t    {\n\t\t\t\tif ((e1Wc != 0 && e1Wc != 1) || (e2Wc != 0 && e2Wc != 1) ||\n\t\t\t\t(e1.PolyTyp != e2.PolyTyp && this.m_ClipType != ClipperLib.ClipType.ctXor))\n\t\t\t\t{\n\t\t\t\t\tthis.AddLocalMaxPoly(e1, e2, pt);\n\t\t\t\t}\n\t      else\n\t      {\n\t        this.AddOutPt(e1, pt);\n\t        this.AddOutPt(e2, pt);\n\t        ClipperLib.Clipper.SwapSides(e1, e2);\n\t        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n\t      }\n\t    }\n\t    else if (e1Contributing)\n\t    {\n\t      if (e2Wc === 0 || e2Wc == 1)\n\t      {\n\t        this.AddOutPt(e1, pt);\n\t        ClipperLib.Clipper.SwapSides(e1, e2);\n\t        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n\t      }\n\t    }\n\t    else if (e2Contributing)\n\t    {\n\t      if (e1Wc === 0 || e1Wc == 1)\n\t      {\n\t        this.AddOutPt(e2, pt);\n\t        ClipperLib.Clipper.SwapSides(e1, e2);\n\t        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n\t      }\n\t    }\n\t\t\telse if ( (e1Wc == 0 || e1Wc == 1) && (e2Wc == 0 || e2Wc == 1))\n\t    {\n\t      //neither edge is currently contributing ...\n\t      var e1Wc2, e2Wc2;\n\t      switch (e1FillType2)\n\t      {\n\t      case ClipperLib.PolyFillType.pftPositive:\n\t        e1Wc2 = e1.WindCnt2;\n\t        break;\n\t      case ClipperLib.PolyFillType.pftNegative:\n\t        e1Wc2 = -e1.WindCnt2;\n\t        break;\n\t      default:\n\t        e1Wc2 = Math.abs(e1.WindCnt2);\n\t        break;\n\t      }\n\t      switch (e2FillType2)\n\t      {\n\t      case ClipperLib.PolyFillType.pftPositive:\n\t        e2Wc2 = e2.WindCnt2;\n\t        break;\n\t      case ClipperLib.PolyFillType.pftNegative:\n\t        e2Wc2 = -e2.WindCnt2;\n\t        break;\n\t      default:\n\t        e2Wc2 = Math.abs(e2.WindCnt2);\n\t        break;\n\t      }\n\t      if (e1.PolyTyp != e2.PolyTyp)\n\t      {\n\t        this.AddLocalMinPoly(e1, e2, pt);\n\t      }\n\t      else if (e1Wc == 1 && e2Wc == 1)\n\t        switch (this.m_ClipType)\n\t        {\n\t        case ClipperLib.ClipType.ctIntersection:\n\t          if (e1Wc2 > 0 && e2Wc2 > 0)\n\t            this.AddLocalMinPoly(e1, e2, pt);\n\t          break;\n\t        case ClipperLib.ClipType.ctUnion:\n\t          if (e1Wc2 <= 0 && e2Wc2 <= 0)\n\t            this.AddLocalMinPoly(e1, e2, pt);\n\t          break;\n\t        case ClipperLib.ClipType.ctDifference:\n\t          if (((e1.PolyTyp == ClipperLib.PolyType.ptClip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||\n\t            ((e1.PolyTyp == ClipperLib.PolyType.ptSubject) && (e1Wc2 <= 0) && (e2Wc2 <= 0)))\n\t            this.AddLocalMinPoly(e1, e2, pt);\n\t          break;\n\t        case ClipperLib.ClipType.ctXor:\n\t          this.AddLocalMinPoly(e1, e2, pt);\n\t          break;\n\t        }\n\t      else\n\t        ClipperLib.Clipper.SwapSides(e1, e2);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.DeleteFromAEL = function (e)\n\t  {\n\t    var AelPrev = e.PrevInAEL;\n\t    var AelNext = e.NextInAEL;\n\t    if (AelPrev === null && AelNext === null && (e != this.m_ActiveEdges))\n\t      return;\n\t    //already deleted\n\t    if (AelPrev !== null)\n\t      AelPrev.NextInAEL = AelNext;\n\t    else\n\t      this.m_ActiveEdges = AelNext;\n\t    if (AelNext !== null)\n\t      AelNext.PrevInAEL = AelPrev;\n\t    e.NextInAEL = null;\n\t    e.PrevInAEL = null;\n\t  };\n\t  ClipperLib.Clipper.prototype.DeleteFromSEL = function (e)\n\t  {\n\t    var SelPrev = e.PrevInSEL;\n\t    var SelNext = e.NextInSEL;\n\t    if (SelPrev === null && SelNext === null && (e != this.m_SortedEdges))\n\t      return;\n\t    //already deleted\n\t    if (SelPrev !== null)\n\t      SelPrev.NextInSEL = SelNext;\n\t    else\n\t      this.m_SortedEdges = SelNext;\n\t    if (SelNext !== null)\n\t      SelNext.PrevInSEL = SelPrev;\n\t    e.NextInSEL = null;\n\t    e.PrevInSEL = null;\n\t  };\n\t  ClipperLib.Clipper.prototype.UpdateEdgeIntoAEL = function (e)\n\t  {\n\t    if (e.NextInLML === null)\n\t      ClipperLib.Error(\"UpdateEdgeIntoAEL: invalid call\");\n\t    var AelPrev = e.PrevInAEL;\n\t    var AelNext = e.NextInAEL;\n\t    e.NextInLML.OutIdx = e.OutIdx;\n\t    if (AelPrev !== null)\n\t      AelPrev.NextInAEL = e.NextInLML;\n\t    else\n\t      this.m_ActiveEdges = e.NextInLML;\n\t    if (AelNext !== null)\n\t      AelNext.PrevInAEL = e.NextInLML;\n\t    e.NextInLML.Side = e.Side;\n\t    e.NextInLML.WindDelta = e.WindDelta;\n\t    e.NextInLML.WindCnt = e.WindCnt;\n\t    e.NextInLML.WindCnt2 = e.WindCnt2;\n\t    e = e.NextInLML;\n\t    //    e.Curr = e.Bot;\n\t    e.Curr.X = e.Bot.X;\n\t    e.Curr.Y = e.Bot.Y;\n\t    e.PrevInAEL = AelPrev;\n\t    e.NextInAEL = AelNext;\n\t    if (!ClipperLib.ClipperBase.IsHorizontal(e))\n\t      this.InsertScanbeam(e.Top.Y);\n\t    return e;\n\t  };\n\t  ClipperLib.Clipper.prototype.ProcessHorizontals = function (isTopOfScanbeam)\n\t  {\n\t    var horzEdge = this.m_SortedEdges;\n\t    while (horzEdge !== null)\n\t    {\n\t      this.DeleteFromSEL(horzEdge);\n\t      this.ProcessHorizontal(horzEdge, isTopOfScanbeam);\n\t      horzEdge = this.m_SortedEdges;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.GetHorzDirection = function (HorzEdge, $var)\n\t  {\n\t    if (HorzEdge.Bot.X < HorzEdge.Top.X)\n\t    {\n\t        $var.Left = HorzEdge.Bot.X;\n\t        $var.Right = HorzEdge.Top.X;\n\t        $var.Dir = ClipperLib.Direction.dLeftToRight;\n\t    }\n\t    else\n\t    {\n\t        $var.Left = HorzEdge.Top.X;\n\t        $var.Right = HorzEdge.Bot.X;\n\t        $var.Dir = ClipperLib.Direction.dRightToLeft;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.ProcessHorizontal = function (horzEdge, isTopOfScanbeam)\n\t  {\n\t    var $var = {Dir: null, Left: null, Right: null};\n\t    this.GetHorzDirection(horzEdge, $var);\n\t    var dir = $var.Dir;\n\t    var horzLeft = $var.Left;\n\t    var horzRight = $var.Right;\n\t\n\t    var eLastHorz = horzEdge,\n\t      eMaxPair = null;\n\t    while (eLastHorz.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(eLastHorz.NextInLML))\n\t      eLastHorz = eLastHorz.NextInLML;\n\t    if (eLastHorz.NextInLML === null)\n\t      eMaxPair = this.GetMaximaPair(eLastHorz);\n\t    for (;;)\n\t    {\n\t      var IsLastHorz = (horzEdge == eLastHorz);\n\t      var e = this.GetNextInAEL(horzEdge, dir);\n\t      while (e !== null)\n\t      {\n\t        //Break if we've got to the end of an intermediate horizontal edge ...\n\t        //nb: Smaller Dx's are to the right of larger Dx's ABOVE the horizontal.\n\t        if (e.Curr.X == horzEdge.Top.X && horzEdge.NextInLML !== null && e.Dx < horzEdge.NextInLML.Dx)\n\t          break;\n\t        var eNext = this.GetNextInAEL(e, dir);\n\t        //saves eNext for later\n\t        if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X <= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X >= horzLeft))\n\t        {\n\t          //so far we're still in range of the horizontal Edge  but make sure\n\t          //we're at the last of consec. horizontals when matching with eMaxPair\n\t          if (e == eMaxPair && IsLastHorz)\n\t          {\n\t\t\t\t\t\t\tif (horzEdge.OutIdx >= 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\t\t\t\t\t\t\t\tvar eNextHorz = this.m_SortedEdges;\n\t\t\t\t\t\t\t\twhile (eNextHorz !== null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (eNextHorz.OutIdx >= 0 &&\n\t\t\t\t\t\t\t\t\t\tthis.HorzSegmentsOverlap(horzEdge.Bot.X,\n\t\t\t\t\t\t\t\t\t\thorzEdge.Top.X, eNextHorz.Bot.X, eNextHorz.Top.X))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tvar op2 = this.AddOutPt(eNextHorz, eNextHorz.Bot);\n\t\t\t\t\t\t\t\t\t\tthis.AddJoin(op2, op1, eNextHorz.Top);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\teNextHorz = eNextHorz.NextInSEL;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthis.AddGhostJoin(op1, horzEdge.Bot);\n\t\t\t\t\t\t\t\tthis.AddLocalMaxPoly(horzEdge, eMaxPair, horzEdge.Top);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.DeleteFromAEL(horzEdge);\n\t\t\t\t\t\t\tthis.DeleteFromAEL(eMaxPair);\n\t            return;\n\t          }\n\t          else if (dir == ClipperLib.Direction.dLeftToRight)\n\t          {\n\t            var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n\t            this.IntersectEdges(horzEdge, e, Pt);\n\t          }\n\t          else\n\t          {\n\t            var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n\t            this.IntersectEdges(e, horzEdge, Pt);\n\t          }\n\t          this.SwapPositionsInAEL(horzEdge, e);\n\t        }\n\t        else if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X >= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X <= horzLeft))\n\t          break;\n\t        e = eNext;\n\t      }\n\t      //end while\n\t      if (horzEdge.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(horzEdge.NextInLML))\n\t      {\n\t        horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n\t        if (horzEdge.OutIdx >= 0)\n\t          this.AddOutPt(horzEdge, horzEdge.Bot);\n\t\n\t          var $var = {Dir: dir, Left: horzLeft, Right: horzRight};\n\t          this.GetHorzDirection(horzEdge, $var);\n\t          dir = $var.Dir;\n\t          horzLeft = $var.Left;\n\t          horzRight = $var.Right;\n\t      }\n\t      else\n\t        break;\n\t    }\n\t    //end for (;;)\n\t    if (horzEdge.NextInLML !== null)\n\t    {\n\t      if (horzEdge.OutIdx >= 0)\n\t      {\n\t        var op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\t\t\t\t\tif (isTopOfScanbeam) this.AddGhostJoin(op1, horzEdge.Bot);\n\t        horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n\t        if (horzEdge.WindDelta === 0)\n\t          return;\n\t        //nb: HorzEdge is no longer horizontal here\n\t        var ePrev = horzEdge.PrevInAEL;\n\t        var eNext = horzEdge.NextInAEL;\n\t        if (ePrev !== null && ePrev.Curr.X == horzEdge.Bot.X &&\n\t          ePrev.Curr.Y == horzEdge.Bot.Y && ePrev.WindDelta !== 0 &&\n\t          (ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&\n\t            ClipperLib.ClipperBase.SlopesEqual(horzEdge, ePrev, this.m_UseFullRange)))\n\t        {\n\t          var op2 = this.AddOutPt(ePrev, horzEdge.Bot);\n\t          this.AddJoin(op1, op2, horzEdge.Top);\n\t        }\n\t        else if (eNext !== null && eNext.Curr.X == horzEdge.Bot.X &&\n\t          eNext.Curr.Y == horzEdge.Bot.Y && eNext.WindDelta !== 0 &&\n\t          eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&\n\t          ClipperLib.ClipperBase.SlopesEqual(horzEdge, eNext, this.m_UseFullRange))\n\t        {\n\t          var op2 = this.AddOutPt(eNext, horzEdge.Bot);\n\t          this.AddJoin(op1, op2, horzEdge.Top);\n\t        }\n\t      }\n\t      else horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n\t    }\n\t  \telse\n\t    {\n\t      if (horzEdge.OutIdx >= 0)\n\t        this.AddOutPt(horzEdge, horzEdge.Top);\n\t      this.DeleteFromAEL(horzEdge);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.GetNextInAEL = function (e, Direction)\n\t  {\n\t    return Direction == ClipperLib.Direction.dLeftToRight ? e.NextInAEL : e.PrevInAEL;\n\t  };\n\t  ClipperLib.Clipper.prototype.IsMinima = function (e)\n\t  {\n\t    return e !== null && (e.Prev.NextInLML != e) && (e.Next.NextInLML != e);\n\t  };\n\t  ClipperLib.Clipper.prototype.IsMaxima = function (e, Y)\n\t  {\n\t    return (e !== null && e.Top.Y == Y && e.NextInLML === null);\n\t  };\n\t  ClipperLib.Clipper.prototype.IsIntermediate = function (e, Y)\n\t  {\n\t    return (e.Top.Y == Y && e.NextInLML !== null);\n\t  };\n\t  ClipperLib.Clipper.prototype.GetMaximaPair = function (e)\n\t  {\n\t    var result = null;\n\t    if ((ClipperLib.IntPoint.op_Equality(e.Next.Top, e.Top)) && e.Next.NextInLML === null)\n\t      result = e.Next;\n\t    else if ((ClipperLib.IntPoint.op_Equality(e.Prev.Top, e.Top)) && e.Prev.NextInLML === null)\n\t      result = e.Prev;\n\t    if (result !== null && (result.OutIdx == -2 || (result.NextInAEL == result.PrevInAEL && !ClipperLib.ClipperBase.IsHorizontal(result))))\n\t      return null;\n\t    return result;\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.ProcessIntersections = function (topY)\n\t  {\n\t    if (this.m_ActiveEdges == null)\n\t      return true;\n\t    try\n\t    {\n\t      this.BuildIntersectList(topY);\n\t      if (this.m_IntersectList.length == 0)\n\t        return true;\n\t      if (this.m_IntersectList.length == 1 || this.FixupIntersectionOrder())\n\t        this.ProcessIntersectList();\n\t      else\n\t        return false;\n\t    }\n\t    catch ($$e2)\n\t    {\n\t      this.m_SortedEdges = null;\n\t      this.m_IntersectList.length = 0;\n\t      ClipperLib.Error(\"ProcessIntersections error\");\n\t    }\n\t    this.m_SortedEdges = null;\n\t    return true;\n\t  };\n\t  ClipperLib.Clipper.prototype.BuildIntersectList = function (topY)\n\t  {\n\t    if (this.m_ActiveEdges === null)\n\t      return;\n\t    //prepare for sorting ...\n\t    var e = this.m_ActiveEdges;\n\t    //console.log(JSON.stringify(JSON.decycle( e )));\n\t    this.m_SortedEdges = e;\n\t    while (e !== null)\n\t    {\n\t      e.PrevInSEL = e.PrevInAEL;\n\t      e.NextInSEL = e.NextInAEL;\n\t      e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n\t      e = e.NextInAEL;\n\t    }\n\t    //bubblesort ...\n\t    var isModified = true;\n\t    while (isModified && this.m_SortedEdges !== null)\n\t    {\n\t      isModified = false;\n\t      e = this.m_SortedEdges;\n\t      while (e.NextInSEL !== null)\n\t      {\n\t        var eNext = e.NextInSEL;\n\t        var pt = new ClipperLib.IntPoint();\n\t        //console.log(\"e.Curr.X: \" + e.Curr.X + \" eNext.Curr.X\" + eNext.Curr.X);\n\t        if (e.Curr.X > eNext.Curr.X)\n\t        {\n\t\t\t\t\t\tthis.IntersectPoint(e, eNext, pt);\n\t          var newNode = new ClipperLib.IntersectNode();\n\t          newNode.Edge1 = e;\n\t          newNode.Edge2 = eNext;\n\t          //newNode.Pt = pt;\n\t          newNode.Pt.X = pt.X;\n\t          newNode.Pt.Y = pt.Y;\n\t          this.m_IntersectList.push(newNode);\n\t          this.SwapPositionsInSEL(e, eNext);\n\t          isModified = true;\n\t        }\n\t        else\n\t          e = eNext;\n\t      }\n\t      if (e.PrevInSEL !== null)\n\t        e.PrevInSEL.NextInSEL = null;\n\t      else\n\t        break;\n\t    }\n\t    this.m_SortedEdges = null;\n\t  };\n\t  ClipperLib.Clipper.prototype.EdgesAdjacent = function (inode)\n\t  {\n\t    return (inode.Edge1.NextInSEL == inode.Edge2) || (inode.Edge1.PrevInSEL == inode.Edge2);\n\t  };\n\t  ClipperLib.Clipper.IntersectNodeSort = function (node1, node2)\n\t  {\n\t    //the following typecast is safe because the differences in Pt.Y will\n\t    //be limited to the height of the scanbeam.\n\t    return (node2.Pt.Y - node1.Pt.Y);\n\t  };\n\t  ClipperLib.Clipper.prototype.FixupIntersectionOrder = function ()\n\t  {\n\t    //pre-condition: intersections are sorted bottom-most first.\n\t    //Now it's crucial that intersections are made only between adjacent edges,\n\t    //so to ensure this the order of intersections may need adjusting ...\n\t    this.m_IntersectList.sort(this.m_IntersectNodeComparer);\n\t    this.CopyAELToSEL();\n\t    var cnt = this.m_IntersectList.length;\n\t    for (var i = 0; i < cnt; i++)\n\t    {\n\t      if (!this.EdgesAdjacent(this.m_IntersectList[i]))\n\t      {\n\t        var j = i + 1;\n\t        while (j < cnt && !this.EdgesAdjacent(this.m_IntersectList[j]))\n\t          j++;\n\t        if (j == cnt)\n\t          return false;\n\t        var tmp = this.m_IntersectList[i];\n\t        this.m_IntersectList[i] = this.m_IntersectList[j];\n\t        this.m_IntersectList[j] = tmp;\n\t      }\n\t      this.SwapPositionsInSEL(this.m_IntersectList[i].Edge1, this.m_IntersectList[i].Edge2);\n\t    }\n\t    return true;\n\t  };\n\t  ClipperLib.Clipper.prototype.ProcessIntersectList = function ()\n\t  {\n\t    for (var i = 0, ilen = this.m_IntersectList.length; i < ilen; i++)\n\t    {\n\t      var iNode = this.m_IntersectList[i];\n\t      this.IntersectEdges(iNode.Edge1, iNode.Edge2, iNode.Pt);\n\t      this.SwapPositionsInAEL(iNode.Edge1, iNode.Edge2);\n\t    }\n\t    this.m_IntersectList.length = 0;\n\t  };\n\t  /*\n\t  --------------------------------\n\t  Round speedtest: http://jsperf.com/fastest-round\n\t  --------------------------------\n\t  */\n\t  var R1 = function (a)\n\t  {\n\t    return a < 0 ? Math.ceil(a - 0.5) : Math.round(a)\n\t  };\n\t  var R2 = function (a)\n\t  {\n\t    return a < 0 ? Math.ceil(a - 0.5) : Math.floor(a + 0.5)\n\t  };\n\t  var R3 = function (a)\n\t  {\n\t    return a < 0 ? -Math.round(Math.abs(a)) : Math.round(a)\n\t  };\n\t  var R4 = function (a)\n\t  {\n\t    if (a < 0)\n\t    {\n\t      a -= 0.5;\n\t      return a < -2147483648 ? Math.ceil(a) : a | 0;\n\t    }\n\t    else\n\t    {\n\t      a += 0.5;\n\t      return a > 2147483647 ? Math.floor(a) : a | 0;\n\t    }\n\t  };\n\t  if (browser.msie) ClipperLib.Clipper.Round = R1;\n\t  else if (browser.chromium) ClipperLib.Clipper.Round = R3;\n\t  else if (browser.safari) ClipperLib.Clipper.Round = R4;\n\t  else ClipperLib.Clipper.Round = R2; // eg. browser.chrome || browser.firefox || browser.opera\n\t  ClipperLib.Clipper.TopX = function (edge, currentY)\n\t  {\n\t    //if (edge.Bot == edge.Curr) alert (\"edge.Bot = edge.Curr\");\n\t    //if (edge.Bot == edge.Top) alert (\"edge.Bot = edge.Top\");\n\t    if (currentY == edge.Top.Y)\n\t      return edge.Top.X;\n\t    return edge.Bot.X + ClipperLib.Clipper.Round(edge.Dx * (currentY - edge.Bot.Y));\n\t  };\n\t  ClipperLib.Clipper.prototype.IntersectPoint = function (edge1, edge2, ip)\n\t  {\n\t    ip.X = 0;\n\t    ip.Y = 0;\n\t    var b1, b2;\n\t    //nb: with very large coordinate values, it's possible for SlopesEqual() to\n\t    //return false but for the edge.Dx value be equal due to double precision rounding.\n\t    if (edge1.Dx == edge2.Dx)\n\t\t\t{\n\t\t\t\tip.Y = edge1.Curr.Y;\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t\t\treturn;\n\t    }\n\t    if (edge1.Delta.X === 0)\n\t    {\n\t      ip.X = edge1.Bot.X;\n\t      if (ClipperLib.ClipperBase.IsHorizontal(edge2))\n\t      {\n\t        ip.Y = edge2.Bot.Y;\n\t      }\n\t      else\n\t      {\n\t        b2 = edge2.Bot.Y - (edge2.Bot.X / edge2.Dx);\n\t        ip.Y = ClipperLib.Clipper.Round(ip.X / edge2.Dx + b2);\n\t      }\n\t    }\n\t    else if (edge2.Delta.X === 0)\n\t    {\n\t      ip.X = edge2.Bot.X;\n\t      if (ClipperLib.ClipperBase.IsHorizontal(edge1))\n\t      {\n\t        ip.Y = edge1.Bot.Y;\n\t      }\n\t      else\n\t      {\n\t        b1 = edge1.Bot.Y - (edge1.Bot.X / edge1.Dx);\n\t        ip.Y = ClipperLib.Clipper.Round(ip.X / edge1.Dx + b1);\n\t      }\n\t    }\n\t    else\n\t    {\n\t      b1 = edge1.Bot.X - edge1.Bot.Y * edge1.Dx;\n\t      b2 = edge2.Bot.X - edge2.Bot.Y * edge2.Dx;\n\t      var q = (b2 - b1) / (edge1.Dx - edge2.Dx);\n\t      ip.Y = ClipperLib.Clipper.Round(q);\n\t      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n\t        ip.X = ClipperLib.Clipper.Round(edge1.Dx * q + b1);\n\t      else\n\t        ip.X = ClipperLib.Clipper.Round(edge2.Dx * q + b2);\n\t    }\n\t    if (ip.Y < edge1.Top.Y || ip.Y < edge2.Top.Y)\n\t    {\n\t      if (edge1.Top.Y > edge2.Top.Y)\n\t      {\n\t        ip.Y = edge1.Top.Y;\n\t        ip.X = ClipperLib.Clipper.TopX(edge2, edge1.Top.Y);\n\t        return ip.X < edge1.Top.X;\n\t      }\n\t      else\n\t        ip.Y = edge2.Top.Y;\n\t      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n\t        ip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t      else\n\t        ip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n\t    }\n\t\t\t//finally, don't allow 'ip' to be BELOW curr.Y (ie bottom of scanbeam) ...\n\t\t\tif (ip.Y > edge1.Curr.Y)\n\t\t\t{\n\t\t\t\tip.Y = edge1.Curr.Y;\n\t\t\t\t//better to use the more vertical edge to derive X ...\n\t\t\t\tif (Math.abs(edge1.Dx) > Math.abs(edge2.Dx))\n\t\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n\t\t\t\telse\n\t\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t\t}\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function (topY)\n\t  {\n\t    var e = this.m_ActiveEdges;\n\t    while (e !== null)\n\t    {\n\t      //1. process maxima, treating them as if they're 'bent' horizontal edges,\n\t      //   but exclude maxima with horizontal edges. nb: e can't be a horizontal.\n\t      var IsMaximaEdge = this.IsMaxima(e, topY);\n\t      if (IsMaximaEdge)\n\t      {\n\t        var eMaxPair = this.GetMaximaPair(e);\n\t        IsMaximaEdge = (eMaxPair === null || !ClipperLib.ClipperBase.IsHorizontal(eMaxPair));\n\t      }\n\t      if (IsMaximaEdge)\n\t      {\n\t        var ePrev = e.PrevInAEL;\n\t        this.DoMaxima(e);\n\t        if (ePrev === null)\n\t          e = this.m_ActiveEdges;\n\t        else\n\t          e = ePrev.NextInAEL;\n\t      }\n\t      else\n\t      {\n\t        //2. promote horizontal edges, otherwise update Curr.X and Curr.Y ...\n\t        if (this.IsIntermediate(e, topY) && ClipperLib.ClipperBase.IsHorizontal(e.NextInLML))\n\t        {\n\t          e = this.UpdateEdgeIntoAEL(e);\n\t          if (e.OutIdx >= 0)\n\t            this.AddOutPt(e, e.Bot);\n\t          this.AddEdgeToSEL(e);\n\t        }\n\t        else\n\t        {\n\t          e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n\t          e.Curr.Y = topY;\n\t        }\n\t        if (this.StrictlySimple)\n\t        {\n\t          var ePrev = e.PrevInAEL;\n\t          if ((e.OutIdx >= 0) && (e.WindDelta !== 0) && ePrev !== null &&\n\t            (ePrev.OutIdx >= 0) && (ePrev.Curr.X == e.Curr.X) &&\n\t            (ePrev.WindDelta !== 0))\n\t          {\n\t           \tvar ip = new ClipperLib.IntPoint(e.Curr);\n\t\n\t\t\t\t\t\t\tif(use_xyz)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tthis.SetZ(ip, ePrev, e);\n\t\t\t\t\t\t\t}\n\t\n\t            var op = this.AddOutPt(ePrev, ip);\n\t            var op2 = this.AddOutPt(e, ip);\n\t            this.AddJoin(op, op2, ip);\n\t            //StrictlySimple (type-3) join\n\t          }\n\t        }\n\t        e = e.NextInAEL;\n\t      }\n\t    }\n\t    //3. Process horizontals at the Top of the scanbeam ...\n\t    this.ProcessHorizontals(true);\n\t    //4. Promote intermediate vertices ...\n\t    e = this.m_ActiveEdges;\n\t    while (e !== null)\n\t    {\n\t      if (this.IsIntermediate(e, topY))\n\t      {\n\t        var op = null;\n\t        if (e.OutIdx >= 0)\n\t          op = this.AddOutPt(e, e.Top);\n\t        e = this.UpdateEdgeIntoAEL(e);\n\t        //if output polygons share an edge, they'll need joining later ...\n\t        var ePrev = e.PrevInAEL;\n\t        var eNext = e.NextInAEL;\n\t        if (ePrev !== null && ePrev.Curr.X == e.Bot.X &&\n\t          ePrev.Curr.Y == e.Bot.Y && op !== null &&\n\t          ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&\n\t          ClipperLib.ClipperBase.SlopesEqual(e, ePrev, this.m_UseFullRange) &&\n\t          (e.WindDelta !== 0) && (ePrev.WindDelta !== 0))\n\t        {\n\t          var op2 = this.AddOutPt(ePrev, e.Bot);\n\t          this.AddJoin(op, op2, e.Top);\n\t        }\n\t        else if (eNext !== null && eNext.Curr.X == e.Bot.X &&\n\t          eNext.Curr.Y == e.Bot.Y && op !== null &&\n\t          eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&\n\t          ClipperLib.ClipperBase.SlopesEqual(e, eNext, this.m_UseFullRange) &&\n\t          (e.WindDelta !== 0) && (eNext.WindDelta !== 0))\n\t        {\n\t          var op2 = this.AddOutPt(eNext, e.Bot);\n\t          this.AddJoin(op, op2, e.Top);\n\t        }\n\t      }\n\t      e = e.NextInAEL;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.DoMaxima = function (e)\n\t  {\n\t    var eMaxPair = this.GetMaximaPair(e);\n\t    if (eMaxPair === null)\n\t    {\n\t      if (e.OutIdx >= 0)\n\t        this.AddOutPt(e, e.Top);\n\t      this.DeleteFromAEL(e);\n\t      return;\n\t    }\n\t    var eNext = e.NextInAEL;\n\t    var use_lines = true;\n\t    while (eNext !== null && eNext != eMaxPair)\n\t    {\n\t      this.IntersectEdges(e, eNext, e.Top);\n\t      this.SwapPositionsInAEL(e, eNext);\n\t      eNext = e.NextInAEL;\n\t    }\n\t    if (e.OutIdx == -1 && eMaxPair.OutIdx == -1)\n\t    {\n\t      this.DeleteFromAEL(e);\n\t      this.DeleteFromAEL(eMaxPair);\n\t    }\n\t    else if (e.OutIdx >= 0 && eMaxPair.OutIdx >= 0)\n\t    {\n\t    \tif (e.OutIdx >= 0) this.AddLocalMaxPoly(e, eMaxPair, e.Top);\n\t      this.DeleteFromAEL(e);\n\t      this.DeleteFromAEL(eMaxPair);\n\t    }\n\t    else if (use_lines && e.WindDelta === 0)\n\t    {\n\t      if (e.OutIdx >= 0)\n\t      {\n\t        this.AddOutPt(e, e.Top);\n\t        e.OutIdx = -1;\n\t      }\n\t      this.DeleteFromAEL(e);\n\t      if (eMaxPair.OutIdx >= 0)\n\t      {\n\t        this.AddOutPt(eMaxPair, e.Top);\n\t        eMaxPair.OutIdx = -1;\n\t      }\n\t      this.DeleteFromAEL(eMaxPair);\n\t    }\n\t    else\n\t      ClipperLib.Error(\"DoMaxima error\");\n\t  };\n\t  ClipperLib.Clipper.ReversePaths = function (polys)\n\t  {\n\t    for (var i = 0, len = polys.length; i < len; i++)\n\t      polys[i].reverse();\n\t  };\n\t  ClipperLib.Clipper.Orientation = function (poly)\n\t  {\n\t    return ClipperLib.Clipper.Area(poly) >= 0;\n\t  };\n\t  ClipperLib.Clipper.prototype.PointCount = function (pts)\n\t  {\n\t    if (pts === null)\n\t      return 0;\n\t    var result = 0;\n\t    var p = pts;\n\t    do {\n\t      result++;\n\t      p = p.Next;\n\t    }\n\t    while (p != pts)\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.prototype.BuildResult = function (polyg)\n\t  {\n\t    ClipperLib.Clear(polyg);\n\t    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t    {\n\t      var outRec = this.m_PolyOuts[i];\n\t      if (outRec.Pts === null)\n\t        continue;\n\t      var p = outRec.Pts.Prev;\n\t      var cnt = this.PointCount(p);\n\t      if (cnt < 2)\n\t        continue;\n\t      var pg = new Array(cnt);\n\t      for (var j = 0; j < cnt; j++)\n\t      {\n\t        pg[j] = p.Pt;\n\t        p = p.Prev;\n\t      }\n\t      polyg.push(pg);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.BuildResult2 = function (polytree)\n\t  {\n\t    polytree.Clear();\n\t    //add each output polygon/contour to polytree ...\n\t    //polytree.m_AllPolys.set_Capacity(this.m_PolyOuts.length);\n\t    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t    {\n\t      var outRec = this.m_PolyOuts[i];\n\t      var cnt = this.PointCount(outRec.Pts);\n\t      if ((outRec.IsOpen && cnt < 2) || (!outRec.IsOpen && cnt < 3))\n\t        continue;\n\t      this.FixHoleLinkage(outRec);\n\t      var pn = new ClipperLib.PolyNode();\n\t      polytree.m_AllPolys.push(pn);\n\t      outRec.PolyNode = pn;\n\t      pn.m_polygon.length = cnt;\n\t      var op = outRec.Pts.Prev;\n\t      for (var j = 0; j < cnt; j++)\n\t      {\n\t        pn.m_polygon[j] = op.Pt;\n\t        op = op.Prev;\n\t      }\n\t    }\n\t    //fixup PolyNode links etc ...\n\t    //polytree.m_Childs.set_Capacity(this.m_PolyOuts.length);\n\t    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t    {\n\t      var outRec = this.m_PolyOuts[i];\n\t      if (outRec.PolyNode === null)\n\t        continue;\n\t      else if (outRec.IsOpen)\n\t      {\n\t        outRec.PolyNode.IsOpen = true;\n\t        polytree.AddChild(outRec.PolyNode);\n\t      }\n\t      else if (outRec.FirstLeft !== null && outRec.FirstLeft.PolyNode != null)\n\t        outRec.FirstLeft.PolyNode.AddChild(outRec.PolyNode);\n\t      else\n\t        polytree.AddChild(outRec.PolyNode);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.FixupOutPolygon = function (outRec)\n\t  {\n\t    //FixupOutPolygon() - removes duplicate points and simplifies consecutive\n\t    //parallel edges by removing the middle vertex.\n\t    var lastOK = null;\n\t    outRec.BottomPt = null;\n\t    var pp = outRec.Pts;\n\t    for (;;)\n\t    {\n\t      if (pp.Prev == pp || pp.Prev == pp.Next)\n\t      {\n\t        outRec.Pts = null;\n\t        return;\n\t      }\n\t      //test for duplicate points and collinear edges ...\n\t      if ((ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Next.Pt)) || (ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Prev.Pt)) ||\n\t        (ClipperLib.ClipperBase.SlopesEqual(pp.Prev.Pt, pp.Pt, pp.Next.Pt, this.m_UseFullRange) &&\n\t          (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(pp.Prev.Pt, pp.Pt, pp.Next.Pt))))\n\t      {\n\t        lastOK = null;\n\t        pp.Prev.Next = pp.Next;\n\t        pp.Next.Prev = pp.Prev;\n\t        pp = pp.Prev;\n\t      }\n\t      else if (pp == lastOK)\n\t        break;\n\t      else\n\t      {\n\t        if (lastOK === null)\n\t          lastOK = pp;\n\t        pp = pp.Next;\n\t      }\n\t    }\n\t    outRec.Pts = pp;\n\t  };\n\t  ClipperLib.Clipper.prototype.DupOutPt = function (outPt, InsertAfter)\n\t  {\n\t    var result = new ClipperLib.OutPt();\n\t    //result.Pt = outPt.Pt;\n\t    result.Pt.X = outPt.Pt.X;\n\t    result.Pt.Y = outPt.Pt.Y;\n\t    result.Idx = outPt.Idx;\n\t    if (InsertAfter)\n\t    {\n\t      result.Next = outPt.Next;\n\t      result.Prev = outPt;\n\t      outPt.Next.Prev = result;\n\t      outPt.Next = result;\n\t    }\n\t    else\n\t    {\n\t      result.Prev = outPt.Prev;\n\t      result.Next = outPt;\n\t      outPt.Prev.Next = result;\n\t      outPt.Prev = result;\n\t    }\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.prototype.GetOverlap = function (a1, a2, b1, b2, $val)\n\t  {\n\t    if (a1 < a2)\n\t    {\n\t      if (b1 < b2)\n\t      {\n\t        $val.Left = Math.max(a1, b1);\n\t        $val.Right = Math.min(a2, b2);\n\t      }\n\t      else\n\t      {\n\t        $val.Left = Math.max(a1, b2);\n\t        $val.Right = Math.min(a2, b1);\n\t      }\n\t    }\n\t    else\n\t    {\n\t      if (b1 < b2)\n\t      {\n\t        $val.Left = Math.max(a2, b1);\n\t        $val.Right = Math.min(a1, b2);\n\t      }\n\t      else\n\t      {\n\t        $val.Left = Math.max(a2, b2);\n\t        $val.Right = Math.min(a1, b1);\n\t      }\n\t    }\n\t    return $val.Left < $val.Right;\n\t  };\n\t  ClipperLib.Clipper.prototype.JoinHorz = function (op1, op1b, op2, op2b, Pt, DiscardLeft)\n\t  {\n\t    var Dir1 = (op1.Pt.X > op1b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n\t    var Dir2 = (op2.Pt.X > op2b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n\t    if (Dir1 == Dir2)\n\t      return false;\n\t    //When DiscardLeft, we want Op1b to be on the Left of Op1, otherwise we\n\t    //want Op1b to be on the Right. (And likewise with Op2 and Op2b.)\n\t    //So, to facilitate this while inserting Op1b and Op2b ...\n\t    //when DiscardLeft, make sure we're AT or RIGHT of Pt before adding Op1b,\n\t    //otherwise make sure we're AT or LEFT of Pt. (Likewise with Op2b.)\n\t    if (Dir1 == ClipperLib.Direction.dLeftToRight)\n\t    {\n\t      while (op1.Next.Pt.X <= Pt.X &&\n\t        op1.Next.Pt.X >= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)\n\t        op1 = op1.Next;\n\t      if (DiscardLeft && (op1.Pt.X != Pt.X))\n\t        op1 = op1.Next;\n\t      op1b = this.DupOutPt(op1, !DiscardLeft);\n\t      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n\t      {\n\t        op1 = op1b;\n\t        //op1.Pt = Pt;\n\t        op1.Pt.X = Pt.X;\n\t        op1.Pt.Y = Pt.Y;\n\t        op1b = this.DupOutPt(op1, !DiscardLeft);\n\t      }\n\t    }\n\t    else\n\t    {\n\t      while (op1.Next.Pt.X >= Pt.X &&\n\t        op1.Next.Pt.X <= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)\n\t        op1 = op1.Next;\n\t      if (!DiscardLeft && (op1.Pt.X != Pt.X))\n\t        op1 = op1.Next;\n\t      op1b = this.DupOutPt(op1, DiscardLeft);\n\t      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n\t      {\n\t        op1 = op1b;\n\t        //op1.Pt = Pt;\n\t        op1.Pt.X = Pt.X;\n\t        op1.Pt.Y = Pt.Y;\n\t        op1b = this.DupOutPt(op1, DiscardLeft);\n\t      }\n\t    }\n\t    if (Dir2 == ClipperLib.Direction.dLeftToRight)\n\t    {\n\t      while (op2.Next.Pt.X <= Pt.X &&\n\t        op2.Next.Pt.X >= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)\n\t        op2 = op2.Next;\n\t      if (DiscardLeft && (op2.Pt.X != Pt.X))\n\t        op2 = op2.Next;\n\t      op2b = this.DupOutPt(op2, !DiscardLeft);\n\t      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n\t      {\n\t        op2 = op2b;\n\t        //op2.Pt = Pt;\n\t        op2.Pt.X = Pt.X;\n\t        op2.Pt.Y = Pt.Y;\n\t        op2b = this.DupOutPt(op2, !DiscardLeft);\n\t      }\n\t    }\n\t    else\n\t    {\n\t      while (op2.Next.Pt.X >= Pt.X &&\n\t        op2.Next.Pt.X <= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)\n\t        op2 = op2.Next;\n\t      if (!DiscardLeft && (op2.Pt.X != Pt.X))\n\t        op2 = op2.Next;\n\t      op2b = this.DupOutPt(op2, DiscardLeft);\n\t      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n\t      {\n\t        op2 = op2b;\n\t        //op2.Pt = Pt;\n\t        op2.Pt.X = Pt.X;\n\t        op2.Pt.Y = Pt.Y;\n\t        op2b = this.DupOutPt(op2, DiscardLeft);\n\t      }\n\t    }\n\t    if ((Dir1 == ClipperLib.Direction.dLeftToRight) == DiscardLeft)\n\t    {\n\t      op1.Prev = op2;\n\t      op2.Next = op1;\n\t      op1b.Next = op2b;\n\t      op2b.Prev = op1b;\n\t    }\n\t    else\n\t    {\n\t      op1.Next = op2;\n\t      op2.Prev = op1;\n\t      op1b.Prev = op2b;\n\t      op2b.Next = op1b;\n\t    }\n\t    return true;\n\t  };\n\t  ClipperLib.Clipper.prototype.JoinPoints = function (j, outRec1, outRec2)\n\t  {\n\t    var op1 = j.OutPt1,\n\t      op1b = new ClipperLib.OutPt();\n\t    var op2 = j.OutPt2,\n\t      op2b = new ClipperLib.OutPt();\n\t    //There are 3 kinds of joins for output polygons ...\n\t    //1. Horizontal joins where Join.OutPt1 & Join.OutPt2 are a vertices anywhere\n\t    //along (horizontal) collinear edges (& Join.OffPt is on the same horizontal).\n\t    //2. Non-horizontal joins where Join.OutPt1 & Join.OutPt2 are at the same\n\t    //location at the Bottom of the overlapping segment (& Join.OffPt is above).\n\t    //3. StrictlySimple joins where edges touch but are not collinear and where\n\t    //Join.OutPt1, Join.OutPt2 & Join.OffPt all share the same point.\n\t    var isHorizontal = (j.OutPt1.Pt.Y == j.OffPt.Y);\n\t    if (isHorizontal && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt1.Pt)) && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt2.Pt)))\n\t    {\n\t      //Strictly Simple join ...\n\t\t\t\tif (outRec1 != outRec2) return false;\n\t\n\t      op1b = j.OutPt1.Next;\n\t      while (op1b != op1 && (ClipperLib.IntPoint.op_Equality(op1b.Pt, j.OffPt)))\n\t        op1b = op1b.Next;\n\t      var reverse1 = (op1b.Pt.Y > j.OffPt.Y);\n\t      op2b = j.OutPt2.Next;\n\t      while (op2b != op2 && (ClipperLib.IntPoint.op_Equality(op2b.Pt, j.OffPt)))\n\t        op2b = op2b.Next;\n\t      var reverse2 = (op2b.Pt.Y > j.OffPt.Y);\n\t      if (reverse1 == reverse2)\n\t        return false;\n\t      if (reverse1)\n\t      {\n\t        op1b = this.DupOutPt(op1, false);\n\t        op2b = this.DupOutPt(op2, true);\n\t        op1.Prev = op2;\n\t        op2.Next = op1;\n\t        op1b.Next = op2b;\n\t        op2b.Prev = op1b;\n\t        j.OutPt1 = op1;\n\t        j.OutPt2 = op1b;\n\t        return true;\n\t      }\n\t      else\n\t      {\n\t        op1b = this.DupOutPt(op1, true);\n\t        op2b = this.DupOutPt(op2, false);\n\t        op1.Next = op2;\n\t        op2.Prev = op1;\n\t        op1b.Prev = op2b;\n\t        op2b.Next = op1b;\n\t        j.OutPt1 = op1;\n\t        j.OutPt2 = op1b;\n\t        return true;\n\t      }\n\t    }\n\t    else if (isHorizontal)\n\t    {\n\t      //treat horizontal joins differently to non-horizontal joins since with\n\t      //them we're not yet sure where the overlapping is. OutPt1.Pt & OutPt2.Pt\n\t      //may be anywhere along the horizontal edge.\n\t      op1b = op1;\n\t      while (op1.Prev.Pt.Y == op1.Pt.Y && op1.Prev != op1b && op1.Prev != op2)\n\t        op1 = op1.Prev;\n\t      while (op1b.Next.Pt.Y == op1b.Pt.Y && op1b.Next != op1 && op1b.Next != op2)\n\t        op1b = op1b.Next;\n\t      if (op1b.Next == op1 || op1b.Next == op2)\n\t        return false;\n\t      //a flat 'polygon'\n\t      op2b = op2;\n\t      while (op2.Prev.Pt.Y == op2.Pt.Y && op2.Prev != op2b && op2.Prev != op1b)\n\t        op2 = op2.Prev;\n\t      while (op2b.Next.Pt.Y == op2b.Pt.Y && op2b.Next != op2 && op2b.Next != op1)\n\t        op2b = op2b.Next;\n\t      if (op2b.Next == op2 || op2b.Next == op1)\n\t        return false;\n\t      //a flat 'polygon'\n\t      //Op1 -. Op1b & Op2 -. Op2b are the extremites of the horizontal edges\n\t\n\t      var $val = {Left: null, Right: null};\n\t      if (!this.GetOverlap(op1.Pt.X, op1b.Pt.X, op2.Pt.X, op2b.Pt.X, $val))\n\t        return false;\n\t      var Left = $val.Left;\n\t      var Right = $val.Right;\n\t\n\t      //DiscardLeftSide: when overlapping edges are joined, a spike will created\n\t      //which needs to be cleaned up. However, we don't want Op1 or Op2 caught up\n\t      //on the discard Side as either may still be needed for other joins ...\n\t      var Pt = new ClipperLib.IntPoint();\n\t      var DiscardLeftSide;\n\t      if (op1.Pt.X >= Left && op1.Pt.X <= Right)\n\t      {\n\t        //Pt = op1.Pt;\n\t        Pt.X = op1.Pt.X;\n\t        Pt.Y = op1.Pt.Y;\n\t        DiscardLeftSide = (op1.Pt.X > op1b.Pt.X);\n\t      }\n\t      else if (op2.Pt.X >= Left && op2.Pt.X <= Right)\n\t      {\n\t        //Pt = op2.Pt;\n\t        Pt.X = op2.Pt.X;\n\t        Pt.Y = op2.Pt.Y;\n\t        DiscardLeftSide = (op2.Pt.X > op2b.Pt.X);\n\t      }\n\t      else if (op1b.Pt.X >= Left && op1b.Pt.X <= Right)\n\t      {\n\t        //Pt = op1b.Pt;\n\t        Pt.X = op1b.Pt.X;\n\t        Pt.Y = op1b.Pt.Y;\n\t        DiscardLeftSide = op1b.Pt.X > op1.Pt.X;\n\t      }\n\t      else\n\t      {\n\t        //Pt = op2b.Pt;\n\t        Pt.X = op2b.Pt.X;\n\t        Pt.Y = op2b.Pt.Y;\n\t        DiscardLeftSide = (op2b.Pt.X > op2.Pt.X);\n\t      }\n\t      j.OutPt1 = op1;\n\t      j.OutPt2 = op2;\n\t      return this.JoinHorz(op1, op1b, op2, op2b, Pt, DiscardLeftSide);\n\t    }\n\t    else\n\t    {\n\t      //nb: For non-horizontal joins ...\n\t      //    1. Jr.OutPt1.Pt.Y == Jr.OutPt2.Pt.Y\n\t      //    2. Jr.OutPt1.Pt > Jr.OffPt.Y\n\t      //make sure the polygons are correctly oriented ...\n\t      op1b = op1.Next;\n\t      while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))\n\t        op1b = op1b.Next;\n\t      var Reverse1 = ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange));\n\t      if (Reverse1)\n\t      {\n\t        op1b = op1.Prev;\n\t        while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))\n\t          op1b = op1b.Prev;\n\t        if ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange))\n\t          return false;\n\t      }\n\t      op2b = op2.Next;\n\t      while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))\n\t        op2b = op2b.Next;\n\t      var Reverse2 = ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange));\n\t      if (Reverse2)\n\t      {\n\t        op2b = op2.Prev;\n\t        while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))\n\t          op2b = op2b.Prev;\n\t        if ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange))\n\t          return false;\n\t      }\n\t      if ((op1b == op1) || (op2b == op2) || (op1b == op2b) ||\n\t        ((outRec1 == outRec2) && (Reverse1 == Reverse2)))\n\t        return false;\n\t      if (Reverse1)\n\t      {\n\t        op1b = this.DupOutPt(op1, false);\n\t        op2b = this.DupOutPt(op2, true);\n\t        op1.Prev = op2;\n\t        op2.Next = op1;\n\t        op1b.Next = op2b;\n\t        op2b.Prev = op1b;\n\t        j.OutPt1 = op1;\n\t        j.OutPt2 = op1b;\n\t        return true;\n\t      }\n\t      else\n\t      {\n\t        op1b = this.DupOutPt(op1, true);\n\t        op2b = this.DupOutPt(op2, false);\n\t        op1.Next = op2;\n\t        op2.Prev = op1;\n\t        op1b.Prev = op2b;\n\t        op2b.Next = op1b;\n\t        j.OutPt1 = op1;\n\t        j.OutPt2 = op1b;\n\t        return true;\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.Clipper.GetBounds = function (paths)\n\t  {\n\t    var i = 0,\n\t      cnt = paths.length;\n\t    while (i < cnt && paths[i].length == 0) i++;\n\t    if (i == cnt) return new ClipperLib.IntRect(0, 0, 0, 0);\n\t    var result = new ClipperLib.IntRect();\n\t    result.left = paths[i][0].X;\n\t    result.right = result.left;\n\t    result.top = paths[i][0].Y;\n\t    result.bottom = result.top;\n\t    for (; i < cnt; i++)\n\t      for (var j = 0, jlen = paths[i].length; j < jlen; j++)\n\t      {\n\t        if (paths[i][j].X < result.left) result.left = paths[i][j].X;\n\t        else if (paths[i][j].X > result.right) result.right = paths[i][j].X;\n\t        if (paths[i][j].Y < result.top) result.top = paths[i][j].Y;\n\t        else if (paths[i][j].Y > result.bottom) result.bottom = paths[i][j].Y;\n\t      }\n\t    return result;\n\t  }\n\t  ClipperLib.Clipper.prototype.GetBounds2 = function (ops)\n\t  {\n\t    var opStart = ops;\n\t    var result = new ClipperLib.IntRect();\n\t    result.left = ops.Pt.X;\n\t    result.right = ops.Pt.X;\n\t    result.top = ops.Pt.Y;\n\t    result.bottom = ops.Pt.Y;\n\t    ops = ops.Next;\n\t    while (ops != opStart)\n\t    {\n\t      if (ops.Pt.X < result.left)\n\t        result.left = ops.Pt.X;\n\t      if (ops.Pt.X > result.right)\n\t        result.right = ops.Pt.X;\n\t      if (ops.Pt.Y < result.top)\n\t        result.top = ops.Pt.Y;\n\t      if (ops.Pt.Y > result.bottom)\n\t        result.bottom = ops.Pt.Y;\n\t      ops = ops.Next;\n\t    }\n\t    return result;\n\t  };\n\t\n\t  ClipperLib.Clipper.PointInPolygon = function (pt, path)\n\t  {\n\t    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t\t\t//See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n\t    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n\t    var result = 0,\n\t      cnt = path.length;\n\t    if (cnt < 3)\n\t      return 0;\n\t    var ip = path[0];\n\t    for (var i = 1; i <= cnt; ++i)\n\t    {\n\t      var ipNext = (i == cnt ? path[0] : path[i]);\n\t      if (ipNext.Y == pt.Y)\n\t      {\n\t        if ((ipNext.X == pt.X) || (ip.Y == pt.Y && ((ipNext.X > pt.X) == (ip.X < pt.X))))\n\t          return -1;\n\t      }\n\t      if ((ip.Y < pt.Y) != (ipNext.Y < pt.Y))\n\t      {\n\t        if (ip.X >= pt.X)\n\t        {\n\t          if (ipNext.X > pt.X)\n\t            result = 1 - result;\n\t          else\n\t          {\n\t            var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n\t            if (d == 0)\n\t              return -1;\n\t            else if ((d > 0) == (ipNext.Y > ip.Y))\n\t              result = 1 - result;\n\t          }\n\t        }\n\t        else\n\t        {\n\t          if (ipNext.X > pt.X)\n\t          {\n\t            var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n\t            if (d == 0)\n\t              return -1;\n\t            else if ((d > 0) == (ipNext.Y > ip.Y))\n\t              result = 1 - result;\n\t          }\n\t        }\n\t      }\n\t      ip = ipNext;\n\t    }\n\t    return result;\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.PointInPolygon = function (pt, op)\n\t  {\n\t    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t\t\t//See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n\t    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n\t    var result = 0;\n\t    var startOp = op;\n\t\t\tvar ptx = pt.X, pty = pt.Y;\n\t    var poly0x = op.Pt.X, poly0y = op.Pt.Y;\n\t    do\n\t    {\n\t\t\t\top = op.Next;\n\t\t\t\tvar poly1x = op.Pt.X, poly1y = op.Pt.Y;\n\t      if (poly1y == pty)\n\t      {\n\t        if ((poly1x == ptx) || (poly0y == pty && ((poly1x > ptx) == (poly0x < ptx))))\n\t          return -1;\n\t      }\n\t      if ((poly0y < pty) != (poly1y < pty))\n\t      {\n\t        if (poly0x >= ptx)\n\t        {\n\t          if (poly1x > ptx)\n\t            result = 1 - result;\n\t          else\n\t          {\n\t            var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n\t            if (d == 0)\n\t              return -1;\n\t            if ((d > 0) == (poly1y > poly0y))\n\t              result = 1 - result;\n\t          }\n\t        }\n\t        else\n\t        {\n\t          if (poly1x > ptx)\n\t          {\n\t            var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n\t            if (d == 0)\n\t              return -1;\n\t            if ((d > 0) == (poly1y > poly0y))\n\t              result = 1 - result;\n\t          }\n\t        }\n\t      }\n\t      poly0x = poly1x;\n\t      poly0y = poly1y;\n\t    } while (startOp != op);\n\t\n\t    return result;\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.Poly2ContainsPoly1 = function (outPt1, outPt2)\n\t  {\n\t    var op = outPt1;\n\t    do\n\t    {\n\t\t\t\t//nb: PointInPolygon returns 0 if false, +1 if true, -1 if pt on polygon\n\t      var res = this.PointInPolygon(op.Pt, outPt2);\n\t      if (res >= 0)\n\t        return res > 0;\n\t      op = op.Next;\n\t    }\n\t    while (op != outPt1)\n\t    return true;\n\t  };\n\t  ClipperLib.Clipper.prototype.FixupFirstLefts1 = function (OldOutRec, NewOutRec)\n\t  {\n\t    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t    {\n\t\t\t\tvar outRec = this.m_PolyOuts[i];\n\t\t\t\tif (outRec.Pts == null || outRec.FirstLeft == null)\n\t\t\t\t\tcontinue;\n\t\t\t\tvar firstLeft = this.ParseFirstLeft(outRec.FirstLeft);\n\t\t\t\tif (firstLeft == OldOutRec)\n\t\t\t\t{\n\t        if (this.Poly2ContainsPoly1(outRec.Pts, NewOutRec.Pts))\n\t          outRec.FirstLeft = NewOutRec;\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.FixupFirstLefts2 = function (OldOutRec, NewOutRec)\n\t  {\n\t    for (var $i2 = 0, $t2 = this.m_PolyOuts, $l2 = $t2.length, outRec = $t2[$i2]; $i2 < $l2; $i2++, outRec = $t2[$i2])\n\t      if (outRec.FirstLeft == OldOutRec)\n\t        outRec.FirstLeft = NewOutRec;\n\t  };\n\t  ClipperLib.Clipper.ParseFirstLeft = function (FirstLeft)\n\t  {\n\t    while (FirstLeft != null && FirstLeft.Pts == null)\n\t      FirstLeft = FirstLeft.FirstLeft;\n\t    return FirstLeft;\n\t  };\n\t  ClipperLib.Clipper.prototype.JoinCommonEdges = function ()\n\t  {\n\t    for (var i = 0, ilen = this.m_Joins.length; i < ilen; i++)\n\t    {\n\t      var join = this.m_Joins[i];\n\t      var outRec1 = this.GetOutRec(join.OutPt1.Idx);\n\t      var outRec2 = this.GetOutRec(join.OutPt2.Idx);\n\t      if (outRec1.Pts == null || outRec2.Pts == null)\n\t        continue;\n\t      //get the polygon fragment with the correct hole state (FirstLeft)\n\t      //before calling JoinPoints() ...\n\t      var holeStateRec;\n\t      if (outRec1 == outRec2)\n\t        holeStateRec = outRec1;\n\t      else if (this.Param1RightOfParam2(outRec1, outRec2))\n\t        holeStateRec = outRec2;\n\t      else if (this.Param1RightOfParam2(outRec2, outRec1))\n\t        holeStateRec = outRec1;\n\t      else\n\t        holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\t\n\t      if (!this.JoinPoints(join, outRec1, outRec2)) continue;\n\t\n\t      if (outRec1 == outRec2)\n\t      {\n\t        //instead of joining two polygons, we've just created a new one by\n\t        //splitting one polygon into two.\n\t        outRec1.Pts = join.OutPt1;\n\t        outRec1.BottomPt = null;\n\t        outRec2 = this.CreateOutRec();\n\t        outRec2.Pts = join.OutPt2;\n\t        //update all OutRec2.Pts Idx's ...\n\t        this.UpdateOutPtIdxs(outRec2);\n\t        //We now need to check every OutRec.FirstLeft pointer. If it points\n\t        //to OutRec1 it may need to point to OutRec2 instead ...\n\t        if (this.m_UsingPolyTree)\n\t          for (var j = 0, jlen = this.m_PolyOuts.length; j < jlen - 1; j++)\n\t          {\n\t            var oRec = this.m_PolyOuts[j];\n\t            if (oRec.Pts == null || ClipperLib.Clipper.ParseFirstLeft(oRec.FirstLeft) != outRec1 || oRec.IsHole == outRec1.IsHole)\n\t              continue;\n\t            if (this.Poly2ContainsPoly1(oRec.Pts, join.OutPt2))\n\t              oRec.FirstLeft = outRec2;\n\t          }\n\t        if (this.Poly2ContainsPoly1(outRec2.Pts, outRec1.Pts))\n\t        {\n\t          //outRec2 is contained by outRec1 ...\n\t          outRec2.IsHole = !outRec1.IsHole;\n\t          outRec2.FirstLeft = outRec1;\n\t          //fixup FirstLeft pointers that may need reassigning to OutRec1\n\t          if (this.m_UsingPolyTree)\n\t            this.FixupFirstLefts2(outRec2, outRec1);\n\t          if ((outRec2.IsHole ^ this.ReverseSolution) == (this.Area(outRec2) > 0))\n\t            this.ReversePolyPtLinks(outRec2.Pts);\n\t        }\n\t        else if (this.Poly2ContainsPoly1(outRec1.Pts, outRec2.Pts))\n\t        {\n\t          //outRec1 is contained by outRec2 ...\n\t          outRec2.IsHole = outRec1.IsHole;\n\t          outRec1.IsHole = !outRec2.IsHole;\n\t          outRec2.FirstLeft = outRec1.FirstLeft;\n\t          outRec1.FirstLeft = outRec2;\n\t          //fixup FirstLeft pointers that may need reassigning to OutRec1\n\t          if (this.m_UsingPolyTree)\n\t            this.FixupFirstLefts2(outRec1, outRec2);\n\t          if ((outRec1.IsHole ^ this.ReverseSolution) == (this.Area(outRec1) > 0))\n\t            this.ReversePolyPtLinks(outRec1.Pts);\n\t        }\n\t        else\n\t        {\n\t          //the 2 polygons are completely separate ...\n\t          outRec2.IsHole = outRec1.IsHole;\n\t          outRec2.FirstLeft = outRec1.FirstLeft;\n\t          //fixup FirstLeft pointers that may need reassigning to OutRec2\n\t          if (this.m_UsingPolyTree)\n\t            this.FixupFirstLefts1(outRec1, outRec2);\n\t        }\n\t      }\n\t      else\n\t      {\n\t        //joined 2 polygons together ...\n\t        outRec2.Pts = null;\n\t        outRec2.BottomPt = null;\n\t        outRec2.Idx = outRec1.Idx;\n\t        outRec1.IsHole = holeStateRec.IsHole;\n\t        if (holeStateRec == outRec2)\n\t          outRec1.FirstLeft = outRec2.FirstLeft;\n\t        outRec2.FirstLeft = outRec1;\n\t        //fixup FirstLeft pointers that may need reassigning to OutRec1\n\t        if (this.m_UsingPolyTree)\n\t          this.FixupFirstLefts2(outRec2, outRec1);\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.UpdateOutPtIdxs = function (outrec)\n\t  {\n\t    var op = outrec.Pts;\n\t    do {\n\t      op.Idx = outrec.Idx;\n\t      op = op.Prev;\n\t    }\n\t    while (op != outrec.Pts)\n\t  };\n\t  ClipperLib.Clipper.prototype.DoSimplePolygons = function ()\n\t  {\n\t    var i = 0;\n\t    while (i < this.m_PolyOuts.length)\n\t    {\n\t      var outrec = this.m_PolyOuts[i++];\n\t      var op = outrec.Pts;\n\t\t\t\tif (op == null || outrec.IsOpen)\n\t\t\t\t\tcontinue;\n\t      do //for each Pt in Polygon until duplicate found do ...\n\t      {\n\t        var op2 = op.Next;\n\t        while (op2 != outrec.Pts)\n\t        {\n\t          if ((ClipperLib.IntPoint.op_Equality(op.Pt, op2.Pt)) && op2.Next != op && op2.Prev != op)\n\t          {\n\t            //split the polygon into two ...\n\t            var op3 = op.Prev;\n\t            var op4 = op2.Prev;\n\t            op.Prev = op4;\n\t            op4.Next = op;\n\t            op2.Prev = op3;\n\t            op3.Next = op2;\n\t            outrec.Pts = op;\n\t            var outrec2 = this.CreateOutRec();\n\t            outrec2.Pts = op2;\n\t            this.UpdateOutPtIdxs(outrec2);\n\t            if (this.Poly2ContainsPoly1(outrec2.Pts, outrec.Pts))\n\t            {\n\t              //OutRec2 is contained by OutRec1 ...\n\t              outrec2.IsHole = !outrec.IsHole;\n\t              outrec2.FirstLeft = outrec;\n\t\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec2, outrec);\n\t\n\t            }\n\t            else if (this.Poly2ContainsPoly1(outrec.Pts, outrec2.Pts))\n\t            {\n\t              //OutRec1 is contained by OutRec2 ...\n\t              outrec2.IsHole = outrec.IsHole;\n\t              outrec.IsHole = !outrec2.IsHole;\n\t              outrec2.FirstLeft = outrec.FirstLeft;\n\t              outrec.FirstLeft = outrec2;\n\t              if (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec, outrec2);\n\t            }\n\t            else\n\t            {\n\t              //the 2 polygons are separate ...\n\t              outrec2.IsHole = outrec.IsHole;\n\t              outrec2.FirstLeft = outrec.FirstLeft;\n\t\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts1(outrec, outrec2);\n\t            }\n\t            op2 = op;\n\t            //ie get ready for the next iteration\n\t          }\n\t          op2 = op2.Next;\n\t        }\n\t        op = op.Next;\n\t      }\n\t      while (op != outrec.Pts)\n\t    }\n\t  };\n\t  ClipperLib.Clipper.Area = function (poly)\n\t  {\n\t    var cnt = poly.length;\n\t    if (cnt < 3)\n\t      return 0;\n\t    var a = 0;\n\t    for (var i = 0, j = cnt - 1; i < cnt; ++i)\n\t    {\n\t      a += (poly[j].X + poly[i].X) * (poly[j].Y - poly[i].Y);\n\t      j = i;\n\t    }\n\t    return -a * 0.5;\n\t  };\n\t  ClipperLib.Clipper.prototype.Area = function (outRec)\n\t  {\n\t    var op = outRec.Pts;\n\t    if (op == null)\n\t      return 0;\n\t    var a = 0;\n\t    do {\n\t      a = a + (op.Prev.Pt.X + op.Pt.X) * (op.Prev.Pt.Y - op.Pt.Y);\n\t      op = op.Next;\n\t    }\n\t    while (op != outRec.Pts)\n\t    return a * 0.5;\n\t  };\n\t  ClipperLib.Clipper.SimplifyPolygon = function (poly, fillType)\n\t  {\n\t    var result = new Array();\n\t    var c = new ClipperLib.Clipper(0);\n\t    c.StrictlySimple = true;\n\t    c.AddPath(poly, ClipperLib.PolyType.ptSubject, true);\n\t    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.SimplifyPolygons = function (polys, fillType)\n\t  {\n\t    if (typeof (fillType) == \"undefined\") fillType = ClipperLib.PolyFillType.pftEvenOdd;\n\t    var result = new Array();\n\t    var c = new ClipperLib.Clipper(0);\n\t    c.StrictlySimple = true;\n\t    c.AddPaths(polys, ClipperLib.PolyType.ptSubject, true);\n\t    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.DistanceSqrd = function (pt1, pt2)\n\t  {\n\t    var dx = (pt1.X - pt2.X);\n\t    var dy = (pt1.Y - pt2.Y);\n\t    return (dx * dx + dy * dy);\n\t  };\n\t  ClipperLib.Clipper.DistanceFromLineSqrd = function (pt, ln1, ln2)\n\t  {\n\t    //The equation of a line in general form (Ax + By + C = 0)\n\t    //given 2 points (x,y) & (x,y) is ...\n\t    //(y - y)x + (x - x)y + (y - y)x - (x - x)y = 0\n\t    //A = (y - y); B = (x - x); C = (y - y)x - (x - x)y\n\t    //perpendicular distance of point (x,y) = (Ax + By + C)/Sqrt(A + B)\n\t    //see http://en.wikipedia.org/wiki/Perpendicular_distance\n\t    var A = ln1.Y - ln2.Y;\n\t    var B = ln2.X - ln1.X;\n\t    var C = A * ln1.X + B * ln1.Y;\n\t    C = A * pt.X + B * pt.Y - C;\n\t    return (C * C) / (A * A + B * B);\n\t  };\n\t\n\t\tClipperLib.Clipper.SlopesNearCollinear = function(pt1, pt2, pt3, distSqrd)\n\t\t{\n\t\t\t//this function is more accurate when the point that's GEOMETRICALLY\n\t\t\t//between the other 2 points is the one that's tested for distance.\n\t\t\t//nb: with 'spikes', either pt1 or pt3 is geometrically between the other pts\n\t\t\tif (Math.abs(pt1.X - pt2.X) > Math.abs(pt1.Y - pt2.Y))\n\t\t\t{\n\t\t\tif ((pt1.X > pt2.X) == (pt1.X < pt3.X))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n\t\t\telse if ((pt2.X > pt1.X) == (pt2.X < pt3.X))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t\t\t\t\telse\n\t\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\tif ((pt1.Y > pt2.Y) == (pt1.Y < pt3.Y))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n\t\t\telse if ((pt2.Y > pt1.Y) == (pt2.Y < pt3.Y))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t\t\t\t\telse\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n\t\t\t}\n\t\t}\n\t\n\t  ClipperLib.Clipper.PointsAreClose = function (pt1, pt2, distSqrd)\n\t  {\n\t    var dx = pt1.X - pt2.X;\n\t    var dy = pt1.Y - pt2.Y;\n\t    return ((dx * dx) + (dy * dy) <= distSqrd);\n\t  };\n\t  //------------------------------------------------------------------------------\n\t  ClipperLib.Clipper.ExcludeOp = function (op)\n\t  {\n\t    var result = op.Prev;\n\t    result.Next = op.Next;\n\t    op.Next.Prev = result;\n\t    result.Idx = 0;\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.CleanPolygon = function (path, distance)\n\t  {\n\t    if (typeof (distance) == \"undefined\") distance = 1.415;\n\t    //distance = proximity in units/pixels below which vertices will be stripped.\n\t    //Default ~= sqrt(2) so when adjacent vertices or semi-adjacent vertices have\n\t    //both x & y coords within 1 unit, then the second vertex will be stripped.\n\t    var cnt = path.length;\n\t    if (cnt == 0)\n\t      return new Array();\n\t    var outPts = new Array(cnt);\n\t    for (var i = 0; i < cnt; ++i)\n\t      outPts[i] = new ClipperLib.OutPt();\n\t    for (var i = 0; i < cnt; ++i)\n\t    {\n\t      outPts[i].Pt = path[i];\n\t      outPts[i].Next = outPts[(i + 1) % cnt];\n\t      outPts[i].Next.Prev = outPts[i];\n\t      outPts[i].Idx = 0;\n\t    }\n\t    var distSqrd = distance * distance;\n\t    var op = outPts[0];\n\t    while (op.Idx == 0 && op.Next != op.Prev)\n\t    {\n\t      if (ClipperLib.Clipper.PointsAreClose(op.Pt, op.Prev.Pt, distSqrd))\n\t      {\n\t        op = ClipperLib.Clipper.ExcludeOp(op);\n\t        cnt--;\n\t      }\n\t      else if (ClipperLib.Clipper.PointsAreClose(op.Prev.Pt, op.Next.Pt, distSqrd))\n\t      {\n\t        ClipperLib.Clipper.ExcludeOp(op.Next);\n\t        op = ClipperLib.Clipper.ExcludeOp(op);\n\t        cnt -= 2;\n\t      }\n\t      else if (ClipperLib.Clipper.SlopesNearCollinear(op.Prev.Pt, op.Pt, op.Next.Pt, distSqrd))\n\t      {\n\t        op = ClipperLib.Clipper.ExcludeOp(op);\n\t        cnt--;\n\t      }\n\t      else\n\t      {\n\t        op.Idx = 1;\n\t        op = op.Next;\n\t      }\n\t    }\n\t    if (cnt < 3)\n\t      cnt = 0;\n\t    var result = new Array(cnt);\n\t    for (var i = 0; i < cnt; ++i)\n\t    {\n\t      result[i] = new ClipperLib.IntPoint(op.Pt);\n\t      op = op.Next;\n\t    }\n\t    outPts = null;\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.CleanPolygons = function (polys, distance)\n\t  {\n\t    var result = new Array(polys.length);\n\t    for (var i = 0, ilen = polys.length; i < ilen; i++)\n\t      result[i] = ClipperLib.Clipper.CleanPolygon(polys[i], distance);\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.Minkowski = function (pattern, path, IsSum, IsClosed)\n\t  {\n\t    var delta = (IsClosed ? 1 : 0);\n\t    var polyCnt = pattern.length;\n\t    var pathCnt = path.length;\n\t    var result = new Array();\n\t    if (IsSum)\n\t      for (var i = 0; i < pathCnt; i++)\n\t      {\n\t        var p = new Array(polyCnt);\n\t        for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n\t          p[j] = new ClipperLib.IntPoint(path[i].X + ip.X, path[i].Y + ip.Y);\n\t        result.push(p);\n\t      }\n\t    else\n\t      for (var i = 0; i < pathCnt; i++)\n\t      {\n\t        var p = new Array(polyCnt);\n\t        for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n\t          p[j] = new ClipperLib.IntPoint(path[i].X - ip.X, path[i].Y - ip.Y);\n\t        result.push(p);\n\t      }\n\t    var quads = new Array();\n\t    for (var i = 0; i < pathCnt - 1 + delta; i++)\n\t      for (var j = 0; j < polyCnt; j++)\n\t      {\n\t        var quad = new Array();\n\t        quad.push(result[i % pathCnt][j % polyCnt]);\n\t        quad.push(result[(i + 1) % pathCnt][j % polyCnt]);\n\t        quad.push(result[(i + 1) % pathCnt][(j + 1) % polyCnt]);\n\t        quad.push(result[i % pathCnt][(j + 1) % polyCnt]);\n\t        if (!ClipperLib.Clipper.Orientation(quad))\n\t          quad.reverse();\n\t        quads.push(quad);\n\t      }\n\t\t\t\treturn quads;\n\t  };\n\t\n\t\tClipperLib.Clipper.MinkowskiSum = function(pattern, path_or_paths, pathIsClosed)\n\t\t{\n\t\t\tif(!(path_or_paths[0] instanceof Array))\n\t\t\t{\n\t\t\t\tvar path = path_or_paths;\n\t\t\t\tvar paths = ClipperLib.Clipper.Minkowski(pattern, path, true, pathIsClosed);\n\t\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\t\tc.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n\t\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\t\treturn paths;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t \t\t\tvar paths = path_or_paths;\n\t\t\t\tvar solution = new ClipperLib.Paths();\n\t\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\t\tfor (var i = 0; i < paths.length; ++i)\n\t\t\t\t{\n\t\t\t\t\tvar tmp = ClipperLib.Clipper.Minkowski(pattern, paths[i], true, pathIsClosed);\n\t\t\t\t\tc.AddPaths(tmp, ClipperLib.PolyType.ptSubject, true);\n\t\t\t\t\tif (pathIsClosed)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar path = ClipperLib.Clipper.TranslatePath(paths[i], pattern[0]);\n\t\t\t\t\t\tc.AddPath(path, ClipperLib.PolyType.ptClip, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, solution,\n\t\t\t\t\tClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\t\treturn solution;\n\t\t\t}\n\t\t}\n\t\t//------------------------------------------------------------------------------\n\t\n\t\tClipperLib.Clipper.TranslatePath = function (path, delta)\n\t\t{\n\t\t\tvar outPath = new ClipperLib.Path();\n\t\t\tfor (var i = 0; i < path.length; i++)\n\t\t\t\toutPath.push(new ClipperLib.IntPoint(path[i].X + delta.X, path[i].Y + delta.Y));\n\t\t\treturn outPath;\n\t\t}\n\t\t//------------------------------------------------------------------------------\n\t\n\t\tClipperLib.Clipper.MinkowskiDiff = function (poly1, poly2)\n\t\t{\n\t\t\tvar paths = ClipperLib.Clipper.Minkowski(poly1, poly2, false, true);\n\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\tc.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\treturn paths;\n\t\t}\n\t\n\t  ClipperLib.Clipper.PolyTreeToPaths = function (polytree)\n\t  {\n\t    var result = new Array();\n\t    //result.set_Capacity(polytree.get_Total());\n\t    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntAny, result);\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.AddPolyNodeToPaths = function (polynode, nt, paths)\n\t  {\n\t    var match = true;\n\t    switch (nt)\n\t    {\n\t    case ClipperLib.Clipper.NodeType.ntOpen:\n\t      return;\n\t    case ClipperLib.Clipper.NodeType.ntClosed:\n\t      match = !polynode.IsOpen;\n\t      break;\n\t    default:\n\t      break;\n\t    }\n\t    if (polynode.m_polygon.length > 0 && match)\n\t      paths.push(polynode.m_polygon);\n\t    for (var $i3 = 0, $t3 = polynode.Childs(), $l3 = $t3.length, pn = $t3[$i3]; $i3 < $l3; $i3++, pn = $t3[$i3])\n\t      ClipperLib.Clipper.AddPolyNodeToPaths(pn, nt, paths);\n\t  };\n\t  ClipperLib.Clipper.OpenPathsFromPolyTree = function (polytree)\n\t  {\n\t    var result = new ClipperLib.Paths();\n\t    //result.set_Capacity(polytree.ChildCount());\n\t    for (var i = 0, ilen = polytree.ChildCount(); i < ilen; i++)\n\t      if (polytree.Childs()[i].IsOpen)\n\t        result.push(polytree.Childs()[i].m_polygon);\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.ClosedPathsFromPolyTree = function (polytree)\n\t  {\n\t    var result = new ClipperLib.Paths();\n\t    //result.set_Capacity(polytree.Total());\n\t    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntClosed, result);\n\t    return result;\n\t  };\n\t  Inherit(ClipperLib.Clipper, ClipperLib.ClipperBase);\n\t  ClipperLib.Clipper.NodeType = {\n\t    ntAny: 0,\n\t    ntOpen: 1,\n\t    ntClosed: 2\n\t  };\n\t  ClipperLib.ClipperOffset = function (miterLimit, arcTolerance)\n\t  {\n\t    if (typeof (miterLimit) == \"undefined\") miterLimit = 2;\n\t    if (typeof (arcTolerance) == \"undefined\") arcTolerance = ClipperLib.ClipperOffset.def_arc_tolerance;\n\t    this.m_destPolys = new ClipperLib.Paths();\n\t    this.m_srcPoly = new ClipperLib.Path();\n\t    this.m_destPoly = new ClipperLib.Path();\n\t    this.m_normals = new Array();\n\t    this.m_delta = 0;\n\t    this.m_sinA = 0;\n\t    this.m_sin = 0;\n\t    this.m_cos = 0;\n\t    this.m_miterLim = 0;\n\t    this.m_StepsPerRad = 0;\n\t    this.m_lowest = new ClipperLib.IntPoint();\n\t    this.m_polyNodes = new ClipperLib.PolyNode();\n\t    this.MiterLimit = miterLimit;\n\t    this.ArcTolerance = arcTolerance;\n\t    this.m_lowest.X = -1;\n\t  };\n\t  ClipperLib.ClipperOffset.two_pi = 6.28318530717959;\n\t  ClipperLib.ClipperOffset.def_arc_tolerance = 0.25;\n\t  ClipperLib.ClipperOffset.prototype.Clear = function ()\n\t  {\n\t    ClipperLib.Clear(this.m_polyNodes.Childs());\n\t    this.m_lowest.X = -1;\n\t  };\n\t  ClipperLib.ClipperOffset.Round = ClipperLib.Clipper.Round;\n\t  ClipperLib.ClipperOffset.prototype.AddPath = function (path, joinType, endType)\n\t  {\n\t    var highI = path.length - 1;\n\t    if (highI < 0)\n\t      return;\n\t    var newNode = new ClipperLib.PolyNode();\n\t    newNode.m_jointype = joinType;\n\t    newNode.m_endtype = endType;\n\t    //strip duplicate points from path and also get index to the lowest point ...\n\t    if (endType == ClipperLib.EndType.etClosedLine || endType == ClipperLib.EndType.etClosedPolygon)\n\t      while (highI > 0 && ClipperLib.IntPoint.op_Equality(path[0], path[highI]))\n\t        highI--;\n\t    //newNode.m_polygon.set_Capacity(highI + 1);\n\t    newNode.m_polygon.push(path[0]);\n\t    var j = 0,\n\t      k = 0;\n\t    for (var i = 1; i <= highI; i++)\n\t      if (ClipperLib.IntPoint.op_Inequality(newNode.m_polygon[j], path[i]))\n\t      {\n\t        j++;\n\t        newNode.m_polygon.push(path[i]);\n\t        if (path[i].Y > newNode.m_polygon[k].Y || (path[i].Y == newNode.m_polygon[k].Y && path[i].X < newNode.m_polygon[k].X))\n\t          k = j;\n\t      }\n\t    if (endType == ClipperLib.EndType.etClosedPolygon && j < 2) return;\n\t\n\t    this.m_polyNodes.AddChild(newNode);\n\t    //if this path's lowest pt is lower than all the others then update m_lowest\n\t    if (endType != ClipperLib.EndType.etClosedPolygon)\n\t      return;\n\t    if (this.m_lowest.X < 0)\n\t      this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);\n\t    else\n\t    {\n\t      var ip = this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon[this.m_lowest.Y];\n\t      if (newNode.m_polygon[k].Y > ip.Y || (newNode.m_polygon[k].Y == ip.Y && newNode.m_polygon[k].X < ip.X))\n\t        this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);\n\t    }\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.AddPaths = function (paths, joinType, endType)\n\t  {\n\t    for (var i = 0, ilen = paths.length; i < ilen; i++)\n\t      this.AddPath(paths[i], joinType, endType);\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.FixOrientations = function ()\n\t  {\n\t    //fixup orientations of all closed paths if the orientation of the\n\t    //closed path with the lowermost vertex is wrong ...\n\t    if (this.m_lowest.X >= 0 && !ClipperLib.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon))\n\t    {\n\t      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t      {\n\t        var node = this.m_polyNodes.Childs()[i];\n\t        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon || (node.m_endtype == ClipperLib.EndType.etClosedLine && ClipperLib.Clipper.Orientation(node.m_polygon)))\n\t          node.m_polygon.reverse();\n\t      }\n\t    }\n\t    else\n\t    {\n\t      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t      {\n\t        var node = this.m_polyNodes.Childs()[i];\n\t        if (node.m_endtype == ClipperLib.EndType.etClosedLine && !ClipperLib.Clipper.Orientation(node.m_polygon))\n\t          node.m_polygon.reverse();\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.ClipperOffset.GetUnitNormal = function (pt1, pt2)\n\t  {\n\t    var dx = (pt2.X - pt1.X);\n\t    var dy = (pt2.Y - pt1.Y);\n\t    if ((dx == 0) && (dy == 0))\n\t      return new ClipperLib.DoublePoint(0, 0);\n\t    var f = 1 / Math.sqrt(dx * dx + dy * dy);\n\t    dx *= f;\n\t    dy *= f;\n\t    return new ClipperLib.DoublePoint(dy, -dx);\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.DoOffset = function (delta)\n\t  {\n\t    this.m_destPolys = new Array();\n\t    this.m_delta = delta;\n\t    //if Zero offset, just copy any CLOSED polygons to m_p and return ...\n\t    if (ClipperLib.ClipperBase.near_zero(delta))\n\t    {\n\t      //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount);\n\t      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t      {\n\t        var node = this.m_polyNodes.Childs()[i];\n\t        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n\t          this.m_destPolys.push(node.m_polygon);\n\t      }\n\t      return;\n\t    }\n\t    //see offset_triginometry3.svg in the documentation folder ...\n\t    if (this.MiterLimit > 2)\n\t      this.m_miterLim = 2 / (this.MiterLimit * this.MiterLimit);\n\t    else\n\t      this.m_miterLim = 0.5;\n\t    var y;\n\t    if (this.ArcTolerance <= 0)\n\t      y = ClipperLib.ClipperOffset.def_arc_tolerance;\n\t    else if (this.ArcTolerance > Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance)\n\t      y = Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance;\n\t    else\n\t      y = this.ArcTolerance;\n\t    //see offset_triginometry2.svg in the documentation folder ...\n\t    var steps = 3.14159265358979 / Math.acos(1 - y / Math.abs(delta));\n\t    this.m_sin = Math.sin(ClipperLib.ClipperOffset.two_pi / steps);\n\t    this.m_cos = Math.cos(ClipperLib.ClipperOffset.two_pi / steps);\n\t    this.m_StepsPerRad = steps / ClipperLib.ClipperOffset.two_pi;\n\t    if (delta < 0)\n\t      this.m_sin = -this.m_sin;\n\t    //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount * 2);\n\t    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t    {\n\t      var node = this.m_polyNodes.Childs()[i];\n\t      this.m_srcPoly = node.m_polygon;\n\t      var len = this.m_srcPoly.length;\n\t      if (len == 0 || (delta <= 0 && (len < 3 || node.m_endtype != ClipperLib.EndType.etClosedPolygon)))\n\t        continue;\n\t      this.m_destPoly = new Array();\n\t      if (len == 1)\n\t      {\n\t        if (node.m_jointype == ClipperLib.JoinType.jtRound)\n\t        {\n\t          var X = 1,\n\t            Y = 0;\n\t          for (var j = 1; j <= steps; j++)\n\t          {\n\t            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n\t            var X2 = X;\n\t            X = X * this.m_cos - this.m_sin * Y;\n\t            Y = X2 * this.m_sin + Y * this.m_cos;\n\t          }\n\t        }\n\t        else\n\t        {\n\t          var X = -1,\n\t            Y = -1;\n\t          for (var j = 0; j < 4; ++j)\n\t          {\n\t            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n\t            if (X < 0)\n\t              X = 1;\n\t            else if (Y < 0)\n\t              Y = 1;\n\t            else\n\t              X = -1;\n\t          }\n\t        }\n\t        this.m_destPolys.push(this.m_destPoly);\n\t        continue;\n\t      }\n\t      //build m_normals ...\n\t      this.m_normals.length = 0;\n\t      //this.m_normals.set_Capacity(len);\n\t      for (var j = 0; j < len - 1; j++)\n\t        this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[j], this.m_srcPoly[j + 1]));\n\t      if (node.m_endtype == ClipperLib.EndType.etClosedLine || node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n\t        this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[len - 1], this.m_srcPoly[0]));\n\t      else\n\t        this.m_normals.push(new ClipperLib.DoublePoint(this.m_normals[len - 2]));\n\t      if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n\t      {\n\t        var k = len - 1;\n\t        for (var j = 0; j < len; j++)\n\t          k = this.OffsetPoint(j, k, node.m_jointype);\n\t        this.m_destPolys.push(this.m_destPoly);\n\t      }\n\t      else if (node.m_endtype == ClipperLib.EndType.etClosedLine)\n\t      {\n\t        var k = len - 1;\n\t        for (var j = 0; j < len; j++)\n\t          k = this.OffsetPoint(j, k, node.m_jointype);\n\t        this.m_destPolys.push(this.m_destPoly);\n\t        this.m_destPoly = new Array();\n\t        //re-build m_normals ...\n\t        var n = this.m_normals[len - 1];\n\t        for (var j = len - 1; j > 0; j--)\n\t          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n\t        this.m_normals[0] = new ClipperLib.DoublePoint(-n.X, -n.Y);\n\t        k = 0;\n\t        for (var j = len - 1; j >= 0; j--)\n\t          k = this.OffsetPoint(j, k, node.m_jointype);\n\t        this.m_destPolys.push(this.m_destPoly);\n\t      }\n\t      else\n\t      {\n\t        var k = 0;\n\t        for (var j = 1; j < len - 1; ++j)\n\t          k = this.OffsetPoint(j, k, node.m_jointype);\n\t        var pt1;\n\t        if (node.m_endtype == ClipperLib.EndType.etOpenButt)\n\t        {\n\t          var j = len - 1;\n\t          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * delta));\n\t          this.m_destPoly.push(pt1);\n\t          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X - this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y - this.m_normals[j].Y * delta));\n\t          this.m_destPoly.push(pt1);\n\t        }\n\t        else\n\t        {\n\t          var j = len - 1;\n\t          k = len - 2;\n\t          this.m_sinA = 0;\n\t          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j].X, -this.m_normals[j].Y);\n\t          if (node.m_endtype == ClipperLib.EndType.etOpenSquare)\n\t            this.DoSquare(j, k);\n\t          else\n\t            this.DoRound(j, k);\n\t        }\n\t        //re-build m_normals ...\n\t        for (var j = len - 1; j > 0; j--)\n\t          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n\t        this.m_normals[0] = new ClipperLib.DoublePoint(-this.m_normals[1].X, -this.m_normals[1].Y);\n\t        k = len - 1;\n\t        for (var j = k - 1; j > 0; --j)\n\t          k = this.OffsetPoint(j, k, node.m_jointype);\n\t        if (node.m_endtype == ClipperLib.EndType.etOpenButt)\n\t        {\n\t          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X - this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y - this.m_normals[0].Y * delta));\n\t          this.m_destPoly.push(pt1);\n\t          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + this.m_normals[0].Y * delta));\n\t          this.m_destPoly.push(pt1);\n\t        }\n\t        else\n\t        {\n\t          k = 1;\n\t          this.m_sinA = 0;\n\t          if (node.m_endtype == ClipperLib.EndType.etOpenSquare)\n\t            this.DoSquare(0, 1);\n\t          else\n\t            this.DoRound(0, 1);\n\t        }\n\t        this.m_destPolys.push(this.m_destPoly);\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.Execute = function ()\n\t  {\n\t    var a = arguments,\n\t      ispolytree = a[0] instanceof ClipperLib.PolyTree;\n\t    if (!ispolytree) // function (solution, delta)\n\t    {\n\t      var solution = a[0],\n\t        delta = a[1];\n\t      ClipperLib.Clear(solution);\n\t      this.FixOrientations();\n\t      this.DoOffset(delta);\n\t      //now clean up 'corners' ...\n\t      var clpr = new ClipperLib.Clipper(0);\n\t      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n\t      if (delta > 0)\n\t      {\n\t        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n\t      }\n\t      else\n\t      {\n\t        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n\t        var outer = new ClipperLib.Path();\n\t        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n\t        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n\t        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n\t        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n\t        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n\t        clpr.ReverseSolution = true;\n\t        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n\t        if (solution.length > 0)\n\t          solution.splice(0, 1);\n\t      }\n\t      //console.log(JSON.stringify(solution));\n\t    }\n\t    else // function (polytree, delta)\n\t    {\n\t      var solution = a[0],\n\t        delta = a[1];\n\t      solution.Clear();\n\t      this.FixOrientations();\n\t      this.DoOffset(delta);\n\t      //now clean up 'corners' ...\n\t      var clpr = new ClipperLib.Clipper(0);\n\t      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n\t      if (delta > 0)\n\t      {\n\t        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n\t      }\n\t      else\n\t      {\n\t        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n\t        var outer = new ClipperLib.Path();\n\t        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n\t        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n\t        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n\t        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n\t        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n\t        clpr.ReverseSolution = true;\n\t        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n\t        //remove the outer PolyNode rectangle ...\n\t        if (solution.ChildCount() == 1 && solution.Childs()[0].ChildCount() > 0)\n\t        {\n\t          var outerNode = solution.Childs()[0];\n\t          //solution.Childs.set_Capacity(outerNode.ChildCount);\n\t          solution.Childs()[0] = outerNode.Childs()[0];\n\t          solution.Childs()[0].m_Parent = solution;\n\t          for (var i = 1; i < outerNode.ChildCount(); i++)\n\t            solution.AddChild(outerNode.Childs()[i]);\n\t        }\n\t        else\n\t          solution.Clear();\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.OffsetPoint = function (j, k, jointype)\n\t  {\n\t\t\t//cross product ...\n\t\t\tthis.m_sinA = (this.m_normals[k].X * this.m_normals[j].Y - this.m_normals[j].X * this.m_normals[k].Y);\n\t\n\t\t\tif (Math.abs(this.m_sinA * this.m_delta) < 1.0)\n\t\t\t{\n\t\t\t\t//dot product ...\n\t\t\t\tvar cosA = (this.m_normals[k].X * this.m_normals[j].X + this.m_normals[j].Y * this.m_normals[k].Y);\n\t\t\t\tif (cosA > 0) // angle ==> 0 degrees\n\t\t\t\t{\n\t\t\t\t\tthis.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),\n\t\t\t\t\t\tClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n\t\t\t\t\treturn k;\n\t\t\t\t}\n\t\t\t\t//else angle ==> 180 degrees\n\t\t\t}\n\t    else if (this.m_sinA > 1)\n\t      this.m_sinA = 1.0;\n\t    else if (this.m_sinA < -1)\n\t      this.m_sinA = -1.0;\n\t    if (this.m_sinA * this.m_delta < 0)\n\t    {\n\t      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),\n\t        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n\t      this.m_destPoly.push(new ClipperLib.IntPoint(this.m_srcPoly[j]));\n\t      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n\t        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n\t    }\n\t    else\n\t      switch (jointype)\n\t      {\n\t      case ClipperLib.JoinType.jtMiter:\n\t        {\n\t          var r = 1 + (this.m_normals[j].X * this.m_normals[k].X + this.m_normals[j].Y * this.m_normals[k].Y);\n\t          if (r >= this.m_miterLim)\n\t            this.DoMiter(j, k, r);\n\t          else\n\t            this.DoSquare(j, k);\n\t          break;\n\t        }\n\t      case ClipperLib.JoinType.jtSquare:\n\t        this.DoSquare(j, k);\n\t        break;\n\t      case ClipperLib.JoinType.jtRound:\n\t        this.DoRound(j, k);\n\t        break;\n\t      }\n\t    k = j;\n\t    return k;\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.DoSquare = function (j, k)\n\t  {\n\t    var dx = Math.tan(Math.atan2(this.m_sinA,\n\t      this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y) / 4);\n\t    this.m_destPoly.push(new ClipperLib.IntPoint(\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[k].X - this.m_normals[k].Y * dx)),\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[k].Y + this.m_normals[k].X * dx))));\n\t    this.m_destPoly.push(new ClipperLib.IntPoint(\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[j].X + this.m_normals[j].Y * dx)),\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[j].Y - this.m_normals[j].X * dx))));\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.DoMiter = function (j, k, r)\n\t  {\n\t    var q = this.m_delta / r;\n\t    this.m_destPoly.push(new ClipperLib.IntPoint(\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + (this.m_normals[k].X + this.m_normals[j].X) * q),\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + (this.m_normals[k].Y + this.m_normals[j].Y) * q)));\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.DoRound = function (j, k)\n\t  {\n\t    var a = Math.atan2(this.m_sinA,\n\t      this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y);\n\t\n\t    \tvar steps = Math.max(ClipperLib.Cast_Int32(ClipperLib.ClipperOffset.Round(this.m_StepsPerRad * Math.abs(a))), 1);\n\t\n\t    var X = this.m_normals[k].X,\n\t      Y = this.m_normals[k].Y,\n\t      X2;\n\t    for (var i = 0; i < steps; ++i)\n\t    {\n\t      this.m_destPoly.push(new ClipperLib.IntPoint(\n\t        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + X * this.m_delta),\n\t        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + Y * this.m_delta)));\n\t      X2 = X;\n\t      X = X * this.m_cos - this.m_sin * Y;\n\t      Y = X2 * this.m_sin + Y * this.m_cos;\n\t    }\n\t    this.m_destPoly.push(new ClipperLib.IntPoint(\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n\t  };\n\t  ClipperLib.Error = function (message)\n\t  {\n\t    try\n\t    {\n\t      throw new Error(message);\n\t    }\n\t    catch (err)\n\t    {\n\t      alert(err.message);\n\t    }\n\t  };\n\t  // ---------------------------------\n\t  // JS extension by Timo 2013\n\t  ClipperLib.JS = {};\n\t  ClipperLib.JS.AreaOfPolygon = function (poly, scale)\n\t  {\n\t    if (!scale) scale = 1;\n\t    return ClipperLib.Clipper.Area(poly) / (scale * scale);\n\t  };\n\t  ClipperLib.JS.AreaOfPolygons = function (poly, scale)\n\t  {\n\t    if (!scale) scale = 1;\n\t    var area = 0;\n\t    for (var i = 0; i < poly.length; i++)\n\t    {\n\t      area += ClipperLib.Clipper.Area(poly[i]);\n\t    }\n\t    return area / (scale * scale);\n\t  };\n\t  ClipperLib.JS.BoundsOfPath = function (path, scale)\n\t  {\n\t    return ClipperLib.JS.BoundsOfPaths([path], scale);\n\t  };\n\t  ClipperLib.JS.BoundsOfPaths = function (paths, scale)\n\t  {\n\t    if (!scale) scale = 1;\n\t    var bounds = ClipperLib.Clipper.GetBounds(paths);\n\t    bounds.left /= scale;\n\t    bounds.bottom /= scale;\n\t    bounds.right /= scale;\n\t    bounds.top /= scale;\n\t    return bounds;\n\t  };\n\t  // Clean() joins vertices that are too near each other\n\t  // and causes distortion to offsetted polygons without cleaning\n\t  ClipperLib.JS.Clean = function (polygon, delta)\n\t  {\n\t    if (!(polygon instanceof Array)) return [];\n\t    var isPolygons = polygon[0] instanceof Array;\n\t    var polygon = ClipperLib.JS.Clone(polygon);\n\t    if (typeof delta != \"number\" || delta === null)\n\t    {\n\t      ClipperLib.Error(\"Delta is not a number in Clean().\");\n\t      return polygon;\n\t    }\n\t    if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || delta < 0) return polygon;\n\t    if (!isPolygons) polygon = [polygon];\n\t    var k_length = polygon.length;\n\t    var len, poly, result, d, p, j, i;\n\t    var results = [];\n\t    for (var k = 0; k < k_length; k++)\n\t    {\n\t      poly = polygon[k];\n\t      len = poly.length;\n\t      if (len === 0) continue;\n\t      else if (len < 3)\n\t      {\n\t        result = poly;\n\t        results.push(result);\n\t        continue;\n\t      }\n\t      result = poly;\n\t      d = delta * delta;\n\t      //d = Math.floor(c_delta * c_delta);\n\t      p = poly[0];\n\t      j = 1;\n\t      for (i = 1; i < len; i++)\n\t      {\n\t        if ((poly[i].X - p.X) * (poly[i].X - p.X) +\n\t          (poly[i].Y - p.Y) * (poly[i].Y - p.Y) <= d)\n\t          continue;\n\t        result[j] = poly[i];\n\t        p = poly[i];\n\t        j++;\n\t      }\n\t      p = poly[j - 1];\n\t      if ((poly[0].X - p.X) * (poly[0].X - p.X) +\n\t        (poly[0].Y - p.Y) * (poly[0].Y - p.Y) <= d)\n\t        j--;\n\t      if (j < len)\n\t        result.splice(j, len - j);\n\t      if (result.length) results.push(result);\n\t    }\n\t    if (!isPolygons && results.length) results = results[0];\n\t    else if (!isPolygons && results.length === 0) results = [];\n\t    else if (isPolygons && results.length === 0) results = [\n\t      []\n\t    ];\n\t    return results;\n\t  }\n\t  // Make deep copy of Polygons or Polygon\n\t  // so that also IntPoint objects are cloned and not only referenced\n\t  // This should be the fastest way\n\t  ClipperLib.JS.Clone = function (polygon)\n\t  {\n\t    if (!(polygon instanceof Array)) return [];\n\t    if (polygon.length === 0) return [];\n\t    else if (polygon.length == 1 && polygon[0].length === 0) return [[]];\n\t    var isPolygons = polygon[0] instanceof Array;\n\t    if (!isPolygons) polygon = [polygon];\n\t    var len = polygon.length,\n\t      plen, i, j, result;\n\t    var results = new Array(len);\n\t    for (i = 0; i < len; i++)\n\t    {\n\t      plen = polygon[i].length;\n\t      result = new Array(plen);\n\t      for (j = 0; j < plen; j++)\n\t      {\n\t        result[j] = {\n\t          X: polygon[i][j].X,\n\t          Y: polygon[i][j].Y\n\t        };\n\t      }\n\t      results[i] = result;\n\t    }\n\t    if (!isPolygons) results = results[0];\n\t    return results;\n\t  };\n\t  // Removes points that doesn't affect much to the visual appearance.\n\t  // If middle point is at or under certain distance (tolerance) of the line segment between\n\t  // start and end point, the middle point is removed.\n\t  ClipperLib.JS.Lighten = function (polygon, tolerance)\n\t  {\n\t    if (!(polygon instanceof Array)) return [];\n\t    if (typeof tolerance != \"number\" || tolerance === null)\n\t    {\n\t      ClipperLib.Error(\"Tolerance is not a number in Lighten().\")\n\t      return ClipperLib.JS.Clone(polygon);\n\t    }\n\t    if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || tolerance < 0)\n\t    {\n\t      return ClipperLib.JS.Clone(polygon);\n\t    }\n\t    if (!(polygon[0] instanceof Array)) polygon = [polygon];\n\t    var i, j, poly, k, poly2, plen, A, B, P, d, rem, addlast;\n\t    var bxax, byay, l, ax, ay;\n\t    var len = polygon.length;\n\t    var toleranceSq = tolerance * tolerance;\n\t    var results = [];\n\t    for (i = 0; i < len; i++)\n\t    {\n\t      poly = polygon[i];\n\t      plen = poly.length;\n\t      if (plen == 0) continue;\n\t      for (k = 0; k < 1000000; k++) // could be forever loop, but wiser to restrict max repeat count\n\t      {\n\t        poly2 = [];\n\t        plen = poly.length;\n\t        // the first have to added to the end, if first and last are not the same\n\t        // this way we ensure that also the actual last point can be removed if needed\n\t        if (poly[plen - 1].X != poly[0].X || poly[plen - 1].Y != poly[0].Y)\n\t        {\n\t          addlast = 1;\n\t          poly.push(\n\t          {\n\t            X: poly[0].X,\n\t            Y: poly[0].Y\n\t          });\n\t          plen = poly.length;\n\t        }\n\t        else addlast = 0;\n\t        rem = []; // Indexes of removed points\n\t        for (j = 0; j < plen - 2; j++)\n\t        {\n\t          A = poly[j]; // Start point of line segment\n\t          P = poly[j + 1]; // Middle point. This is the one to be removed.\n\t          B = poly[j + 2]; // End point of line segment\n\t          ax = A.X;\n\t          ay = A.Y;\n\t          bxax = B.X - ax;\n\t          byay = B.Y - ay;\n\t          if (bxax !== 0 || byay !== 0) // To avoid Nan, when A==P && P==B. And to avoid peaks (A==B && A!=P), which have lenght, but not area.\n\t          {\n\t            l = ((P.X - ax) * bxax + (P.Y - ay) * byay) / (bxax * bxax + byay * byay);\n\t            if (l > 1)\n\t            {\n\t              ax = B.X;\n\t              ay = B.Y;\n\t            }\n\t            else if (l > 0)\n\t            {\n\t              ax += bxax * l;\n\t              ay += byay * l;\n\t            }\n\t          }\n\t          bxax = P.X - ax;\n\t          byay = P.Y - ay;\n\t          d = bxax * bxax + byay * byay;\n\t          if (d <= toleranceSq)\n\t          {\n\t            rem[j + 1] = 1;\n\t            j++; // when removed, transfer the pointer to the next one\n\t          }\n\t        }\n\t        // add all unremoved points to poly2\n\t        poly2.push(\n\t        {\n\t          X: poly[0].X,\n\t          Y: poly[0].Y\n\t        });\n\t        for (j = 1; j < plen - 1; j++)\n\t          if (!rem[j]) poly2.push(\n\t          {\n\t            X: poly[j].X,\n\t            Y: poly[j].Y\n\t          });\n\t        poly2.push(\n\t        {\n\t          X: poly[plen - 1].X,\n\t          Y: poly[plen - 1].Y\n\t        });\n\t        // if the first point was added to the end, remove it\n\t        if (addlast) poly.pop();\n\t        // break, if there was not anymore removed points\n\t        if (!rem.length) break;\n\t        // else continue looping using poly2, to check if there are points to remove\n\t        else poly = poly2;\n\t      }\n\t      plen = poly2.length;\n\t      // remove duplicate from end, if needed\n\t      if (poly2[plen - 1].X == poly2[0].X && poly2[plen - 1].Y == poly2[0].Y)\n\t      {\n\t        poly2.pop();\n\t      }\n\t      if (poly2.length > 2) // to avoid two-point-polygons\n\t        results.push(poly2);\n\t    }\n\t    if (!(polygon[0] instanceof Array)) results = results[0];\n\t    if (typeof (results) == \"undefined\") results = [\n\t      []\n\t    ];\n\t    return results;\n\t  }\n\t  ClipperLib.JS.PerimeterOfPath = function (path, closed, scale)\n\t  {\n\t    if (typeof (path) == \"undefined\") return 0;\n\t    var sqrt = Math.sqrt;\n\t    var perimeter = 0.0;\n\t    var p1, p2, p1x = 0.0,\n\t      p1y = 0.0,\n\t      p2x = 0.0,\n\t      p2y = 0.0;\n\t    var j = path.length;\n\t    if (j < 2) return 0;\n\t    if (closed)\n\t    {\n\t      path[j] = path[0];\n\t      j++;\n\t    }\n\t    while (--j)\n\t    {\n\t      p1 = path[j];\n\t      p1x = p1.X;\n\t      p1y = p1.Y;\n\t      p2 = path[j - 1];\n\t      p2x = p2.X;\n\t      p2y = p2.Y;\n\t      perimeter += sqrt((p1x - p2x) * (p1x - p2x) + (p1y - p2y) * (p1y - p2y));\n\t    }\n\t    if (closed) path.pop();\n\t    return perimeter / scale;\n\t  };\n\t  ClipperLib.JS.PerimeterOfPaths = function (paths, closed, scale)\n\t  {\n\t    if (!scale) scale = 1;\n\t    var perimeter = 0;\n\t    for (var i = 0; i < paths.length; i++)\n\t    {\n\t      perimeter += ClipperLib.JS.PerimeterOfPath(paths[i], closed, scale);\n\t    }\n\t    return perimeter;\n\t  };\n\t  ClipperLib.JS.ScaleDownPath = function (path, scale)\n\t  {\n\t    var i, p;\n\t    if (!scale) scale = 1;\n\t    i = path.length;\n\t    while (i--)\n\t    {\n\t      p = path[i];\n\t      p.X = p.X / scale;\n\t      p.Y = p.Y / scale;\n\t    }\n\t  };\n\t  ClipperLib.JS.ScaleDownPaths = function (paths, scale)\n\t  {\n\t    var i, j, p;\n\t    if (!scale) scale = 1;\n\t    i = paths.length;\n\t    while (i--)\n\t    {\n\t      j = paths[i].length;\n\t      while (j--)\n\t      {\n\t        p = paths[i][j];\n\t        p.X = p.X / scale;\n\t        p.Y = p.Y / scale;\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.JS.ScaleUpPath = function (path, scale)\n\t  {\n\t    var i, p, round = Math.round;\n\t    if (!scale) scale = 1;\n\t    i = path.length;\n\t    while (i--)\n\t    {\n\t      p = path[i];\n\t      p.X = round(p.X * scale);\n\t      p.Y = round(p.Y * scale);\n\t    }\n\t  };\n\t  ClipperLib.JS.ScaleUpPaths = function (paths, scale)\n\t  {\n\t    var i, j, p, round = Math.round;\n\t    if (!scale) scale = 1;\n\t    i = paths.length;\n\t    while (i--)\n\t    {\n\t      j = paths[i].length;\n\t      while (j--)\n\t      {\n\t        p = paths[i][j];\n\t        p.X = round(p.X * scale);\n\t        p.Y = round(p.Y * scale);\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.ExPolygons = function ()\n\t  {\n\t    return [];\n\t  }\n\t  ClipperLib.ExPolygon = function ()\n\t  {\n\t    this.outer = null;\n\t    this.holes = null;\n\t  };\n\t  ClipperLib.JS.AddOuterPolyNodeToExPolygons = function (polynode, expolygons)\n\t  {\n\t    var ep = new ClipperLib.ExPolygon();\n\t    ep.outer = polynode.Contour();\n\t    var childs = polynode.Childs();\n\t    var ilen = childs.length;\n\t    ep.holes = new Array(ilen);\n\t    var node, n, i, j, childs2, jlen;\n\t    for (i = 0; i < ilen; i++)\n\t    {\n\t      node = childs[i];\n\t      ep.holes[i] = node.Contour();\n\t      //Add outer polygons contained by (nested within) holes ...\n\t      for (j = 0, childs2 = node.Childs(), jlen = childs2.length; j < jlen; j++)\n\t      {\n\t        n = childs2[j];\n\t        ClipperLib.JS.AddOuterPolyNodeToExPolygons(n, expolygons);\n\t      }\n\t    }\n\t    expolygons.push(ep);\n\t  };\n\t  ClipperLib.JS.ExPolygonsToPaths = function (expolygons)\n\t  {\n\t    var a, i, alen, ilen;\n\t    var paths = new ClipperLib.Paths();\n\t    for (a = 0, alen = expolygons.length; a < alen; a++)\n\t    {\n\t      paths.push(expolygons[a].outer);\n\t      for (i = 0, ilen = expolygons[a].holes.length; i < ilen; i++)\n\t      {\n\t        paths.push(expolygons[a].holes[i]);\n\t      }\n\t    }\n\t    return paths;\n\t  }\n\t  ClipperLib.JS.PolyTreeToExPolygons = function (polytree)\n\t  {\n\t    var expolygons = new ClipperLib.ExPolygons();\n\t    var node, i, childs, ilen;\n\t    for (i = 0, childs = polytree.Childs(), ilen = childs.length; i < ilen; i++)\n\t    {\n\t      node = childs[i];\n\t      ClipperLib.JS.AddOuterPolyNodeToExPolygons(node, expolygons);\n\t    }\n\t    return expolygons;\n\t  };\n\t})();\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t!function(t,e){ true?module.exports=e():\"function\"==typeof define&&define.amd?define(\"SVGCurves\",[],e):\"object\"==typeof exports?exports.SVGCurves=e():t.SVGCurves=e()}(this,function(){return function(t){function e(n){if(i[n])return i[n].exports;var r=i[n]={exports:{},id:n,loaded:!1};return t[n].call(r.exports,r,r.exports,e),r.loaded=!0,r.exports}var i={};return e.m=t,e.c=i,e.p=\"\",e(0)}([function(t,e,i){t.exports=i(1)},function(t,e,i){\"use strict\";function n(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function r(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function s(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function o(t,e){return(t%e+e)%e}function h(t,e,i){return Math.min(Math.max(t,e),i)}function a(t,e){return Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2))}function u(t,e){var i=t.x*e.x+t.y*e.y,n=Math.sqrt((Math.pow(t.x,2)+Math.pow(t.y,2))*(Math.pow(e.x,2)+Math.pow(e.y,2)));return(t.x*e.y-t.y*e.x<0?-1:1)*Math.acos(i/n)}Object.defineProperty(e,\"__esModule\",{value:!0}),e.QuadricBezier=e.CubicBezier=e.Arc=void 0;var p=function t(e,i,n){null===e&&(e=Function.prototype);var r=Object.getOwnPropertyDescriptor(e,i);if(void 0===r){var s=Object.getPrototypeOf(e);return null===s?void 0:t(s,i,n)}if(\"value\"in r)return r.value;var o=r.get;if(void 0!==o)return o.call(n)},c=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e}}(),f=i(2),l=2*Math.PI,y=Math.PI/180,v=function(){function t(e){s(this,t),this.path=[],this.linear=!0,this.step=.01,this.resolution=500,this.segmentLength=.1,Object.assign(this,e||{}),this.arcLength=null,this.arcLengthMap=null}return c(t,[{key:\"_clearPath\",value:function(){this.path=[]}},{key:\"getPath\",value:function(){return this.path}},{key:\"getPointAtT\",value:function(t){return new f.Point(0,0)}},{key:\"_addPoint\",value:function(t){this.path.push(t.x,t.y)}},{key:\"_postTrace\",value:function(){}},{key:\"_approximateLength\",value:function(){var t=0,e=[],i=this.getPointAtT(0),n=void 0,r=void 0,s=void 0;for(n=0;n<this.resolution;n++)r=h(n*(1/this.resolution),0,1),s=this.getPointAtT(r),t+=a(i,s),e.push({t:r,arcLength:t}),i=s;s=this.getPointAtT(1),t+=a(i,s),e.push({t:1,arcLength:t}),Object.assign(this,{arcLength:t,arcLengthMap:e})}},{key:\"getPointAtU\",value:function(t){t=h(t,0,1);var e=t*this.arcLength,i=0,n=0,r=0;return this.arcLengthMap.every(function(t){var s=t.t,o=t.arcLength;if(o>=e){var h=o-e,a=e-n,u=a/(h+a)||0;return i=r+(s-r)*u,!1}return n=o,r=s,!0}),this.getPointAtT(i)}},{key:\"trace\",value:function(t){Object.assign(this,t||{});var e=\"getPointAtT\",i=this.step;if(this.linear){this._approximateLength();var n=Math.round(this.arcLength/this.segmentLength);e=\"getPointAtU\",i=1/n}this._clearPath();for(var r=0;r<=1;r+=i)this._addPoint(this[e](r));return this._postTrace(),this.getPath()}}]),t}(),x=function(t){function e(){return s(this,e),n(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return r(e,t),c(e,[{key:\"init\",value:function(t){if(Object.assign(this,t||{}),this.radians=o(this.angle,360)*y,this.p1.x===this.p2.x&&this.p1.y===this.p2.y)return this.path;if(this.rx=Math.abs(this.rx),this.ry=Math.abs(this.ry),0===this.rx||0===this.ry)return this.__addPoint(this.p1),this.__addPoint(this.p2),this.path;var e=(this.p1.x-this.p2.x)/2,i=(this.p1.y-this.p2.y)/2,n={x:Math.cos(this.radians)*e+Math.sin(this.radians)*i,y:-Math.sin(this.radians)*e+Math.cos(this.radians)*i},r=Math.pow(n.x,2)/Math.pow(this.rx,2)+Math.pow(n.y,2)/Math.pow(this.ry,2);r>1&&(this.rx=Math.sqrt(r)*this.rx,this.ry=Math.sqrt(r)*this.ry);var s=Math.pow(this.rx,2)*Math.pow(this.ry,2)-Math.pow(this.rx,2)*Math.pow(n.y,2)-Math.pow(this.ry,2)*Math.pow(n.x,2),h=Math.pow(this.rx,2)*Math.pow(n.y,2)+Math.pow(this.ry,2)*Math.pow(n.x,2),a=s/h;a=a<0?0:a;var p=(this.large!==this.sweep?1:-1)*Math.sqrt(a),c={x:p*(this.rx*n.y/this.ry),y:p*(-(this.ry*n.x)/this.rx)};this.center={x:Math.cos(this.radians)*c.x-Math.sin(this.radians)*c.y+(this.p1.x+this.p2.x)/2,y:Math.sin(this.radians)*c.x+Math.cos(this.radians)*c.y+(this.p1.y+this.p2.y)/2};var f={x:(n.x-c.x)/this.rx,y:(n.y-c.y)/this.ry},v={x:(-n.x-c.x)/this.rx,y:(-n.y-c.y)/this.ry};this.startAngle=u({x:1,y:0},f),this.sweepAngle=u(f,v),!this.sweep&&this.sweepAngle>0?this.sweepAngle-=l:this.sweep&&this.sweepAngle<0&&(this.sweepAngle+=l),this.sweepAngle%=l}},{key:\"trace\",value:function(t){return this.init(t),p(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),\"trace\",this).call(this)}},{key:\"getPointAtT\",value:function(t){var e=this.startAngle+this.sweepAngle*t,i=this.rx*Math.cos(e),n=this.ry*Math.sin(e);return new f.Point(Math.cos(this.radians)*i-Math.sin(this.radians)*n+this.center.x,Math.sin(this.radians)*i+Math.cos(this.radians)*n+this.center.y)}},{key:\"_postTrace\",value:function(){this._addPoint(this.p2)}}]),e}(v),d=function(t){function e(){return s(this,e),n(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return r(e,t),c(e,[{key:\"_B1\",value:function(t){return t*t*t}},{key:\"_B2\",value:function(t){return 3*t*t*(1-t)}},{key:\"_B3\",value:function(t){return 3*t*(1-t)*(1-t)}},{key:\"_B4\",value:function(t){return(1-t)*(1-t)*(1-t)}},{key:\"_C1\",value:function(t,e,i,n,r){return t*this._B1(r)+e*this._B2(r)+i*this._B3(r)+n*this._B4(r)}},{key:\"getPointAtT\",value:function(t){return new f.Point(this._C1(this.p1.x,this.p2.x,this.p3.x,this.p4.x,t),this._C1(this.p1.y,this.p2.y,this.p3.y,this.p4.y,t))}},{key:\"_addPoint\",value:function(t){this.path.unshift(t.x,t.y)}}]),e}(v),g=function(t){function e(){return s(this,e),n(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return r(e,t),c(e,[{key:\"_B1\",value:function(t){return t*t}},{key:\"_B2\",value:function(t){return 2*t*(1-t)}},{key:\"_B3\",value:function(t){return(1-t)*(1-t)}},{key:\"_C1\",value:function(t,e,i,n){return t*this._B1(n)+e*this._B2(n)+i*this._B3(n)}},{key:\"getPointAtT\",value:function(t){return new f.Point(this._C1(this.p1.x,this.p2.x,this.p3.x,t),this._C1(this.p1.y,this.p2.y,this.p3.y,t))}},{key:\"_addPoint\",value:function(t){this.path.unshift(t.x,t.y)}}]),e}(v);e.Arc=x,e.CubicBezier=d,e.QuadricBezier=g},function(t,e,i){!function(e,i){t.exports=i()}(this,function(){return function(t){function e(n){if(i[n])return i[n].exports;var r=i[n]={exports:{},id:n,loaded:!1};return t[n].call(r.exports,r,r.exports,e),r.loaded=!0,r.exports}var i={};return e.m=t,e.c=i,e.p=\"\",e(0)}([function(t,e,i){t.exports=i(1)},function(t,e){\"use strict\";function i(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}Object.defineProperty(e,\"__esModule\",{value:!0});var n=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e}}(),r=function(){function t(e,n){if(i(this,t),this.x=parseFloat(e),this.y=parseFloat(n),isNaN(this.x)||isNaN(this.y))throw console.error(\"new Point(\",e,n,\")\"),new Error(\"Invalid input: x and y params must be float.\")}return n(t,[{key:\"isEqual\",value:function(t){return this.x===t.x&&this.y===t.y}}]),t}(),s=function(){function t(){i(this,t),this.points=[],this.length=0}return n(t,[{key:\"getPoints\",value:function(){return this.points}},{key:\"getFlattenPoints\",value:function(){var t=[];return this.points.forEach(function(e){return t.push(e.x,e.y)}),t}},{key:\"getClipperPoints\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,e=[];return this.points.forEach(function(i){return e.push({X:parseInt(i.x*t),Y:parseInt(i.y*t)})}),e}},{key:\"fromClipperPoints\",value:function(t){var e=this,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return this.points=[],t.forEach(function(t){return e.addPoint(parseFloat(t.X*i),parseFloat(t.Y*i))}),this}},{key:\"getPoint\",value:function(t){return this.points[t<0?this.length+t:t]||null}},{key:\"addPoint\",value:function(t,e){this.points.push(new r(t,e)),this.length=this.points.length}},{key:\"addPoints\",value:function(t){for(var e=0,i=t.length;e<i;e+=2)this.addPoint(t[e],t[e+1])}},{key:\"isClosed\",value:function(){var t=this.getPoint(0);return t&&t.isEqual(this.getPoint(-1))}},{key:\"close\",value:function(){if(!this.isClosed()&&this.length>2){var t=this.getPoint(0);return this.addPoint(t.x,t.y),!0}return!1}},{key:\"transform\",value:function(t){this.points=this.points.map(function(e){return new r(t[0]*e.x+t[2]*e.y+t[4],t[1]*e.x+t[3]*e.y+t[5])})}}]),t}();e.Path=s,e.Point=r,e.default=s}])})}])});\n\t//# sourceMappingURL=lw.svg-curves.js.map\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// lw.svg-parser.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap fea28de34ee0b0e2d9ee","!function(t,n){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=n():\"function\"==typeof define&&define.amd?define(\"SVGPath\",[],n):\"object\"==typeof exports?exports.SVGPath=n():t.SVGPath=n()}(this,function(){return function(t){function n(i){if(e[i])return e[i].exports;var o=e[i]={exports:{},id:i,loaded:!1};return t[i].call(o.exports,o,o.exports,n),o.loaded=!0,o.exports}var e={};return n.m=t,n.c=e,n.p=\"\",n(0)}([function(t,n,e){t.exports=e(1)},function(t,n){\"use strict\";function e(t,n){if(!(t instanceof n))throw new TypeError(\"Cannot call a class as a function\")}Object.defineProperty(n,\"__esModule\",{value:!0});var i=function(){function t(t,n){for(var e=0;e<n.length;e++){var i=n[e];i.enumerable=i.enumerable||!1,i.configurable=!0,\"value\"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(n,e,i){return e&&t(n.prototype,e),i&&t(n,i),n}}(),o=function(){function t(n,i){if(e(this,t),this.x=parseFloat(n),this.y=parseFloat(i),isNaN(this.x)||isNaN(this.y))throw console.error(\"new Point(\",n,i,\")\"),new Error(\"Invalid input: x and y params must be float.\")}return i(t,[{key:\"isEqual\",value:function(t){return this.x===t.x&&this.y===t.y}}]),t}(),r=function(){function t(){e(this,t),this.points=[],this.length=0}return i(t,[{key:\"getPoints\",value:function(){return this.points}},{key:\"getFlattenPoints\",value:function(){var t=[];return this.points.forEach(function(n){return t.push(n.x,n.y)}),t}},{key:\"getClipperPoints\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,n=[];return this.points.forEach(function(e){return n.push({X:parseInt(e.x*t),Y:parseInt(e.y*t)})}),n}},{key:\"fromClipperPoints\",value:function(t){var n=this,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return this.points=[],t.forEach(function(t){return n.addPoint(parseFloat(t.X*e),parseFloat(t.Y*e))}),this}},{key:\"getPoint\",value:function(t){return this.points[t<0?this.length+t:t]||null}},{key:\"addPoint\",value:function(t,n){this.points.push(new o(t,n)),this.length=this.points.length}},{key:\"addPoints\",value:function(t){for(var n=0,e=t.length;n<e;n+=2)this.addPoint(t[n],t[n+1])}},{key:\"isClosed\",value:function(){var t=this.getPoint(0);return t&&t.isEqual(this.getPoint(-1))}},{key:\"close\",value:function(){if(!this.isClosed()&&this.length>2){var t=this.getPoint(0);return this.addPoint(t.x,t.y),!0}return!1}},{key:\"transform\",value:function(t){this.points=this.points.map(function(n){return new o(t[0]*n.x+t[2]*n.y+t[4],t[1]*n.x+t[3]*n.y+t[5])})}}]),t}();n.Path=r,n.Point=o,n.default=r}])});\n//# sourceMappingURL=lw.svg-path.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/lw.svg-path/dist/lw.svg-path.js\n// module id = 1\n// module chunks = 0","// Imports\nimport { Tag } from './tag'\nimport { TagParser } from './tagparser'\n\n// SVG parser class\nclass Parser {\n    // Class constructor...\n    constructor(settings) {\n        // Defaults settings\n        settings = settings || {}\n\n        // Init properties\n        this.element  = null // XML document Element object\n        this.editor   = null // Editor info { name, version, fingerprint }\n        this.document = null // Document info { width, height, viewBox }\n        this.defs     = null // Defined <defs> (DOM) nodes list by id\n        this.tags     = null // Tag objects hierarchy\n\n        // Trace settings (Arc, Bezier)\n        this.traceSettings = Object.assign({\n            linear       : true, // Linear trace mode\n            step         : 0.01, // Step resolution if linear mode = false\n            resolution   : 100,  // Number of segments we use to approximate arc length\n            segmentLength: 1,    // Segment length\n        }, settings.traceSettings || {})\n\n        // Supported tags by this lib\n        this.supportedTags = [\n            'svg', 'g', 'defs', 'use',\n            'line', 'polyline', 'polygon',\n            'rect', 'circle', 'ellipse', 'path',\n            'title', 'desc', 'image', 'text'\n        ]\n\n        // Tags list to includes/excludes\n        this.parseTags = settings.includes || this.supportedTags\n        this.skipTags  = settings.excludes || ['#text', '#comment']  // silent (no warning)\n\n        // User onTag callback ?\n        settings.onTag && this.onTag(settings.onTag, settings.onTagContext)\n    }\n\n    // Load raw XML string, XMLDocument, Element or File object\n    load(input) {\n        // Load raw XML string\n        if (typeof input === 'string') {\n            return this.loadFromString(input)\n        }\n\n        // Load File object\n        if (input instanceof File) {\n            return this.loadFromFile(input)\n        }\n\n        // Load XMLDocument object\n        if (input instanceof XMLDocument) {\n            return this.loadFromXMLDocument(input)\n        }\n\n        // Load Element object\n        if (input instanceof Element) {\n            return this.loadFromElement(input)\n        }\n\n        // Return rejected promise with an Error object\n        return Promise.reject(new Error('Unsupported input format.'))\n    }\n\n    // Load from Element object\n    loadFromElement(input) {\n        return new Promise((resolve, reject) => {\n            // Bad input type\n            if (! (input instanceof Element)) {\n                reject(new Error('Input param must be a Element object.'))\n            }\n\n            // Parser error\n            if (input.nodeName === 'parsererror') { // FF\n                reject(new Error(input.textContent))\n            }\n\n            if (input.nodeName === 'html' && input.getElementsByTagName('parsererror')) { // Chrome\n                reject(new Error(input.getElementsByTagName('parsererror')[0].textContent))\n            }\n\n            // Set document element\n            this.element = input\n\n            // Resolve promise\n            resolve(input)\n        })\n    }\n\n    // Load from XMLDocument object\n    loadFromXMLDocument(input) {\n        return new Promise((resolve, reject) => {\n            // Bad input type\n            if (! (input instanceof XMLDocument)) {\n                reject(new Error('Input param must be a XMLDocument object.'))\n            }\n\n            // Load from Element...\n            this.loadFromElement(input.documentElement).then(resolve).catch(reject)\n        })\n    }\n\n    // Load raw XML string\n    loadFromString(input) {\n        return new Promise((resolve, reject) => {\n            // Bad input type\n            if (typeof input !== 'string') {\n                reject(new Error('Input param must be a string.'))\n            }\n\n            // Parse svg editor\n            this._parseEditor(input)\n\n            // Parse string as DOM object\n            let parser = new DOMParser()\n            let XMLDoc = parser.parseFromString(input, 'text/xml')\n\n            // Load from XMLDocument...\n            this.loadFromXMLDocument(XMLDoc).then(resolve).catch(reject)\n        })\n    }\n\n    // Try to get the svg editor from input string\n    _parseEditor(input) {\n        // Reset editor\n        this.editor = {\n            name       : 'unknown',\n            version    : null,\n            fingerprint: null\n        }\n\n        // Fingerprint matches\n        let fingerprint\n\n        // Inkscape\n        fingerprint = input.match(/<!-- Created with Inkscape .*-->/i)\n\n        if (fingerprint) {\n            this.editor.name        = 'inkscape'\n            this.editor.fingerprint = fingerprint[0]\n\n            return this.editor\n        }\n\n        // Illustrator\n        fingerprint = input.match(/<!-- Generator: Adobe Illustrator ([0-9\\.]+), .*-->/i)\n\n        if (fingerprint) {\n            this.editor.name        = 'illustrator'\n            this.editor.version     = fingerprint[1]\n            this.editor.fingerprint = fingerprint[0]\n\n            return this.editor\n        }\n\n        // Return default\n        return this.editor\n    }\n\n    // Load from File object\n    loadFromFile(input) {\n        return new Promise((resolve, reject) => {\n            // Bad input type\n            if (! (input instanceof File)) {\n                reject(new Error('Input param must be a File object.'))\n            }\n\n            // Create file reader\n            let reader = new FileReader()\n\n            // Register reader events handlers\n            reader.onload = event => {\n                this.loadFromString(event.target.result).then(resolve).catch(reject)\n            }\n\n            reader.onerror = event => {\n                reject(new Error('Error reading file : ' + input.name))\n            }\n\n            // Finally read input file as text\n            reader.readAsText(input)\n        })\n    }\n\n    // Parse the (loaded) element\n    parse(input) {\n        // Reset properties\n        this.document = null\n        this.defs     = {}\n        this.tags     = null\n\n        // Load input if provided\n        if (input) {\n            return new Promise((resolve, reject) => {\n                this.load(input).then(() => {\n                    resolve(this.parse())\n                }).catch(reject)\n            })\n        }\n\n        // Start parsing element\n        return new Promise((resolve, reject) => {\n            // If no element is loaded\n            if (! this.element) {\n                reject(new Error('No element is loaded, call the load method before.'))\n            }\n\n            // Parse the main Element (recursive)\n            this.tags = this._parseElement(this.element)\n\n            if (! this.tags) {\n                reject(new Error('No supported tags found.'))\n            }\n\n            // Apply matrix (recursive)\n            this.tags.applyMatrix()\n\n            // Resolve the promise\n            resolve(this.tags)\n        })\n    }\n\n    // On tag callback\n    _onTag(tag) {\n        //console.info('onTag:', tag)\n    }\n\n    // Register on tag callback\n    onTag(callback, context) {\n        this._onTag = tag => callback.call(context || this, tag)\n    }\n\n    // Parse the provided Element and return an Tag collection (recursive)\n    _parseElement(element, parent) {\n        // Create base tag object\n        let tag = new Tag(element, parent)\n\n        // Exluded tag ?\n        if (this.skipTags.indexOf(tag.name) !== -1) {\n            return null // silent\n        }\n\n        // Supported tag ?\n        if (this.parseTags.indexOf(tag.name) === -1) {\n            return this._skipTag(tag, 'unsupported')\n        }\n\n        // Parse the tag\n        let tagParser = new TagParser(tag, this)\n\n        if (! tagParser.parse()) {\n            return false\n        }\n\n        // Call the on tag callback\n        this._onTag(tag)\n\n        // Parse child nodes\n        let childTag\n\n        element.childNodes.forEach(childNode => {\n            // Parse child element\n            if (childTag = this._parseElement(childNode, tag)) {\n                tag.addChild(childTag)\n            }\n        })\n\n        // Empty group\n        if (['svg', 'g'].indexOf(tag.name) !== -1 && ! tag.children.length) {\n            return this._skipTag(tag, 'empty')\n        }\n\n        // Return tag object\n        return tag\n    }\n\n    // Log skip tag warning message\n    _skipTag(tag, message) {\n        console.warn('Skip tag :', message + ':', tag)\n        return false\n    }\n\n    // Log skip tag attribute warning message\n    _skipTagAttr(tag, attr, message) {\n        console.warn('Skip tag attribute :', message + ':', attr, tag)\n        return false\n    }\n\n}\n\n// Exports\nexport { Parser }\nexport default Parser\n\n\n\n// WEBPACK FOOTER //\n// ./parser.js","import { Path, Point } from 'lw.svg-path'\nimport clipper from 'clipper-lib'\n\nconst DEG_TO_RAD = Math.PI / 180\n\n// SVG tag class\nclass Tag {\n    // Class constructor...\n    constructor(element, parent) {\n        // Init properties\n        this.element  = element\n        this.name     = element.nodeName.toLowerCase()\n        this.parent   = parent || null\n        this.layer    = null\n        this.attrs    = {}\n        this.children = []\n        this.paths    = []\n        this.matrix   = null\n        this.path     = new Path()\n        this.point    = new Point(0, 0)\n        this.shapes   = []\n\n        // Add first path\n        this.paths.push(this.path)\n\n        // Set the matrix\n        this.setMatrix(this.parent && this.parent.matrix)\n\n        // Clone parent attributes\n        if (this.parent && (this.parent.name === 'g' || this.parent.name === 'svg')) {\n            // Inherit layer name\n            this.layer = this.parent.layer\n\n            // Inherit parent attributes\n            let excludes = ['transform', 'width', 'height']\n\n            if (this.name !== 'g' && this.name !== 'svg') {\n                excludes.push('viewBox')\n            }\n\n            Object.keys(this.parent.attrs).forEach(key => {\n                if (excludes.indexOf(key) === -1) {\n                    this.setAttr(key, this.parent.attrs[key])\n                }\n            })\n        }\n    }\n\n    setAttr(name, value) {\n        this.attrs[name] = value\n    }\n\n    getAttr(name, defaultValue) {\n        return this.attrs[name] !== undefined ? this.attrs[name]\n            : (defaultValue !== undefined ? defaultValue : null)\n    }\n\n    getLayerName() {\n        if (this.name === 'g') {\n            return this.getAttr('inkscape:label', this.getAttr('id', null))\n        }\n    }\n\n    setLayerName(name) {\n        if (this.name === 'g') {\n            this.layer = name || this.getLayerName()\n        }\n    }\n\n    addChild(childTag) {\n        this.children.push(childTag)\n    }\n\n    clearPath() {\n        this.path = new Path()\n    }\n\n    newPath() {\n        if (this.path.length > 0) {\n            this.clearPath()\n            this.paths.push(this.path)\n        }\n    }\n\n    closePath() {\n        return this.path.close()\n    }\n\n    addPoint(x, y, relative) {\n        // Relative from the last point\n        if (relative) {\n            x += this.point.x\n            y += this.point.y\n        }\n\n        // Add current point\n        this.path.addPoint(x, y)\n\n        // Update current point\n        this.point = this.path.getPoint(-1)\n    }\n\n    addPoints(points, relative) {\n        // For each couple of points\n        for (let i = 0, il = points.length; i < il; i += 2) {\n            this.addPoint(points[i], points[i + 1], relative)\n        }\n    }\n\n    setMatrix(matrix) {\n        this.matrix = matrix || [1, 0, 0, 1, 0, 0]\n    }\n\n    addMatrix(matrix) {\n        this.matrix = [\n            this.matrix[0] * matrix[0] + this.matrix[2] * matrix[1],\n            this.matrix[1] * matrix[0] + this.matrix[3] * matrix[1],\n            this.matrix[0] * matrix[2] + this.matrix[2] * matrix[3],\n            this.matrix[1] * matrix[2] + this.matrix[3] * matrix[3],\n            this.matrix[0] * matrix[4] + this.matrix[2] * matrix[5] + this.matrix[4],\n            this.matrix[1] * matrix[4] + this.matrix[3] * matrix[5] + this.matrix[5]\n        ]\n    }\n\n    translate(x, y) {\n        y = y === undefined ? 0 : y\n        this.addMatrix([1, 0, 0, 1, x, y])\n    }\n\n    rotate(angle, x, y) {\n        angle = angle * DEG_TO_RAD\n\n        if (arguments.length == 2) {\n            this.addMatrix([1, 0, 0, 1, x, y])\n        }\n\n        this.addMatrix([Math.cos(angle), Math.sin(angle), -Math.sin(angle), Math.cos(angle), 0, 0])\n\n        if (arguments.length == 2) {\n            this.addMatrix([1, 0, 0, 1, -x, -y])\n        }\n    }\n\n    scale(x, y) {\n        y = y === undefined ? x : y\n        this.addMatrix([x, 0, 0, y, 0, 0])\n    }\n\n    skewX(angle) {\n        this.addMatrix([1, 0, Math.tan(angle * DEG_TO_RAD), 1, 0, 0])\n    }\n\n    skewY(angle) {\n        this.addMatrix([1, Math.tan(angle * DEG_TO_RAD), 0, 1, 0, 0])\n    }\n\n    applyMatrix(matrix) {\n        matrix && this.addMatrix(matrix)\n\n        this.paths.forEach(path => {\n            path.transform(this.matrix)\n        })\n\n        this.shapes.forEach(shape => {\n            shape.outer.transform(this.matrix)\n            shape.holes.forEach(hole => {\n                hole.transform(this.matrix)\n            })\n        })\n\n        this.setMatrix(null)\n\n        this.children.forEach(tag => {\n            tag.applyMatrix(matrix)\n        })\n    }\n\n    getPaths() {\n        return this.paths\n    }\n\n    getShapes() {\n        // No shapes...\n        if (this.getAttr('fill', 'none') === 'none' || ! this.paths[0].length) {\n            return this.shapes\n        }\n\n        // Get fill rule\n        let fillRule = this.getAttr('fill-rule', 'nonzero')\n            fillRule = fillRule === 'nonzero' ? clipper.PolyFillType.pftNonZero : clipper.PolyFillType.pftEvenOdd\n\n        // Create clipper path\n        let cPolyTree    = new clipper.PolyTree()\n        let cClipper     = new clipper.Clipper()\n        let clipperScale = 10000000\n        let clipperPaths = []\n\n        this.paths.forEach(path => {\n            clipperPaths.push(path.getClipperPoints(clipperScale))\n        })\n\n        cClipper.AddPaths(clipperPaths, clipper.PolyType.ptSubject, true)\n        cClipper.Execute(clipper.ClipType.ctUnion, cPolyTree, fillRule, fillRule)\n\n        let paths     = clipper.Clipper.PolyTreeToPaths(cPolyTree)\n        let polygones = clipper.Clipper.SimplifyPolygons(paths, fillRule)\n\n        // Single path (no hole)\n        if (this.paths.length > 1) {\n            cClipper.Clear()\n            cClipper.StrictlySimple = true\n            cPolyTree = new clipper.PolyTree()\n            cClipper.AddPaths(polygones, clipper.PolyType.ptSubject, true)\n            cClipper.Execute(clipper.ClipType.ctUnion, cPolyTree, fillRule, fillRule)\n        }\n\n        // PolyTree to ExPolygons\n        let toPath     = path => new Path().fromClipperPoints(path, 1 / clipperScale)\n        let exPolygons = clipper.JS.PolyTreeToExPolygons(cPolyTree)\n        this.shapes    = exPolygons.map(exPolygon => {\n            return {\n                outer: toPath(exPolygon.outer),\n                holes: exPolygon.holes.map(toPath)\n            }\n        })\n\n        // Return shapes...\n        return this.shapes\n    }\n}\n\n// Exports\nexport { Tag }\nexport default Tag\n\n\n\n// WEBPACK FOOTER //\n// ./tag.js","import { Arc, CubicBezier, QuadricBezier } from 'lw.svg-curves'\nimport { Point, Path } from 'lw.svg-path'\n\n// SVG tag parser\nclass TagParser {\n    // Class constructor...\n    constructor(tag, parser) {\n        // Init properties\n        this.tag            = tag\n        this.parser         = parser\n        this.currentCommand = null\n        this.lastCommand    = null\n        this.pathData       = null\n        this.traceSettings  = parser.traceSettings\n    }\n\n    parse() {\n        // Get internal parser from node name\n        let handler = this['_' + this.tag.name]\n\n        // Implemented tag handler?\n        if (! handler || typeof handler !== 'function') {\n            return this.parser._skipTag(this.tag, 'not yet implemented')\n        }\n\n        // Parse tag attributes\n        this._parseTagAttrs()\n\n        // Parse tag\n        return handler.call(this)\n    }\n\n    // Parse the tag attributes\n    _parseTagAttrs() {\n        // Get tag attributes\n        let attrs = this.tag.element.attributes\n\n        if (! attrs) {\n            return null\n        }\n\n        // Get viewBox attribute if any\n        let viewBox = attrs.getNamedItem('viewBox')\n\n        if (viewBox) {\n            this.tag.setAttr('viewBox', this._normalizeTagAttrPoints(viewBox))\n        }\n\n        // For each attribute\n        let attr, value, style\n\n        Object.keys(attrs).some(key => {\n            // Current attribute\n            attr = attrs[key]\n\n            // Normalize attribute value\n            value = this._normalizeTagAttr(attr)\n\n            if (value === false) {\n                return false // continue\n            }\n\n            // Special case\n            if (attr.nodeName === 'style') {\n                style = value\n            }\n            else {\n                // Set new attribute name/value\n                this.tag.setAttr(attr.nodeName, value)\n            }\n        })\n\n        // If style attribute (override tag attributes)\n        // TODO get/parse global style and override this one...\n        style && style.replace(/;$/, '').split(';').some(attr => {\n            // Current style\n            attr = attr.split(':')\n            attr = { nodeName: attr[0], nodeValue: attr[1] }\n\n            // Normalize attribute value\n            value = this._normalizeTagAttr(attr)\n\n            if (value === false) {\n                return false // continue\n            }\n\n            // Set new attribute name/value\n            this.tag.setAttr(attr.nodeName, value)\n        })\n\n        // Set inherited color\n        let colorsAttrs = ['fill', 'stroke', 'color']\n\n        colorsAttrs.forEach(attrName => {\n            if (this.tag.getAttr(attrName) === 'inherit') {\n                this.tag.setAttr(attrName, this.tag.parent.getAttr(attrName, 'none'))\n            }\n        })\n\n        // Parse viewBox attribute\n        this._parseViewBoxAttr()\n\n        // Parse transform attribute\n        this._parseTransformAttr()\n    }\n\n    // Normalize tag attribute\n    _normalizeTagAttr(attr) {\n        // Normalize whitespaces\n        let value = attr.nodeValue\n            .replace(/(\\r?\\n|\\r)+/gm, ' ') // Remove all new line chars\n            .replace(/\\s+/gm, ' ')         // Reduce multiple whitespaces\n            .trim()                        // Remove trailing whitespaces\n\n        if (! value.length) {\n            return this.parser._skipTagAttr(this.tag, attr, 'empty')\n        }\n\n        // Filters\n        switch (attr.nodeName) {\n            // Normalize size unit -> to px\n            case 'x':\n            case 'y':\n            case 'width':\n            case 'height':\n                value = this._normalizeTagAttrUnit(attr)\n            break\n\n            case 'x1':\n            case 'y1':\n            case 'x2':\n            case 'y2':\n            case 'r':\n            case 'rx':\n            case 'ry':\n            case 'cx':\n            case 'cy':\n            case 'font-size':\n            case 'stroke-width':\n                value = this._normalizeTagAttrUnit(attr, true)\n            break\n\n            // Normalize points attribute\n            case 'points':\n            //case 'viewBox':\n                value = this._normalizeTagAttrPoints(attr)\n            break\n\n            case 'viewBox':\n                value = false\n            break\n\n            // Range limit to [0 - 1]\n            case 'opacity':\n            case 'fill-opacity':\n            case 'stroke-opacity':\n                value = this._normalizeTagAttrRange(attr, 0, 1)\n            break\n\n            case 'preserveAspectRatio':\n                value = this._normalizeTagAttrPreserveAspectRatio(attr)\n            break\n        }\n\n        // Return normalized value\n        return value\n    }\n\n    // Normalize attribute unit to px\n    _normalizeTagAttrUnit(attr, ratio) {\n        let stringValue = attr.nodeValue.toLowerCase()\n        let floatValue  = parseFloat(stringValue)\n\n        if (isNaN(floatValue)) {\n            return this.parser._skipTagAttr(this.tag, attr, 'only numeric value allowed')\n        }\n\n        if (stringValue.indexOf('mm') !== -1) {\n            return floatValue * 3.5433070869\n        }\n\n        if (stringValue.indexOf('cm') !== -1) {\n            return floatValue * 35.433070869\n        }\n\n        if (stringValue.indexOf('in') !== -1) {\n            return floatValue * 90.0\n        }\n\n        if (stringValue.indexOf('pt') !== -1) {\n            return floatValue * 1.25\n        }\n\n        if (stringValue.indexOf('pc') !== -1) {\n            return floatValue * 15.0\n        }\n\n        if (stringValue.indexOf('%') !== -1) {\n            let viewBox = this.tag.getAttr('viewBox', this.tag.parent && this.tag.parent.getAttr('viewBox'))\n\n            switch (attr.nodeName) {\n                case 'x':\n                case 'width':\n                    floatValue *= viewBox[2] / 100\n                break\n                case 'y':\n                case 'height':\n                    floatValue *= viewBox[3] / 100\n                break\n            }\n        }\n\n        if (stringValue.indexOf('em') !== -1) {\n            let fontSize = this.tag.getAttr('font-size', 16)\n\n            switch (attr.nodeName) {\n                case 'x':\n                case 'y':\n                case 'width':\n                case 'height':\n                    floatValue *= fontSize\n                break\n            }\n        }\n\n        return floatValue\n    }\n\n    // Normalize points attribute\n    _normalizeTagAttrPoints(attr) {\n        let points = this._parseNumbers(attr.nodeValue)\n\n        if (points === false) {\n            return this.parser._skipTagAttr(this.tag, attr, 'only numeric values are allowed')\n        }\n\n        if (! points.length) {\n            return this.parser._skipTagAttr(this.tag, attr, 'empty points list')\n        }\n\n        if (points.length % 0) {\n            return this.parser._skipTagAttr(this.tag, attr, 'the number of points must be even')\n        }\n\n        return points\n    }\n\n    // Normalize range attribute like \"opacity\"\n    _normalizeTagAttrRange(attr, min, max) {\n        let stringValue = attr.nodeValue.trim()\n        let floatValue  = parseFloat(stringValue)\n\n        if (isNaN(floatValue)) {\n            return this.parser._skipTagAttr(this.tag, attr, 'only numeric values are allowed')\n        }\n\n        if (floatValue < min || floatValue > max) {\n            return this.parser._skipTagAttr(this.tag, attr, 'out of range [' + min + ', ' + max + ']')\n        }\n\n        return floatValue\n    }\n\n    // Parse points string as numbers array\n    _parseNumbers(points) {\n        // http://stackoverflow.com/questions/638565/parsing-scientific-notation-sensibly\n        if (typeof points === 'string') {\n            points = points.split(/([+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)?/g)\n            .filter(point => {\n                return point && ['', ','].indexOf(point.trim()) === -1\n            })\n        }\n\n        // Normalize to float values\n        points = points.map(parseFloat)\n\n        // Test if all numbers is valid\n        if (points.some(isNaN)) {\n            return false\n        }\n\n        return points\n    }\n\n    // Normalize the preserveAspectRatio attribute\n    _normalizeTagAttrPreserveAspectRatio(attr) {\n        let params = {\n            defer: false,\n            align: 'none',\n            meet : true,\n            slice: false\n        }\n\n        let rawParams = attr.nodeValue\n\n        if (rawParams.indexOf('defer') === 0) {\n            rawParams    = rawParams.substr(6)\n            params.defer = true\n        }\n\n        rawParams    = rawParams.split(' ')\n        params.align = rawParams[0]\n        params.meet  = rawParams[1] || 'meet'\n        params.meet  = params.meet === 'meet'\n        params.slice = ! params.meet\n\n        return params\n    }\n\n    // Parse viewBox attribute and set transformations\n    _parseViewBoxAttr() {\n        // Get viewBox attribute\n        let viewBox = this.tag.getAttr('viewBox', null)\n\n        // No viewBox...\n        if (viewBox === null) {\n            return null\n        }\n\n        // Update size attributes\n        let width  = this.tag.getAttr('width', viewBox[2])\n        let height = this.tag.getAttr('height', viewBox[3])\n\n        this.tag.setAttr('width' , width)\n        this.tag.setAttr('height', height)\n\n        // Scale to match viewBox\n        // TODO clip path if preserveAspectRatio.slice\n        let scaleX     = width  / viewBox[2]\n        let scaleY     = height / viewBox[3]\n        let translateX = viewBox[0]\n        let translateY = viewBox[1]\n\n        let preserveAspectRatio = this.tag.getAttr('preserveAspectRatio', 'meet xMidYMid')\n\n        if (preserveAspectRatio) {\n            let newWidth, newHeight\n\n            if (preserveAspectRatio.meet) {\n                if (scaleX > scaleY) {\n                    scaleX   = scaleY\n                    newWidth = viewBox[2] * scaleX\n                }\n                else if (scaleX < scaleY) {\n                    scaleY    = scaleX\n                    newHeight = viewBox[3] * scaleY\n                }\n            }\n            else if (preserveAspectRatio.slice) {\n                if (scaleX < scaleY) {\n                    scaleX   = scaleY\n                    newWidth = viewBox[2] * scaleX\n                }\n                else if (scaleX > scaleY) {\n                    scaleY    = scaleX\n                    newHeight = viewBox[3] * scaleY\n                }\n            }\n\n            if (newWidth !== undefined) {\n                if (preserveAspectRatio.align === 'xMidYMid') {\n                    this.tag.translate((width - newWidth) / 2, 0)\n                }\n                else if (preserveAspectRatio.align === 'xMaxYMax') {\n                    this.tag.translate(width - newWidth, 0)\n                }\n            }\n            else if (newHeight !== undefined) {\n                if (preserveAspectRatio.align === 'xMidYMid') {\n                    this.tag.translate(0, (height - newHeight) / 2)\n                }\n                else if (preserveAspectRatio.align === 'xMaxYMax') {\n                    this.tag.translate(0, height - newHeight)\n                }\n            }\n        }\n\n        this.tag.scale(scaleX, scaleY)\n        this.tag.translate(-translateX, -translateY)\n    }\n\n    // Parse transform attribute and set transformations\n    _parseTransformAttr() {\n        // Get transform attribute\n        let transformAttr = this.tag.getAttr('transform', null)\n\n        // No transformation...\n        if (transformAttr === null || ! transformAttr.length) {\n            return null\n        }\n\n        // Parse attribute (split group on closing parenthesis)\n        let transformations = transformAttr.split(')')\n\n        // Remove last entry due to last \")\" found\n        transformations.pop()\n\n        // For each transformation\n        let transform, type, params\n\n        transformations.some(raw => {\n            // Split name and value on opening parenthesis\n            transform = raw.split('(')\n\n            // Invalid parts number\n            if (transform.length !== 2) {\n                return this.parser._skipTagAttr(this.tag, transformAttr, 'malformed') // continue\n            }\n\n            type = transform[0].trim()\n\n            // Quik hack 1/2\n            let func = type\n            if (func === 'matrix') {\n                func = 'addMatrix'\n            }\n\n            // Get tag transform method\n            let tagTransform = this.tag[func]\n\n            if (typeof tagTransform !== 'function') {\n                return this.parser._skipTagAttr(this.tag, transformAttr, 'unsupported transform type :' + type)\n            }\n\n            params = transform[1].trim()\n            params = this._parseNumbers(params)\n\n            // Skip empty value\n            if (! params.length) {\n                return this.parser._skipTagAttr(this.tag, transformAttr, 'malformed transform type :' + type)\n            }\n\n            // Quik hack 2/2\n            if (func == 'addMatrix') {\n                params = [params]\n            }\n\n            // Call tag transform method like \"tag.translate(param1, ..., paramN)\"\n            tagTransform.apply(this.tag, params)\n        })\n    }\n\n    _newPath() {\n        this.tag.newPath()\n    }\n\n    _clearPath() {\n        this.tag.clearPath()\n    }\n\n    _closePath() {\n        return this.tag.closePath()\n    }\n\n    _addPoints(points, relative) {\n        if (! points.length) {\n            return this.parser._skipTag(this.tag, 'empty points list')\n        }\n\n        if (points.length % 0) {\n            return this.parser._skipTag(this.tag, 'the number of points must be even')\n        }\n\n        relative = arguments.length < 2 && this.currentCommand.relative\n\n        this.tag.addPoints(points, relative)\n        return true\n    }\n\n    // SVG specs at https://www.w3.org/TR/SVG11/\n\n    _svg() {\n        // Only parse the root SVG tag as main document\n        if (this.parser.document) {\n            // Handled tag\n            return true\n        }\n\n        // Get the document size\n        let width  = this.tag.getAttr('width')\n        let height = this.tag.getAttr('height')\n\n        // Invalid size\n        if (! width || width < 0 || ! height || height < 0) {\n            throw new Error('Invalid document size: ' + width + ' / ' + height)\n        }\n\n        // Set document size\n        this.parser.document = {\n            width : width,\n            height: height\n        }\n\n        // Get document viewBox or set default to document size\n        let viewBox = this.tag.getAttr('viewBox', [0, 0, width, height])\n\n        this.parser.document.viewBox = {\n            x     : viewBox[0],\n            y     : viewBox[1],\n            width : viewBox[2],\n            height: viewBox[3]\n        }\n\n        // Check inkscape version\n        if (this.parser.editor.name === 'inkscape') {\n            this.parser.editor.version = this.tag.getAttr('inkscape:version')\n        }\n\n        // Handled tag\n        return true\n    }\n\n    _title() {\n        // Register the first encountered title tag as document title\n        if (this.parser.document && ! this.parser.document.title) {\n            this.parser.document.title = this.tag.element.textContent\n        }\n\n        // Skipped tag\n        return false\n    }\n\n    _desc() {\n        // Register the first encountered desc tag as document description\n        if (this.parser.document && ! this.parser.document.description) {\n            this.parser.document.description = this.tag.element.textContent\n        }\n\n        // Skipped tag\n        return false\n    }\n\n    _image() {\n        // console.log(this.tag.getAttr('xlink:href'))\n        // Handled tag\n        return true\n    }\n\n    _text() {\n        // console.log(this.tag.element.textContent)\n        // Handled tag\n        return true\n    }\n\n    _defs() {\n        // Register all child element with an id attribute\n        this.tag.element.childNodes.forEach(childNode => {\n            childNode.id && (this.parser.defs[childNode.id] = childNode)\n        })\n\n        // Skipped tag\n        return false\n    }\n\n    _use() {\n        // Get the target id\n        let target  = this.tag.getAttr('xlink:href').replace(/^#/, '')\n\n        // Try to get the defined element\n        let element = this.parser.defs[target]\n\n        if (! element) {\n            return this.parser._skipTag(this.tag, 'undefined reference [' + target + ']')\n        }\n\n        // Parse the defined element and set new parent from <use> tag parent\n        let useTag = this.parser._parseElement(element, this.tag.parent)\n\n        if (! useTag) {\n            return this.parser._skipTag(this.tag, 'empty reference [' + target + ']')\n        }\n\n        // Set matrix from real parent (<use>)\n        useTag.setMatrix(this.tag.matrix)\n\n        // Replace the use tag with new one\n        this.tag.parent.addChild(useTag)\n\n        // Skipped tag\n        return false\n    }\n\n    _g() {\n        // Set the tag layer name\n        this.tag.setLayerName()\n\n        // Handled tag\n        return true\n    }\n\n    _line() {\n        // Handled tag\n        return this._path([\n            'M', this.tag.getAttr('x1'), this.tag.getAttr('y1'),\n            'L', this.tag.getAttr('x2'), this.tag.getAttr('y2')\n        ])\n    }\n\n    _polyline(close=false) {\n        let points = this.tag.getAttr('points')\n        let path   = ['M', points.shift(), points.shift(), 'L']\n\n        path = path.concat(points)\n        close && path.push('Z')\n\n        // Handled tag\n        return this._path(path)\n    }\n\n    _polygon() {\n        // Handled like polyline but closed\n        return this._polyline(true)\n    }\n\n    _rect() {\n        // Get rectangle attributes\n        let w  = this.tag.getAttr('width')\n        let h  = this.tag.getAttr('height')\n        let x  = this.tag.getAttr('x', 0)\n        let y  = this.tag.getAttr('y', 0)\n        let rx = this.tag.getAttr('rx', null)\n        let ry = this.tag.getAttr('ry', null)\n\n        // Simple rect\n        if (!rx && !ry) {\n            // Handled tag\n            return this._path(['M', x, y, 'h', w, 'v', h, 'h', -w, 'z'])\n        }\n\n        // If a properly specified value is provided for rx, but not for ry,\n        // then set both rx and ry to the value of rx and vis-vera...\n        if (rx === null) rx = ry\n        if (ry === null) ry = rx\n\n        // A negative value is an error\n        if (rx === null || rx === null || rx < 0 || ry < 0) {\n            // Skip tag\n            return this.parser._skipTag(this.tag, 'negative value for \"rx/ry\" not allowed')\n        }\n\n        // If rx is greater than half of width, then set rx to half of width.\n        // If ry is greater than half of height, then set ry to half of height.\n        if (rx > w / 2) rx = w / 2\n        if (ry > h / 2) ry = h / 2\n\n        let dx = rx * 2\n        let dy = ry * 2\n\n        // Handled tag\n        return this._path([\n            'M', x + rx, y,\n            'h', w - dx,\n            'c', rx, 0, rx, ry, rx, ry,\n            'v', h - dy,\n            'c', 0, ry, -rx, ry, -rx, ry,\n            'h', -w + dx,\n            'c', -rx, 0, -rx, -ry, -rx, -ry,\n            'v', -h + dy,\n            'c', 0, 0, 0, -ry, rx, -ry,\n            'z'\n        ])\n    }\n\n    _circle() {\n        let r = this.tag.getAttr('r', 0)\n\n        if (r <= 0) {\n            // Skipped tag\n            return false\n        }\n\n        let cx = this.tag.getAttr('cx', 0)\n        let cy = this.tag.getAttr('cy', 0)\n\n        // Handled tag\n        return this._path([\n            'M', cx-r, cy,\n            'A', r, r, 0, 0, 0, cx, cy+r,\n            'A', r, r, 0, 0, 0, cx+r, cy,\n            'A', r, r, 0, 0, 0, cx, cy-r,\n            'A', r, r, 0, 0, 0, cx-r, cy,\n            'Z'\n        ])\n    }\n\n    _ellipse() {\n        let rx = this.tag.getAttr('rx', 0)\n        let ry = this.tag.getAttr('ry', 0)\n\n        if (rx <= 0 || ry <= 0) {\n            // Skipped tag\n            return false\n        }\n\n        let cx = this.tag.getAttr('cx', 0)\n        let cy = this.tag.getAttr('cy', 0)\n\n        // Handled tag\n        return this._path([\n            'M', cx-rx, cy,\n            'A', rx, ry, 0, 0, 0, cx, cy+ry,\n            'A', rx, ry, 0, 0, 0, cx+rx, cy,\n            'A', rx, ry, 0, 0, 0, cx, cy-ry,\n            'A', rx, ry, 0, 0, 0, cx-rx, cy,\n            'Z'\n        ])\n    }\n\n    _paths(type, num, points) {\n        if (points.length > num) {\n            let handler, result = true\n\n            while(result && points.length) {\n                handler = this['_path' + type]\n                result  = handler.call(this, points.splice(0, num))\n            }\n\n            return result\n        }\n\n        return null\n    }\n\n    _path(path) {\n        // Provided path\n        if (path && typeof path !== 'string') {\n            path = path.join(' ')\n        }\n\n        // Get the paths data attribute value\n        let dAttr = path || this.tag.getAttr('d', null)\n\n        if (! dAttr) {\n            // Skipped tag\n            return false\n        }\n\n        // Split on each commands\n        let commands = dAttr.match(/([M|Z|L|H|V|C|S|Q|T|A]+([^M|Z|L|H|V|C|S|Q|T|A]+)?)/gi)\n\n        if (! commands) {\n            return this.parser._skipTag(this.tag, 'malformed \"d\" attribute')\n        }\n\n        // For each command...\n        this.currentCommand = {\n            raw     : null,\n            type    : null,\n            params  : null,\n            relative: null\n        }\n        this.lastCommand = this.currentCommand\n        this.pathData    = {}\n\n        let handler    = null\n        let parseError = false\n\n        commands.some(raw => {\n            // Remove trailing whitespaces\n            raw = raw.trim()\n\n            // Extract command char and params\n            this.currentCommand.raw      = raw\n            this.currentCommand.type     = raw[0].toUpperCase()\n            this.currentCommand.params   = raw.substr(1).trim()\n            this.currentCommand.relative = this.currentCommand.type !== raw[0]\n\n            // Get path handler from command char\n            handler = this['_path' + this.currentCommand.type]\n\n            if (! handler || typeof handler !== 'function') {\n                this.parser._skipTag(this.tag, 'unsupported path command [' + raw[0] + ']')\n                return parseError = true // break\n            }\n\n            // Extract all numbers from arguments string\n            this.currentCommand.params = this._parseNumbers(this.currentCommand.params)\n\n            if (this.currentCommand.params === false) {\n                this.parser._skipTag(this.tag, 'only numeric values are allowed in [' + this.currentCommand.raw + ']')\n                return parseError = true // break\n            }\n\n            // Execute command parser\n            if (! handler.call(this, this.currentCommand.params)) {\n                return parseError = true // break\n            }\n\n            // Update last command\n            this.lastCommand = {}\n\n            Object.keys(this.currentCommand).forEach(key => {\n                this.lastCommand[key] = this.currentCommand[key]\n            })\n        })\n\n        // Skip tag\n        if (parseError) {\n            this._clearPath()\n            return false\n        }\n\n        // Handled tag\n        return true\n    }\n\n    _pathM(points) {\n        // New path\n        this._newPath()\n\n        // Set the current point (start of new path)\n        // If is followed by multiple pairs of coordinates,\n        // the subsequent pairs are treated as implicit lineto commands.\n        return this._addPoints(points)\n    }\n\n    _pathZ() {\n        this._closePath()\n        return true\n    }\n\n    _pathL(points) {\n        return this._addPoints(points)\n    }\n\n    _pathH(points) {\n        return points.every(x => {\n            return this._addPoints([x, this.currentCommand.relative ? 0 : this.tag.point.y])\n        })\n    }\n\n    _pathV(points) {\n        return points.every(y => {\n            return this._addPoints([this.currentCommand.relative ? 0 : this.tag.point.x, y])\n        })\n    }\n\n    _pathC(points) {\n        // Multiple paths\n        let result = this._paths('C', 6, points)\n\n        if (result !== null) {\n            return result\n        }\n\n        // Single path\n        let p1 = this.tag.point\n        let rl = this.currentCommand.relative\n\n        let x1 = points[0] + (rl ? p1.x : 0)\n        let y1 = points[1] + (rl ? p1.y : 0)\n        let x2 = points[2] + (rl ? p1.x : 0)\n        let y2 = points[3] + (rl ? p1.y : 0)\n        let x  = points[4] + (rl ? p1.x : 0)\n        let y  = points[5] + (rl ? p1.y : 0)\n\n        this.pathData.x2 = x2\n        this.pathData.y2 = y2\n\n        let p2 = new Point(x1, y1)\n        let p3 = new Point(x2, y2)\n        let p4 = new Point(x, y)\n\n        //console.log('C', p1, p2, p3, p4)\n\n        // p1  : starting point\n        // p2  : control point\n        // p3  : control point\n        // p4  : end point\n        let tracer = new CubicBezier(this.traceSettings)\n        let coords = tracer.trace({ p1, p2, p3, p4 }) // => [x,y, x,y, ...]\n        // let tracer = trace(CubicBezier, this.traceSettings)\n        // let coords = tracer({ p1, p2, p3, p4 })\n\n        // Trace the line\n        return this._addPoints(coords, false)\n    }\n\n    _pathS(points) {\n        // Multiple paths\n        let result = this._paths('S', 4, points)\n\n        if (result !== null) {\n            return result\n        }\n\n        // Single path\n        let p1 = this.tag.point\n        let rl = this.currentCommand.relative\n\n        let x1 = p1.x\n        let y1 = p1.y\n\n        if (this.lastCommand.type === 'S' || this.lastCommand.type === 'C') {\n            x1 -= this.pathData.x2 - x1\n            y1 -= this.pathData.y2 - y1\n        }\n\n        let x2 = points[0] + (rl ? p1.x : 0)\n        let y2 = points[1] + (rl ? p1.y : 0)\n        let x  = points[2] + (rl ? p1.x : 0)\n        let y  = points[3] + (rl ? p1.y : 0)\n\n        this.pathData.x2 = x2\n        this.pathData.y2 = y2\n\n        let p2 = new Point(x1, y1)\n        let p3 = new Point(x2, y2)\n        let p4 = new Point(x, y)\n\n        //console.log('S', p1, p2, p3, p4)\n\n        // p1  : starting point\n        // p2  : control point\n        // p3  : control point\n        // p4  : end point\n        let tracer = new CubicBezier(this.traceSettings)\n        let coords = tracer.trace({ p1, p2, p3, p4 }) // => [x,y, x,y, ...]\n        // let tracer = trace(CubicBezier, this.traceSettings)\n        // let coords = tracer({ p1, p2, p3, p4 })\n\n        // Trace the line\n        return this._addPoints(coords, false)\n    }\n\n    _pathQ(points) {\n        // Multiple paths\n        let result = this._paths('Q', 4, points)\n\n        if (result !== null) {\n            return result\n        }\n\n        // Single path\n        let p1 = this.tag.point\n        let rl = this.currentCommand.relative\n\n        let x1 = points[0] + (rl ? p1.x : 0)\n        let y1 = points[1] + (rl ? p1.y : 0)\n        let x  = points[2] + (rl ? p1.x : 0)\n        let y  = points[3] + (rl ? p1.y : 0)\n\n        this.pathData.x1 = x1\n        this.pathData.y1 = y1\n\n        let p2 = new Point(x1, y1)\n        let p3 = new Point(x, y)\n\n        //console.log('Q', p1, p2, p3)\n\n        // p1  : starting point\n        // p2  : control point\n        // p3  : end point\n        let tracer = new QuadricBezier(this.traceSettings)\n        let coords = tracer.trace({ p1, p2, p3 }) // => [x,y, x,y, ...]\n\n        // Trace the line\n        return this._addPoints(coords, false)\n    }\n\n    _pathT(points) {\n        // Multiple paths\n        let result = this._paths('T', 2, points)\n\n        if (result !== null) {\n            return result\n        }\n\n        // Single path\n        let p1 = this.tag.point\n        let rl = this.currentCommand.relative\n\n        let x1 = p1.x\n        let y1 = p1.y\n\n        if (this.lastCommand.type === 'Q' || this.lastCommand.type === 'T') {\n            x1 -= this.pathData.x1 - x1\n            y1 -= this.pathData.y1 - y1\n        }\n\n        let x = points[0] + (rl ? p1.x : 0)\n        let y = points[1] + (rl ? p1.y : 0)\n\n        this.pathData.x1 = x1\n        this.pathData.y1 = y1\n\n        let p2 = new Point(x1, y1)\n        let p3 = new Point(x, y)\n\n        //console.log('T', p1, p2, p3)\n\n        // p1  : starting point\n        // p2  : control point\n        // p3  : end point\n        let tracer = new QuadricBezier(this.traceSettings)\n        let coords = tracer.trace({ p1, p2, p3 }) // => [x,y, x,y, ...]\n\n        // Trace the line\n        return this._addPoints(coords, false)\n    }\n\n    _pathA(points) {\n        // Multiple paths\n        let result = this._paths('A', 7, points)\n\n        if (result !== null) {\n            return result\n        }\n\n        // Single path\n        let rl    = this.currentCommand.relative\n        let p1    = this.tag.point\n        let rx    = points[0]\n        let ry    = points[1]\n        let angle = points[2]\n        let large = !!points[3]\n        let sweep = !!points[4]\n        let x     = points[5] + (rl ? p1.x : 0)\n        let y     = points[6] + (rl ? p1.y : 0)\n        let p2    = new Point(x, y)\n\n        //console.log('A', p1, rx, ry, angle, large, sweep, p2)\n\n        let tracer = new Arc(this.traceSettings)\n        let coords = tracer.trace({ p1, rx, ry, angle, large, sweep, p2 }) // => [x,y, x,y, ...]\n\n        // Trace the line\n        return this._addPoints(coords, false)\n    }\n}\n\n// Exports\nexport { TagParser }\nexport default TagParser\n\n\n\n// WEBPACK FOOTER //\n// ./tagparser.js","// rev 482\n/********************************************************************************\n *                                                                              *\n * Author    :  Angus Johnson                                                   *\n * Version   :  6.2.1                                                          *\n * Date      :  31 October 2014                                                 *\n * Website   :  http://www.angusj.com                                           *\n * Copyright :  Angus Johnson 2010-2014                                         *\n *                                                                              *\n * License:                                                                     *\n * Use, modification & distribution is subject to Boost Software License Ver 1. *\n * http://www.boost.org/LICENSE_1_0.txt                                         *\n *                                                                              *\n * Attributions:                                                                *\n * The code in this library is an extension of Bala Vatti's clipping algorithm: *\n * \"A generic solution to polygon clipping\"                                     *\n * Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *\n * http://portal.acm.org/citation.cfm?id=129906                                 *\n *                                                                              *\n * Computer graphics and geometric modeling: implementation and algorithms      *\n * By Max K. Agoston                                                            *\n * Springer; 1 edition (January 4, 2005)                                        *\n * http://books.google.com/books?q=vatti+clipping+agoston                       *\n *                                                                              *\n * See also:                                                                    *\n * \"Polygon Offsetting by Computing Winding Numbers\"                            *\n * Paper no. DETC2005-85513 pp. 565-575                                         *\n * ASME 2005 International Design Engineering Technical Conferences             *\n * and Computers and Information in Engineering Conference (IDETC/CIE2005)      *\n * September 24-28, 2005 , Long Beach, California, USA                          *\n * http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *\n *                                                                              *\n *******************************************************************************/\n/*******************************************************************************\n *                                                                              *\n * Author    :  Timo                                                            *\n * Version   :  6.2.1.0                                                         *\n * Date      :  17 June 2016                                                 *\n *                                                                              *\n * This is a translation of the C# Clipper library to Javascript.               *\n * Int128 struct of C# is implemented using JSBN of Tom Wu.                     *\n * Because Javascript lacks support for 64-bit integers, the space              *\n * is a little more restricted than in C# version.                              *\n *                                                                              *\n * C# version has support for coordinate space:                                 *\n * +-4611686018427387903 ( sqrt(2^127 -1)/2 )                                   *\n * while Javascript version has support for space:                              *\n * +-4503599627370495 ( sqrt(2^106 -1)/2 )                                      *\n *                                                                              *\n * Tom Wu's JSBN proved to be the fastest big integer library:                  *\n * http://jsperf.com/big-integer-library-test                                   *\n *                                                                              *\n * This class can be made simpler when (if ever) 64-bit integer support comes.  *\n *                                                                              *\n *******************************************************************************/\n/*******************************************************************************\n *                                                                              *\n * Basic JavaScript BN library - subset useful for RSA encryption.              *\n * http://www-cs-students.stanford.edu/~tjw/jsbn/                               *\n * Copyright (c) 2005  Tom Wu                                                   *\n * All Rights Reserved.                                                         *\n * See \"LICENSE\" for details:                                                   *\n * http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE                        *\n *                                                                              *\n *******************************************************************************/\n(function ()\n{\n  \"use strict\";\n  //use_int32: When enabled 32bit ints are used instead of 64bit ints. This\n  //improve performance but coordinate values are limited to the range +/- 46340\n  var use_int32 = false;\n  //use_xyz: adds a Z member to IntPoint. Adds a minor cost to performance.\n  var use_xyz = false;\n  //UseLines: Enables open path clipping. Adds a very minor cost to performance.\n  var use_lines = true;\n\n  var ClipperLib = {};\n  var isNode = false;\n  if (typeof module !== 'undefined' && module.exports)\n  {\n    module.exports = ClipperLib;\n    isNode = true;\n  }\n  else\n  {\n    if (typeof define === 'function' && define.amd) {\n      define(ClipperLib);\n    }\n    if (typeof (document) !== \"undefined\") window.ClipperLib = ClipperLib;\n    else self['ClipperLib'] = ClipperLib;\n  }\n  var navigator_appName;\n  if (!isNode)\n  {\n    var nav = navigator.userAgent.toString().toLowerCase();\n    navigator_appName = navigator.appName;\n  }\n  else\n  {\n    var nav = \"chrome\"; // Node.js uses Chrome's V8 engine\n    navigator_appName = \"Netscape\"; // Firefox, Chrome and Safari returns \"Netscape\", so Node.js should also\n  }\n  // Browser test to speedup performance critical functions\n  var browser = {};\n  if (nav.indexOf(\"chrome\") != -1 && nav.indexOf(\"chromium\") == -1) browser.chrome = 1;\n  else browser.chrome = 0;\n  if (nav.indexOf(\"chromium\") != -1) browser.chromium = 1;\n  else browser.chromium = 0;\n  if (nav.indexOf(\"safari\") != -1 && nav.indexOf(\"chrome\") == -1 && nav.indexOf(\"chromium\") == -1) browser.safari = 1;\n  else browser.safari = 0;\n  if (nav.indexOf(\"firefox\") != -1) browser.firefox = 1;\n  else browser.firefox = 0;\n  if (nav.indexOf(\"firefox/17\") != -1) browser.firefox17 = 1;\n  else browser.firefox17 = 0;\n  if (nav.indexOf(\"firefox/15\") != -1) browser.firefox15 = 1;\n  else browser.firefox15 = 0;\n  if (nav.indexOf(\"firefox/3\") != -1) browser.firefox3 = 1;\n  else browser.firefox3 = 0;\n  if (nav.indexOf(\"opera\") != -1) browser.opera = 1;\n  else browser.opera = 0;\n  if (nav.indexOf(\"msie 10\") != -1) browser.msie10 = 1;\n  else browser.msie10 = 0;\n  if (nav.indexOf(\"msie 9\") != -1) browser.msie9 = 1;\n  else browser.msie9 = 0;\n  if (nav.indexOf(\"msie 8\") != -1) browser.msie8 = 1;\n  else browser.msie8 = 0;\n  if (nav.indexOf(\"msie 7\") != -1) browser.msie7 = 1;\n  else browser.msie7 = 0;\n  if (nav.indexOf(\"msie \") != -1) browser.msie = 1;\n  else browser.msie = 0;\n  ClipperLib.biginteger_used = null;\n\n  // Copyright (c) 2005  Tom Wu\n  // All Rights Reserved.\n  // See \"LICENSE\" for details.\n  // Basic JavaScript BN library - subset useful for RSA encryption.\n  // Bits per digit\n  var dbits;\n  // JavaScript engine analysis\n  var canary = 0xdeadbeefcafe;\n  var j_lm = ((canary & 0xffffff) == 0xefcafe);\n  // (public) Constructor\n  function BigInteger(a, b, c)\n  {\n    // This test variable can be removed,\n    // but at least for performance tests it is useful piece of knowledge\n    // This is the only ClipperLib related variable in BigInteger library\n    ClipperLib.biginteger_used = 1;\n    if (a != null)\n      if (\"number\" == typeof a && \"undefined\" == typeof (b)) this.fromInt(a); // faster conversion\n      else if (\"number\" == typeof a) this.fromNumber(a, b, c);\n    else if (b == null && \"string\" != typeof a) this.fromString(a, 256);\n    else this.fromString(a, b);\n  }\n  // return new, unset BigInteger\n  function nbi()\n  {\n    return new BigInteger(null,undefined,undefined);\n  }\n  // am: Compute w_j += (x*this_i), propagate carries,\n  // c is initial carry, returns final carry.\n  // c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n  // We need to select the fastest one that works in this environment.\n  // am1: use a single mult and divide to get the high bits,\n  // max digit bits should be 26 because\n  // max internal value = 2*dvalue^2-2*dvalue (< 2^53)\n  function am1(i, x, w, j, c, n)\n  {\n    while (--n >= 0)\n    {\n      var v = x * this[i++] + w[j] + c;\n      c = Math.floor(v / 0x4000000);\n      w[j++] = v & 0x3ffffff;\n    }\n    return c;\n  }\n  // am2 avoids a big mult-and-extract completely.\n  // Max digit bits should be <= 30 because we do bitwise ops\n  // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\n  function am2(i, x, w, j, c, n)\n  {\n    var xl = x & 0x7fff,\n      xh = x >> 15;\n    while (--n >= 0)\n    {\n      var l = this[i] & 0x7fff;\n      var h = this[i++] >> 15;\n      var m = xh * l + h * xl;\n      l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);\n      c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);\n      w[j++] = l & 0x3fffffff;\n    }\n    return c;\n  }\n  // Alternately, set max digit bits to 28 since some\n  // browsers slow down when dealing with 32-bit numbers.\n  function am3(i, x, w, j, c, n)\n  {\n    var xl = x & 0x3fff,\n      xh = x >> 14;\n    while (--n >= 0)\n    {\n      var l = this[i] & 0x3fff;\n      var h = this[i++] >> 14;\n      var m = xh * l + h * xl;\n      l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;\n      c = (l >> 28) + (m >> 14) + xh * h;\n      w[j++] = l & 0xfffffff;\n    }\n    return c;\n  }\n  if (j_lm && (navigator_appName == \"Microsoft Internet Explorer\"))\n  {\n    BigInteger.prototype.am = am2;\n    dbits = 30;\n  }\n  else if (j_lm && (navigator_appName != \"Netscape\"))\n  {\n    BigInteger.prototype.am = am1;\n    dbits = 26;\n  }\n  else\n  { // Mozilla/Netscape seems to prefer am3\n    BigInteger.prototype.am = am3;\n    dbits = 28;\n  }\n  BigInteger.prototype.DB = dbits;\n  BigInteger.prototype.DM = ((1 << dbits) - 1);\n  BigInteger.prototype.DV = (1 << dbits);\n  var BI_FP = 52;\n  BigInteger.prototype.FV = Math.pow(2, BI_FP);\n  BigInteger.prototype.F1 = BI_FP - dbits;\n  BigInteger.prototype.F2 = 2 * dbits - BI_FP;\n  // Digit conversions\n  var BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n  var BI_RC = new Array();\n  var rr, vv;\n  rr = \"0\".charCodeAt(0);\n  for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\n  rr = \"a\".charCodeAt(0);\n  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n  rr = \"A\".charCodeAt(0);\n  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\n  function int2char(n)\n  {\n    return BI_RM.charAt(n);\n  }\n\n  function intAt(s, i)\n  {\n    var c = BI_RC[s.charCodeAt(i)];\n    return (c == null) ? -1 : c;\n  }\n  // (protected) copy this to r\n  function bnpCopyTo(r)\n  {\n    for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];\n    r.t = this.t;\n    r.s = this.s;\n  }\n  // (protected) set from integer value x, -DV <= x < DV\n  function bnpFromInt(x)\n  {\n    this.t = 1;\n    this.s = (x < 0) ? -1 : 0;\n    if (x > 0) this[0] = x;\n    else if (x < -1) this[0] = x + this.DV;\n    else this.t = 0;\n  }\n  // return bigint initialized to value\n  function nbv(i)\n  {\n    var r = nbi();\n    r.fromInt(i);\n    return r;\n  }\n  // (protected) set from string and radix\n  function bnpFromString(s, b)\n  {\n    var k;\n    if (b == 16) k = 4;\n    else if (b == 8) k = 3;\n    else if (b == 256) k = 8; // byte array\n    else if (b == 2) k = 1;\n    else if (b == 32) k = 5;\n    else if (b == 4) k = 2;\n    else\n    {\n      this.fromRadix(s, b);\n      return;\n    }\n    this.t = 0;\n    this.s = 0;\n    var i = s.length,\n      mi = false,\n      sh = 0;\n    while (--i >= 0)\n    {\n      var x = (k == 8) ? s[i] & 0xff : intAt(s, i);\n      if (x < 0)\n      {\n        if (s.charAt(i) == \"-\") mi = true;\n        continue;\n      }\n      mi = false;\n      if (sh == 0)\n        this[this.t++] = x;\n      else if (sh + k > this.DB)\n      {\n        this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;\n        this[this.t++] = (x >> (this.DB - sh));\n      }\n      else\n        this[this.t - 1] |= x << sh;\n      sh += k;\n      if (sh >= this.DB) sh -= this.DB;\n    }\n    if (k == 8 && (s[0] & 0x80) != 0)\n    {\n      this.s = -1;\n      if (sh > 0) this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;\n    }\n    this.clamp();\n    if (mi) BigInteger.ZERO.subTo(this, this);\n  }\n  // (protected) clamp off excess high words\n  function bnpClamp()\n  {\n    var c = this.s & this.DM;\n    while (this.t > 0 && this[this.t - 1] == c)--this.t;\n  }\n  // (public) return string representation in given radix\n  function bnToString(b)\n  {\n    if (this.s < 0) return \"-\" + this.negate().toString(b);\n    var k;\n    if (b == 16) k = 4;\n    else if (b == 8) k = 3;\n    else if (b == 2) k = 1;\n    else if (b == 32) k = 5;\n    else if (b == 4) k = 2;\n    else return this.toRadix(b);\n    var km = (1 << k) - 1,\n      d, m = false,\n      r = \"\",\n      i = this.t;\n    var p = this.DB - (i * this.DB) % k;\n    if (i-- > 0)\n    {\n      if (p < this.DB && (d = this[i] >> p) > 0)\n      {\n        m = true;\n        r = int2char(d);\n      }\n      while (i >= 0)\n      {\n        if (p < k)\n        {\n          d = (this[i] & ((1 << p) - 1)) << (k - p);\n          d |= this[--i] >> (p += this.DB - k);\n        }\n        else\n        {\n          d = (this[i] >> (p -= k)) & km;\n          if (p <= 0)\n          {\n            p += this.DB;\n            --i;\n          }\n        }\n        if (d > 0) m = true;\n        if (m) r += int2char(d);\n      }\n    }\n    return m ? r : \"0\";\n  }\n  // (public) -this\n  function bnNegate()\n  {\n    var r = nbi();\n    BigInteger.ZERO.subTo(this, r);\n    return r;\n  }\n  // (public) |this|\n  function bnAbs()\n  {\n    return (this.s < 0) ? this.negate() : this;\n  }\n  // (public) return + if this > a, - if this < a, 0 if equal\n  function bnCompareTo(a)\n  {\n    var r = this.s - a.s;\n    if (r != 0) return r;\n    var i = this.t;\n    r = i - a.t;\n    if (r != 0) return (this.s < 0) ? -r : r;\n    while (--i >= 0)\n      if ((r = this[i] - a[i]) != 0) return r;\n    return 0;\n  }\n  // returns bit length of the integer x\n  function nbits(x)\n  {\n    var r = 1,\n      t;\n    if ((t = x >>> 16) != 0)\n    {\n      x = t;\n      r += 16;\n    }\n    if ((t = x >> 8) != 0)\n    {\n      x = t;\n      r += 8;\n    }\n    if ((t = x >> 4) != 0)\n    {\n      x = t;\n      r += 4;\n    }\n    if ((t = x >> 2) != 0)\n    {\n      x = t;\n      r += 2;\n    }\n    if ((t = x >> 1) != 0)\n    {\n      x = t;\n      r += 1;\n    }\n    return r;\n  }\n  // (public) return the number of bits in \"this\"\n  function bnBitLength()\n  {\n    if (this.t <= 0) return 0;\n    return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));\n  }\n  // (protected) r = this << n*DB\n  function bnpDLShiftTo(n, r)\n  {\n    var i;\n    for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];\n    for (i = n - 1; i >= 0; --i) r[i] = 0;\n    r.t = this.t + n;\n    r.s = this.s;\n  }\n  // (protected) r = this >> n*DB\n  function bnpDRShiftTo(n, r)\n  {\n    for (var i = n; i < this.t; ++i) r[i - n] = this[i];\n    r.t = Math.max(this.t - n, 0);\n    r.s = this.s;\n  }\n  // (protected) r = this << n\n  function bnpLShiftTo(n, r)\n  {\n    var bs = n % this.DB;\n    var cbs = this.DB - bs;\n    var bm = (1 << cbs) - 1;\n    var ds = Math.floor(n / this.DB),\n      c = (this.s << bs) & this.DM,\n      i;\n    for (i = this.t - 1; i >= 0; --i)\n    {\n      r[i + ds + 1] = (this[i] >> cbs) | c;\n      c = (this[i] & bm) << bs;\n    }\n    for (i = ds - 1; i >= 0; --i) r[i] = 0;\n    r[ds] = c;\n    r.t = this.t + ds + 1;\n    r.s = this.s;\n    r.clamp();\n  }\n  // (protected) r = this >> n\n  function bnpRShiftTo(n, r)\n  {\n    r.s = this.s;\n    var ds = Math.floor(n / this.DB);\n    if (ds >= this.t)\n    {\n      r.t = 0;\n      return;\n    }\n    var bs = n % this.DB;\n    var cbs = this.DB - bs;\n    var bm = (1 << bs) - 1;\n    r[0] = this[ds] >> bs;\n    for (var i = ds + 1; i < this.t; ++i)\n    {\n      r[i - ds - 1] |= (this[i] & bm) << cbs;\n      r[i - ds] = this[i] >> bs;\n    }\n    if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;\n    r.t = this.t - ds;\n    r.clamp();\n  }\n  // (protected) r = this - a\n  function bnpSubTo(a, r)\n  {\n    var i = 0,\n      c = 0,\n      m = Math.min(a.t, this.t);\n    while (i < m)\n    {\n      c += this[i] - a[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n    if (a.t < this.t)\n    {\n      c -= a.s;\n      while (i < this.t)\n      {\n        c += this[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n      c += this.s;\n    }\n    else\n    {\n      c += this.s;\n      while (i < a.t)\n      {\n        c -= a[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n      c -= a.s;\n    }\n    r.s = (c < 0) ? -1 : 0;\n    if (c < -1) r[i++] = this.DV + c;\n    else if (c > 0) r[i++] = c;\n    r.t = i;\n    r.clamp();\n  }\n  // (protected) r = this * a, r != this,a (HAC 14.12)\n  // \"this\" should be the larger one if appropriate.\n  function bnpMultiplyTo(a, r)\n  {\n    var x = this.abs(),\n      y = a.abs();\n    var i = x.t;\n    r.t = i + y.t;\n    while (--i >= 0) r[i] = 0;\n    for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);\n    r.s = 0;\n    r.clamp();\n    if (this.s != a.s) BigInteger.ZERO.subTo(r, r);\n  }\n  // (protected) r = this^2, r != this (HAC 14.16)\n  function bnpSquareTo(r)\n  {\n    var x = this.abs();\n    var i = r.t = 2 * x.t;\n    while (--i >= 0) r[i] = 0;\n    for (i = 0; i < x.t - 1; ++i)\n    {\n      var c = x.am(i, x[i], r, 2 * i, 0, 1);\n      if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV)\n      {\n        r[i + x.t] -= x.DV;\n        r[i + x.t + 1] = 1;\n      }\n    }\n    if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);\n    r.s = 0;\n    r.clamp();\n  }\n  // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n  // r != q, this != m.  q or r may be null.\n  function bnpDivRemTo(m, q, r)\n  {\n    var pm = m.abs();\n    if (pm.t <= 0) return;\n    var pt = this.abs();\n    if (pt.t < pm.t)\n    {\n      if (q != null) q.fromInt(0);\n      if (r != null) this.copyTo(r);\n      return;\n    }\n    if (r == null) r = nbi();\n    var y = nbi(),\n      ts = this.s,\n      ms = m.s;\n    var nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus\n    if (nsh > 0)\n    {\n      pm.lShiftTo(nsh, y);\n      pt.lShiftTo(nsh, r);\n    }\n    else\n    {\n      pm.copyTo(y);\n      pt.copyTo(r);\n    }\n    var ys = y.t;\n    var y0 = y[ys - 1];\n    if (y0 == 0) return;\n    var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);\n    var d1 = this.FV / yt,\n      d2 = (1 << this.F1) / yt,\n      e = 1 << this.F2;\n    var i = r.t,\n      j = i - ys,\n      t = (q == null) ? nbi() : q;\n    y.dlShiftTo(j, t);\n    if (r.compareTo(t) >= 0)\n    {\n      r[r.t++] = 1;\n      r.subTo(t, r);\n    }\n    BigInteger.ONE.dlShiftTo(ys, t);\n    t.subTo(y, y); // \"negative\" y so we can replace sub with am later\n    while (y.t < ys) y[y.t++] = 0;\n    while (--j >= 0)\n    {\n      // Estimate quotient digit\n      var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);\n      if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd)\n      { // Try it out\n        y.dlShiftTo(j, t);\n        r.subTo(t, r);\n        while (r[i] < --qd) r.subTo(t, r);\n      }\n    }\n    if (q != null)\n    {\n      r.drShiftTo(ys, q);\n      if (ts != ms) BigInteger.ZERO.subTo(q, q);\n    }\n    r.t = ys;\n    r.clamp();\n    if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder\n    if (ts < 0) BigInteger.ZERO.subTo(r, r);\n  }\n  // (public) this mod a\n  function bnMod(a)\n  {\n    var r = nbi();\n    this.abs().divRemTo(a, null, r);\n    if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);\n    return r;\n  }\n  // Modular reduction using \"classic\" algorithm\n  function Classic(m)\n  {\n    this.m = m;\n  }\n\n  function cConvert(x)\n  {\n    if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n    else return x;\n  }\n\n  function cRevert(x)\n  {\n    return x;\n  }\n\n  function cReduce(x)\n  {\n    x.divRemTo(this.m, null, x);\n  }\n\n  function cMulTo(x, y, r)\n  {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n  }\n\n  function cSqrTo(x, r)\n  {\n    x.squareTo(r);\n    this.reduce(r);\n  }\n  Classic.prototype.convert = cConvert;\n  Classic.prototype.revert = cRevert;\n  Classic.prototype.reduce = cReduce;\n  Classic.prototype.mulTo = cMulTo;\n  Classic.prototype.sqrTo = cSqrTo;\n  // (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n  // justification:\n  //         xy == 1 (mod m)\n  //         xy =  1+km\n  //   xy(2-xy) = (1+km)(1-km)\n  // x[y(2-xy)] = 1-k^2m^2\n  // x[y(2-xy)] == 1 (mod m^2)\n  // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n  // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n  // JS multiply \"overflows\" differently from C/C++, so care is needed here.\n  function bnpInvDigit()\n  {\n    if (this.t < 1) return 0;\n    var x = this[0];\n    if ((x & 1) == 0) return 0;\n    var y = x & 3; // y == 1/x mod 2^2\n    y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4\n    y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8\n    y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16\n    // last step - calculate inverse mod DV directly;\n    // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n    y = (y * (2 - x * y % this.DV)) % this.DV; // y == 1/x mod 2^dbits\n    // we really want the negative inverse, and -DV < y < DV\n    return (y > 0) ? this.DV - y : -y;\n  }\n  // Montgomery reduction\n  function Montgomery(m)\n  {\n    this.m = m;\n    this.mp = m.invDigit();\n    this.mpl = this.mp & 0x7fff;\n    this.mph = this.mp >> 15;\n    this.um = (1 << (m.DB - 15)) - 1;\n    this.mt2 = 2 * m.t;\n  }\n  // xR mod m\n  function montConvert(x)\n  {\n    var r = nbi();\n    x.abs().dlShiftTo(this.m.t, r);\n    r.divRemTo(this.m, null, r);\n    if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);\n    return r;\n  }\n  // x/R mod m\n  function montRevert(x)\n  {\n    var r = nbi();\n    x.copyTo(r);\n    this.reduce(r);\n    return r;\n  }\n  // x = x/R mod m (HAC 14.32)\n  function montReduce(x)\n  {\n    while (x.t <= this.mt2) // pad x so am has enough room later\n      x[x.t++] = 0;\n    for (var i = 0; i < this.m.t; ++i)\n    {\n      // faster way of calculating u0 = x[i]*mp mod DV\n      var j = x[i] & 0x7fff;\n      var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;\n      // use am to combine the multiply-shift-add into one call\n      j = i + this.m.t;\n      x[j] += this.m.am(0, u0, x, i, 0, this.m.t);\n      // propagate carry\n      while (x[j] >= x.DV)\n      {\n        x[j] -= x.DV;\n        x[++j]++;\n      }\n    }\n    x.clamp();\n    x.drShiftTo(this.m.t, x);\n    if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n  }\n  // r = \"x^2/R mod m\"; x != r\n  function montSqrTo(x, r)\n  {\n    x.squareTo(r);\n    this.reduce(r);\n  }\n  // r = \"xy/R mod m\"; x,y != r\n  function montMulTo(x, y, r)\n  {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n  }\n  Montgomery.prototype.convert = montConvert;\n  Montgomery.prototype.revert = montRevert;\n  Montgomery.prototype.reduce = montReduce;\n  Montgomery.prototype.mulTo = montMulTo;\n  Montgomery.prototype.sqrTo = montSqrTo;\n  // (protected) true iff this is even\n  function bnpIsEven()\n  {\n    return ((this.t > 0) ? (this[0] & 1) : this.s) == 0;\n  }\n  // (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\n  function bnpExp(e, z)\n  {\n    if (e > 0xffffffff || e < 1) return BigInteger.ONE;\n    var r = nbi(),\n      r2 = nbi(),\n      g = z.convert(this),\n      i = nbits(e) - 1;\n    g.copyTo(r);\n    while (--i >= 0)\n    {\n      z.sqrTo(r, r2);\n      if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);\n      else\n      {\n        var t = r;\n        r = r2;\n        r2 = t;\n      }\n    }\n    return z.revert(r);\n  }\n  // (public) this^e % m, 0 <= e < 2^32\n  function bnModPowInt(e, m)\n  {\n    var z;\n    if (e < 256 || m.isEven()) z = new Classic(m);\n    else z = new Montgomery(m);\n    return this.exp(e, z);\n  }\n  // protected\n  BigInteger.prototype.copyTo = bnpCopyTo;\n  BigInteger.prototype.fromInt = bnpFromInt;\n  BigInteger.prototype.fromString = bnpFromString;\n  BigInteger.prototype.clamp = bnpClamp;\n  BigInteger.prototype.dlShiftTo = bnpDLShiftTo;\n  BigInteger.prototype.drShiftTo = bnpDRShiftTo;\n  BigInteger.prototype.lShiftTo = bnpLShiftTo;\n  BigInteger.prototype.rShiftTo = bnpRShiftTo;\n  BigInteger.prototype.subTo = bnpSubTo;\n  BigInteger.prototype.multiplyTo = bnpMultiplyTo;\n  BigInteger.prototype.squareTo = bnpSquareTo;\n  BigInteger.prototype.divRemTo = bnpDivRemTo;\n  BigInteger.prototype.invDigit = bnpInvDigit;\n  BigInteger.prototype.isEven = bnpIsEven;\n  BigInteger.prototype.exp = bnpExp;\n  // public\n  BigInteger.prototype.toString = bnToString;\n  BigInteger.prototype.negate = bnNegate;\n  BigInteger.prototype.abs = bnAbs;\n  BigInteger.prototype.compareTo = bnCompareTo;\n  BigInteger.prototype.bitLength = bnBitLength;\n  BigInteger.prototype.mod = bnMod;\n  BigInteger.prototype.modPowInt = bnModPowInt;\n  // \"constants\"\n  BigInteger.ZERO = nbv(0);\n  BigInteger.ONE = nbv(1);\n  // Copyright (c) 2005-2009  Tom Wu\n  // All Rights Reserved.\n  // See \"LICENSE\" for details.\n  // Extended JavaScript BN functions, required for RSA private ops.\n  // Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\n  // Version 1.2: square() API, isProbablePrime fix\n  // (public)\n  function bnClone()\n  {\n    var r = nbi();\n    this.copyTo(r);\n    return r;\n  }\n  // (public) return value as integer\n  function bnIntValue()\n  {\n    if (this.s < 0)\n    {\n      if (this.t == 1) return this[0] - this.DV;\n      else if (this.t == 0) return -1;\n    }\n    else if (this.t == 1) return this[0];\n    else if (this.t == 0) return 0;\n    // assumes 16 < DB < 32\n    return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];\n  }\n  // (public) return value as byte\n  function bnByteValue()\n  {\n    return (this.t == 0) ? this.s : (this[0] << 24) >> 24;\n  }\n  // (public) return value as short (assumes DB>=16)\n  function bnShortValue()\n  {\n    return (this.t == 0) ? this.s : (this[0] << 16) >> 16;\n  }\n  // (protected) return x s.t. r^x < DV\n  function bnpChunkSize(r)\n  {\n    return Math.floor(Math.LN2 * this.DB / Math.log(r));\n  }\n  // (public) 0 if this == 0, 1 if this > 0\n  function bnSigNum()\n  {\n    if (this.s < 0) return -1;\n    else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n    else return 1;\n  }\n  // (protected) convert to radix string\n  function bnpToRadix(b)\n  {\n    if (b == null) b = 10;\n    if (this.signum() == 0 || b < 2 || b > 36) return \"0\";\n    var cs = this.chunkSize(b);\n    var a = Math.pow(b, cs);\n    var d = nbv(a),\n      y = nbi(),\n      z = nbi(),\n      r = \"\";\n    this.divRemTo(d, y, z);\n    while (y.signum() > 0)\n    {\n      r = (a + z.intValue()).toString(b).substr(1) + r;\n      y.divRemTo(d, y, z);\n    }\n    return z.intValue().toString(b) + r;\n  }\n  // (protected) convert from radix string\n  function bnpFromRadix(s, b)\n  {\n    this.fromInt(0);\n    if (b == null) b = 10;\n    var cs = this.chunkSize(b);\n    var d = Math.pow(b, cs),\n      mi = false,\n      j = 0,\n      w = 0;\n    for (var i = 0; i < s.length; ++i)\n    {\n      var x = intAt(s, i);\n      if (x < 0)\n      {\n        if (s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\n        continue;\n      }\n      w = b * w + x;\n      if (++j >= cs)\n      {\n        this.dMultiply(d);\n        this.dAddOffset(w, 0);\n        j = 0;\n        w = 0;\n      }\n    }\n    if (j > 0)\n    {\n      this.dMultiply(Math.pow(b, j));\n      this.dAddOffset(w, 0);\n    }\n    if (mi) BigInteger.ZERO.subTo(this, this);\n  }\n  // (protected) alternate constructor\n  function bnpFromNumber(a, b, c)\n  {\n    if (\"number\" == typeof b)\n    {\n      // new BigInteger(int,int,RNG)\n      if (a < 2) this.fromInt(1);\n      else\n      {\n        this.fromNumber(a, c);\n        if (!this.testBit(a - 1)) // force MSB set\n          this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);\n        if (this.isEven()) this.dAddOffset(1, 0); // force odd\n        while (!this.isProbablePrime(b))\n        {\n          this.dAddOffset(2, 0);\n          if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);\n        }\n      }\n    }\n    else\n    {\n      // new BigInteger(int,RNG)\n      var x = new Array(),\n        t = a & 7;\n      x.length = (a >> 3) + 1;\n      b.nextBytes(x);\n      if (t > 0) x[0] &= ((1 << t) - 1);\n      else x[0] = 0;\n      this.fromString(x, 256);\n    }\n  }\n  // (public) convert to bigendian byte array\n  function bnToByteArray()\n  {\n    var i = this.t,\n      r = new Array();\n    r[0] = this.s;\n    var p = this.DB - (i * this.DB) % 8,\n      d, k = 0;\n    if (i-- > 0)\n    {\n      if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)\n        r[k++] = d | (this.s << (this.DB - p));\n      while (i >= 0)\n      {\n        if (p < 8)\n        {\n          d = (this[i] & ((1 << p) - 1)) << (8 - p);\n          d |= this[--i] >> (p += this.DB - 8);\n        }\n        else\n        {\n          d = (this[i] >> (p -= 8)) & 0xff;\n          if (p <= 0)\n          {\n            p += this.DB;\n            --i;\n          }\n        }\n        if ((d & 0x80) != 0) d |= -256;\n        if (k == 0 && (this.s & 0x80) != (d & 0x80))++k;\n        if (k > 0 || d != this.s) r[k++] = d;\n      }\n    }\n    return r;\n  }\n\n  function bnEquals(a)\n  {\n    return (this.compareTo(a) == 0);\n  }\n\n  function bnMin(a)\n  {\n    return (this.compareTo(a) < 0) ? this : a;\n  }\n\n  function bnMax(a)\n  {\n    return (this.compareTo(a) > 0) ? this : a;\n  }\n  // (protected) r = this op a (bitwise)\n  function bnpBitwiseTo(a, op, r)\n  {\n    var i, f, m = Math.min(a.t, this.t);\n    for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);\n    if (a.t < this.t)\n    {\n      f = a.s & this.DM;\n      for (i = m; i < this.t; ++i) r[i] = op(this[i], f);\n      r.t = this.t;\n    }\n    else\n    {\n      f = this.s & this.DM;\n      for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);\n      r.t = a.t;\n    }\n    r.s = op(this.s, a.s);\n    r.clamp();\n  }\n  // (public) this & a\n  function op_and(x, y)\n  {\n    return x & y;\n  }\n\n  function bnAnd(a)\n  {\n    var r = nbi();\n    this.bitwiseTo(a, op_and, r);\n    return r;\n  }\n  // (public) this | a\n  function op_or(x, y)\n  {\n    return x | y;\n  }\n\n  function bnOr(a)\n  {\n    var r = nbi();\n    this.bitwiseTo(a, op_or, r);\n    return r;\n  }\n  // (public) this ^ a\n  function op_xor(x, y)\n  {\n    return x ^ y;\n  }\n\n  function bnXor(a)\n  {\n    var r = nbi();\n    this.bitwiseTo(a, op_xor, r);\n    return r;\n  }\n  // (public) this & ~a\n  function op_andnot(x, y)\n  {\n    return x & ~y;\n  }\n\n  function bnAndNot(a)\n  {\n    var r = nbi();\n    this.bitwiseTo(a, op_andnot, r);\n    return r;\n  }\n  // (public) ~this\n  function bnNot()\n  {\n    var r = nbi();\n    for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];\n    r.t = this.t;\n    r.s = ~this.s;\n    return r;\n  }\n  // (public) this << n\n  function bnShiftLeft(n)\n  {\n    var r = nbi();\n    if (n < 0) this.rShiftTo(-n, r);\n    else this.lShiftTo(n, r);\n    return r;\n  }\n  // (public) this >> n\n  function bnShiftRight(n)\n  {\n    var r = nbi();\n    if (n < 0) this.lShiftTo(-n, r);\n    else this.rShiftTo(n, r);\n    return r;\n  }\n  // return index of lowest 1-bit in x, x < 2^31\n  function lbit(x)\n  {\n    if (x == 0) return -1;\n    var r = 0;\n    if ((x & 0xffff) == 0)\n    {\n      x >>= 16;\n      r += 16;\n    }\n    if ((x & 0xff) == 0)\n    {\n      x >>= 8;\n      r += 8;\n    }\n    if ((x & 0xf) == 0)\n    {\n      x >>= 4;\n      r += 4;\n    }\n    if ((x & 3) == 0)\n    {\n      x >>= 2;\n      r += 2;\n    }\n    if ((x & 1) == 0)++r;\n    return r;\n  }\n  // (public) returns index of lowest 1-bit (or -1 if none)\n  function bnGetLowestSetBit()\n  {\n    for (var i = 0; i < this.t; ++i)\n      if (this[i] != 0) return i * this.DB + lbit(this[i]);\n    if (this.s < 0) return this.t * this.DB;\n    return -1;\n  }\n  // return number of 1 bits in x\n  function cbit(x)\n  {\n    var r = 0;\n    while (x != 0)\n    {\n      x &= x - 1;\n      ++r;\n    }\n    return r;\n  }\n  // (public) return number of set bits\n  function bnBitCount()\n  {\n    var r = 0,\n      x = this.s & this.DM;\n    for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);\n    return r;\n  }\n  // (public) true iff nth bit is set\n  function bnTestBit(n)\n  {\n    var j = Math.floor(n / this.DB);\n    if (j >= this.t) return (this.s != 0);\n    return ((this[j] & (1 << (n % this.DB))) != 0);\n  }\n  // (protected) this op (1<<n)\n  function bnpChangeBit(n, op)\n  {\n    var r = BigInteger.ONE.shiftLeft(n);\n    this.bitwiseTo(r, op, r);\n    return r;\n  }\n  // (public) this | (1<<n)\n  function bnSetBit(n)\n  {\n    return this.changeBit(n, op_or);\n  }\n  // (public) this & ~(1<<n)\n  function bnClearBit(n)\n  {\n    return this.changeBit(n, op_andnot);\n  }\n  // (public) this ^ (1<<n)\n  function bnFlipBit(n)\n  {\n    return this.changeBit(n, op_xor);\n  }\n  // (protected) r = this + a\n  function bnpAddTo(a, r)\n  {\n    var i = 0,\n      c = 0,\n      m = Math.min(a.t, this.t);\n    while (i < m)\n    {\n      c += this[i] + a[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n    if (a.t < this.t)\n    {\n      c += a.s;\n      while (i < this.t)\n      {\n        c += this[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n      c += this.s;\n    }\n    else\n    {\n      c += this.s;\n      while (i < a.t)\n      {\n        c += a[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n      c += a.s;\n    }\n    r.s = (c < 0) ? -1 : 0;\n    if (c > 0) r[i++] = c;\n    else if (c < -1) r[i++] = this.DV + c;\n    r.t = i;\n    r.clamp();\n  }\n  // (public) this + a\n  function bnAdd(a)\n  {\n    var r = nbi();\n    this.addTo(a, r);\n    return r;\n  }\n  // (public) this - a\n  function bnSubtract(a)\n  {\n    var r = nbi();\n    this.subTo(a, r);\n    return r;\n  }\n  // (public) this * a\n  function bnMultiply(a)\n  {\n    var r = nbi();\n    this.multiplyTo(a, r);\n    return r;\n  }\n  // (public) this^2\n  function bnSquare()\n  {\n    var r = nbi();\n    this.squareTo(r);\n    return r;\n  }\n  // (public) this / a\n  function bnDivide(a)\n  {\n    var r = nbi();\n    this.divRemTo(a, r, null);\n    return r;\n  }\n  // (public) this % a\n  function bnRemainder(a)\n  {\n    var r = nbi();\n    this.divRemTo(a, null, r);\n    return r;\n  }\n  // (public) [this/a,this%a]\n  function bnDivideAndRemainder(a)\n  {\n    var q = nbi(),\n      r = nbi();\n    this.divRemTo(a, q, r);\n    return new Array(q, r);\n  }\n  // (protected) this *= n, this >= 0, 1 < n < DV\n  function bnpDMultiply(n)\n  {\n    this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);\n    ++this.t;\n    this.clamp();\n  }\n  // (protected) this += n << w words, this >= 0\n  function bnpDAddOffset(n, w)\n  {\n    if (n == 0) return;\n    while (this.t <= w) this[this.t++] = 0;\n    this[w] += n;\n    while (this[w] >= this.DV)\n    {\n      this[w] -= this.DV;\n      if (++w >= this.t) this[this.t++] = 0;\n      ++this[w];\n    }\n  }\n  // A \"null\" reducer\n  function NullExp()\n  {}\n\n  function nNop(x)\n  {\n    return x;\n  }\n\n  function nMulTo(x, y, r)\n  {\n    x.multiplyTo(y, r);\n  }\n\n  function nSqrTo(x, r)\n  {\n    x.squareTo(r);\n  }\n  NullExp.prototype.convert = nNop;\n  NullExp.prototype.revert = nNop;\n  NullExp.prototype.mulTo = nMulTo;\n  NullExp.prototype.sqrTo = nSqrTo;\n  // (public) this^e\n  function bnPow(e)\n  {\n    return this.exp(e, new NullExp());\n  }\n  // (protected) r = lower n words of \"this * a\", a.t <= n\n  // \"this\" should be the larger one if appropriate.\n  function bnpMultiplyLowerTo(a, n, r)\n  {\n    var i = Math.min(this.t + a.t, n);\n    r.s = 0; // assumes a,this >= 0\n    r.t = i;\n    while (i > 0) r[--i] = 0;\n    var j;\n    for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);\n    for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);\n    r.clamp();\n  }\n  // (protected) r = \"this * a\" without lower n words, n > 0\n  // \"this\" should be the larger one if appropriate.\n  function bnpMultiplyUpperTo(a, n, r)\n  {\n    --n;\n    var i = r.t = this.t + a.t - n;\n    r.s = 0; // assumes a,this >= 0\n    while (--i >= 0) r[i] = 0;\n    for (i = Math.max(n - this.t, 0); i < a.t; ++i)\n      r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);\n    r.clamp();\n    r.drShiftTo(1, r);\n  }\n  // Barrett modular reduction\n  function Barrett(m)\n  {\n    // setup Barrett\n    this.r2 = nbi();\n    this.q3 = nbi();\n    BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);\n    this.mu = this.r2.divide(m);\n    this.m = m;\n  }\n\n  function barrettConvert(x)\n  {\n    if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);\n    else if (x.compareTo(this.m) < 0) return x;\n    else\n    {\n      var r = nbi();\n      x.copyTo(r);\n      this.reduce(r);\n      return r;\n    }\n  }\n\n  function barrettRevert(x)\n  {\n    return x;\n  }\n  // x = x mod m (HAC 14.42)\n  function barrettReduce(x)\n  {\n    x.drShiftTo(this.m.t - 1, this.r2);\n    if (x.t > this.m.t + 1)\n    {\n      x.t = this.m.t + 1;\n      x.clamp();\n    }\n    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);\n    this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);\n    while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);\n    x.subTo(this.r2, x);\n    while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n  }\n  // r = x^2 mod m; x != r\n  function barrettSqrTo(x, r)\n  {\n    x.squareTo(r);\n    this.reduce(r);\n  }\n  // r = x*y mod m; x,y != r\n  function barrettMulTo(x, y, r)\n  {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n  }\n  Barrett.prototype.convert = barrettConvert;\n  Barrett.prototype.revert = barrettRevert;\n  Barrett.prototype.reduce = barrettReduce;\n  Barrett.prototype.mulTo = barrettMulTo;\n  Barrett.prototype.sqrTo = barrettSqrTo;\n  // (public) this^e % m (HAC 14.85)\n  function bnModPow(e, m)\n  {\n    var i = e.bitLength(),\n      k, r = nbv(1),\n      z;\n    if (i <= 0) return r;\n    else if (i < 18) k = 1;\n    else if (i < 48) k = 3;\n    else if (i < 144) k = 4;\n    else if (i < 768) k = 5;\n    else k = 6;\n    if (i < 8)\n      z = new Classic(m);\n    else if (m.isEven())\n      z = new Barrett(m);\n    else\n      z = new Montgomery(m);\n    // precomputation\n    var g = new Array(),\n      n = 3,\n      k1 = k - 1,\n      km = (1 << k) - 1;\n    g[1] = z.convert(this);\n    if (k > 1)\n    {\n      var g2 = nbi();\n      z.sqrTo(g[1], g2);\n      while (n <= km)\n      {\n        g[n] = nbi();\n        z.mulTo(g2, g[n - 2], g[n]);\n        n += 2;\n      }\n    }\n    var j = e.t - 1,\n      w, is1 = true,\n      r2 = nbi(),\n      t;\n    i = nbits(e[j]) - 1;\n    while (j >= 0)\n    {\n      if (i >= k1) w = (e[j] >> (i - k1)) & km;\n      else\n      {\n        w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);\n        if (j > 0) w |= e[j - 1] >> (this.DB + i - k1);\n      }\n      n = k;\n      while ((w & 1) == 0)\n      {\n        w >>= 1;\n        --n;\n      }\n      if ((i -= n) < 0)\n      {\n        i += this.DB;\n        --j;\n      }\n      if (is1)\n      { // ret == 1, don't bother squaring or multiplying it\n        g[w].copyTo(r);\n        is1 = false;\n      }\n      else\n      {\n        while (n > 1)\n        {\n          z.sqrTo(r, r2);\n          z.sqrTo(r2, r);\n          n -= 2;\n        }\n        if (n > 0) z.sqrTo(r, r2);\n        else\n        {\n          t = r;\n          r = r2;\n          r2 = t;\n        }\n        z.mulTo(r2, g[w], r);\n      }\n      while (j >= 0 && (e[j] & (1 << i)) == 0)\n      {\n        z.sqrTo(r, r2);\n        t = r;\n        r = r2;\n        r2 = t;\n        if (--i < 0)\n        {\n          i = this.DB - 1;\n          --j;\n        }\n      }\n    }\n    return z.revert(r);\n  }\n  // (public) gcd(this,a) (HAC 14.54)\n  function bnGCD(a)\n  {\n    var x = (this.s < 0) ? this.negate() : this.clone();\n    var y = (a.s < 0) ? a.negate() : a.clone();\n    if (x.compareTo(y) < 0)\n    {\n      var t = x;\n      x = y;\n      y = t;\n    }\n    var i = x.getLowestSetBit(),\n      g = y.getLowestSetBit();\n    if (g < 0) return x;\n    if (i < g) g = i;\n    if (g > 0)\n    {\n      x.rShiftTo(g, x);\n      y.rShiftTo(g, y);\n    }\n    while (x.signum() > 0)\n    {\n      if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);\n      if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);\n      if (x.compareTo(y) >= 0)\n      {\n        x.subTo(y, x);\n        x.rShiftTo(1, x);\n      }\n      else\n      {\n        y.subTo(x, y);\n        y.rShiftTo(1, y);\n      }\n    }\n    if (g > 0) y.lShiftTo(g, y);\n    return y;\n  }\n  // (protected) this % n, n < 2^26\n  function bnpModInt(n)\n  {\n    if (n <= 0) return 0;\n    var d = this.DV % n,\n      r = (this.s < 0) ? n - 1 : 0;\n    if (this.t > 0)\n      if (d == 0) r = this[0] % n;\n      else\n        for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;\n    return r;\n  }\n  // (public) 1/this % m (HAC 14.61)\n  function bnModInverse(m)\n  {\n    var ac = m.isEven();\n    if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n    var u = m.clone(),\n      v = this.clone();\n    var a = nbv(1),\n      b = nbv(0),\n      c = nbv(0),\n      d = nbv(1);\n    while (u.signum() != 0)\n    {\n      while (u.isEven())\n      {\n        u.rShiftTo(1, u);\n        if (ac)\n        {\n          if (!a.isEven() || !b.isEven())\n          {\n            a.addTo(this, a);\n            b.subTo(m, b);\n          }\n          a.rShiftTo(1, a);\n        }\n        else if (!b.isEven()) b.subTo(m, b);\n        b.rShiftTo(1, b);\n      }\n      while (v.isEven())\n      {\n        v.rShiftTo(1, v);\n        if (ac)\n        {\n          if (!c.isEven() || !d.isEven())\n          {\n            c.addTo(this, c);\n            d.subTo(m, d);\n          }\n          c.rShiftTo(1, c);\n        }\n        else if (!d.isEven()) d.subTo(m, d);\n        d.rShiftTo(1, d);\n      }\n      if (u.compareTo(v) >= 0)\n      {\n        u.subTo(v, u);\n        if (ac) a.subTo(c, a);\n        b.subTo(d, b);\n      }\n      else\n      {\n        v.subTo(u, v);\n        if (ac) c.subTo(a, c);\n        d.subTo(b, d);\n      }\n    }\n    if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n    if (d.compareTo(m) >= 0) return d.subtract(m);\n    if (d.signum() < 0) d.addTo(m, d);\n    else return d;\n    if (d.signum() < 0) return d.add(m);\n    else return d;\n  }\n  var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\n  var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];\n  // (public) test primality with certainty >= 1-.5^t\n  function bnIsProbablePrime(t)\n  {\n    var i, x = this.abs();\n    if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1])\n    {\n      for (i = 0; i < lowprimes.length; ++i)\n        if (x[0] == lowprimes[i]) return true;\n      return false;\n    }\n    if (x.isEven()) return false;\n    i = 1;\n    while (i < lowprimes.length)\n    {\n      var m = lowprimes[i],\n        j = i + 1;\n      while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n      m = x.modInt(m);\n      while (i < j)\n        if (m % lowprimes[i++] == 0) return false;\n    }\n    return x.millerRabin(t);\n  }\n  // (protected) true if probably prime (HAC 4.24, Miller-Rabin)\n  function bnpMillerRabin(t)\n  {\n    var n1 = this.subtract(BigInteger.ONE);\n    var k = n1.getLowestSetBit();\n    if (k <= 0) return false;\n    var r = n1.shiftRight(k);\n    t = (t + 1) >> 1;\n    if (t > lowprimes.length) t = lowprimes.length;\n    var a = nbi();\n    for (var i = 0; i < t; ++i)\n    {\n      //Pick bases at random, instead of starting at 2\n      a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);\n      var y = a.modPow(r, this);\n      if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0)\n      {\n        var j = 1;\n        while (j++ < k && y.compareTo(n1) != 0)\n        {\n          y = y.modPowInt(2, this);\n          if (y.compareTo(BigInteger.ONE) == 0) return false;\n        }\n        if (y.compareTo(n1) != 0) return false;\n      }\n    }\n    return true;\n  }\n  // protected\n  BigInteger.prototype.chunkSize = bnpChunkSize;\n  BigInteger.prototype.toRadix = bnpToRadix;\n  BigInteger.prototype.fromRadix = bnpFromRadix;\n  BigInteger.prototype.fromNumber = bnpFromNumber;\n  BigInteger.prototype.bitwiseTo = bnpBitwiseTo;\n  BigInteger.prototype.changeBit = bnpChangeBit;\n  BigInteger.prototype.addTo = bnpAddTo;\n  BigInteger.prototype.dMultiply = bnpDMultiply;\n  BigInteger.prototype.dAddOffset = bnpDAddOffset;\n  BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\n  BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\n  BigInteger.prototype.modInt = bnpModInt;\n  BigInteger.prototype.millerRabin = bnpMillerRabin;\n  // public\n  BigInteger.prototype.clone = bnClone;\n  BigInteger.prototype.intValue = bnIntValue;\n  BigInteger.prototype.byteValue = bnByteValue;\n  BigInteger.prototype.shortValue = bnShortValue;\n  BigInteger.prototype.signum = bnSigNum;\n  BigInteger.prototype.toByteArray = bnToByteArray;\n  BigInteger.prototype.equals = bnEquals;\n  BigInteger.prototype.min = bnMin;\n  BigInteger.prototype.max = bnMax;\n  BigInteger.prototype.and = bnAnd;\n  BigInteger.prototype.or = bnOr;\n  BigInteger.prototype.xor = bnXor;\n  BigInteger.prototype.andNot = bnAndNot;\n  BigInteger.prototype.not = bnNot;\n  BigInteger.prototype.shiftLeft = bnShiftLeft;\n  BigInteger.prototype.shiftRight = bnShiftRight;\n  BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\n  BigInteger.prototype.bitCount = bnBitCount;\n  BigInteger.prototype.testBit = bnTestBit;\n  BigInteger.prototype.setBit = bnSetBit;\n  BigInteger.prototype.clearBit = bnClearBit;\n  BigInteger.prototype.flipBit = bnFlipBit;\n  BigInteger.prototype.add = bnAdd;\n  BigInteger.prototype.subtract = bnSubtract;\n  BigInteger.prototype.multiply = bnMultiply;\n  BigInteger.prototype.divide = bnDivide;\n  BigInteger.prototype.remainder = bnRemainder;\n  BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\n  BigInteger.prototype.modPow = bnModPow;\n  BigInteger.prototype.modInverse = bnModInverse;\n  BigInteger.prototype.pow = bnPow;\n  BigInteger.prototype.gcd = bnGCD;\n  BigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n  // JSBN-specific extension\n  BigInteger.prototype.square = bnSquare;\n  var Int128 = BigInteger;\n  // BigInteger interfaces not implemented in jsbn:\n  // BigInteger(int signum, byte[] magnitude)\n  // double doubleValue()\n  // float floatValue()\n  // int hashCode()\n  // long longValue()\n  // static BigInteger valueOf(long val)\n  // Helper functions to make BigInteger functions callable with two parameters\n  // as in original C# Clipper\n  Int128.prototype.IsNegative = function ()\n  {\n    if (this.compareTo(Int128.ZERO) == -1) return true;\n    else return false;\n  };\n  Int128.op_Equality = function (val1, val2)\n  {\n    if (val1.compareTo(val2) == 0) return true;\n    else return false;\n  };\n  Int128.op_Inequality = function (val1, val2)\n  {\n    if (val1.compareTo(val2) != 0) return true;\n    else return false;\n  };\n  Int128.op_GreaterThan = function (val1, val2)\n  {\n    if (val1.compareTo(val2) > 0) return true;\n    else return false;\n  };\n  Int128.op_LessThan = function (val1, val2)\n  {\n    if (val1.compareTo(val2) < 0) return true;\n    else return false;\n  };\n  Int128.op_Addition = function (lhs, rhs)\n  {\n    return new Int128(lhs).add(new Int128(rhs));\n  };\n  Int128.op_Subtraction = function (lhs, rhs)\n  {\n    return new Int128(lhs).subtract(new Int128(rhs));\n  };\n  Int128.Int128Mul = function (lhs, rhs)\n  {\n    return new Int128(lhs).multiply(new Int128(rhs));\n  };\n  Int128.op_Division = function (lhs, rhs)\n  {\n    return lhs.divide(rhs);\n  };\n  Int128.prototype.ToDouble = function ()\n  {\n    return parseFloat(this.toString()); // This could be something faster\n  };\n  // end of Int128 section\n  /*\n  // Uncomment the following two lines if you want to use Int128 outside ClipperLib\n  if (typeof(document) !== \"undefined\") window.Int128 = Int128;\n  else self.Int128 = Int128;\n  */\n\n\n  // ---------------------------------------------\n  // Here starts the actual Clipper library:\n  // Helper function to support Inheritance in Javascript\n\tvar Inherit = function (ce, ce2)\n\t{\n\t\tvar p;\n\t\tif (typeof (Object.getOwnPropertyNames) == 'undefined')\n\t\t{\n\t\t\tfor (p in ce2.prototype)\n\t\t\t\tif (typeof (ce.prototype[p]) == 'undefined' || ce.prototype[p] == Object.prototype[p]) ce.prototype[p] = ce2.prototype[p];\n\t\t\tfor (p in ce2)\n\t\t\t\tif (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];\n\t\t\tce.$baseCtor = ce2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar props = Object.getOwnPropertyNames(ce2.prototype);\n\t\t\tfor (var i = 0; i < props.length; i++)\n\t\t\t\tif (typeof (Object.getOwnPropertyDescriptor(ce.prototype, props[i])) == 'undefined') Object.defineProperty(ce.prototype, props[i], Object.getOwnPropertyDescriptor(ce2.prototype, props[i]));\n\t\t\tfor (p in ce2)\n\t\t\t\tif (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];\n\t\t\tce.$baseCtor = ce2;\n\t\t}\n\t};\n  ClipperLib.Path = function ()\n  {\n    return [];\n  };\n  ClipperLib.Paths = function ()\n  {\n    return []; // Was previously [[]], but caused problems when pushed\n  };\n  // Preserves the calling way of original C# Clipper\n  // Is essential due to compatibility, because DoublePoint is public class in original C# version\n  ClipperLib.DoublePoint = function ()\n  {\n    var a = arguments;\n    this.X = 0;\n    this.Y = 0;\n    // public DoublePoint(DoublePoint dp)\n    // public DoublePoint(IntPoint ip)\n    if (a.length == 1)\n    {\n      this.X = a[0].X;\n      this.Y = a[0].Y;\n    }\n    else if (a.length == 2)\n    {\n      this.X = a[0];\n      this.Y = a[1];\n    }\n  }; // This is internal faster function when called without arguments\n  ClipperLib.DoublePoint0 = function ()\n  {\n    this.X = 0;\n    this.Y = 0;\n  };\n  // This is internal faster function when called with 1 argument (dp or ip)\n  ClipperLib.DoublePoint1 = function (dp)\n  {\n    this.X = dp.X;\n    this.Y = dp.Y;\n  };\n  // This is internal faster function when called with 2 arguments (x and y)\n  ClipperLib.DoublePoint2 = function (x, y)\n  {\n    this.X = x;\n    this.Y = y;\n  };\n  // PolyTree & PolyNode start\n  // -------------------------------\n  ClipperLib.PolyNode = function ()\n  {\n    this.m_Parent = null;\n    this.m_polygon = new ClipperLib.Path();\n    this.m_Index = 0;\n    this.m_jointype = 0;\n    this.m_endtype = 0;\n    this.m_Childs = [];\n    this.IsOpen = false;\n  };\n  ClipperLib.PolyNode.prototype.IsHoleNode = function ()\n  {\n    var result = true;\n    var node = this.m_Parent;\n    while (node !== null)\n    {\n      result = !result;\n      node = node.m_Parent;\n    }\n    return result;\n  };\n  ClipperLib.PolyNode.prototype.ChildCount = function ()\n  {\n    return this.m_Childs.length;\n  };\n  ClipperLib.PolyNode.prototype.Contour = function ()\n  {\n    return this.m_polygon;\n  };\n  ClipperLib.PolyNode.prototype.AddChild = function (Child)\n  {\n    var cnt = this.m_Childs.length;\n    this.m_Childs.push(Child);\n    Child.m_Parent = this;\n    Child.m_Index = cnt;\n  };\n  ClipperLib.PolyNode.prototype.GetNext = function ()\n  {\n    if (this.m_Childs.length > 0)\n      return this.m_Childs[0];\n    else\n      return this.GetNextSiblingUp();\n  };\n  ClipperLib.PolyNode.prototype.GetNextSiblingUp = function ()\n  {\n    if (this.m_Parent === null)\n      return null;\n    else if (this.m_Index == this.m_Parent.m_Childs.length - 1)\n      return this.m_Parent.GetNextSiblingUp();\n    else\n      return this.m_Parent.m_Childs[this.m_Index + 1];\n  };\n  ClipperLib.PolyNode.prototype.Childs = function ()\n  {\n    return this.m_Childs;\n  };\n  ClipperLib.PolyNode.prototype.Parent = function ()\n  {\n    return this.m_Parent;\n  };\n  ClipperLib.PolyNode.prototype.IsHole = function ()\n  {\n    return this.IsHoleNode();\n  };\n  // PolyTree : PolyNode\n  ClipperLib.PolyTree = function ()\n  {\n    this.m_AllPolys = [];\n    ClipperLib.PolyNode.call(this);\n  };\n  ClipperLib.PolyTree.prototype.Clear = function ()\n  {\n    for (var i = 0, ilen = this.m_AllPolys.length; i < ilen; i++)\n      this.m_AllPolys[i] = null;\n    this.m_AllPolys.length = 0;\n    this.m_Childs.length = 0;\n  };\n  ClipperLib.PolyTree.prototype.GetFirst = function ()\n  {\n    if (this.m_Childs.length > 0)\n      return this.m_Childs[0];\n    else\n      return null;\n  };\n  ClipperLib.PolyTree.prototype.Total = function ()\n  {\n\t\tvar result = this.m_AllPolys.length;\n\t\t//with negative offsets, ignore the hidden outer polygon ...\n\t\tif (result > 0 && this.m_Childs[0] != this.m_AllPolys[0]) result--;\n\t\treturn result;\n  };\n  Inherit(ClipperLib.PolyTree, ClipperLib.PolyNode);\n  // -------------------------------\n  // PolyTree & PolyNode end\n  ClipperLib.Math_Abs_Int64 = ClipperLib.Math_Abs_Int32 = ClipperLib.Math_Abs_Double = function (a)\n  {\n    return Math.abs(a);\n  };\n  ClipperLib.Math_Max_Int32_Int32 = function (a, b)\n  {\n    return Math.max(a, b);\n  };\n  /*\n  -----------------------------------\n  cast_32 speedtest: http://jsperf.com/truncate-float-to-integer/2\n  -----------------------------------\n  */\n  if (browser.msie || browser.opera || browser.safari) ClipperLib.Cast_Int32 = function (a)\n  {\n    return a | 0;\n  };\n  else ClipperLib.Cast_Int32 = function (a)\n  { // eg. browser.chrome || browser.chromium || browser.firefox\n    return~~ a;\n  };\n  /*\n  --------------------------\n  cast_64 speedtests: http://jsperf.com/truncate-float-to-integer\n  Chrome: bitwise_not_floor\n  Firefox17: toInteger (typeof test)\n  IE9: bitwise_or_floor\n  IE7 and IE8: to_parseint\n  Chromium: to_floor_or_ceil\n  Firefox3: to_floor_or_ceil\n  Firefox15: to_floor_or_ceil\n  Opera: to_floor_or_ceil\n  Safari: to_floor_or_ceil\n  --------------------------\n  */\n  if (browser.chrome) ClipperLib.Cast_Int64 = function (a)\n  {\n    if (a < -2147483648 || a > 2147483647)\n      return a < 0 ? Math.ceil(a) : Math.floor(a);\n    else return~~ a;\n  };\n  else if (browser.firefox && typeof (Number.toInteger) == \"function\") ClipperLib.Cast_Int64 = function (a)\n  {\n    return Number.toInteger(a);\n  };\n  else if (browser.msie7 || browser.msie8) ClipperLib.Cast_Int64 = function (a)\n  {\n    return parseInt(a, 10);\n  };\n  else if (browser.msie) ClipperLib.Cast_Int64 = function (a)\n  {\n    if (a < -2147483648 || a > 2147483647)\n      return a < 0 ? Math.ceil(a) : Math.floor(a);\n    return a | 0;\n  };\n  // eg. browser.chromium || browser.firefox || browser.opera || browser.safari\n  else ClipperLib.Cast_Int64 = function (a)\n  {\n    return a < 0 ? Math.ceil(a) : Math.floor(a);\n  };\n  ClipperLib.Clear = function (a)\n  {\n    a.length = 0;\n  };\n  //ClipperLib.MaxSteps = 64; // How many steps at maximum in arc in BuildArc() function\n  ClipperLib.PI = 3.141592653589793;\n  ClipperLib.PI2 = 2 * 3.141592653589793;\n  ClipperLib.IntPoint = function ()\n  {\n    var a = arguments,\n      alen = a.length;\n    this.X = 0;\n    this.Y = 0;\n    if (use_xyz)\n    {\n      this.Z = 0;\n      if (alen == 3) // public IntPoint(cInt x, cInt y, cInt z = 0)\n      {\n        this.X = a[0];\n        this.Y = a[1];\n        this.Z = a[2];\n      }\n      else if (alen == 2) // public IntPoint(cInt x, cInt y)\n      {\n        this.X = a[0];\n        this.Y = a[1];\n        this.Z = 0;\n      }\n      else if (alen == 1)\n      {\n        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n        {\n          var dp = a[0];\n          this.X = ClipperLib.Clipper.Round(dp.X);\n          this.Y = ClipperLib.Clipper.Round(dp.Y);\n          this.Z = 0;\n        }\n        else // public IntPoint(IntPoint pt)\n        {\n          var pt = a[0];\n          if (typeof (pt.Z) == \"undefined\") pt.Z = 0;\n          this.X = pt.X;\n          this.Y = pt.Y;\n          this.Z = pt.Z;\n        }\n      }\n      else // public IntPoint()\n      {\n        this.X = 0;\n        this.Y = 0;\n        this.Z = 0;\n      }\n    }\n    else // if (!use_xyz)\n    {\n      if (alen == 2) // public IntPoint(cInt X, cInt Y)\n      {\n        this.X = a[0];\n        this.Y = a[1];\n      }\n      else if (alen == 1)\n      {\n        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n        {\n          var dp = a[0];\n          this.X = ClipperLib.Clipper.Round(dp.X);\n          this.Y = ClipperLib.Clipper.Round(dp.Y);\n        }\n        else // public IntPoint(IntPoint pt)\n        {\n          var pt = a[0];\n          this.X = pt.X;\n          this.Y = pt.Y;\n        }\n      }\n      else // public IntPoint(IntPoint pt)\n      {\n        this.X = 0;\n        this.Y = 0;\n      }\n    }\n  };\n  ClipperLib.IntPoint.op_Equality = function (a, b)\n  {\n    //return a == b;\n    return a.X == b.X && a.Y == b.Y;\n  };\n  ClipperLib.IntPoint.op_Inequality = function (a, b)\n  {\n    //return a != b;\n    return a.X != b.X || a.Y != b.Y;\n  };\n  /*\n  ClipperLib.IntPoint.prototype.Equals = function (obj)\n  {\n    if (obj === null)\n        return false;\n    if (obj instanceof ClipperLib.IntPoint)\n    {\n        var a = Cast(obj, ClipperLib.IntPoint);\n        return (this.X == a.X) && (this.Y == a.Y);\n    }\n    else\n        return false;\n  };\n*/\n  if (use_xyz)\n  {\n    ClipperLib.IntPoint0 = function ()\n    {\n      this.X = 0;\n      this.Y = 0;\n      this.Z = 0;\n    };\n    ClipperLib.IntPoint1 = function (pt)\n    {\n      this.X = pt.X;\n      this.Y = pt.Y;\n      this.Z = pt.Z;\n    };\n    ClipperLib.IntPoint1dp = function (dp)\n    {\n      this.X = ClipperLib.Clipper.Round(dp.X);\n      this.Y = ClipperLib.Clipper.Round(dp.Y);\n      this.Z = 0;\n    };\n    ClipperLib.IntPoint2 = function (x, y)\n    {\n      this.X = x;\n      this.Y = y;\n      this.Z = 0;\n    };\n    ClipperLib.IntPoint3 = function (x, y, z)\n    {\n      this.X = x;\n      this.Y = y;\n      this.Z = z;\n    };\n  }\n  else // if (!use_xyz)\n  {\n    ClipperLib.IntPoint0 = function ()\n    {\n      this.X = 0;\n      this.Y = 0;\n    };\n    ClipperLib.IntPoint1 = function (pt)\n    {\n      this.X = pt.X;\n      this.Y = pt.Y;\n    };\n    ClipperLib.IntPoint1dp = function (dp)\n    {\n      this.X = ClipperLib.Clipper.Round(dp.X);\n      this.Y = ClipperLib.Clipper.Round(dp.Y);\n    };\n    ClipperLib.IntPoint2 = function (x, y)\n    {\n      this.X = x;\n      this.Y = y;\n    };\n  }\n  ClipperLib.IntRect = function ()\n  {\n    var a = arguments,\n      alen = a.length;\n    if (alen == 4) // function (l, t, r, b)\n    {\n      this.left = a[0];\n      this.top = a[1];\n      this.right = a[2];\n      this.bottom = a[3];\n    }\n    else if (alen == 1) // function (ir)\n    {\n      this.left = ir.left;\n      this.top = ir.top;\n      this.right = ir.right;\n      this.bottom = ir.bottom;\n    }\n    else // function ()\n    {\n      this.left = 0;\n      this.top = 0;\n      this.right = 0;\n      this.bottom = 0;\n    }\n  };\n  ClipperLib.IntRect0 = function ()\n  {\n    this.left = 0;\n    this.top = 0;\n    this.right = 0;\n    this.bottom = 0;\n  };\n  ClipperLib.IntRect1 = function (ir)\n  {\n    this.left = ir.left;\n    this.top = ir.top;\n    this.right = ir.right;\n    this.bottom = ir.bottom;\n  };\n  ClipperLib.IntRect4 = function (l, t, r, b)\n  {\n    this.left = l;\n    this.top = t;\n    this.right = r;\n    this.bottom = b;\n  };\n  ClipperLib.ClipType = {\n    ctIntersection: 0,\n    ctUnion: 1,\n    ctDifference: 2,\n    ctXor: 3\n  };\n  ClipperLib.PolyType = {\n    ptSubject: 0,\n    ptClip: 1\n  };\n  ClipperLib.PolyFillType = {\n    pftEvenOdd: 0,\n    pftNonZero: 1,\n    pftPositive: 2,\n    pftNegative: 3\n  };\n  ClipperLib.JoinType = {\n    jtSquare: 0,\n    jtRound: 1,\n    jtMiter: 2\n  };\n  ClipperLib.EndType = {\n    etOpenSquare: 0,\n    etOpenRound: 1,\n    etOpenButt: 2,\n    etClosedLine: 3,\n    etClosedPolygon: 4\n  };\n  ClipperLib.EdgeSide = {\n    esLeft: 0,\n    esRight: 1\n  };\n  ClipperLib.Direction = {\n    dRightToLeft: 0,\n    dLeftToRight: 1\n  };\n  ClipperLib.TEdge = function ()\n  {\n    this.Bot = new ClipperLib.IntPoint();\n    this.Curr = new ClipperLib.IntPoint();\n    this.Top = new ClipperLib.IntPoint();\n    this.Delta = new ClipperLib.IntPoint();\n    this.Dx = 0;\n    this.PolyTyp = ClipperLib.PolyType.ptSubject;\n    this.Side = ClipperLib.EdgeSide.esLeft;\n    this.WindDelta = 0;\n    this.WindCnt = 0;\n    this.WindCnt2 = 0;\n    this.OutIdx = 0;\n    this.Next = null;\n    this.Prev = null;\n    this.NextInLML = null;\n    this.NextInAEL = null;\n    this.PrevInAEL = null;\n    this.NextInSEL = null;\n    this.PrevInSEL = null;\n  };\n  ClipperLib.IntersectNode = function ()\n  {\n    this.Edge1 = null;\n    this.Edge2 = null;\n    this.Pt = new ClipperLib.IntPoint();\n  };\n  ClipperLib.MyIntersectNodeSort = function () {};\n  ClipperLib.MyIntersectNodeSort.Compare = function (node1, node2)\n  {\n    var i = node2.Pt.Y - node1.Pt.Y;\n    if (i > 0) return 1;\n    else if (i < 0) return -1;\n    else return 0;\n  };\n\n  ClipperLib.LocalMinima = function ()\n  {\n    this.Y = 0;\n    this.LeftBound = null;\n    this.RightBound = null;\n    this.Next = null;\n  };\n  ClipperLib.Scanbeam = function ()\n  {\n    this.Y = 0;\n    this.Next = null;\n  };\n  ClipperLib.OutRec = function ()\n  {\n    this.Idx = 0;\n    this.IsHole = false;\n    this.IsOpen = false;\n    this.FirstLeft = null;\n    this.Pts = null;\n    this.BottomPt = null;\n    this.PolyNode = null;\n  };\n  ClipperLib.OutPt = function ()\n  {\n    this.Idx = 0;\n    this.Pt = new ClipperLib.IntPoint();\n    this.Next = null;\n    this.Prev = null;\n  };\n  ClipperLib.Join = function ()\n  {\n    this.OutPt1 = null;\n    this.OutPt2 = null;\n    this.OffPt = new ClipperLib.IntPoint();\n  };\n  ClipperLib.ClipperBase = function ()\n  {\n    this.m_MinimaList = null;\n    this.m_CurrentLM = null;\n    this.m_edges = new Array();\n    this.m_UseFullRange = false;\n    this.m_HasOpenPaths = false;\n    this.PreserveCollinear = false;\n    this.m_MinimaList = null;\n    this.m_CurrentLM = null;\n    this.m_UseFullRange = false;\n    this.m_HasOpenPaths = false;\n  };\n  // Ranges are in original C# too high for Javascript (in current state 2013 september):\n  // protected const double horizontal = -3.4E+38;\n  // internal const cInt loRange = 0x3FFFFFFF; // = 1073741823 = sqrt(2^63 -1)/2\n  // internal const cInt hiRange = 0x3FFFFFFFFFFFFFFFL; // = 4611686018427387903 = sqrt(2^127 -1)/2\n  // So had to adjust them to more suitable for Javascript.\n  // If JS some day supports truly 64-bit integers, then these ranges can be as in C#\n  // and biginteger library can be more simpler (as then 128bit can be represented as two 64bit numbers)\n  ClipperLib.ClipperBase.horizontal = -9007199254740992; //-2^53\n  ClipperLib.ClipperBase.Skip = -2;\n  ClipperLib.ClipperBase.Unassigned = -1;\n  ClipperLib.ClipperBase.tolerance = 1E-20;\n  if (use_int32)\n  {\n    ClipperLib.ClipperBase.loRange = 0x7FFF;\n    ClipperLib.ClipperBase.hiRange = 0x7FFF;\n  }\n  else\n  {\n    ClipperLib.ClipperBase.loRange = 47453132; // sqrt(2^53 -1)/2\n    ClipperLib.ClipperBase.hiRange = 4503599627370495; // sqrt(2^106 -1)/2\n  }\n\n  ClipperLib.ClipperBase.near_zero = function (val)\n  {\n    return (val > -ClipperLib.ClipperBase.tolerance) && (val < ClipperLib.ClipperBase.tolerance);\n  };\n  ClipperLib.ClipperBase.IsHorizontal = function (e)\n  {\n    return e.Delta.Y === 0;\n  };\n  ClipperLib.ClipperBase.prototype.PointIsVertex = function (pt, pp)\n  {\n    var pp2 = pp;\n    do {\n      if (ClipperLib.IntPoint.op_Equality(pp2.Pt, pt))\n        return true;\n      pp2 = pp2.Next;\n    }\n    while (pp2 != pp)\n    return false;\n  };\n  ClipperLib.ClipperBase.prototype.PointOnLineSegment = function (pt, linePt1, linePt2, UseFullRange)\n  {\n    if (UseFullRange)\n      return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) ||\n        ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) ||\n        (((pt.X > linePt1.X) == (pt.X < linePt2.X)) &&\n        ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) &&\n        (Int128.op_Equality(Int128.Int128Mul((pt.X - linePt1.X), (linePt2.Y - linePt1.Y)),\n          Int128.Int128Mul((linePt2.X - linePt1.X), (pt.Y - linePt1.Y)))));\n    else\n      return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) || ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) || (((pt.X > linePt1.X) == (pt.X < linePt2.X)) && ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) && ((pt.X - linePt1.X) * (linePt2.Y - linePt1.Y) == (linePt2.X - linePt1.X) * (pt.Y - linePt1.Y)));\n  };\n  ClipperLib.ClipperBase.prototype.PointOnPolygon = function (pt, pp, UseFullRange)\n  {\n    var pp2 = pp;\n    while (true)\n    {\n      if (this.PointOnLineSegment(pt, pp2.Pt, pp2.Next.Pt, UseFullRange))\n        return true;\n      pp2 = pp2.Next;\n      if (pp2 == pp)\n        break;\n    }\n    return false;\n  };\n  ClipperLib.ClipperBase.prototype.SlopesEqual = ClipperLib.ClipperBase.SlopesEqual = function ()\n  {\n    var a = arguments,\n      alen = a.length;\n    var e1, e2, pt1, pt2, pt3, pt4, UseFullRange;\n    if (alen == 3) // function (e1, e2, UseFullRange)\n    {\n      e1 = a[0];\n      e2 = a[1];\n      UseFullRange = a[2];\n      if (UseFullRange)\n        return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n      else\n        return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n    }\n    else if (alen == 4) // function (pt1, pt2, pt3, UseFullRange)\n    {\n      pt1 = a[0];\n      pt2 = a[1];\n      pt3 = a[2];\n      UseFullRange = a[3];\n      if (UseFullRange)\n        return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n      else\n        return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n    }\n    else // function (pt1, pt2, pt3, pt4, UseFullRange)\n    {\n      pt1 = a[0];\n      pt2 = a[1];\n      pt3 = a[2];\n      pt4 = a[3];\n      UseFullRange = a[4];\n      if (UseFullRange)\n        return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n      else\n        return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n    }\n  };\n  ClipperLib.ClipperBase.SlopesEqual3 = function (e1, e2, UseFullRange)\n  {\n    if (UseFullRange)\n      return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n    else\n      return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n  };\n  ClipperLib.ClipperBase.SlopesEqual4 = function (pt1, pt2, pt3, UseFullRange)\n  {\n    if (UseFullRange)\n      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n    else\n      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n  };\n  ClipperLib.ClipperBase.SlopesEqual5 = function (pt1, pt2, pt3, pt4, UseFullRange)\n  {\n    if (UseFullRange)\n      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n    else\n      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n  };\n  ClipperLib.ClipperBase.prototype.Clear = function ()\n  {\n    this.DisposeLocalMinimaList();\n    for (var i = 0, ilen = this.m_edges.length; i < ilen; ++i)\n    {\n      for (var j = 0, jlen = this.m_edges[i].length; j < jlen; ++j)\n        this.m_edges[i][j] = null;\n      ClipperLib.Clear(this.m_edges[i]);\n    }\n    ClipperLib.Clear(this.m_edges);\n    this.m_UseFullRange = false;\n    this.m_HasOpenPaths = false;\n  };\n  ClipperLib.ClipperBase.prototype.DisposeLocalMinimaList = function ()\n  {\n    while (this.m_MinimaList !== null)\n    {\n      var tmpLm = this.m_MinimaList.Next;\n      this.m_MinimaList = null;\n      this.m_MinimaList = tmpLm;\n    }\n    this.m_CurrentLM = null;\n  };\n  ClipperLib.ClipperBase.prototype.RangeTest = function (Pt, useFullRange)\n  {\n    if (useFullRange.Value)\n    {\n      if (Pt.X > ClipperLib.ClipperBase.hiRange || Pt.Y > ClipperLib.ClipperBase.hiRange || -Pt.X > ClipperLib.ClipperBase.hiRange || -Pt.Y > ClipperLib.ClipperBase.hiRange)\n        ClipperLib.Error(\"Coordinate outside allowed range in RangeTest().\");\n    }\n    else if (Pt.X > ClipperLib.ClipperBase.loRange || Pt.Y > ClipperLib.ClipperBase.loRange || -Pt.X > ClipperLib.ClipperBase.loRange || -Pt.Y > ClipperLib.ClipperBase.loRange)\n    {\n      useFullRange.Value = true;\n      this.RangeTest(Pt, useFullRange);\n    }\n  };\n  ClipperLib.ClipperBase.prototype.InitEdge = function (e, eNext, ePrev, pt)\n  {\n    e.Next = eNext;\n    e.Prev = ePrev;\n    //e.Curr = pt;\n    e.Curr.X = pt.X;\n    e.Curr.Y = pt.Y;\n    e.OutIdx = -1;\n  };\n  ClipperLib.ClipperBase.prototype.InitEdge2 = function (e, polyType)\n  {\n    if (e.Curr.Y >= e.Next.Curr.Y)\n    {\n      //e.Bot = e.Curr;\n      e.Bot.X = e.Curr.X;\n      e.Bot.Y = e.Curr.Y;\n      //e.Top = e.Next.Curr;\n      e.Top.X = e.Next.Curr.X;\n      e.Top.Y = e.Next.Curr.Y;\n    }\n    else\n    {\n      //e.Top = e.Curr;\n      e.Top.X = e.Curr.X;\n      e.Top.Y = e.Curr.Y;\n      //e.Bot = e.Next.Curr;\n      e.Bot.X = e.Next.Curr.X;\n      e.Bot.Y = e.Next.Curr.Y;\n    }\n    this.SetDx(e);\n    e.PolyTyp = polyType;\n  };\n  ClipperLib.ClipperBase.prototype.FindNextLocMin = function (E)\n  {\n    var E2;\n    for (;;)\n    {\n      while (ClipperLib.IntPoint.op_Inequality(E.Bot, E.Prev.Bot) || ClipperLib.IntPoint.op_Equality(E.Curr, E.Top))\n        E = E.Next;\n      if (E.Dx != ClipperLib.ClipperBase.horizontal && E.Prev.Dx != ClipperLib.ClipperBase.horizontal)\n        break;\n      while (E.Prev.Dx == ClipperLib.ClipperBase.horizontal)\n        E = E.Prev;\n      E2 = E;\n      while (E.Dx == ClipperLib.ClipperBase.horizontal)\n        E = E.Next;\n      if (E.Top.Y == E.Prev.Bot.Y)\n        continue;\n      //ie just an intermediate horz.\n      if (E2.Prev.Bot.X < E.Bot.X)\n        E = E2;\n      break;\n    }\n    return E;\n  };\n  ClipperLib.ClipperBase.prototype.ProcessBound = function (E, LeftBoundIsForward)\n  {\n    var EStart;\n    var Result = E;\n    var Horz;\n\n      if (Result.OutIdx == ClipperLib.ClipperBase.Skip)\n      {\n        //check if there are edges beyond the skip edge in the bound and if so\n        //create another LocMin and calling ProcessBound once more ...\n        E = Result;\n        if (LeftBoundIsForward)\n        {\n          while (E.Top.Y == E.Next.Bot.Y) E = E.Next;\n          while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Prev;\n        }\n        else\n        {\n          while (E.Top.Y == E.Prev.Bot.Y) E = E.Prev;\n          while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Next;\n        }\n        if (E == Result)\n        {\n          if (LeftBoundIsForward) Result = E.Next;\n          else Result = E.Prev;\n        }\n        else\n        {\n          //there are more edges in the bound beyond result starting with E\n          if (LeftBoundIsForward)\n            E = Result.Next;\n          else\n            E = Result.Prev;\n          var locMin = new ClipperLib.LocalMinima();\n          locMin.Next = null;\n          locMin.Y = E.Bot.Y;\n          locMin.LeftBound = null;\n          locMin.RightBound = E;\n          E.WindDelta = 0;\n          Result = this.ProcessBound(E, LeftBoundIsForward);\n          this.InsertLocalMinima(locMin);\n        }\n        return Result;\n      }\n\n      if (E.Dx == ClipperLib.ClipperBase.horizontal)\n      {\n        //We need to be careful with open paths because this may not be a\n        //true local minima (ie E may be following a skip edge).\n        //Also, consecutive horz. edges may start heading left before going right.\n        if (LeftBoundIsForward) EStart = E.Prev;\n        else EStart = E.Next;\n        if (EStart.OutIdx != ClipperLib.ClipperBase.Skip)\n        {\n          if (EStart.Dx == ClipperLib.ClipperBase.horizontal) //ie an adjoining horizontal skip edge\n          {\n            if (EStart.Bot.X != E.Bot.X && EStart.Top.X != E.Bot.X)\n              this.ReverseHorizontal(E);\n          }\n          else if (EStart.Bot.X != E.Bot.X)\n            this.ReverseHorizontal(E);\n        }\n      }\n\n      EStart = E;\n      if (LeftBoundIsForward)\n      {\n        while (Result.Top.Y == Result.Next.Bot.Y && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n          Result = Result.Next;\n        if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n        {\n          //nb: at the top of a bound, horizontals are added to the bound\n          //only when the preceding edge attaches to the horizontal's left vertex\n          //unless a Skip edge is encountered when that becomes the top divide\n          Horz = Result;\n          while (Horz.Prev.Dx == ClipperLib.ClipperBase.horizontal)\n            Horz = Horz.Prev;\n          if (Horz.Prev.Top.X == Result.Next.Top.X)\n          {\n            if (!LeftBoundIsForward)\n              Result = Horz.Prev;\n          }\n          else if (Horz.Prev.Top.X > Result.Next.Top.X)\n            Result = Horz.Prev;\n        }\n        while (E != Result)\n        {\n          E.NextInLML = E.Next;\n          if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)\n            this.ReverseHorizontal(E);\n          E = E.Next;\n        }\n        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)\n          this.ReverseHorizontal(E);\n        Result = Result.Next;\n        //move to the edge just beyond current bound\n      }\n      else\n      {\n        while (Result.Top.Y == Result.Prev.Bot.Y && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)\n          Result = Result.Prev;\n        if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)\n        {\n          Horz = Result;\n          while (Horz.Next.Dx == ClipperLib.ClipperBase.horizontal)\n            Horz = Horz.Next;\n          if (Horz.Next.Top.X == Result.Prev.Top.X)\n          {\n            if (!LeftBoundIsForward)\n              Result = Horz.Next;\n          }\n          else if (Horz.Next.Top.X > Result.Prev.Top.X)\n            Result = Horz.Next;\n        }\n        while (E != Result)\n        {\n          E.NextInLML = E.Prev;\n          if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)\n            this.ReverseHorizontal(E);\n          E = E.Prev;\n        }\n        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)\n          this.ReverseHorizontal(E);\n        Result = Result.Prev;\n        //move to the edge just beyond current bound\n      }\n\n    return Result;\n  };\n\n  ClipperLib.ClipperBase.prototype.AddPath = function (pg, polyType, Closed)\n  {\n    if (use_lines)\n    {\n      if (!Closed && polyType == ClipperLib.PolyType.ptClip)\n        ClipperLib.Error(\"AddPath: Open paths must be subject.\");\n    }\n    else\n    {\n      if (!Closed)\n        ClipperLib.Error(\"AddPath: Open paths have been disabled.\");\n    }\n    var highI = pg.length - 1;\n    if (Closed)\n      while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[0])))\n    --highI;\n    while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[highI - 1])))\n    --highI;\n    if ((Closed && highI < 2) || (!Closed && highI < 1))\n      return false;\n    //create a new edge array ...\n    var edges = new Array();\n    for (var i = 0; i <= highI; i++)\n      edges.push(new ClipperLib.TEdge());\n    var IsFlat = true;\n    //1. Basic (first) edge initialization ...\n\n    //edges[1].Curr = pg[1];\n    edges[1].Curr.X = pg[1].X;\n    edges[1].Curr.Y = pg[1].Y;\n\n    var $1 = {Value: this.m_UseFullRange};\n    this.RangeTest(pg[0], $1);\n    this.m_UseFullRange = $1.Value;\n\n    $1.Value = this.m_UseFullRange;\n    this.RangeTest(pg[highI], $1);\n    this.m_UseFullRange = $1.Value;\n\n    this.InitEdge(edges[0], edges[1], edges[highI], pg[0]);\n    this.InitEdge(edges[highI], edges[0], edges[highI - 1], pg[highI]);\n    for (var i = highI - 1; i >= 1; --i)\n    {\n      $1.Value = this.m_UseFullRange;\n      this.RangeTest(pg[i], $1);\n      this.m_UseFullRange = $1.Value;\n\n      this.InitEdge(edges[i], edges[i + 1], edges[i - 1], pg[i]);\n    }\n\n    var eStart = edges[0];\n    //2. Remove duplicate vertices, and (when closed) collinear edges ...\n    var E = eStart,\n      eLoopStop = eStart;\n    for (;;)\n    {\n    //console.log(E.Next, eStart);\n    \t//nb: allows matching start and end points when not Closed ...\n      if (E.Curr == E.Next.Curr && (Closed || E.Next != eStart))\n      {\n        if (E == E.Next)\n          break;\n        if (E == eStart)\n          eStart = E.Next;\n        E = this.RemoveEdge(E);\n        eLoopStop = E;\n        continue;\n      }\n      if (E.Prev == E.Next)\n        break;\n      else if (Closed && ClipperLib.ClipperBase.SlopesEqual(E.Prev.Curr, E.Curr, E.Next.Curr, this.m_UseFullRange) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(E.Prev.Curr, E.Curr, E.Next.Curr)))\n      {\n        //Collinear edges are allowed for open paths but in closed paths\n        //the default is to merge adjacent collinear edges into a single edge.\n        //However, if the PreserveCollinear property is enabled, only overlapping\n        //collinear edges (ie spikes) will be removed from closed paths.\n        if (E == eStart)\n          eStart = E.Next;\n        E = this.RemoveEdge(E);\n        E = E.Prev;\n        eLoopStop = E;\n        continue;\n      }\n      E = E.Next;\n      if ((E == eLoopStop) || (!Closed && E.Next == eStart)) break;\n    }\n    if ((!Closed && (E == E.Next)) || (Closed && (E.Prev == E.Next)))\n      return false;\n    if (!Closed)\n    {\n      this.m_HasOpenPaths = true;\n      eStart.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n    }\n    //3. Do second stage of edge initialization ...\n    E = eStart;\n    do {\n      this.InitEdge2(E, polyType);\n      E = E.Next;\n      if (IsFlat && E.Curr.Y != eStart.Curr.Y)\n        IsFlat = false;\n    }\n    while (E != eStart)\n    //4. Finally, add edge bounds to LocalMinima list ...\n    //Totally flat paths must be handled differently when adding them\n    //to LocalMinima list to avoid endless loops etc ...\n    if (IsFlat)\n    {\n      if (Closed)\n        return false;\n      E.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n      if (E.Prev.Bot.X < E.Prev.Top.X)\n        this.ReverseHorizontal(E.Prev);\n      var locMin = new ClipperLib.LocalMinima();\n      locMin.Next = null;\n      locMin.Y = E.Bot.Y;\n      locMin.LeftBound = null;\n      locMin.RightBound = E;\n      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n      locMin.RightBound.WindDelta = 0;\n      while (E.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n      {\n        E.NextInLML = E.Next;\n        if (E.Bot.X != E.Prev.Top.X)\n          this.ReverseHorizontal(E);\n        E = E.Next;\n      }\n      this.InsertLocalMinima(locMin);\n      this.m_edges.push(edges);\n      return true;\n    }\n    this.m_edges.push(edges);\n    var leftBoundIsForward;\n    var EMin = null;\n\n\t\t//workaround to avoid an endless loop in the while loop below when\n    //open paths have matching start and end points ...\n    if(ClipperLib.IntPoint.op_Equality(E.Prev.Bot, E.Prev.Top))\n    \tE = E.Next;\n\n    for (;;)\n    {\n      E = this.FindNextLocMin(E);\n      if (E == EMin)\n        break;\n      else if (EMin == null)\n        EMin = E;\n      //E and E.Prev now share a local minima (left aligned if horizontal).\n      //Compare their slopes to find which starts which bound ...\n      var locMin = new ClipperLib.LocalMinima();\n      locMin.Next = null;\n      locMin.Y = E.Bot.Y;\n      if (E.Dx < E.Prev.Dx)\n      {\n        locMin.LeftBound = E.Prev;\n        locMin.RightBound = E;\n        leftBoundIsForward = false;\n        //Q.nextInLML = Q.prev\n      }\n      else\n      {\n        locMin.LeftBound = E;\n        locMin.RightBound = E.Prev;\n        leftBoundIsForward = true;\n        //Q.nextInLML = Q.next\n      }\n      locMin.LeftBound.Side = ClipperLib.EdgeSide.esLeft;\n      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n      if (!Closed)\n        locMin.LeftBound.WindDelta = 0;\n      else if (locMin.LeftBound.Next == locMin.RightBound)\n        locMin.LeftBound.WindDelta = -1;\n      else\n        locMin.LeftBound.WindDelta = 1;\n      locMin.RightBound.WindDelta = -locMin.LeftBound.WindDelta;\n      E = this.ProcessBound(locMin.LeftBound, leftBoundIsForward);\n      if (E.OutIdx == ClipperLib.ClipperBase.Skip)\n      \tE = this.ProcessBound(E, leftBoundIsForward);\n      var E2 = this.ProcessBound(locMin.RightBound, !leftBoundIsForward);\n      if (E2.OutIdx == ClipperLib.ClipperBase.Skip) E2 = this.ProcessBound(E2, !leftBoundIsForward);\n      if (locMin.LeftBound.OutIdx == ClipperLib.ClipperBase.Skip)\n        locMin.LeftBound = null;\n      else if (locMin.RightBound.OutIdx == ClipperLib.ClipperBase.Skip)\n        locMin.RightBound = null;\n      this.InsertLocalMinima(locMin);\n      if (!leftBoundIsForward)\n        E = E2;\n    }\n    return true;\n  };\n  ClipperLib.ClipperBase.prototype.AddPaths = function (ppg, polyType, closed)\n  {\n    //  console.log(\"-------------------------------------------\");\n    //  console.log(JSON.stringify(ppg));\n    var result = false;\n    for (var i = 0, ilen = ppg.length; i < ilen; ++i)\n      if (this.AddPath(ppg[i], polyType, closed))\n        result = true;\n    return result;\n  };\n  //------------------------------------------------------------------------------\n  ClipperLib.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3 = function (pt1, pt2, pt3)\n  {\n    if ((ClipperLib.IntPoint.op_Equality(pt1, pt3)) || (ClipperLib.IntPoint.op_Equality(pt1, pt2)) ||       (ClipperLib.IntPoint.op_Equality(pt3, pt2)))\n\n   //if ((pt1 == pt3) || (pt1 == pt2) || (pt3 == pt2))\n   return false;\n\n    else if (pt1.X != pt3.X)\n      return (pt2.X > pt1.X) == (pt2.X < pt3.X);\n    else\n      return (pt2.Y > pt1.Y) == (pt2.Y < pt3.Y);\n  };\n  ClipperLib.ClipperBase.prototype.RemoveEdge = function (e)\n  {\n    //removes e from double_linked_list (but without removing from memory)\n    e.Prev.Next = e.Next;\n    e.Next.Prev = e.Prev;\n    var result = e.Next;\n    e.Prev = null; //flag as removed (see ClipperBase.Clear)\n    return result;\n  };\n  ClipperLib.ClipperBase.prototype.SetDx = function (e)\n  {\n    e.Delta.X = (e.Top.X - e.Bot.X);\n    e.Delta.Y = (e.Top.Y - e.Bot.Y);\n    if (e.Delta.Y === 0) e.Dx = ClipperLib.ClipperBase.horizontal;\n    else e.Dx = (e.Delta.X) / (e.Delta.Y);\n  };\n  ClipperLib.ClipperBase.prototype.InsertLocalMinima = function (newLm)\n  {\n    if (this.m_MinimaList === null)\n    {\n      this.m_MinimaList = newLm;\n    }\n    else if (newLm.Y >= this.m_MinimaList.Y)\n    {\n      newLm.Next = this.m_MinimaList;\n      this.m_MinimaList = newLm;\n    }\n    else\n    {\n      var tmpLm = this.m_MinimaList;\n      while (tmpLm.Next !== null && (newLm.Y < tmpLm.Next.Y))\n        tmpLm = tmpLm.Next;\n      newLm.Next = tmpLm.Next;\n      tmpLm.Next = newLm;\n    }\n  };\n  ClipperLib.ClipperBase.prototype.PopLocalMinima = function ()\n  {\n    if (this.m_CurrentLM === null)\n      return;\n    this.m_CurrentLM = this.m_CurrentLM.Next;\n  };\n  ClipperLib.ClipperBase.prototype.ReverseHorizontal = function (e)\n  {\n    //swap horizontal edges' top and bottom x's so they follow the natural\n    //progression of the bounds - ie so their xbots will align with the\n    //adjoining lower edge. [Helpful in the ProcessHorizontal() method.]\n    var tmp = e.Top.X;\n    e.Top.X = e.Bot.X;\n    e.Bot.X = tmp;\n    if (use_xyz)\n    {\n      tmp = e.Top.Z;\n      e.Top.Z = e.Bot.Z;\n      e.Bot.Z = tmp;\n    }\n  };\n  ClipperLib.ClipperBase.prototype.Reset = function ()\n  {\n    this.m_CurrentLM = this.m_MinimaList;\n    if (this.m_CurrentLM == null)\n      return;\n    //ie nothing to process\n    //reset all edges ...\n    var lm = this.m_MinimaList;\n    while (lm != null)\n    {\n      var e = lm.LeftBound;\n      if (e != null)\n      {\n        //e.Curr = e.Bot;\n        e.Curr.X = e.Bot.X;\n        e.Curr.Y = e.Bot.Y;\n        e.Side = ClipperLib.EdgeSide.esLeft;\n        e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n      }\n      e = lm.RightBound;\n      if (e != null)\n      {\n        //e.Curr = e.Bot;\n        e.Curr.X = e.Bot.X;\n        e.Curr.Y = e.Bot.Y;\n        e.Side = ClipperLib.EdgeSide.esRight;\n        e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n      }\n      lm = lm.Next;\n    }\n  };\n  ClipperLib.Clipper = function (InitOptions) // public Clipper(int InitOptions = 0)\n  {\n    if (typeof (InitOptions) == \"undefined\") InitOptions = 0;\n    this.m_PolyOuts = null;\n    this.m_ClipType = ClipperLib.ClipType.ctIntersection;\n    this.m_Scanbeam = null;\n    this.m_ActiveEdges = null;\n    this.m_SortedEdges = null;\n    this.m_IntersectList = null;\n    this.m_IntersectNodeComparer = null;\n    this.m_ExecuteLocked = false;\n    this.m_ClipFillType = ClipperLib.PolyFillType.pftEvenOdd;\n    this.m_SubjFillType = ClipperLib.PolyFillType.pftEvenOdd;\n    this.m_Joins = null;\n    this.m_GhostJoins = null;\n    this.m_UsingPolyTree = false;\n    this.ReverseSolution = false;\n    this.StrictlySimple = false;\n    ClipperLib.ClipperBase.call(this);\n    this.m_Scanbeam = null;\n    this.m_ActiveEdges = null;\n    this.m_SortedEdges = null;\n    this.m_IntersectList = new Array();\n    this.m_IntersectNodeComparer = ClipperLib.MyIntersectNodeSort.Compare;\n    this.m_ExecuteLocked = false;\n    this.m_UsingPolyTree = false;\n    this.m_PolyOuts = new Array();\n    this.m_Joins = new Array();\n    this.m_GhostJoins = new Array();\n    this.ReverseSolution = (1 & InitOptions) !== 0;\n    this.StrictlySimple = (2 & InitOptions) !== 0;\n    this.PreserveCollinear = (4 & InitOptions) !== 0;\n    if (use_xyz)\n    {\n      this.ZFillFunction = null; // function (IntPoint vert1, IntPoint vert2, ref IntPoint intersectPt);\n    }\n  };\n  ClipperLib.Clipper.ioReverseSolution = 1;\n  ClipperLib.Clipper.ioStrictlySimple = 2;\n  ClipperLib.Clipper.ioPreserveCollinear = 4;\n\n  ClipperLib.Clipper.prototype.Clear = function ()\n  {\n    if (this.m_edges.length === 0)\n      return;\n    //avoids problems with ClipperBase destructor\n    this.DisposeAllPolyPts();\n    ClipperLib.ClipperBase.prototype.Clear.call(this);\n  };\n\n  ClipperLib.Clipper.prototype.DisposeScanbeamList = function ()\n  {\n    while (this.m_Scanbeam !== null)\n    {\n      var sb2 = this.m_Scanbeam.Next;\n      this.m_Scanbeam = null;\n      this.m_Scanbeam = sb2;\n    }\n  };\n  ClipperLib.Clipper.prototype.Reset = function ()\n  {\n    ClipperLib.ClipperBase.prototype.Reset.call(this);\n    this.m_Scanbeam = null;\n    this.m_ActiveEdges = null;\n    this.m_SortedEdges = null;\n\n    var lm = this.m_MinimaList;\n    while (lm !== null)\n    {\n      this.InsertScanbeam(lm.Y);\n      lm = lm.Next;\n    }\n  };\n  ClipperLib.Clipper.prototype.InsertScanbeam = function (Y)\n  {\n    if (this.m_Scanbeam === null)\n    {\n      this.m_Scanbeam = new ClipperLib.Scanbeam();\n      this.m_Scanbeam.Next = null;\n      this.m_Scanbeam.Y = Y;\n    }\n    else if (Y > this.m_Scanbeam.Y)\n    {\n      var newSb = new ClipperLib.Scanbeam();\n      newSb.Y = Y;\n      newSb.Next = this.m_Scanbeam;\n      this.m_Scanbeam = newSb;\n    }\n    else\n    {\n      var sb2 = this.m_Scanbeam;\n      while (sb2.Next !== null && (Y <= sb2.Next.Y))\n        sb2 = sb2.Next;\n      if (Y == sb2.Y)\n        return;\n      //ie ignores duplicates\n      var newSb = new ClipperLib.Scanbeam();\n      newSb.Y = Y;\n      newSb.Next = sb2.Next;\n      sb2.Next = newSb;\n    }\n  };\n  // ************************************\n  ClipperLib.Clipper.prototype.Execute = function ()\n  {\n    var a = arguments,\n      alen = a.length,\n      ispolytree = a[1] instanceof ClipperLib.PolyTree;\n    if (alen == 4 && !ispolytree) // function (clipType, solution, subjFillType, clipFillType)\n    {\n      var clipType = a[0],\n        solution = a[1],\n        subjFillType = a[2],\n        clipFillType = a[3];\n      if (this.m_ExecuteLocked)\n        return false;\n      if (this.m_HasOpenPaths)\n        ClipperLib.Error(\"Error: PolyTree struct is need for open path clipping.\");\n      this.m_ExecuteLocked = true;\n      ClipperLib.Clear(solution);\n      this.m_SubjFillType = subjFillType;\n      this.m_ClipFillType = clipFillType;\n      this.m_ClipType = clipType;\n      this.m_UsingPolyTree = false;\n      try\n      {\n        var succeeded = this.ExecuteInternal();\n        //build the return polygons ...\n        if (succeeded) this.BuildResult(solution);\n      }\n      finally\n      {\n        this.DisposeAllPolyPts();\n        this.m_ExecuteLocked = false;\n      }\n      return succeeded;\n    }\n    else if (alen == 4 && ispolytree) // function (clipType, polytree, subjFillType, clipFillType)\n    {\n      var clipType = a[0],\n        polytree = a[1],\n        subjFillType = a[2],\n        clipFillType = a[3];\n      if (this.m_ExecuteLocked)\n        return false;\n      this.m_ExecuteLocked = true;\n      this.m_SubjFillType = subjFillType;\n      this.m_ClipFillType = clipFillType;\n      this.m_ClipType = clipType;\n      this.m_UsingPolyTree = true;\n      try\n      {\n        var succeeded = this.ExecuteInternal();\n        //build the return polygons ...\n        if (succeeded) this.BuildResult2(polytree);\n      }\n      finally\n      {\n        this.DisposeAllPolyPts();\n        this.m_ExecuteLocked = false;\n      }\n      return succeeded;\n    }\n    else if (alen == 2 && !ispolytree) // function (clipType, solution)\n    {\n      var clipType = a[0],\n        solution = a[1];\n      return this.Execute(clipType, solution, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n    }\n    else if (alen == 2 && ispolytree) // function (clipType, polytree)\n    {\n      var clipType = a[0],\n        polytree = a[1];\n      return this.Execute(clipType, polytree, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n    }\n  };\n  ClipperLib.Clipper.prototype.FixHoleLinkage = function (outRec)\n  {\n    //skip if an outermost polygon or\n    //already already points to the correct FirstLeft ...\n    if (outRec.FirstLeft === null || (outRec.IsHole != outRec.FirstLeft.IsHole && outRec.FirstLeft.Pts !== null))\n      return;\n    var orfl = outRec.FirstLeft;\n    while (orfl !== null && ((orfl.IsHole == outRec.IsHole) || orfl.Pts === null))\n      orfl = orfl.FirstLeft;\n    outRec.FirstLeft = orfl;\n  };\n  ClipperLib.Clipper.prototype.ExecuteInternal = function ()\n  {\n    try\n    {\n      this.Reset();\n      if (this.m_CurrentLM === null)\n        return false;\n      var botY = this.PopScanbeam();\n      do {\n        this.InsertLocalMinimaIntoAEL(botY);\n        ClipperLib.Clear(this.m_GhostJoins);\n        this.ProcessHorizontals(false);\n        if (this.m_Scanbeam === null)\n          break;\n        var topY = this.PopScanbeam();\n        if (!this.ProcessIntersections(topY)) return false;\n\n        this.ProcessEdgesAtTopOfScanbeam(topY);\n        botY = topY;\n      }\n      while (this.m_Scanbeam !== null || this.m_CurrentLM !== null)\n      //fix orientations ...\n      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n      {\n        var outRec = this.m_PolyOuts[i];\n        if (outRec.Pts === null || outRec.IsOpen)\n          continue;\n        if ((outRec.IsHole ^ this.ReverseSolution) == (this.Area(outRec) > 0))\n          this.ReversePolyPtLinks(outRec.Pts);\n      }\n      this.JoinCommonEdges();\n      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n      {\n        var outRec = this.m_PolyOuts[i];\n        if (outRec.Pts !== null && !outRec.IsOpen)\n          this.FixupOutPolygon(outRec);\n      }\n      if (this.StrictlySimple)\n        this.DoSimplePolygons();\n      return true;\n    }\n    finally\n    {\n      ClipperLib.Clear(this.m_Joins);\n      ClipperLib.Clear(this.m_GhostJoins);\n    }\n  };\n  ClipperLib.Clipper.prototype.PopScanbeam = function ()\n  {\n    var Y = this.m_Scanbeam.Y;\n    this.m_Scanbeam = this.m_Scanbeam.Next;\n    return Y;\n  };\n\n  ClipperLib.Clipper.prototype.DisposeAllPolyPts = function ()\n  {\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; ++i)\n      this.DisposeOutRec(i);\n    ClipperLib.Clear(this.m_PolyOuts);\n  };\n  ClipperLib.Clipper.prototype.DisposeOutRec = function (index)\n  {\n    var outRec = this.m_PolyOuts[index];\n    outRec.Pts = null;\n    outRec = null;\n    this.m_PolyOuts[index] = null;\n  };\n\n  ClipperLib.Clipper.prototype.AddJoin = function (Op1, Op2, OffPt)\n  {\n    var j = new ClipperLib.Join();\n    j.OutPt1 = Op1;\n    j.OutPt2 = Op2;\n    //j.OffPt = OffPt;\n    j.OffPt.X = OffPt.X;\n    j.OffPt.Y = OffPt.Y;\n    this.m_Joins.push(j);\n  };\n  ClipperLib.Clipper.prototype.AddGhostJoin = function (Op, OffPt)\n  {\n    var j = new ClipperLib.Join();\n    j.OutPt1 = Op;\n    //j.OffPt = OffPt;\n    j.OffPt.X = OffPt.X;\n    j.OffPt.Y = OffPt.Y;\n    this.m_GhostJoins.push(j);\n  };\n  if (use_xyz)\n  {\n    ClipperLib.Clipper.prototype.SetZ = function (pt, e1, e2)\n    {\n      if (this.ZFillFunction !== null)\n      {\n        if (pt.Z != 0 || this.ZFillFunction === null) return;\n        else if (ClipperLib.IntPoint.op_Equality(pt, e1.Bot)) pt.Z = e1.Bot.Z;\n        else if (ClipperLib.IntPoint.op_Equality(pt, e1.Top)) pt.Z = e1.Top.Z;\n        else if (ClipperLib.IntPoint.op_Equality(pt, e2.Bot)) pt.Z = e2.Bot.Z;\n        else if (ClipperLib.IntPoint.op_Equality(pt, e2.Top)) pt.Z = e2.Top.Z;\n        else ZFillFunction(e1.Bot, e1.Top, e2.Bot, e2.Top, pt);\n      }\n    };\n\n    //------------------------------------------------------------------------------\n  }\n\n  ClipperLib.Clipper.prototype.InsertLocalMinimaIntoAEL = function (botY)\n  {\n    while (this.m_CurrentLM !== null && (this.m_CurrentLM.Y == botY))\n    {\n      var lb = this.m_CurrentLM.LeftBound;\n      var rb = this.m_CurrentLM.RightBound;\n      this.PopLocalMinima();\n      var Op1 = null;\n      if (lb === null)\n      {\n        this.InsertEdgeIntoAEL(rb, null);\n        this.SetWindingCount(rb);\n        if (this.IsContributing(rb))\n          Op1 = this.AddOutPt(rb, rb.Bot);\n      }\n      else if (rb == null)\n      {\n        this.InsertEdgeIntoAEL(lb, null);\n        this.SetWindingCount(lb);\n        if (this.IsContributing(lb))\n          Op1 = this.AddOutPt(lb, lb.Bot);\n        this.InsertScanbeam(lb.Top.Y);\n      }\n      else\n      {\n        this.InsertEdgeIntoAEL(lb, null);\n        this.InsertEdgeIntoAEL(rb, lb);\n        this.SetWindingCount(lb);\n        rb.WindCnt = lb.WindCnt;\n        rb.WindCnt2 = lb.WindCnt2;\n        if (this.IsContributing(lb))\n          Op1 = this.AddLocalMinPoly(lb, rb, lb.Bot);\n        this.InsertScanbeam(lb.Top.Y);\n      }\n      if (rb != null)\n      {\n        if (ClipperLib.ClipperBase.IsHorizontal(rb))\n          this.AddEdgeToSEL(rb);\n        else\n          this.InsertScanbeam(rb.Top.Y);\n      }\n      if (lb == null || rb == null) continue;\n      //if output polygons share an Edge with a horizontal rb, they'll need joining later ...\n      if (Op1 !== null && ClipperLib.ClipperBase.IsHorizontal(rb) && this.m_GhostJoins.length > 0 && rb.WindDelta !== 0)\n      {\n        for (var i = 0, ilen = this.m_GhostJoins.length; i < ilen; i++)\n        {\n          //if the horizontal Rb and a 'ghost' horizontal overlap, then convert\n          //the 'ghost' join to a real join ready for later ...\n          var j = this.m_GhostJoins[i];\n\n\t\t\t\t\tif (this.HorzSegmentsOverlap(j.OutPt1.Pt.X, j.OffPt.X, rb.Bot.X, rb.Top.X))\n            this.AddJoin(j.OutPt1, Op1, j.OffPt);\n        }\n      }\n      if (lb.OutIdx >= 0 && lb.PrevInAEL !== null &&\n        lb.PrevInAEL.Curr.X == lb.Bot.X &&\n        lb.PrevInAEL.OutIdx >= 0 &&\n        ClipperLib.ClipperBase.SlopesEqual(lb.PrevInAEL, lb, this.m_UseFullRange) &&\n        lb.WindDelta !== 0 && lb.PrevInAEL.WindDelta !== 0)\n      {\n        var Op2 = this.AddOutPt(lb.PrevInAEL, lb.Bot);\n        this.AddJoin(Op1, Op2, lb.Top);\n      }\n      if (lb.NextInAEL != rb)\n      {\n        if (rb.OutIdx >= 0 && rb.PrevInAEL.OutIdx >= 0 &&\n          ClipperLib.ClipperBase.SlopesEqual(rb.PrevInAEL, rb, this.m_UseFullRange) &&\n          rb.WindDelta !== 0 && rb.PrevInAEL.WindDelta !== 0)\n        {\n          var Op2 = this.AddOutPt(rb.PrevInAEL, rb.Bot);\n          this.AddJoin(Op1, Op2, rb.Top);\n        }\n        var e = lb.NextInAEL;\n        if (e !== null)\n          while (e != rb)\n          {\n            //nb: For calculating winding counts etc, IntersectEdges() assumes\n            //that param1 will be to the right of param2 ABOVE the intersection ...\n            this.IntersectEdges(rb, e, lb.Curr, false);\n            //order important here\n            e = e.NextInAEL;\n          }\n      }\n    }\n  };\n  ClipperLib.Clipper.prototype.InsertEdgeIntoAEL = function (edge, startEdge)\n  {\n    if (this.m_ActiveEdges === null)\n    {\n      edge.PrevInAEL = null;\n      edge.NextInAEL = null;\n      this.m_ActiveEdges = edge;\n    }\n    else if (startEdge === null && this.E2InsertsBeforeE1(this.m_ActiveEdges, edge))\n    {\n      edge.PrevInAEL = null;\n      edge.NextInAEL = this.m_ActiveEdges;\n      this.m_ActiveEdges.PrevInAEL = edge;\n      this.m_ActiveEdges = edge;\n    }\n    else\n    {\n      if (startEdge === null)\n        startEdge = this.m_ActiveEdges;\n      while (startEdge.NextInAEL !== null && !this.E2InsertsBeforeE1(startEdge.NextInAEL, edge))\n        startEdge = startEdge.NextInAEL;\n      edge.NextInAEL = startEdge.NextInAEL;\n      if (startEdge.NextInAEL !== null)\n        startEdge.NextInAEL.PrevInAEL = edge;\n      edge.PrevInAEL = startEdge;\n      startEdge.NextInAEL = edge;\n    }\n  };\n  ClipperLib.Clipper.prototype.E2InsertsBeforeE1 = function (e1, e2)\n  {\n    if (e2.Curr.X == e1.Curr.X)\n    {\n      if (e2.Top.Y > e1.Top.Y)\n        return e2.Top.X < ClipperLib.Clipper.TopX(e1, e2.Top.Y);\n      else\n        return e1.Top.X > ClipperLib.Clipper.TopX(e2, e1.Top.Y);\n    }\n    else\n      return e2.Curr.X < e1.Curr.X;\n  };\n  ClipperLib.Clipper.prototype.IsEvenOddFillType = function (edge)\n  {\n    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n      return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n    else\n      return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n  };\n  ClipperLib.Clipper.prototype.IsEvenOddAltFillType = function (edge)\n  {\n    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n      return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n    else\n      return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n  };\n  ClipperLib.Clipper.prototype.IsContributing = function (edge)\n  {\n    var pft, pft2;\n    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n    {\n      pft = this.m_SubjFillType;\n      pft2 = this.m_ClipFillType;\n    }\n    else\n    {\n      pft = this.m_ClipFillType;\n      pft2 = this.m_SubjFillType;\n    }\n    switch (pft)\n    {\n    case ClipperLib.PolyFillType.pftEvenOdd:\n      if (edge.WindDelta === 0 && edge.WindCnt != 1)\n        return false;\n      break;\n    case ClipperLib.PolyFillType.pftNonZero:\n      if (Math.abs(edge.WindCnt) != 1)\n        return false;\n      break;\n    case ClipperLib.PolyFillType.pftPositive:\n      if (edge.WindCnt != 1)\n        return false;\n      break;\n    default:\n      if (edge.WindCnt != -1)\n        return false;\n      break;\n    }\n    switch (this.m_ClipType)\n    {\n    case ClipperLib.ClipType.ctIntersection:\n      switch (pft2)\n      {\n      case ClipperLib.PolyFillType.pftEvenOdd:\n      case ClipperLib.PolyFillType.pftNonZero:\n        return (edge.WindCnt2 !== 0);\n      case ClipperLib.PolyFillType.pftPositive:\n        return (edge.WindCnt2 > 0);\n      default:\n        return (edge.WindCnt2 < 0);\n      }\n    case ClipperLib.ClipType.ctUnion:\n      switch (pft2)\n      {\n      case ClipperLib.PolyFillType.pftEvenOdd:\n      case ClipperLib.PolyFillType.pftNonZero:\n        return (edge.WindCnt2 === 0);\n      case ClipperLib.PolyFillType.pftPositive:\n        return (edge.WindCnt2 <= 0);\n      default:\n        return (edge.WindCnt2 >= 0);\n      }\n    case ClipperLib.ClipType.ctDifference:\n      if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n        switch (pft2)\n        {\n        case ClipperLib.PolyFillType.pftEvenOdd:\n        case ClipperLib.PolyFillType.pftNonZero:\n          return (edge.WindCnt2 === 0);\n        case ClipperLib.PolyFillType.pftPositive:\n          return (edge.WindCnt2 <= 0);\n        default:\n          return (edge.WindCnt2 >= 0);\n        }\n      else\n        switch (pft2)\n        {\n        case ClipperLib.PolyFillType.pftEvenOdd:\n        case ClipperLib.PolyFillType.pftNonZero:\n          return (edge.WindCnt2 !== 0);\n        case ClipperLib.PolyFillType.pftPositive:\n          return (edge.WindCnt2 > 0);\n        default:\n          return (edge.WindCnt2 < 0);\n        }\n    case ClipperLib.ClipType.ctXor:\n      if (edge.WindDelta === 0)\n        switch (pft2)\n        {\n        case ClipperLib.PolyFillType.pftEvenOdd:\n        case ClipperLib.PolyFillType.pftNonZero:\n          return (edge.WindCnt2 === 0);\n        case ClipperLib.PolyFillType.pftPositive:\n          return (edge.WindCnt2 <= 0);\n        default:\n          return (edge.WindCnt2 >= 0);\n        }\n      else\n        return true;\n    }\n    return true;\n  };\n  ClipperLib.Clipper.prototype.SetWindingCount = function (edge)\n  {\n    var e = edge.PrevInAEL;\n    //find the edge of the same polytype that immediately preceeds 'edge' in AEL\n    while (e !== null && ((e.PolyTyp != edge.PolyTyp) || (e.WindDelta === 0)))\n      e = e.PrevInAEL;\n    if (e === null)\n    {\n      edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n      edge.WindCnt2 = 0;\n      e = this.m_ActiveEdges;\n      //ie get ready to calc WindCnt2\n    }\n    else if (edge.WindDelta === 0 && this.m_ClipType != ClipperLib.ClipType.ctUnion)\n    {\n      edge.WindCnt = 1;\n      edge.WindCnt2 = e.WindCnt2;\n      e = e.NextInAEL;\n      //ie get ready to calc WindCnt2\n    }\n    else if (this.IsEvenOddFillType(edge))\n    {\n      //EvenOdd filling ...\n      if (edge.WindDelta === 0)\n      {\n        //are we inside a subj polygon ...\n        var Inside = true;\n        var e2 = e.PrevInAEL;\n        while (e2 !== null)\n        {\n          if (e2.PolyTyp == e.PolyTyp && e2.WindDelta !== 0)\n            Inside = !Inside;\n          e2 = e2.PrevInAEL;\n        }\n        edge.WindCnt = (Inside ? 0 : 1);\n      }\n      else\n      {\n        edge.WindCnt = edge.WindDelta;\n      }\n      edge.WindCnt2 = e.WindCnt2;\n      e = e.NextInAEL;\n      //ie get ready to calc WindCnt2\n    }\n    else\n    {\n      //nonZero, Positive or Negative filling ...\n      if (e.WindCnt * e.WindDelta < 0)\n      {\n        //prev edge is 'decreasing' WindCount (WC) toward zero\n        //so we're outside the previous polygon ...\n        if (Math.abs(e.WindCnt) > 1)\n        {\n          //outside prev poly but still inside another.\n          //when reversing direction of prev poly use the same WC\n          if (e.WindDelta * edge.WindDelta < 0)\n            edge.WindCnt = e.WindCnt;\n          else\n            edge.WindCnt = e.WindCnt + edge.WindDelta;\n        }\n        else\n          edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n      }\n      else\n      {\n        //prev edge is 'increasing' WindCount (WC) away from zero\n        //so we're inside the previous polygon ...\n        if (edge.WindDelta === 0)\n          edge.WindCnt = (e.WindCnt < 0 ? e.WindCnt - 1 : e.WindCnt + 1);\n        else if (e.WindDelta * edge.WindDelta < 0)\n          edge.WindCnt = e.WindCnt;\n        else\n          edge.WindCnt = e.WindCnt + edge.WindDelta;\n      }\n      edge.WindCnt2 = e.WindCnt2;\n      e = e.NextInAEL;\n      //ie get ready to calc WindCnt2\n    }\n    //update WindCnt2 ...\n    if (this.IsEvenOddAltFillType(edge))\n    {\n      //EvenOdd filling ...\n      while (e != edge)\n      {\n        if (e.WindDelta !== 0)\n          edge.WindCnt2 = (edge.WindCnt2 === 0 ? 1 : 0);\n        e = e.NextInAEL;\n      }\n    }\n    else\n    {\n      //nonZero, Positive or Negative filling ...\n      while (e != edge)\n      {\n        edge.WindCnt2 += e.WindDelta;\n        e = e.NextInAEL;\n      }\n    }\n  };\n  ClipperLib.Clipper.prototype.AddEdgeToSEL = function (edge)\n  {\n    //SEL pointers in PEdge are reused to build a list of horizontal edges.\n    //However, we don't need to worry about order with horizontal edge processing.\n    if (this.m_SortedEdges === null)\n    {\n      this.m_SortedEdges = edge;\n      edge.PrevInSEL = null;\n      edge.NextInSEL = null;\n    }\n    else\n    {\n      edge.NextInSEL = this.m_SortedEdges;\n      edge.PrevInSEL = null;\n      this.m_SortedEdges.PrevInSEL = edge;\n      this.m_SortedEdges = edge;\n    }\n  };\n  ClipperLib.Clipper.prototype.CopyAELToSEL = function ()\n  {\n    var e = this.m_ActiveEdges;\n    this.m_SortedEdges = e;\n    while (e !== null)\n    {\n      e.PrevInSEL = e.PrevInAEL;\n      e.NextInSEL = e.NextInAEL;\n      e = e.NextInAEL;\n    }\n  };\n  ClipperLib.Clipper.prototype.SwapPositionsInAEL = function (edge1, edge2)\n  {\n    //check that one or other edge hasn't already been removed from AEL ...\n    if (edge1.NextInAEL == edge1.PrevInAEL || edge2.NextInAEL == edge2.PrevInAEL)\n      return;\n    if (edge1.NextInAEL == edge2)\n    {\n      var next = edge2.NextInAEL;\n      if (next !== null)\n        next.PrevInAEL = edge1;\n      var prev = edge1.PrevInAEL;\n      if (prev !== null)\n        prev.NextInAEL = edge2;\n      edge2.PrevInAEL = prev;\n      edge2.NextInAEL = edge1;\n      edge1.PrevInAEL = edge2;\n      edge1.NextInAEL = next;\n    }\n    else if (edge2.NextInAEL == edge1)\n    {\n      var next = edge1.NextInAEL;\n      if (next !== null)\n        next.PrevInAEL = edge2;\n      var prev = edge2.PrevInAEL;\n      if (prev !== null)\n        prev.NextInAEL = edge1;\n      edge1.PrevInAEL = prev;\n      edge1.NextInAEL = edge2;\n      edge2.PrevInAEL = edge1;\n      edge2.NextInAEL = next;\n    }\n    else\n    {\n      var next = edge1.NextInAEL;\n      var prev = edge1.PrevInAEL;\n      edge1.NextInAEL = edge2.NextInAEL;\n      if (edge1.NextInAEL !== null)\n        edge1.NextInAEL.PrevInAEL = edge1;\n      edge1.PrevInAEL = edge2.PrevInAEL;\n      if (edge1.PrevInAEL !== null)\n        edge1.PrevInAEL.NextInAEL = edge1;\n      edge2.NextInAEL = next;\n      if (edge2.NextInAEL !== null)\n        edge2.NextInAEL.PrevInAEL = edge2;\n      edge2.PrevInAEL = prev;\n      if (edge2.PrevInAEL !== null)\n        edge2.PrevInAEL.NextInAEL = edge2;\n    }\n    if (edge1.PrevInAEL === null)\n      this.m_ActiveEdges = edge1;\n    else if (edge2.PrevInAEL === null)\n      this.m_ActiveEdges = edge2;\n  };\n  ClipperLib.Clipper.prototype.SwapPositionsInSEL = function (edge1, edge2)\n  {\n    if (edge1.NextInSEL === null && edge1.PrevInSEL === null)\n      return;\n    if (edge2.NextInSEL === null && edge2.PrevInSEL === null)\n      return;\n    if (edge1.NextInSEL == edge2)\n    {\n      var next = edge2.NextInSEL;\n      if (next !== null)\n        next.PrevInSEL = edge1;\n      var prev = edge1.PrevInSEL;\n      if (prev !== null)\n        prev.NextInSEL = edge2;\n      edge2.PrevInSEL = prev;\n      edge2.NextInSEL = edge1;\n      edge1.PrevInSEL = edge2;\n      edge1.NextInSEL = next;\n    }\n    else if (edge2.NextInSEL == edge1)\n    {\n      var next = edge1.NextInSEL;\n      if (next !== null)\n        next.PrevInSEL = edge2;\n      var prev = edge2.PrevInSEL;\n      if (prev !== null)\n        prev.NextInSEL = edge1;\n      edge1.PrevInSEL = prev;\n      edge1.NextInSEL = edge2;\n      edge2.PrevInSEL = edge1;\n      edge2.NextInSEL = next;\n    }\n    else\n    {\n      var next = edge1.NextInSEL;\n      var prev = edge1.PrevInSEL;\n      edge1.NextInSEL = edge2.NextInSEL;\n      if (edge1.NextInSEL !== null)\n        edge1.NextInSEL.PrevInSEL = edge1;\n      edge1.PrevInSEL = edge2.PrevInSEL;\n      if (edge1.PrevInSEL !== null)\n        edge1.PrevInSEL.NextInSEL = edge1;\n      edge2.NextInSEL = next;\n      if (edge2.NextInSEL !== null)\n        edge2.NextInSEL.PrevInSEL = edge2;\n      edge2.PrevInSEL = prev;\n      if (edge2.PrevInSEL !== null)\n        edge2.PrevInSEL.NextInSEL = edge2;\n    }\n    if (edge1.PrevInSEL === null)\n      this.m_SortedEdges = edge1;\n    else if (edge2.PrevInSEL === null)\n      this.m_SortedEdges = edge2;\n  };\n  ClipperLib.Clipper.prototype.AddLocalMaxPoly = function (e1, e2, pt)\n  {\n    this.AddOutPt(e1, pt);\n    if (e2.WindDelta == 0) this.AddOutPt(e2, pt);\n    if (e1.OutIdx == e2.OutIdx)\n    {\n      e1.OutIdx = -1;\n      e2.OutIdx = -1;\n    }\n    else if (e1.OutIdx < e2.OutIdx)\n      this.AppendPolygon(e1, e2);\n    else\n      this.AppendPolygon(e2, e1);\n  };\n  ClipperLib.Clipper.prototype.AddLocalMinPoly = function (e1, e2, pt)\n  {\n    var result;\n    var e, prevE;\n    if (ClipperLib.ClipperBase.IsHorizontal(e2) || (e1.Dx > e2.Dx))\n    {\n      result = this.AddOutPt(e1, pt);\n      e2.OutIdx = e1.OutIdx;\n      e1.Side = ClipperLib.EdgeSide.esLeft;\n      e2.Side = ClipperLib.EdgeSide.esRight;\n      e = e1;\n      if (e.PrevInAEL == e2)\n        prevE = e2.PrevInAEL;\n      else\n        prevE = e.PrevInAEL;\n    }\n    else\n    {\n      result = this.AddOutPt(e2, pt);\n      e1.OutIdx = e2.OutIdx;\n      e1.Side = ClipperLib.EdgeSide.esRight;\n      e2.Side = ClipperLib.EdgeSide.esLeft;\n      e = e2;\n      if (e.PrevInAEL == e1)\n        prevE = e1.PrevInAEL;\n      else\n        prevE = e.PrevInAEL;\n    }\n    if (prevE !== null && prevE.OutIdx >= 0 && (ClipperLib.Clipper.TopX(prevE, pt.Y) == ClipperLib.Clipper.TopX(e, pt.Y)) && ClipperLib.ClipperBase.SlopesEqual(e, prevE, this.m_UseFullRange) && (e.WindDelta !== 0) && (prevE.WindDelta !== 0))\n    {\n      var outPt = this.AddOutPt(prevE, pt);\n      this.AddJoin(result, outPt, e.Top);\n    }\n    return result;\n  };\n  ClipperLib.Clipper.prototype.CreateOutRec = function ()\n  {\n    var result = new ClipperLib.OutRec();\n    result.Idx = -1;\n    result.IsHole = false;\n    result.IsOpen = false;\n    result.FirstLeft = null;\n    result.Pts = null;\n    result.BottomPt = null;\n    result.PolyNode = null;\n    this.m_PolyOuts.push(result);\n    result.Idx = this.m_PolyOuts.length - 1;\n    return result;\n  };\n  ClipperLib.Clipper.prototype.AddOutPt = function (e, pt)\n  {\n    var ToFront = (e.Side == ClipperLib.EdgeSide.esLeft);\n    if (e.OutIdx < 0)\n    {\n      var outRec = this.CreateOutRec();\n      outRec.IsOpen = (e.WindDelta === 0);\n      var newOp = new ClipperLib.OutPt();\n      outRec.Pts = newOp;\n      newOp.Idx = outRec.Idx;\n      //newOp.Pt = pt;\n      newOp.Pt.X = pt.X;\n      newOp.Pt.Y = pt.Y;\n      newOp.Next = newOp;\n      newOp.Prev = newOp;\n      if (!outRec.IsOpen)\n        this.SetHoleState(e, outRec);\n      e.OutIdx = outRec.Idx;\n      //nb: do this after SetZ !\n      return newOp;\n    }\n    else\n    {\n      var outRec = this.m_PolyOuts[e.OutIdx];\n      //OutRec.Pts is the 'Left-most' point & OutRec.Pts.Prev is the 'Right-most'\n      var op = outRec.Pts;\n      if (ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Pt))\n        return op;\n      else if (!ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Prev.Pt))\n        return op.Prev;\n      var newOp = new ClipperLib.OutPt();\n      newOp.Idx = outRec.Idx;\n      //newOp.Pt = pt;\n      newOp.Pt.X = pt.X;\n      newOp.Pt.Y = pt.Y;\n      newOp.Next = op;\n      newOp.Prev = op.Prev;\n      newOp.Prev.Next = newOp;\n      op.Prev = newOp;\n      if (ToFront)\n        outRec.Pts = newOp;\n      return newOp;\n    }\n  };\n  ClipperLib.Clipper.prototype.SwapPoints = function (pt1, pt2)\n  {\n    var tmp = new ClipperLib.IntPoint(pt1.Value);\n    //pt1.Value = pt2.Value;\n    pt1.Value.X = pt2.Value.X;\n    pt1.Value.Y = pt2.Value.Y;\n    //pt2.Value = tmp;\n    pt2.Value.X = tmp.X;\n    pt2.Value.Y = tmp.Y;\n  };\n  ClipperLib.Clipper.prototype.HorzSegmentsOverlap = function (seg1a, seg1b, seg2a, seg2b)\n\t{\n\t\tvar tmp;\n\t\tif (seg1a > seg1b)\n\t\t{\n\t\t\ttmp = seg1a;\n\t\t\tseg1a = seg1b;\n\t\t\tseg1b = tmp;\n\t\t}\n\t\tif (seg2a > seg2b)\n\t\t{\n\t\t\ttmp = seg2a;\n\t\t\tseg2a = seg2b;\n\t\t\tseg2b = tmp;\n\t\t}\n\t\treturn (seg1a < seg2b) && (seg2a < seg1b);\n\t}\n\n  ClipperLib.Clipper.prototype.SetHoleState = function (e, outRec)\n  {\n    var isHole = false;\n    var e2 = e.PrevInAEL;\n    while (e2 !== null)\n    {\n      if (e2.OutIdx >= 0 && e2.WindDelta != 0)\n      {\n        isHole = !isHole;\n        if (outRec.FirstLeft === null)\n          outRec.FirstLeft = this.m_PolyOuts[e2.OutIdx];\n      }\n      e2 = e2.PrevInAEL;\n    }\n    if (isHole)\n      outRec.IsHole = true;\n  };\n  ClipperLib.Clipper.prototype.GetDx = function (pt1, pt2)\n  {\n    if (pt1.Y == pt2.Y)\n      return ClipperLib.ClipperBase.horizontal;\n    else\n      return (pt2.X - pt1.X) / (pt2.Y - pt1.Y);\n  };\n  ClipperLib.Clipper.prototype.FirstIsBottomPt = function (btmPt1, btmPt2)\n  {\n    var p = btmPt1.Prev;\n    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))\n      p = p.Prev;\n    var dx1p = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n    p = btmPt1.Next;\n    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))\n      p = p.Next;\n    var dx1n = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n    p = btmPt2.Prev;\n    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))\n      p = p.Prev;\n    var dx2p = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n    p = btmPt2.Next;\n    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))\n      p = p.Next;\n    var dx2n = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n    return (dx1p >= dx2p && dx1p >= dx2n) || (dx1n >= dx2p && dx1n >= dx2n);\n  };\n  ClipperLib.Clipper.prototype.GetBottomPt = function (pp)\n  {\n    var dups = null;\n    var p = pp.Next;\n    while (p != pp)\n    {\n      if (p.Pt.Y > pp.Pt.Y)\n      {\n        pp = p;\n        dups = null;\n      }\n      else if (p.Pt.Y == pp.Pt.Y && p.Pt.X <= pp.Pt.X)\n      {\n        if (p.Pt.X < pp.Pt.X)\n        {\n          dups = null;\n          pp = p;\n        }\n        else\n        {\n          if (p.Next != pp && p.Prev != pp)\n            dups = p;\n        }\n      }\n      p = p.Next;\n    }\n    if (dups !== null)\n    {\n      //there appears to be at least 2 vertices at bottomPt so ...\n      while (dups != p)\n      {\n        if (!this.FirstIsBottomPt(p, dups))\n          pp = dups;\n        dups = dups.Next;\n        while (ClipperLib.IntPoint.op_Inequality(dups.Pt, pp.Pt))\n          dups = dups.Next;\n      }\n    }\n    return pp;\n  };\n  ClipperLib.Clipper.prototype.GetLowermostRec = function (outRec1, outRec2)\n  {\n    //work out which polygon fragment has the correct hole state ...\n    if (outRec1.BottomPt === null)\n      outRec1.BottomPt = this.GetBottomPt(outRec1.Pts);\n    if (outRec2.BottomPt === null)\n      outRec2.BottomPt = this.GetBottomPt(outRec2.Pts);\n    var bPt1 = outRec1.BottomPt;\n    var bPt2 = outRec2.BottomPt;\n    if (bPt1.Pt.Y > bPt2.Pt.Y)\n      return outRec1;\n    else if (bPt1.Pt.Y < bPt2.Pt.Y)\n      return outRec2;\n    else if (bPt1.Pt.X < bPt2.Pt.X)\n      return outRec1;\n    else if (bPt1.Pt.X > bPt2.Pt.X)\n      return outRec2;\n    else if (bPt1.Next == bPt1)\n      return outRec2;\n    else if (bPt2.Next == bPt2)\n      return outRec1;\n    else if (this.FirstIsBottomPt(bPt1, bPt2))\n      return outRec1;\n    else\n      return outRec2;\n  };\n  ClipperLib.Clipper.prototype.Param1RightOfParam2 = function (outRec1, outRec2)\n  {\n    do {\n      outRec1 = outRec1.FirstLeft;\n      if (outRec1 == outRec2)\n        return true;\n    }\n    while (outRec1 !== null)\n    return false;\n  };\n  ClipperLib.Clipper.prototype.GetOutRec = function (idx)\n  {\n    var outrec = this.m_PolyOuts[idx];\n    while (outrec != this.m_PolyOuts[outrec.Idx])\n      outrec = this.m_PolyOuts[outrec.Idx];\n    return outrec;\n  };\n  ClipperLib.Clipper.prototype.AppendPolygon = function (e1, e2)\n  {\n    //get the start and ends of both output polygons ...\n    var outRec1 = this.m_PolyOuts[e1.OutIdx];\n    var outRec2 = this.m_PolyOuts[e2.OutIdx];\n    var holeStateRec;\n    if (this.Param1RightOfParam2(outRec1, outRec2))\n      holeStateRec = outRec2;\n    else if (this.Param1RightOfParam2(outRec2, outRec1))\n      holeStateRec = outRec1;\n    else\n      holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n    var p1_lft = outRec1.Pts;\n    var p1_rt = p1_lft.Prev;\n    var p2_lft = outRec2.Pts;\n    var p2_rt = p2_lft.Prev;\n    var side;\n    //join e2 poly onto e1 poly and delete pointers to e2 ...\n    if (e1.Side == ClipperLib.EdgeSide.esLeft)\n    {\n      if (e2.Side == ClipperLib.EdgeSide.esLeft)\n      {\n        //z y x a b c\n        this.ReversePolyPtLinks(p2_lft);\n        p2_lft.Next = p1_lft;\n        p1_lft.Prev = p2_lft;\n        p1_rt.Next = p2_rt;\n        p2_rt.Prev = p1_rt;\n        outRec1.Pts = p2_rt;\n      }\n      else\n      {\n        //x y z a b c\n        p2_rt.Next = p1_lft;\n        p1_lft.Prev = p2_rt;\n        p2_lft.Prev = p1_rt;\n        p1_rt.Next = p2_lft;\n        outRec1.Pts = p2_lft;\n      }\n      side = ClipperLib.EdgeSide.esLeft;\n    }\n    else\n    {\n      if (e2.Side == ClipperLib.EdgeSide.esRight)\n      {\n        //a b c z y x\n        this.ReversePolyPtLinks(p2_lft);\n        p1_rt.Next = p2_rt;\n        p2_rt.Prev = p1_rt;\n        p2_lft.Next = p1_lft;\n        p1_lft.Prev = p2_lft;\n      }\n      else\n      {\n        //a b c x y z\n        p1_rt.Next = p2_lft;\n        p2_lft.Prev = p1_rt;\n        p1_lft.Prev = p2_rt;\n        p2_rt.Next = p1_lft;\n      }\n      side = ClipperLib.EdgeSide.esRight;\n    }\n    outRec1.BottomPt = null;\n    if (holeStateRec == outRec2)\n    {\n      if (outRec2.FirstLeft != outRec1)\n        outRec1.FirstLeft = outRec2.FirstLeft;\n      outRec1.IsHole = outRec2.IsHole;\n    }\n    outRec2.Pts = null;\n    outRec2.BottomPt = null;\n    outRec2.FirstLeft = outRec1;\n    var OKIdx = e1.OutIdx;\n    var ObsoleteIdx = e2.OutIdx;\n    e1.OutIdx = -1;\n    //nb: safe because we only get here via AddLocalMaxPoly\n    e2.OutIdx = -1;\n    var e = this.m_ActiveEdges;\n    while (e !== null)\n    {\n      if (e.OutIdx == ObsoleteIdx)\n      {\n        e.OutIdx = OKIdx;\n        e.Side = side;\n        break;\n      }\n      e = e.NextInAEL;\n    }\n    outRec2.Idx = outRec1.Idx;\n  };\n  ClipperLib.Clipper.prototype.ReversePolyPtLinks = function (pp)\n  {\n    if (pp === null)\n      return;\n    var pp1;\n    var pp2;\n    pp1 = pp;\n    do {\n      pp2 = pp1.Next;\n      pp1.Next = pp1.Prev;\n      pp1.Prev = pp2;\n      pp1 = pp2;\n    }\n    while (pp1 != pp)\n  };\n  ClipperLib.Clipper.SwapSides = function (edge1, edge2)\n  {\n    var side = edge1.Side;\n    edge1.Side = edge2.Side;\n    edge2.Side = side;\n  };\n  ClipperLib.Clipper.SwapPolyIndexes = function (edge1, edge2)\n  {\n    var outIdx = edge1.OutIdx;\n    edge1.OutIdx = edge2.OutIdx;\n    edge2.OutIdx = outIdx;\n  };\n  ClipperLib.Clipper.prototype.IntersectEdges = function (e1, e2, pt)\n  {\n    //e1 will be to the left of e2 BELOW the intersection. Therefore e1 is before\n    //e2 in AEL except when e1 is being inserted at the intersection point ...\n    var e1Contributing = (e1.OutIdx >= 0);\n    var e2Contributing = (e2.OutIdx >= 0);\n\n    if (use_xyz)\n    \tthis.SetZ(pt, e1, e2);\n\n    if (use_lines)\n    {\n      //if either edge is on an OPEN path ...\n      if (e1.WindDelta === 0 || e2.WindDelta === 0)\n      {\n        //ignore subject-subject open path intersections UNLESS they\n        //are both open paths, AND they are both 'contributing maximas' ...\n\t\t\t\tif (e1.WindDelta == 0 && e2.WindDelta == 0) return;\n        //if intersecting a subj line with a subj poly ...\n        else if (e1.PolyTyp == e2.PolyTyp &&\n          e1.WindDelta != e2.WindDelta && this.m_ClipType == ClipperLib.ClipType.ctUnion)\n        {\n          if (e1.WindDelta === 0)\n          {\n            if (e2Contributing)\n            {\n              this.AddOutPt(e1, pt);\n              if (e1Contributing)\n                e1.OutIdx = -1;\n            }\n          }\n          else\n          {\n            if (e1Contributing)\n            {\n              this.AddOutPt(e2, pt);\n              if (e2Contributing)\n                e2.OutIdx = -1;\n            }\n          }\n        }\n        else if (e1.PolyTyp != e2.PolyTyp)\n        {\n          if ((e1.WindDelta === 0) && Math.abs(e2.WindCnt) == 1 &&\n            (this.m_ClipType != ClipperLib.ClipType.ctUnion || e2.WindCnt2 === 0))\n          {\n            this.AddOutPt(e1, pt);\n            if (e1Contributing)\n              e1.OutIdx = -1;\n          }\n          else if ((e2.WindDelta === 0) && (Math.abs(e1.WindCnt) == 1) &&\n            (this.m_ClipType != ClipperLib.ClipType.ctUnion || e1.WindCnt2 === 0))\n          {\n            this.AddOutPt(e2, pt);\n            if (e2Contributing)\n              e2.OutIdx = -1;\n          }\n        }\n        return;\n      }\n    }\n    //update winding counts...\n    //assumes that e1 will be to the Right of e2 ABOVE the intersection\n    if (e1.PolyTyp == e2.PolyTyp)\n    {\n      if (this.IsEvenOddFillType(e1))\n      {\n        var oldE1WindCnt = e1.WindCnt;\n        e1.WindCnt = e2.WindCnt;\n        e2.WindCnt = oldE1WindCnt;\n      }\n      else\n      {\n        if (e1.WindCnt + e2.WindDelta === 0)\n          e1.WindCnt = -e1.WindCnt;\n        else\n          e1.WindCnt += e2.WindDelta;\n        if (e2.WindCnt - e1.WindDelta === 0)\n          e2.WindCnt = -e2.WindCnt;\n        else\n          e2.WindCnt -= e1.WindDelta;\n      }\n    }\n    else\n    {\n      if (!this.IsEvenOddFillType(e2))\n        e1.WindCnt2 += e2.WindDelta;\n      else\n        e1.WindCnt2 = (e1.WindCnt2 === 0) ? 1 : 0;\n      if (!this.IsEvenOddFillType(e1))\n        e2.WindCnt2 -= e1.WindDelta;\n      else\n        e2.WindCnt2 = (e2.WindCnt2 === 0) ? 1 : 0;\n    }\n    var e1FillType, e2FillType, e1FillType2, e2FillType2;\n    if (e1.PolyTyp == ClipperLib.PolyType.ptSubject)\n    {\n      e1FillType = this.m_SubjFillType;\n      e1FillType2 = this.m_ClipFillType;\n    }\n    else\n    {\n      e1FillType = this.m_ClipFillType;\n      e1FillType2 = this.m_SubjFillType;\n    }\n    if (e2.PolyTyp == ClipperLib.PolyType.ptSubject)\n    {\n      e2FillType = this.m_SubjFillType;\n      e2FillType2 = this.m_ClipFillType;\n    }\n    else\n    {\n      e2FillType = this.m_ClipFillType;\n      e2FillType2 = this.m_SubjFillType;\n    }\n    var e1Wc, e2Wc;\n    switch (e1FillType)\n    {\n    case ClipperLib.PolyFillType.pftPositive:\n      e1Wc = e1.WindCnt;\n      break;\n    case ClipperLib.PolyFillType.pftNegative:\n      e1Wc = -e1.WindCnt;\n      break;\n    default:\n      e1Wc = Math.abs(e1.WindCnt);\n      break;\n    }\n    switch (e2FillType)\n    {\n    case ClipperLib.PolyFillType.pftPositive:\n      e2Wc = e2.WindCnt;\n      break;\n    case ClipperLib.PolyFillType.pftNegative:\n      e2Wc = -e2.WindCnt;\n      break;\n    default:\n      e2Wc = Math.abs(e2.WindCnt);\n      break;\n    }\n    if (e1Contributing && e2Contributing)\n    {\n\t\t\tif ((e1Wc != 0 && e1Wc != 1) || (e2Wc != 0 && e2Wc != 1) ||\n\t\t\t(e1.PolyTyp != e2.PolyTyp && this.m_ClipType != ClipperLib.ClipType.ctXor))\n\t\t\t{\n\t\t\t\tthis.AddLocalMaxPoly(e1, e2, pt);\n\t\t\t}\n      else\n      {\n        this.AddOutPt(e1, pt);\n        this.AddOutPt(e2, pt);\n        ClipperLib.Clipper.SwapSides(e1, e2);\n        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n      }\n    }\n    else if (e1Contributing)\n    {\n      if (e2Wc === 0 || e2Wc == 1)\n      {\n        this.AddOutPt(e1, pt);\n        ClipperLib.Clipper.SwapSides(e1, e2);\n        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n      }\n    }\n    else if (e2Contributing)\n    {\n      if (e1Wc === 0 || e1Wc == 1)\n      {\n        this.AddOutPt(e2, pt);\n        ClipperLib.Clipper.SwapSides(e1, e2);\n        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n      }\n    }\n\t\telse if ( (e1Wc == 0 || e1Wc == 1) && (e2Wc == 0 || e2Wc == 1))\n    {\n      //neither edge is currently contributing ...\n      var e1Wc2, e2Wc2;\n      switch (e1FillType2)\n      {\n      case ClipperLib.PolyFillType.pftPositive:\n        e1Wc2 = e1.WindCnt2;\n        break;\n      case ClipperLib.PolyFillType.pftNegative:\n        e1Wc2 = -e1.WindCnt2;\n        break;\n      default:\n        e1Wc2 = Math.abs(e1.WindCnt2);\n        break;\n      }\n      switch (e2FillType2)\n      {\n      case ClipperLib.PolyFillType.pftPositive:\n        e2Wc2 = e2.WindCnt2;\n        break;\n      case ClipperLib.PolyFillType.pftNegative:\n        e2Wc2 = -e2.WindCnt2;\n        break;\n      default:\n        e2Wc2 = Math.abs(e2.WindCnt2);\n        break;\n      }\n      if (e1.PolyTyp != e2.PolyTyp)\n      {\n        this.AddLocalMinPoly(e1, e2, pt);\n      }\n      else if (e1Wc == 1 && e2Wc == 1)\n        switch (this.m_ClipType)\n        {\n        case ClipperLib.ClipType.ctIntersection:\n          if (e1Wc2 > 0 && e2Wc2 > 0)\n            this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        case ClipperLib.ClipType.ctUnion:\n          if (e1Wc2 <= 0 && e2Wc2 <= 0)\n            this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        case ClipperLib.ClipType.ctDifference:\n          if (((e1.PolyTyp == ClipperLib.PolyType.ptClip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||\n            ((e1.PolyTyp == ClipperLib.PolyType.ptSubject) && (e1Wc2 <= 0) && (e2Wc2 <= 0)))\n            this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        case ClipperLib.ClipType.ctXor:\n          this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        }\n      else\n        ClipperLib.Clipper.SwapSides(e1, e2);\n    }\n  };\n  ClipperLib.Clipper.prototype.DeleteFromAEL = function (e)\n  {\n    var AelPrev = e.PrevInAEL;\n    var AelNext = e.NextInAEL;\n    if (AelPrev === null && AelNext === null && (e != this.m_ActiveEdges))\n      return;\n    //already deleted\n    if (AelPrev !== null)\n      AelPrev.NextInAEL = AelNext;\n    else\n      this.m_ActiveEdges = AelNext;\n    if (AelNext !== null)\n      AelNext.PrevInAEL = AelPrev;\n    e.NextInAEL = null;\n    e.PrevInAEL = null;\n  };\n  ClipperLib.Clipper.prototype.DeleteFromSEL = function (e)\n  {\n    var SelPrev = e.PrevInSEL;\n    var SelNext = e.NextInSEL;\n    if (SelPrev === null && SelNext === null && (e != this.m_SortedEdges))\n      return;\n    //already deleted\n    if (SelPrev !== null)\n      SelPrev.NextInSEL = SelNext;\n    else\n      this.m_SortedEdges = SelNext;\n    if (SelNext !== null)\n      SelNext.PrevInSEL = SelPrev;\n    e.NextInSEL = null;\n    e.PrevInSEL = null;\n  };\n  ClipperLib.Clipper.prototype.UpdateEdgeIntoAEL = function (e)\n  {\n    if (e.NextInLML === null)\n      ClipperLib.Error(\"UpdateEdgeIntoAEL: invalid call\");\n    var AelPrev = e.PrevInAEL;\n    var AelNext = e.NextInAEL;\n    e.NextInLML.OutIdx = e.OutIdx;\n    if (AelPrev !== null)\n      AelPrev.NextInAEL = e.NextInLML;\n    else\n      this.m_ActiveEdges = e.NextInLML;\n    if (AelNext !== null)\n      AelNext.PrevInAEL = e.NextInLML;\n    e.NextInLML.Side = e.Side;\n    e.NextInLML.WindDelta = e.WindDelta;\n    e.NextInLML.WindCnt = e.WindCnt;\n    e.NextInLML.WindCnt2 = e.WindCnt2;\n    e = e.NextInLML;\n    //    e.Curr = e.Bot;\n    e.Curr.X = e.Bot.X;\n    e.Curr.Y = e.Bot.Y;\n    e.PrevInAEL = AelPrev;\n    e.NextInAEL = AelNext;\n    if (!ClipperLib.ClipperBase.IsHorizontal(e))\n      this.InsertScanbeam(e.Top.Y);\n    return e;\n  };\n  ClipperLib.Clipper.prototype.ProcessHorizontals = function (isTopOfScanbeam)\n  {\n    var horzEdge = this.m_SortedEdges;\n    while (horzEdge !== null)\n    {\n      this.DeleteFromSEL(horzEdge);\n      this.ProcessHorizontal(horzEdge, isTopOfScanbeam);\n      horzEdge = this.m_SortedEdges;\n    }\n  };\n  ClipperLib.Clipper.prototype.GetHorzDirection = function (HorzEdge, $var)\n  {\n    if (HorzEdge.Bot.X < HorzEdge.Top.X)\n    {\n        $var.Left = HorzEdge.Bot.X;\n        $var.Right = HorzEdge.Top.X;\n        $var.Dir = ClipperLib.Direction.dLeftToRight;\n    }\n    else\n    {\n        $var.Left = HorzEdge.Top.X;\n        $var.Right = HorzEdge.Bot.X;\n        $var.Dir = ClipperLib.Direction.dRightToLeft;\n    }\n  };\n  ClipperLib.Clipper.prototype.ProcessHorizontal = function (horzEdge, isTopOfScanbeam)\n  {\n    var $var = {Dir: null, Left: null, Right: null};\n    this.GetHorzDirection(horzEdge, $var);\n    var dir = $var.Dir;\n    var horzLeft = $var.Left;\n    var horzRight = $var.Right;\n\n    var eLastHorz = horzEdge,\n      eMaxPair = null;\n    while (eLastHorz.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(eLastHorz.NextInLML))\n      eLastHorz = eLastHorz.NextInLML;\n    if (eLastHorz.NextInLML === null)\n      eMaxPair = this.GetMaximaPair(eLastHorz);\n    for (;;)\n    {\n      var IsLastHorz = (horzEdge == eLastHorz);\n      var e = this.GetNextInAEL(horzEdge, dir);\n      while (e !== null)\n      {\n        //Break if we've got to the end of an intermediate horizontal edge ...\n        //nb: Smaller Dx's are to the right of larger Dx's ABOVE the horizontal.\n        if (e.Curr.X == horzEdge.Top.X && horzEdge.NextInLML !== null && e.Dx < horzEdge.NextInLML.Dx)\n          break;\n        var eNext = this.GetNextInAEL(e, dir);\n        //saves eNext for later\n        if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X <= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X >= horzLeft))\n        {\n          //so far we're still in range of the horizontal Edge  but make sure\n          //we're at the last of consec. horizontals when matching with eMaxPair\n          if (e == eMaxPair && IsLastHorz)\n          {\n\t\t\t\t\t\tif (horzEdge.OutIdx >= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\t\t\t\t\t\t\tvar eNextHorz = this.m_SortedEdges;\n\t\t\t\t\t\t\twhile (eNextHorz !== null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (eNextHorz.OutIdx >= 0 &&\n\t\t\t\t\t\t\t\t\tthis.HorzSegmentsOverlap(horzEdge.Bot.X,\n\t\t\t\t\t\t\t\t\thorzEdge.Top.X, eNextHorz.Bot.X, eNextHorz.Top.X))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tvar op2 = this.AddOutPt(eNextHorz, eNextHorz.Bot);\n\t\t\t\t\t\t\t\t\tthis.AddJoin(op2, op1, eNextHorz.Top);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\teNextHorz = eNextHorz.NextInSEL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.AddGhostJoin(op1, horzEdge.Bot);\n\t\t\t\t\t\t\tthis.AddLocalMaxPoly(horzEdge, eMaxPair, horzEdge.Top);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.DeleteFromAEL(horzEdge);\n\t\t\t\t\t\tthis.DeleteFromAEL(eMaxPair);\n            return;\n          }\n          else if (dir == ClipperLib.Direction.dLeftToRight)\n          {\n            var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n            this.IntersectEdges(horzEdge, e, Pt);\n          }\n          else\n          {\n            var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n            this.IntersectEdges(e, horzEdge, Pt);\n          }\n          this.SwapPositionsInAEL(horzEdge, e);\n        }\n        else if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X >= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X <= horzLeft))\n          break;\n        e = eNext;\n      }\n      //end while\n      if (horzEdge.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(horzEdge.NextInLML))\n      {\n        horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n        if (horzEdge.OutIdx >= 0)\n          this.AddOutPt(horzEdge, horzEdge.Bot);\n\n          var $var = {Dir: dir, Left: horzLeft, Right: horzRight};\n          this.GetHorzDirection(horzEdge, $var);\n          dir = $var.Dir;\n          horzLeft = $var.Left;\n          horzRight = $var.Right;\n      }\n      else\n        break;\n    }\n    //end for (;;)\n    if (horzEdge.NextInLML !== null)\n    {\n      if (horzEdge.OutIdx >= 0)\n      {\n        var op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\t\t\t\tif (isTopOfScanbeam) this.AddGhostJoin(op1, horzEdge.Bot);\n        horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n        if (horzEdge.WindDelta === 0)\n          return;\n        //nb: HorzEdge is no longer horizontal here\n        var ePrev = horzEdge.PrevInAEL;\n        var eNext = horzEdge.NextInAEL;\n        if (ePrev !== null && ePrev.Curr.X == horzEdge.Bot.X &&\n          ePrev.Curr.Y == horzEdge.Bot.Y && ePrev.WindDelta !== 0 &&\n          (ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&\n            ClipperLib.ClipperBase.SlopesEqual(horzEdge, ePrev, this.m_UseFullRange)))\n        {\n          var op2 = this.AddOutPt(ePrev, horzEdge.Bot);\n          this.AddJoin(op1, op2, horzEdge.Top);\n        }\n        else if (eNext !== null && eNext.Curr.X == horzEdge.Bot.X &&\n          eNext.Curr.Y == horzEdge.Bot.Y && eNext.WindDelta !== 0 &&\n          eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&\n          ClipperLib.ClipperBase.SlopesEqual(horzEdge, eNext, this.m_UseFullRange))\n        {\n          var op2 = this.AddOutPt(eNext, horzEdge.Bot);\n          this.AddJoin(op1, op2, horzEdge.Top);\n        }\n      }\n      else horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n    }\n  \telse\n    {\n      if (horzEdge.OutIdx >= 0)\n        this.AddOutPt(horzEdge, horzEdge.Top);\n      this.DeleteFromAEL(horzEdge);\n    }\n  };\n  ClipperLib.Clipper.prototype.GetNextInAEL = function (e, Direction)\n  {\n    return Direction == ClipperLib.Direction.dLeftToRight ? e.NextInAEL : e.PrevInAEL;\n  };\n  ClipperLib.Clipper.prototype.IsMinima = function (e)\n  {\n    return e !== null && (e.Prev.NextInLML != e) && (e.Next.NextInLML != e);\n  };\n  ClipperLib.Clipper.prototype.IsMaxima = function (e, Y)\n  {\n    return (e !== null && e.Top.Y == Y && e.NextInLML === null);\n  };\n  ClipperLib.Clipper.prototype.IsIntermediate = function (e, Y)\n  {\n    return (e.Top.Y == Y && e.NextInLML !== null);\n  };\n  ClipperLib.Clipper.prototype.GetMaximaPair = function (e)\n  {\n    var result = null;\n    if ((ClipperLib.IntPoint.op_Equality(e.Next.Top, e.Top)) && e.Next.NextInLML === null)\n      result = e.Next;\n    else if ((ClipperLib.IntPoint.op_Equality(e.Prev.Top, e.Top)) && e.Prev.NextInLML === null)\n      result = e.Prev;\n    if (result !== null && (result.OutIdx == -2 || (result.NextInAEL == result.PrevInAEL && !ClipperLib.ClipperBase.IsHorizontal(result))))\n      return null;\n    return result;\n  };\n\n  ClipperLib.Clipper.prototype.ProcessIntersections = function (topY)\n  {\n    if (this.m_ActiveEdges == null)\n      return true;\n    try\n    {\n      this.BuildIntersectList(topY);\n      if (this.m_IntersectList.length == 0)\n        return true;\n      if (this.m_IntersectList.length == 1 || this.FixupIntersectionOrder())\n        this.ProcessIntersectList();\n      else\n        return false;\n    }\n    catch ($$e2)\n    {\n      this.m_SortedEdges = null;\n      this.m_IntersectList.length = 0;\n      ClipperLib.Error(\"ProcessIntersections error\");\n    }\n    this.m_SortedEdges = null;\n    return true;\n  };\n  ClipperLib.Clipper.prototype.BuildIntersectList = function (topY)\n  {\n    if (this.m_ActiveEdges === null)\n      return;\n    //prepare for sorting ...\n    var e = this.m_ActiveEdges;\n    //console.log(JSON.stringify(JSON.decycle( e )));\n    this.m_SortedEdges = e;\n    while (e !== null)\n    {\n      e.PrevInSEL = e.PrevInAEL;\n      e.NextInSEL = e.NextInAEL;\n      e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n      e = e.NextInAEL;\n    }\n    //bubblesort ...\n    var isModified = true;\n    while (isModified && this.m_SortedEdges !== null)\n    {\n      isModified = false;\n      e = this.m_SortedEdges;\n      while (e.NextInSEL !== null)\n      {\n        var eNext = e.NextInSEL;\n        var pt = new ClipperLib.IntPoint();\n        //console.log(\"e.Curr.X: \" + e.Curr.X + \" eNext.Curr.X\" + eNext.Curr.X);\n        if (e.Curr.X > eNext.Curr.X)\n        {\n\t\t\t\t\tthis.IntersectPoint(e, eNext, pt);\n          var newNode = new ClipperLib.IntersectNode();\n          newNode.Edge1 = e;\n          newNode.Edge2 = eNext;\n          //newNode.Pt = pt;\n          newNode.Pt.X = pt.X;\n          newNode.Pt.Y = pt.Y;\n          this.m_IntersectList.push(newNode);\n          this.SwapPositionsInSEL(e, eNext);\n          isModified = true;\n        }\n        else\n          e = eNext;\n      }\n      if (e.PrevInSEL !== null)\n        e.PrevInSEL.NextInSEL = null;\n      else\n        break;\n    }\n    this.m_SortedEdges = null;\n  };\n  ClipperLib.Clipper.prototype.EdgesAdjacent = function (inode)\n  {\n    return (inode.Edge1.NextInSEL == inode.Edge2) || (inode.Edge1.PrevInSEL == inode.Edge2);\n  };\n  ClipperLib.Clipper.IntersectNodeSort = function (node1, node2)\n  {\n    //the following typecast is safe because the differences in Pt.Y will\n    //be limited to the height of the scanbeam.\n    return (node2.Pt.Y - node1.Pt.Y);\n  };\n  ClipperLib.Clipper.prototype.FixupIntersectionOrder = function ()\n  {\n    //pre-condition: intersections are sorted bottom-most first.\n    //Now it's crucial that intersections are made only between adjacent edges,\n    //so to ensure this the order of intersections may need adjusting ...\n    this.m_IntersectList.sort(this.m_IntersectNodeComparer);\n    this.CopyAELToSEL();\n    var cnt = this.m_IntersectList.length;\n    for (var i = 0; i < cnt; i++)\n    {\n      if (!this.EdgesAdjacent(this.m_IntersectList[i]))\n      {\n        var j = i + 1;\n        while (j < cnt && !this.EdgesAdjacent(this.m_IntersectList[j]))\n          j++;\n        if (j == cnt)\n          return false;\n        var tmp = this.m_IntersectList[i];\n        this.m_IntersectList[i] = this.m_IntersectList[j];\n        this.m_IntersectList[j] = tmp;\n      }\n      this.SwapPositionsInSEL(this.m_IntersectList[i].Edge1, this.m_IntersectList[i].Edge2);\n    }\n    return true;\n  };\n  ClipperLib.Clipper.prototype.ProcessIntersectList = function ()\n  {\n    for (var i = 0, ilen = this.m_IntersectList.length; i < ilen; i++)\n    {\n      var iNode = this.m_IntersectList[i];\n      this.IntersectEdges(iNode.Edge1, iNode.Edge2, iNode.Pt);\n      this.SwapPositionsInAEL(iNode.Edge1, iNode.Edge2);\n    }\n    this.m_IntersectList.length = 0;\n  };\n  /*\n  --------------------------------\n  Round speedtest: http://jsperf.com/fastest-round\n  --------------------------------\n  */\n  var R1 = function (a)\n  {\n    return a < 0 ? Math.ceil(a - 0.5) : Math.round(a)\n  };\n  var R2 = function (a)\n  {\n    return a < 0 ? Math.ceil(a - 0.5) : Math.floor(a + 0.5)\n  };\n  var R3 = function (a)\n  {\n    return a < 0 ? -Math.round(Math.abs(a)) : Math.round(a)\n  };\n  var R4 = function (a)\n  {\n    if (a < 0)\n    {\n      a -= 0.5;\n      return a < -2147483648 ? Math.ceil(a) : a | 0;\n    }\n    else\n    {\n      a += 0.5;\n      return a > 2147483647 ? Math.floor(a) : a | 0;\n    }\n  };\n  if (browser.msie) ClipperLib.Clipper.Round = R1;\n  else if (browser.chromium) ClipperLib.Clipper.Round = R3;\n  else if (browser.safari) ClipperLib.Clipper.Round = R4;\n  else ClipperLib.Clipper.Round = R2; // eg. browser.chrome || browser.firefox || browser.opera\n  ClipperLib.Clipper.TopX = function (edge, currentY)\n  {\n    //if (edge.Bot == edge.Curr) alert (\"edge.Bot = edge.Curr\");\n    //if (edge.Bot == edge.Top) alert (\"edge.Bot = edge.Top\");\n    if (currentY == edge.Top.Y)\n      return edge.Top.X;\n    return edge.Bot.X + ClipperLib.Clipper.Round(edge.Dx * (currentY - edge.Bot.Y));\n  };\n  ClipperLib.Clipper.prototype.IntersectPoint = function (edge1, edge2, ip)\n  {\n    ip.X = 0;\n    ip.Y = 0;\n    var b1, b2;\n    //nb: with very large coordinate values, it's possible for SlopesEqual() to\n    //return false but for the edge.Dx value be equal due to double precision rounding.\n    if (edge1.Dx == edge2.Dx)\n\t\t{\n\t\t\tip.Y = edge1.Curr.Y;\n\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t\treturn;\n    }\n    if (edge1.Delta.X === 0)\n    {\n      ip.X = edge1.Bot.X;\n      if (ClipperLib.ClipperBase.IsHorizontal(edge2))\n      {\n        ip.Y = edge2.Bot.Y;\n      }\n      else\n      {\n        b2 = edge2.Bot.Y - (edge2.Bot.X / edge2.Dx);\n        ip.Y = ClipperLib.Clipper.Round(ip.X / edge2.Dx + b2);\n      }\n    }\n    else if (edge2.Delta.X === 0)\n    {\n      ip.X = edge2.Bot.X;\n      if (ClipperLib.ClipperBase.IsHorizontal(edge1))\n      {\n        ip.Y = edge1.Bot.Y;\n      }\n      else\n      {\n        b1 = edge1.Bot.Y - (edge1.Bot.X / edge1.Dx);\n        ip.Y = ClipperLib.Clipper.Round(ip.X / edge1.Dx + b1);\n      }\n    }\n    else\n    {\n      b1 = edge1.Bot.X - edge1.Bot.Y * edge1.Dx;\n      b2 = edge2.Bot.X - edge2.Bot.Y * edge2.Dx;\n      var q = (b2 - b1) / (edge1.Dx - edge2.Dx);\n      ip.Y = ClipperLib.Clipper.Round(q);\n      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n        ip.X = ClipperLib.Clipper.Round(edge1.Dx * q + b1);\n      else\n        ip.X = ClipperLib.Clipper.Round(edge2.Dx * q + b2);\n    }\n    if (ip.Y < edge1.Top.Y || ip.Y < edge2.Top.Y)\n    {\n      if (edge1.Top.Y > edge2.Top.Y)\n      {\n        ip.Y = edge1.Top.Y;\n        ip.X = ClipperLib.Clipper.TopX(edge2, edge1.Top.Y);\n        return ip.X < edge1.Top.X;\n      }\n      else\n        ip.Y = edge2.Top.Y;\n      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n        ip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n      else\n        ip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n    }\n\t\t//finally, don't allow 'ip' to be BELOW curr.Y (ie bottom of scanbeam) ...\n\t\tif (ip.Y > edge1.Curr.Y)\n\t\t{\n\t\t\tip.Y = edge1.Curr.Y;\n\t\t\t//better to use the more vertical edge to derive X ...\n\t\t\tif (Math.abs(edge1.Dx) > Math.abs(edge2.Dx))\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n\t\t\telse\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t}\n  };\n\n  ClipperLib.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function (topY)\n  {\n    var e = this.m_ActiveEdges;\n    while (e !== null)\n    {\n      //1. process maxima, treating them as if they're 'bent' horizontal edges,\n      //   but exclude maxima with horizontal edges. nb: e can't be a horizontal.\n      var IsMaximaEdge = this.IsMaxima(e, topY);\n      if (IsMaximaEdge)\n      {\n        var eMaxPair = this.GetMaximaPair(e);\n        IsMaximaEdge = (eMaxPair === null || !ClipperLib.ClipperBase.IsHorizontal(eMaxPair));\n      }\n      if (IsMaximaEdge)\n      {\n        var ePrev = e.PrevInAEL;\n        this.DoMaxima(e);\n        if (ePrev === null)\n          e = this.m_ActiveEdges;\n        else\n          e = ePrev.NextInAEL;\n      }\n      else\n      {\n        //2. promote horizontal edges, otherwise update Curr.X and Curr.Y ...\n        if (this.IsIntermediate(e, topY) && ClipperLib.ClipperBase.IsHorizontal(e.NextInLML))\n        {\n          e = this.UpdateEdgeIntoAEL(e);\n          if (e.OutIdx >= 0)\n            this.AddOutPt(e, e.Bot);\n          this.AddEdgeToSEL(e);\n        }\n        else\n        {\n          e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n          e.Curr.Y = topY;\n        }\n        if (this.StrictlySimple)\n        {\n          var ePrev = e.PrevInAEL;\n          if ((e.OutIdx >= 0) && (e.WindDelta !== 0) && ePrev !== null &&\n            (ePrev.OutIdx >= 0) && (ePrev.Curr.X == e.Curr.X) &&\n            (ePrev.WindDelta !== 0))\n          {\n           \tvar ip = new ClipperLib.IntPoint(e.Curr);\n\n\t\t\t\t\t\tif(use_xyz)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.SetZ(ip, ePrev, e);\n\t\t\t\t\t\t}\n\n            var op = this.AddOutPt(ePrev, ip);\n            var op2 = this.AddOutPt(e, ip);\n            this.AddJoin(op, op2, ip);\n            //StrictlySimple (type-3) join\n          }\n        }\n        e = e.NextInAEL;\n      }\n    }\n    //3. Process horizontals at the Top of the scanbeam ...\n    this.ProcessHorizontals(true);\n    //4. Promote intermediate vertices ...\n    e = this.m_ActiveEdges;\n    while (e !== null)\n    {\n      if (this.IsIntermediate(e, topY))\n      {\n        var op = null;\n        if (e.OutIdx >= 0)\n          op = this.AddOutPt(e, e.Top);\n        e = this.UpdateEdgeIntoAEL(e);\n        //if output polygons share an edge, they'll need joining later ...\n        var ePrev = e.PrevInAEL;\n        var eNext = e.NextInAEL;\n        if (ePrev !== null && ePrev.Curr.X == e.Bot.X &&\n          ePrev.Curr.Y == e.Bot.Y && op !== null &&\n          ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&\n          ClipperLib.ClipperBase.SlopesEqual(e, ePrev, this.m_UseFullRange) &&\n          (e.WindDelta !== 0) && (ePrev.WindDelta !== 0))\n        {\n          var op2 = this.AddOutPt(ePrev, e.Bot);\n          this.AddJoin(op, op2, e.Top);\n        }\n        else if (eNext !== null && eNext.Curr.X == e.Bot.X &&\n          eNext.Curr.Y == e.Bot.Y && op !== null &&\n          eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&\n          ClipperLib.ClipperBase.SlopesEqual(e, eNext, this.m_UseFullRange) &&\n          (e.WindDelta !== 0) && (eNext.WindDelta !== 0))\n        {\n          var op2 = this.AddOutPt(eNext, e.Bot);\n          this.AddJoin(op, op2, e.Top);\n        }\n      }\n      e = e.NextInAEL;\n    }\n  };\n  ClipperLib.Clipper.prototype.DoMaxima = function (e)\n  {\n    var eMaxPair = this.GetMaximaPair(e);\n    if (eMaxPair === null)\n    {\n      if (e.OutIdx >= 0)\n        this.AddOutPt(e, e.Top);\n      this.DeleteFromAEL(e);\n      return;\n    }\n    var eNext = e.NextInAEL;\n    var use_lines = true;\n    while (eNext !== null && eNext != eMaxPair)\n    {\n      this.IntersectEdges(e, eNext, e.Top);\n      this.SwapPositionsInAEL(e, eNext);\n      eNext = e.NextInAEL;\n    }\n    if (e.OutIdx == -1 && eMaxPair.OutIdx == -1)\n    {\n      this.DeleteFromAEL(e);\n      this.DeleteFromAEL(eMaxPair);\n    }\n    else if (e.OutIdx >= 0 && eMaxPair.OutIdx >= 0)\n    {\n    \tif (e.OutIdx >= 0) this.AddLocalMaxPoly(e, eMaxPair, e.Top);\n      this.DeleteFromAEL(e);\n      this.DeleteFromAEL(eMaxPair);\n    }\n    else if (use_lines && e.WindDelta === 0)\n    {\n      if (e.OutIdx >= 0)\n      {\n        this.AddOutPt(e, e.Top);\n        e.OutIdx = -1;\n      }\n      this.DeleteFromAEL(e);\n      if (eMaxPair.OutIdx >= 0)\n      {\n        this.AddOutPt(eMaxPair, e.Top);\n        eMaxPair.OutIdx = -1;\n      }\n      this.DeleteFromAEL(eMaxPair);\n    }\n    else\n      ClipperLib.Error(\"DoMaxima error\");\n  };\n  ClipperLib.Clipper.ReversePaths = function (polys)\n  {\n    for (var i = 0, len = polys.length; i < len; i++)\n      polys[i].reverse();\n  };\n  ClipperLib.Clipper.Orientation = function (poly)\n  {\n    return ClipperLib.Clipper.Area(poly) >= 0;\n  };\n  ClipperLib.Clipper.prototype.PointCount = function (pts)\n  {\n    if (pts === null)\n      return 0;\n    var result = 0;\n    var p = pts;\n    do {\n      result++;\n      p = p.Next;\n    }\n    while (p != pts)\n    return result;\n  };\n  ClipperLib.Clipper.prototype.BuildResult = function (polyg)\n  {\n    ClipperLib.Clear(polyg);\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n      var outRec = this.m_PolyOuts[i];\n      if (outRec.Pts === null)\n        continue;\n      var p = outRec.Pts.Prev;\n      var cnt = this.PointCount(p);\n      if (cnt < 2)\n        continue;\n      var pg = new Array(cnt);\n      for (var j = 0; j < cnt; j++)\n      {\n        pg[j] = p.Pt;\n        p = p.Prev;\n      }\n      polyg.push(pg);\n    }\n  };\n  ClipperLib.Clipper.prototype.BuildResult2 = function (polytree)\n  {\n    polytree.Clear();\n    //add each output polygon/contour to polytree ...\n    //polytree.m_AllPolys.set_Capacity(this.m_PolyOuts.length);\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n      var outRec = this.m_PolyOuts[i];\n      var cnt = this.PointCount(outRec.Pts);\n      if ((outRec.IsOpen && cnt < 2) || (!outRec.IsOpen && cnt < 3))\n        continue;\n      this.FixHoleLinkage(outRec);\n      var pn = new ClipperLib.PolyNode();\n      polytree.m_AllPolys.push(pn);\n      outRec.PolyNode = pn;\n      pn.m_polygon.length = cnt;\n      var op = outRec.Pts.Prev;\n      for (var j = 0; j < cnt; j++)\n      {\n        pn.m_polygon[j] = op.Pt;\n        op = op.Prev;\n      }\n    }\n    //fixup PolyNode links etc ...\n    //polytree.m_Childs.set_Capacity(this.m_PolyOuts.length);\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n      var outRec = this.m_PolyOuts[i];\n      if (outRec.PolyNode === null)\n        continue;\n      else if (outRec.IsOpen)\n      {\n        outRec.PolyNode.IsOpen = true;\n        polytree.AddChild(outRec.PolyNode);\n      }\n      else if (outRec.FirstLeft !== null && outRec.FirstLeft.PolyNode != null)\n        outRec.FirstLeft.PolyNode.AddChild(outRec.PolyNode);\n      else\n        polytree.AddChild(outRec.PolyNode);\n    }\n  };\n  ClipperLib.Clipper.prototype.FixupOutPolygon = function (outRec)\n  {\n    //FixupOutPolygon() - removes duplicate points and simplifies consecutive\n    //parallel edges by removing the middle vertex.\n    var lastOK = null;\n    outRec.BottomPt = null;\n    var pp = outRec.Pts;\n    for (;;)\n    {\n      if (pp.Prev == pp || pp.Prev == pp.Next)\n      {\n        outRec.Pts = null;\n        return;\n      }\n      //test for duplicate points and collinear edges ...\n      if ((ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Next.Pt)) || (ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Prev.Pt)) ||\n        (ClipperLib.ClipperBase.SlopesEqual(pp.Prev.Pt, pp.Pt, pp.Next.Pt, this.m_UseFullRange) &&\n          (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(pp.Prev.Pt, pp.Pt, pp.Next.Pt))))\n      {\n        lastOK = null;\n        pp.Prev.Next = pp.Next;\n        pp.Next.Prev = pp.Prev;\n        pp = pp.Prev;\n      }\n      else if (pp == lastOK)\n        break;\n      else\n      {\n        if (lastOK === null)\n          lastOK = pp;\n        pp = pp.Next;\n      }\n    }\n    outRec.Pts = pp;\n  };\n  ClipperLib.Clipper.prototype.DupOutPt = function (outPt, InsertAfter)\n  {\n    var result = new ClipperLib.OutPt();\n    //result.Pt = outPt.Pt;\n    result.Pt.X = outPt.Pt.X;\n    result.Pt.Y = outPt.Pt.Y;\n    result.Idx = outPt.Idx;\n    if (InsertAfter)\n    {\n      result.Next = outPt.Next;\n      result.Prev = outPt;\n      outPt.Next.Prev = result;\n      outPt.Next = result;\n    }\n    else\n    {\n      result.Prev = outPt.Prev;\n      result.Next = outPt;\n      outPt.Prev.Next = result;\n      outPt.Prev = result;\n    }\n    return result;\n  };\n  ClipperLib.Clipper.prototype.GetOverlap = function (a1, a2, b1, b2, $val)\n  {\n    if (a1 < a2)\n    {\n      if (b1 < b2)\n      {\n        $val.Left = Math.max(a1, b1);\n        $val.Right = Math.min(a2, b2);\n      }\n      else\n      {\n        $val.Left = Math.max(a1, b2);\n        $val.Right = Math.min(a2, b1);\n      }\n    }\n    else\n    {\n      if (b1 < b2)\n      {\n        $val.Left = Math.max(a2, b1);\n        $val.Right = Math.min(a1, b2);\n      }\n      else\n      {\n        $val.Left = Math.max(a2, b2);\n        $val.Right = Math.min(a1, b1);\n      }\n    }\n    return $val.Left < $val.Right;\n  };\n  ClipperLib.Clipper.prototype.JoinHorz = function (op1, op1b, op2, op2b, Pt, DiscardLeft)\n  {\n    var Dir1 = (op1.Pt.X > op1b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n    var Dir2 = (op2.Pt.X > op2b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n    if (Dir1 == Dir2)\n      return false;\n    //When DiscardLeft, we want Op1b to be on the Left of Op1, otherwise we\n    //want Op1b to be on the Right. (And likewise with Op2 and Op2b.)\n    //So, to facilitate this while inserting Op1b and Op2b ...\n    //when DiscardLeft, make sure we're AT or RIGHT of Pt before adding Op1b,\n    //otherwise make sure we're AT or LEFT of Pt. (Likewise with Op2b.)\n    if (Dir1 == ClipperLib.Direction.dLeftToRight)\n    {\n      while (op1.Next.Pt.X <= Pt.X &&\n        op1.Next.Pt.X >= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)\n        op1 = op1.Next;\n      if (DiscardLeft && (op1.Pt.X != Pt.X))\n        op1 = op1.Next;\n      op1b = this.DupOutPt(op1, !DiscardLeft);\n      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n      {\n        op1 = op1b;\n        //op1.Pt = Pt;\n        op1.Pt.X = Pt.X;\n        op1.Pt.Y = Pt.Y;\n        op1b = this.DupOutPt(op1, !DiscardLeft);\n      }\n    }\n    else\n    {\n      while (op1.Next.Pt.X >= Pt.X &&\n        op1.Next.Pt.X <= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)\n        op1 = op1.Next;\n      if (!DiscardLeft && (op1.Pt.X != Pt.X))\n        op1 = op1.Next;\n      op1b = this.DupOutPt(op1, DiscardLeft);\n      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n      {\n        op1 = op1b;\n        //op1.Pt = Pt;\n        op1.Pt.X = Pt.X;\n        op1.Pt.Y = Pt.Y;\n        op1b = this.DupOutPt(op1, DiscardLeft);\n      }\n    }\n    if (Dir2 == ClipperLib.Direction.dLeftToRight)\n    {\n      while (op2.Next.Pt.X <= Pt.X &&\n        op2.Next.Pt.X >= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)\n        op2 = op2.Next;\n      if (DiscardLeft && (op2.Pt.X != Pt.X))\n        op2 = op2.Next;\n      op2b = this.DupOutPt(op2, !DiscardLeft);\n      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n      {\n        op2 = op2b;\n        //op2.Pt = Pt;\n        op2.Pt.X = Pt.X;\n        op2.Pt.Y = Pt.Y;\n        op2b = this.DupOutPt(op2, !DiscardLeft);\n      }\n    }\n    else\n    {\n      while (op2.Next.Pt.X >= Pt.X &&\n        op2.Next.Pt.X <= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)\n        op2 = op2.Next;\n      if (!DiscardLeft && (op2.Pt.X != Pt.X))\n        op2 = op2.Next;\n      op2b = this.DupOutPt(op2, DiscardLeft);\n      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n      {\n        op2 = op2b;\n        //op2.Pt = Pt;\n        op2.Pt.X = Pt.X;\n        op2.Pt.Y = Pt.Y;\n        op2b = this.DupOutPt(op2, DiscardLeft);\n      }\n    }\n    if ((Dir1 == ClipperLib.Direction.dLeftToRight) == DiscardLeft)\n    {\n      op1.Prev = op2;\n      op2.Next = op1;\n      op1b.Next = op2b;\n      op2b.Prev = op1b;\n    }\n    else\n    {\n      op1.Next = op2;\n      op2.Prev = op1;\n      op1b.Prev = op2b;\n      op2b.Next = op1b;\n    }\n    return true;\n  };\n  ClipperLib.Clipper.prototype.JoinPoints = function (j, outRec1, outRec2)\n  {\n    var op1 = j.OutPt1,\n      op1b = new ClipperLib.OutPt();\n    var op2 = j.OutPt2,\n      op2b = new ClipperLib.OutPt();\n    //There are 3 kinds of joins for output polygons ...\n    //1. Horizontal joins where Join.OutPt1 & Join.OutPt2 are a vertices anywhere\n    //along (horizontal) collinear edges (& Join.OffPt is on the same horizontal).\n    //2. Non-horizontal joins where Join.OutPt1 & Join.OutPt2 are at the same\n    //location at the Bottom of the overlapping segment (& Join.OffPt is above).\n    //3. StrictlySimple joins where edges touch but are not collinear and where\n    //Join.OutPt1, Join.OutPt2 & Join.OffPt all share the same point.\n    var isHorizontal = (j.OutPt1.Pt.Y == j.OffPt.Y);\n    if (isHorizontal && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt1.Pt)) && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt2.Pt)))\n    {\n      //Strictly Simple join ...\n\t\t\tif (outRec1 != outRec2) return false;\n\n      op1b = j.OutPt1.Next;\n      while (op1b != op1 && (ClipperLib.IntPoint.op_Equality(op1b.Pt, j.OffPt)))\n        op1b = op1b.Next;\n      var reverse1 = (op1b.Pt.Y > j.OffPt.Y);\n      op2b = j.OutPt2.Next;\n      while (op2b != op2 && (ClipperLib.IntPoint.op_Equality(op2b.Pt, j.OffPt)))\n        op2b = op2b.Next;\n      var reverse2 = (op2b.Pt.Y > j.OffPt.Y);\n      if (reverse1 == reverse2)\n        return false;\n      if (reverse1)\n      {\n        op1b = this.DupOutPt(op1, false);\n        op2b = this.DupOutPt(op2, true);\n        op1.Prev = op2;\n        op2.Next = op1;\n        op1b.Next = op2b;\n        op2b.Prev = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      }\n      else\n      {\n        op1b = this.DupOutPt(op1, true);\n        op2b = this.DupOutPt(op2, false);\n        op1.Next = op2;\n        op2.Prev = op1;\n        op1b.Prev = op2b;\n        op2b.Next = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      }\n    }\n    else if (isHorizontal)\n    {\n      //treat horizontal joins differently to non-horizontal joins since with\n      //them we're not yet sure where the overlapping is. OutPt1.Pt & OutPt2.Pt\n      //may be anywhere along the horizontal edge.\n      op1b = op1;\n      while (op1.Prev.Pt.Y == op1.Pt.Y && op1.Prev != op1b && op1.Prev != op2)\n        op1 = op1.Prev;\n      while (op1b.Next.Pt.Y == op1b.Pt.Y && op1b.Next != op1 && op1b.Next != op2)\n        op1b = op1b.Next;\n      if (op1b.Next == op1 || op1b.Next == op2)\n        return false;\n      //a flat 'polygon'\n      op2b = op2;\n      while (op2.Prev.Pt.Y == op2.Pt.Y && op2.Prev != op2b && op2.Prev != op1b)\n        op2 = op2.Prev;\n      while (op2b.Next.Pt.Y == op2b.Pt.Y && op2b.Next != op2 && op2b.Next != op1)\n        op2b = op2b.Next;\n      if (op2b.Next == op2 || op2b.Next == op1)\n        return false;\n      //a flat 'polygon'\n      //Op1 -. Op1b & Op2 -. Op2b are the extremites of the horizontal edges\n\n      var $val = {Left: null, Right: null};\n      if (!this.GetOverlap(op1.Pt.X, op1b.Pt.X, op2.Pt.X, op2b.Pt.X, $val))\n        return false;\n      var Left = $val.Left;\n      var Right = $val.Right;\n\n      //DiscardLeftSide: when overlapping edges are joined, a spike will created\n      //which needs to be cleaned up. However, we don't want Op1 or Op2 caught up\n      //on the discard Side as either may still be needed for other joins ...\n      var Pt = new ClipperLib.IntPoint();\n      var DiscardLeftSide;\n      if (op1.Pt.X >= Left && op1.Pt.X <= Right)\n      {\n        //Pt = op1.Pt;\n        Pt.X = op1.Pt.X;\n        Pt.Y = op1.Pt.Y;\n        DiscardLeftSide = (op1.Pt.X > op1b.Pt.X);\n      }\n      else if (op2.Pt.X >= Left && op2.Pt.X <= Right)\n      {\n        //Pt = op2.Pt;\n        Pt.X = op2.Pt.X;\n        Pt.Y = op2.Pt.Y;\n        DiscardLeftSide = (op2.Pt.X > op2b.Pt.X);\n      }\n      else if (op1b.Pt.X >= Left && op1b.Pt.X <= Right)\n      {\n        //Pt = op1b.Pt;\n        Pt.X = op1b.Pt.X;\n        Pt.Y = op1b.Pt.Y;\n        DiscardLeftSide = op1b.Pt.X > op1.Pt.X;\n      }\n      else\n      {\n        //Pt = op2b.Pt;\n        Pt.X = op2b.Pt.X;\n        Pt.Y = op2b.Pt.Y;\n        DiscardLeftSide = (op2b.Pt.X > op2.Pt.X);\n      }\n      j.OutPt1 = op1;\n      j.OutPt2 = op2;\n      return this.JoinHorz(op1, op1b, op2, op2b, Pt, DiscardLeftSide);\n    }\n    else\n    {\n      //nb: For non-horizontal joins ...\n      //    1. Jr.OutPt1.Pt.Y == Jr.OutPt2.Pt.Y\n      //    2. Jr.OutPt1.Pt > Jr.OffPt.Y\n      //make sure the polygons are correctly oriented ...\n      op1b = op1.Next;\n      while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))\n        op1b = op1b.Next;\n      var Reverse1 = ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange));\n      if (Reverse1)\n      {\n        op1b = op1.Prev;\n        while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))\n          op1b = op1b.Prev;\n        if ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange))\n          return false;\n      }\n      op2b = op2.Next;\n      while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))\n        op2b = op2b.Next;\n      var Reverse2 = ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange));\n      if (Reverse2)\n      {\n        op2b = op2.Prev;\n        while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))\n          op2b = op2b.Prev;\n        if ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange))\n          return false;\n      }\n      if ((op1b == op1) || (op2b == op2) || (op1b == op2b) ||\n        ((outRec1 == outRec2) && (Reverse1 == Reverse2)))\n        return false;\n      if (Reverse1)\n      {\n        op1b = this.DupOutPt(op1, false);\n        op2b = this.DupOutPt(op2, true);\n        op1.Prev = op2;\n        op2.Next = op1;\n        op1b.Next = op2b;\n        op2b.Prev = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      }\n      else\n      {\n        op1b = this.DupOutPt(op1, true);\n        op2b = this.DupOutPt(op2, false);\n        op1.Next = op2;\n        op2.Prev = op1;\n        op1b.Prev = op2b;\n        op2b.Next = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      }\n    }\n  };\n  ClipperLib.Clipper.GetBounds = function (paths)\n  {\n    var i = 0,\n      cnt = paths.length;\n    while (i < cnt && paths[i].length == 0) i++;\n    if (i == cnt) return new ClipperLib.IntRect(0, 0, 0, 0);\n    var result = new ClipperLib.IntRect();\n    result.left = paths[i][0].X;\n    result.right = result.left;\n    result.top = paths[i][0].Y;\n    result.bottom = result.top;\n    for (; i < cnt; i++)\n      for (var j = 0, jlen = paths[i].length; j < jlen; j++)\n      {\n        if (paths[i][j].X < result.left) result.left = paths[i][j].X;\n        else if (paths[i][j].X > result.right) result.right = paths[i][j].X;\n        if (paths[i][j].Y < result.top) result.top = paths[i][j].Y;\n        else if (paths[i][j].Y > result.bottom) result.bottom = paths[i][j].Y;\n      }\n    return result;\n  }\n  ClipperLib.Clipper.prototype.GetBounds2 = function (ops)\n  {\n    var opStart = ops;\n    var result = new ClipperLib.IntRect();\n    result.left = ops.Pt.X;\n    result.right = ops.Pt.X;\n    result.top = ops.Pt.Y;\n    result.bottom = ops.Pt.Y;\n    ops = ops.Next;\n    while (ops != opStart)\n    {\n      if (ops.Pt.X < result.left)\n        result.left = ops.Pt.X;\n      if (ops.Pt.X > result.right)\n        result.right = ops.Pt.X;\n      if (ops.Pt.Y < result.top)\n        result.top = ops.Pt.Y;\n      if (ops.Pt.Y > result.bottom)\n        result.bottom = ops.Pt.Y;\n      ops = ops.Next;\n    }\n    return result;\n  };\n\n  ClipperLib.Clipper.PointInPolygon = function (pt, path)\n  {\n    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t\t//See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n    var result = 0,\n      cnt = path.length;\n    if (cnt < 3)\n      return 0;\n    var ip = path[0];\n    for (var i = 1; i <= cnt; ++i)\n    {\n      var ipNext = (i == cnt ? path[0] : path[i]);\n      if (ipNext.Y == pt.Y)\n      {\n        if ((ipNext.X == pt.X) || (ip.Y == pt.Y && ((ipNext.X > pt.X) == (ip.X < pt.X))))\n          return -1;\n      }\n      if ((ip.Y < pt.Y) != (ipNext.Y < pt.Y))\n      {\n        if (ip.X >= pt.X)\n        {\n          if (ipNext.X > pt.X)\n            result = 1 - result;\n          else\n          {\n            var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n            if (d == 0)\n              return -1;\n            else if ((d > 0) == (ipNext.Y > ip.Y))\n              result = 1 - result;\n          }\n        }\n        else\n        {\n          if (ipNext.X > pt.X)\n          {\n            var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n            if (d == 0)\n              return -1;\n            else if ((d > 0) == (ipNext.Y > ip.Y))\n              result = 1 - result;\n          }\n        }\n      }\n      ip = ipNext;\n    }\n    return result;\n  };\n\n  ClipperLib.Clipper.prototype.PointInPolygon = function (pt, op)\n  {\n    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t\t//See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n    var result = 0;\n    var startOp = op;\n\t\tvar ptx = pt.X, pty = pt.Y;\n    var poly0x = op.Pt.X, poly0y = op.Pt.Y;\n    do\n    {\n\t\t\top = op.Next;\n\t\t\tvar poly1x = op.Pt.X, poly1y = op.Pt.Y;\n      if (poly1y == pty)\n      {\n        if ((poly1x == ptx) || (poly0y == pty && ((poly1x > ptx) == (poly0x < ptx))))\n          return -1;\n      }\n      if ((poly0y < pty) != (poly1y < pty))\n      {\n        if (poly0x >= ptx)\n        {\n          if (poly1x > ptx)\n            result = 1 - result;\n          else\n          {\n            var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n            if (d == 0)\n              return -1;\n            if ((d > 0) == (poly1y > poly0y))\n              result = 1 - result;\n          }\n        }\n        else\n        {\n          if (poly1x > ptx)\n          {\n            var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n            if (d == 0)\n              return -1;\n            if ((d > 0) == (poly1y > poly0y))\n              result = 1 - result;\n          }\n        }\n      }\n      poly0x = poly1x;\n      poly0y = poly1y;\n    } while (startOp != op);\n\n    return result;\n  };\n\n  ClipperLib.Clipper.prototype.Poly2ContainsPoly1 = function (outPt1, outPt2)\n  {\n    var op = outPt1;\n    do\n    {\n\t\t\t//nb: PointInPolygon returns 0 if false, +1 if true, -1 if pt on polygon\n      var res = this.PointInPolygon(op.Pt, outPt2);\n      if (res >= 0)\n        return res > 0;\n      op = op.Next;\n    }\n    while (op != outPt1)\n    return true;\n  };\n  ClipperLib.Clipper.prototype.FixupFirstLefts1 = function (OldOutRec, NewOutRec)\n  {\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n\t\t\tvar outRec = this.m_PolyOuts[i];\n\t\t\tif (outRec.Pts == null || outRec.FirstLeft == null)\n\t\t\t\tcontinue;\n\t\t\tvar firstLeft = this.ParseFirstLeft(outRec.FirstLeft);\n\t\t\tif (firstLeft == OldOutRec)\n\t\t\t{\n        if (this.Poly2ContainsPoly1(outRec.Pts, NewOutRec.Pts))\n          outRec.FirstLeft = NewOutRec;\n      }\n    }\n  };\n  ClipperLib.Clipper.prototype.FixupFirstLefts2 = function (OldOutRec, NewOutRec)\n  {\n    for (var $i2 = 0, $t2 = this.m_PolyOuts, $l2 = $t2.length, outRec = $t2[$i2]; $i2 < $l2; $i2++, outRec = $t2[$i2])\n      if (outRec.FirstLeft == OldOutRec)\n        outRec.FirstLeft = NewOutRec;\n  };\n  ClipperLib.Clipper.ParseFirstLeft = function (FirstLeft)\n  {\n    while (FirstLeft != null && FirstLeft.Pts == null)\n      FirstLeft = FirstLeft.FirstLeft;\n    return FirstLeft;\n  };\n  ClipperLib.Clipper.prototype.JoinCommonEdges = function ()\n  {\n    for (var i = 0, ilen = this.m_Joins.length; i < ilen; i++)\n    {\n      var join = this.m_Joins[i];\n      var outRec1 = this.GetOutRec(join.OutPt1.Idx);\n      var outRec2 = this.GetOutRec(join.OutPt2.Idx);\n      if (outRec1.Pts == null || outRec2.Pts == null)\n        continue;\n      //get the polygon fragment with the correct hole state (FirstLeft)\n      //before calling JoinPoints() ...\n      var holeStateRec;\n      if (outRec1 == outRec2)\n        holeStateRec = outRec1;\n      else if (this.Param1RightOfParam2(outRec1, outRec2))\n        holeStateRec = outRec2;\n      else if (this.Param1RightOfParam2(outRec2, outRec1))\n        holeStateRec = outRec1;\n      else\n        holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\n      if (!this.JoinPoints(join, outRec1, outRec2)) continue;\n\n      if (outRec1 == outRec2)\n      {\n        //instead of joining two polygons, we've just created a new one by\n        //splitting one polygon into two.\n        outRec1.Pts = join.OutPt1;\n        outRec1.BottomPt = null;\n        outRec2 = this.CreateOutRec();\n        outRec2.Pts = join.OutPt2;\n        //update all OutRec2.Pts Idx's ...\n        this.UpdateOutPtIdxs(outRec2);\n        //We now need to check every OutRec.FirstLeft pointer. If it points\n        //to OutRec1 it may need to point to OutRec2 instead ...\n        if (this.m_UsingPolyTree)\n          for (var j = 0, jlen = this.m_PolyOuts.length; j < jlen - 1; j++)\n          {\n            var oRec = this.m_PolyOuts[j];\n            if (oRec.Pts == null || ClipperLib.Clipper.ParseFirstLeft(oRec.FirstLeft) != outRec1 || oRec.IsHole == outRec1.IsHole)\n              continue;\n            if (this.Poly2ContainsPoly1(oRec.Pts, join.OutPt2))\n              oRec.FirstLeft = outRec2;\n          }\n        if (this.Poly2ContainsPoly1(outRec2.Pts, outRec1.Pts))\n        {\n          //outRec2 is contained by outRec1 ...\n          outRec2.IsHole = !outRec1.IsHole;\n          outRec2.FirstLeft = outRec1;\n          //fixup FirstLeft pointers that may need reassigning to OutRec1\n          if (this.m_UsingPolyTree)\n            this.FixupFirstLefts2(outRec2, outRec1);\n          if ((outRec2.IsHole ^ this.ReverseSolution) == (this.Area(outRec2) > 0))\n            this.ReversePolyPtLinks(outRec2.Pts);\n        }\n        else if (this.Poly2ContainsPoly1(outRec1.Pts, outRec2.Pts))\n        {\n          //outRec1 is contained by outRec2 ...\n          outRec2.IsHole = outRec1.IsHole;\n          outRec1.IsHole = !outRec2.IsHole;\n          outRec2.FirstLeft = outRec1.FirstLeft;\n          outRec1.FirstLeft = outRec2;\n          //fixup FirstLeft pointers that may need reassigning to OutRec1\n          if (this.m_UsingPolyTree)\n            this.FixupFirstLefts2(outRec1, outRec2);\n          if ((outRec1.IsHole ^ this.ReverseSolution) == (this.Area(outRec1) > 0))\n            this.ReversePolyPtLinks(outRec1.Pts);\n        }\n        else\n        {\n          //the 2 polygons are completely separate ...\n          outRec2.IsHole = outRec1.IsHole;\n          outRec2.FirstLeft = outRec1.FirstLeft;\n          //fixup FirstLeft pointers that may need reassigning to OutRec2\n          if (this.m_UsingPolyTree)\n            this.FixupFirstLefts1(outRec1, outRec2);\n        }\n      }\n      else\n      {\n        //joined 2 polygons together ...\n        outRec2.Pts = null;\n        outRec2.BottomPt = null;\n        outRec2.Idx = outRec1.Idx;\n        outRec1.IsHole = holeStateRec.IsHole;\n        if (holeStateRec == outRec2)\n          outRec1.FirstLeft = outRec2.FirstLeft;\n        outRec2.FirstLeft = outRec1;\n        //fixup FirstLeft pointers that may need reassigning to OutRec1\n        if (this.m_UsingPolyTree)\n          this.FixupFirstLefts2(outRec2, outRec1);\n      }\n    }\n  };\n  ClipperLib.Clipper.prototype.UpdateOutPtIdxs = function (outrec)\n  {\n    var op = outrec.Pts;\n    do {\n      op.Idx = outrec.Idx;\n      op = op.Prev;\n    }\n    while (op != outrec.Pts)\n  };\n  ClipperLib.Clipper.prototype.DoSimplePolygons = function ()\n  {\n    var i = 0;\n    while (i < this.m_PolyOuts.length)\n    {\n      var outrec = this.m_PolyOuts[i++];\n      var op = outrec.Pts;\n\t\t\tif (op == null || outrec.IsOpen)\n\t\t\t\tcontinue;\n      do //for each Pt in Polygon until duplicate found do ...\n      {\n        var op2 = op.Next;\n        while (op2 != outrec.Pts)\n        {\n          if ((ClipperLib.IntPoint.op_Equality(op.Pt, op2.Pt)) && op2.Next != op && op2.Prev != op)\n          {\n            //split the polygon into two ...\n            var op3 = op.Prev;\n            var op4 = op2.Prev;\n            op.Prev = op4;\n            op4.Next = op;\n            op2.Prev = op3;\n            op3.Next = op2;\n            outrec.Pts = op;\n            var outrec2 = this.CreateOutRec();\n            outrec2.Pts = op2;\n            this.UpdateOutPtIdxs(outrec2);\n            if (this.Poly2ContainsPoly1(outrec2.Pts, outrec.Pts))\n            {\n              //OutRec2 is contained by OutRec1 ...\n              outrec2.IsHole = !outrec.IsHole;\n              outrec2.FirstLeft = outrec;\n\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec2, outrec);\n\n            }\n            else if (this.Poly2ContainsPoly1(outrec.Pts, outrec2.Pts))\n            {\n              //OutRec1 is contained by OutRec2 ...\n              outrec2.IsHole = outrec.IsHole;\n              outrec.IsHole = !outrec2.IsHole;\n              outrec2.FirstLeft = outrec.FirstLeft;\n              outrec.FirstLeft = outrec2;\n              if (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec, outrec2);\n            }\n            else\n            {\n              //the 2 polygons are separate ...\n              outrec2.IsHole = outrec.IsHole;\n              outrec2.FirstLeft = outrec.FirstLeft;\n\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts1(outrec, outrec2);\n            }\n            op2 = op;\n            //ie get ready for the next iteration\n          }\n          op2 = op2.Next;\n        }\n        op = op.Next;\n      }\n      while (op != outrec.Pts)\n    }\n  };\n  ClipperLib.Clipper.Area = function (poly)\n  {\n    var cnt = poly.length;\n    if (cnt < 3)\n      return 0;\n    var a = 0;\n    for (var i = 0, j = cnt - 1; i < cnt; ++i)\n    {\n      a += (poly[j].X + poly[i].X) * (poly[j].Y - poly[i].Y);\n      j = i;\n    }\n    return -a * 0.5;\n  };\n  ClipperLib.Clipper.prototype.Area = function (outRec)\n  {\n    var op = outRec.Pts;\n    if (op == null)\n      return 0;\n    var a = 0;\n    do {\n      a = a + (op.Prev.Pt.X + op.Pt.X) * (op.Prev.Pt.Y - op.Pt.Y);\n      op = op.Next;\n    }\n    while (op != outRec.Pts)\n    return a * 0.5;\n  };\n  ClipperLib.Clipper.SimplifyPolygon = function (poly, fillType)\n  {\n    var result = new Array();\n    var c = new ClipperLib.Clipper(0);\n    c.StrictlySimple = true;\n    c.AddPath(poly, ClipperLib.PolyType.ptSubject, true);\n    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n    return result;\n  };\n  ClipperLib.Clipper.SimplifyPolygons = function (polys, fillType)\n  {\n    if (typeof (fillType) == \"undefined\") fillType = ClipperLib.PolyFillType.pftEvenOdd;\n    var result = new Array();\n    var c = new ClipperLib.Clipper(0);\n    c.StrictlySimple = true;\n    c.AddPaths(polys, ClipperLib.PolyType.ptSubject, true);\n    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n    return result;\n  };\n  ClipperLib.Clipper.DistanceSqrd = function (pt1, pt2)\n  {\n    var dx = (pt1.X - pt2.X);\n    var dy = (pt1.Y - pt2.Y);\n    return (dx * dx + dy * dy);\n  };\n  ClipperLib.Clipper.DistanceFromLineSqrd = function (pt, ln1, ln2)\n  {\n    //The equation of a line in general form (Ax + By + C = 0)\n    //given 2 points (x,y) & (x,y) is ...\n    //(y - y)x + (x - x)y + (y - y)x - (x - x)y = 0\n    //A = (y - y); B = (x - x); C = (y - y)x - (x - x)y\n    //perpendicular distance of point (x,y) = (Ax + By + C)/Sqrt(A + B)\n    //see http://en.wikipedia.org/wiki/Perpendicular_distance\n    var A = ln1.Y - ln2.Y;\n    var B = ln2.X - ln1.X;\n    var C = A * ln1.X + B * ln1.Y;\n    C = A * pt.X + B * pt.Y - C;\n    return (C * C) / (A * A + B * B);\n  };\n\n\tClipperLib.Clipper.SlopesNearCollinear = function(pt1, pt2, pt3, distSqrd)\n\t{\n\t\t//this function is more accurate when the point that's GEOMETRICALLY\n\t\t//between the other 2 points is the one that's tested for distance.\n\t\t//nb: with 'spikes', either pt1 or pt3 is geometrically between the other pts\n\t\tif (Math.abs(pt1.X - pt2.X) > Math.abs(pt1.Y - pt2.Y))\n\t\t{\n\t\tif ((pt1.X > pt2.X) == (pt1.X < pt3.X))\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n\t\telse if ((pt2.X > pt1.X) == (pt2.X < pt3.X))\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t\t\t\telse\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n\t\t}\n\t\telse\n\t\t{\n\t\tif ((pt1.Y > pt2.Y) == (pt1.Y < pt3.Y))\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n\t\telse if ((pt2.Y > pt1.Y) == (pt2.Y < pt3.Y))\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t\t\t\telse\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n\t\t}\n\t}\n\n  ClipperLib.Clipper.PointsAreClose = function (pt1, pt2, distSqrd)\n  {\n    var dx = pt1.X - pt2.X;\n    var dy = pt1.Y - pt2.Y;\n    return ((dx * dx) + (dy * dy) <= distSqrd);\n  };\n  //------------------------------------------------------------------------------\n  ClipperLib.Clipper.ExcludeOp = function (op)\n  {\n    var result = op.Prev;\n    result.Next = op.Next;\n    op.Next.Prev = result;\n    result.Idx = 0;\n    return result;\n  };\n  ClipperLib.Clipper.CleanPolygon = function (path, distance)\n  {\n    if (typeof (distance) == \"undefined\") distance = 1.415;\n    //distance = proximity in units/pixels below which vertices will be stripped.\n    //Default ~= sqrt(2) so when adjacent vertices or semi-adjacent vertices have\n    //both x & y coords within 1 unit, then the second vertex will be stripped.\n    var cnt = path.length;\n    if (cnt == 0)\n      return new Array();\n    var outPts = new Array(cnt);\n    for (var i = 0; i < cnt; ++i)\n      outPts[i] = new ClipperLib.OutPt();\n    for (var i = 0; i < cnt; ++i)\n    {\n      outPts[i].Pt = path[i];\n      outPts[i].Next = outPts[(i + 1) % cnt];\n      outPts[i].Next.Prev = outPts[i];\n      outPts[i].Idx = 0;\n    }\n    var distSqrd = distance * distance;\n    var op = outPts[0];\n    while (op.Idx == 0 && op.Next != op.Prev)\n    {\n      if (ClipperLib.Clipper.PointsAreClose(op.Pt, op.Prev.Pt, distSqrd))\n      {\n        op = ClipperLib.Clipper.ExcludeOp(op);\n        cnt--;\n      }\n      else if (ClipperLib.Clipper.PointsAreClose(op.Prev.Pt, op.Next.Pt, distSqrd))\n      {\n        ClipperLib.Clipper.ExcludeOp(op.Next);\n        op = ClipperLib.Clipper.ExcludeOp(op);\n        cnt -= 2;\n      }\n      else if (ClipperLib.Clipper.SlopesNearCollinear(op.Prev.Pt, op.Pt, op.Next.Pt, distSqrd))\n      {\n        op = ClipperLib.Clipper.ExcludeOp(op);\n        cnt--;\n      }\n      else\n      {\n        op.Idx = 1;\n        op = op.Next;\n      }\n    }\n    if (cnt < 3)\n      cnt = 0;\n    var result = new Array(cnt);\n    for (var i = 0; i < cnt; ++i)\n    {\n      result[i] = new ClipperLib.IntPoint(op.Pt);\n      op = op.Next;\n    }\n    outPts = null;\n    return result;\n  };\n  ClipperLib.Clipper.CleanPolygons = function (polys, distance)\n  {\n    var result = new Array(polys.length);\n    for (var i = 0, ilen = polys.length; i < ilen; i++)\n      result[i] = ClipperLib.Clipper.CleanPolygon(polys[i], distance);\n    return result;\n  };\n  ClipperLib.Clipper.Minkowski = function (pattern, path, IsSum, IsClosed)\n  {\n    var delta = (IsClosed ? 1 : 0);\n    var polyCnt = pattern.length;\n    var pathCnt = path.length;\n    var result = new Array();\n    if (IsSum)\n      for (var i = 0; i < pathCnt; i++)\n      {\n        var p = new Array(polyCnt);\n        for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n          p[j] = new ClipperLib.IntPoint(path[i].X + ip.X, path[i].Y + ip.Y);\n        result.push(p);\n      }\n    else\n      for (var i = 0; i < pathCnt; i++)\n      {\n        var p = new Array(polyCnt);\n        for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n          p[j] = new ClipperLib.IntPoint(path[i].X - ip.X, path[i].Y - ip.Y);\n        result.push(p);\n      }\n    var quads = new Array();\n    for (var i = 0; i < pathCnt - 1 + delta; i++)\n      for (var j = 0; j < polyCnt; j++)\n      {\n        var quad = new Array();\n        quad.push(result[i % pathCnt][j % polyCnt]);\n        quad.push(result[(i + 1) % pathCnt][j % polyCnt]);\n        quad.push(result[(i + 1) % pathCnt][(j + 1) % polyCnt]);\n        quad.push(result[i % pathCnt][(j + 1) % polyCnt]);\n        if (!ClipperLib.Clipper.Orientation(quad))\n          quad.reverse();\n        quads.push(quad);\n      }\n\t\t\treturn quads;\n  };\n\n\tClipperLib.Clipper.MinkowskiSum = function(pattern, path_or_paths, pathIsClosed)\n\t{\n\t\tif(!(path_or_paths[0] instanceof Array))\n\t\t{\n\t\t\tvar path = path_or_paths;\n\t\t\tvar paths = ClipperLib.Clipper.Minkowski(pattern, path, true, pathIsClosed);\n\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\tc.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\treturn paths;\n\t\t}\n\t\telse\n\t\t{\n \t\t\tvar paths = path_or_paths;\n\t\t\tvar solution = new ClipperLib.Paths();\n\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\tfor (var i = 0; i < paths.length; ++i)\n\t\t\t{\n\t\t\t\tvar tmp = ClipperLib.Clipper.Minkowski(pattern, paths[i], true, pathIsClosed);\n\t\t\t\tc.AddPaths(tmp, ClipperLib.PolyType.ptSubject, true);\n\t\t\t\tif (pathIsClosed)\n\t\t\t\t{\n\t\t\t\t\tvar path = ClipperLib.Clipper.TranslatePath(paths[i], pattern[0]);\n\t\t\t\t\tc.AddPath(path, ClipperLib.PolyType.ptClip, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, solution,\n\t\t\t\tClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\treturn solution;\n\t\t}\n\t}\n\t//------------------------------------------------------------------------------\n\n\tClipperLib.Clipper.TranslatePath = function (path, delta)\n\t{\n\t\tvar outPath = new ClipperLib.Path();\n\t\tfor (var i = 0; i < path.length; i++)\n\t\t\toutPath.push(new ClipperLib.IntPoint(path[i].X + delta.X, path[i].Y + delta.Y));\n\t\treturn outPath;\n\t}\n\t//------------------------------------------------------------------------------\n\n\tClipperLib.Clipper.MinkowskiDiff = function (poly1, poly2)\n\t{\n\t\tvar paths = ClipperLib.Clipper.Minkowski(poly1, poly2, false, true);\n\t\tvar c = new ClipperLib.Clipper();\n\t\tc.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n\t\tc.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\treturn paths;\n\t}\n\n  ClipperLib.Clipper.PolyTreeToPaths = function (polytree)\n  {\n    var result = new Array();\n    //result.set_Capacity(polytree.get_Total());\n    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntAny, result);\n    return result;\n  };\n  ClipperLib.Clipper.AddPolyNodeToPaths = function (polynode, nt, paths)\n  {\n    var match = true;\n    switch (nt)\n    {\n    case ClipperLib.Clipper.NodeType.ntOpen:\n      return;\n    case ClipperLib.Clipper.NodeType.ntClosed:\n      match = !polynode.IsOpen;\n      break;\n    default:\n      break;\n    }\n    if (polynode.m_polygon.length > 0 && match)\n      paths.push(polynode.m_polygon);\n    for (var $i3 = 0, $t3 = polynode.Childs(), $l3 = $t3.length, pn = $t3[$i3]; $i3 < $l3; $i3++, pn = $t3[$i3])\n      ClipperLib.Clipper.AddPolyNodeToPaths(pn, nt, paths);\n  };\n  ClipperLib.Clipper.OpenPathsFromPolyTree = function (polytree)\n  {\n    var result = new ClipperLib.Paths();\n    //result.set_Capacity(polytree.ChildCount());\n    for (var i = 0, ilen = polytree.ChildCount(); i < ilen; i++)\n      if (polytree.Childs()[i].IsOpen)\n        result.push(polytree.Childs()[i].m_polygon);\n    return result;\n  };\n  ClipperLib.Clipper.ClosedPathsFromPolyTree = function (polytree)\n  {\n    var result = new ClipperLib.Paths();\n    //result.set_Capacity(polytree.Total());\n    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntClosed, result);\n    return result;\n  };\n  Inherit(ClipperLib.Clipper, ClipperLib.ClipperBase);\n  ClipperLib.Clipper.NodeType = {\n    ntAny: 0,\n    ntOpen: 1,\n    ntClosed: 2\n  };\n  ClipperLib.ClipperOffset = function (miterLimit, arcTolerance)\n  {\n    if (typeof (miterLimit) == \"undefined\") miterLimit = 2;\n    if (typeof (arcTolerance) == \"undefined\") arcTolerance = ClipperLib.ClipperOffset.def_arc_tolerance;\n    this.m_destPolys = new ClipperLib.Paths();\n    this.m_srcPoly = new ClipperLib.Path();\n    this.m_destPoly = new ClipperLib.Path();\n    this.m_normals = new Array();\n    this.m_delta = 0;\n    this.m_sinA = 0;\n    this.m_sin = 0;\n    this.m_cos = 0;\n    this.m_miterLim = 0;\n    this.m_StepsPerRad = 0;\n    this.m_lowest = new ClipperLib.IntPoint();\n    this.m_polyNodes = new ClipperLib.PolyNode();\n    this.MiterLimit = miterLimit;\n    this.ArcTolerance = arcTolerance;\n    this.m_lowest.X = -1;\n  };\n  ClipperLib.ClipperOffset.two_pi = 6.28318530717959;\n  ClipperLib.ClipperOffset.def_arc_tolerance = 0.25;\n  ClipperLib.ClipperOffset.prototype.Clear = function ()\n  {\n    ClipperLib.Clear(this.m_polyNodes.Childs());\n    this.m_lowest.X = -1;\n  };\n  ClipperLib.ClipperOffset.Round = ClipperLib.Clipper.Round;\n  ClipperLib.ClipperOffset.prototype.AddPath = function (path, joinType, endType)\n  {\n    var highI = path.length - 1;\n    if (highI < 0)\n      return;\n    var newNode = new ClipperLib.PolyNode();\n    newNode.m_jointype = joinType;\n    newNode.m_endtype = endType;\n    //strip duplicate points from path and also get index to the lowest point ...\n    if (endType == ClipperLib.EndType.etClosedLine || endType == ClipperLib.EndType.etClosedPolygon)\n      while (highI > 0 && ClipperLib.IntPoint.op_Equality(path[0], path[highI]))\n        highI--;\n    //newNode.m_polygon.set_Capacity(highI + 1);\n    newNode.m_polygon.push(path[0]);\n    var j = 0,\n      k = 0;\n    for (var i = 1; i <= highI; i++)\n      if (ClipperLib.IntPoint.op_Inequality(newNode.m_polygon[j], path[i]))\n      {\n        j++;\n        newNode.m_polygon.push(path[i]);\n        if (path[i].Y > newNode.m_polygon[k].Y || (path[i].Y == newNode.m_polygon[k].Y && path[i].X < newNode.m_polygon[k].X))\n          k = j;\n      }\n    if (endType == ClipperLib.EndType.etClosedPolygon && j < 2) return;\n\n    this.m_polyNodes.AddChild(newNode);\n    //if this path's lowest pt is lower than all the others then update m_lowest\n    if (endType != ClipperLib.EndType.etClosedPolygon)\n      return;\n    if (this.m_lowest.X < 0)\n      this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);\n    else\n    {\n      var ip = this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon[this.m_lowest.Y];\n      if (newNode.m_polygon[k].Y > ip.Y || (newNode.m_polygon[k].Y == ip.Y && newNode.m_polygon[k].X < ip.X))\n        this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);\n    }\n  };\n  ClipperLib.ClipperOffset.prototype.AddPaths = function (paths, joinType, endType)\n  {\n    for (var i = 0, ilen = paths.length; i < ilen; i++)\n      this.AddPath(paths[i], joinType, endType);\n  };\n  ClipperLib.ClipperOffset.prototype.FixOrientations = function ()\n  {\n    //fixup orientations of all closed paths if the orientation of the\n    //closed path with the lowermost vertex is wrong ...\n    if (this.m_lowest.X >= 0 && !ClipperLib.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon))\n    {\n      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n      {\n        var node = this.m_polyNodes.Childs()[i];\n        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon || (node.m_endtype == ClipperLib.EndType.etClosedLine && ClipperLib.Clipper.Orientation(node.m_polygon)))\n          node.m_polygon.reverse();\n      }\n    }\n    else\n    {\n      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n      {\n        var node = this.m_polyNodes.Childs()[i];\n        if (node.m_endtype == ClipperLib.EndType.etClosedLine && !ClipperLib.Clipper.Orientation(node.m_polygon))\n          node.m_polygon.reverse();\n      }\n    }\n  };\n  ClipperLib.ClipperOffset.GetUnitNormal = function (pt1, pt2)\n  {\n    var dx = (pt2.X - pt1.X);\n    var dy = (pt2.Y - pt1.Y);\n    if ((dx == 0) && (dy == 0))\n      return new ClipperLib.DoublePoint(0, 0);\n    var f = 1 / Math.sqrt(dx * dx + dy * dy);\n    dx *= f;\n    dy *= f;\n    return new ClipperLib.DoublePoint(dy, -dx);\n  };\n  ClipperLib.ClipperOffset.prototype.DoOffset = function (delta)\n  {\n    this.m_destPolys = new Array();\n    this.m_delta = delta;\n    //if Zero offset, just copy any CLOSED polygons to m_p and return ...\n    if (ClipperLib.ClipperBase.near_zero(delta))\n    {\n      //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount);\n      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n      {\n        var node = this.m_polyNodes.Childs()[i];\n        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n          this.m_destPolys.push(node.m_polygon);\n      }\n      return;\n    }\n    //see offset_triginometry3.svg in the documentation folder ...\n    if (this.MiterLimit > 2)\n      this.m_miterLim = 2 / (this.MiterLimit * this.MiterLimit);\n    else\n      this.m_miterLim = 0.5;\n    var y;\n    if (this.ArcTolerance <= 0)\n      y = ClipperLib.ClipperOffset.def_arc_tolerance;\n    else if (this.ArcTolerance > Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance)\n      y = Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance;\n    else\n      y = this.ArcTolerance;\n    //see offset_triginometry2.svg in the documentation folder ...\n    var steps = 3.14159265358979 / Math.acos(1 - y / Math.abs(delta));\n    this.m_sin = Math.sin(ClipperLib.ClipperOffset.two_pi / steps);\n    this.m_cos = Math.cos(ClipperLib.ClipperOffset.two_pi / steps);\n    this.m_StepsPerRad = steps / ClipperLib.ClipperOffset.two_pi;\n    if (delta < 0)\n      this.m_sin = -this.m_sin;\n    //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount * 2);\n    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n    {\n      var node = this.m_polyNodes.Childs()[i];\n      this.m_srcPoly = node.m_polygon;\n      var len = this.m_srcPoly.length;\n      if (len == 0 || (delta <= 0 && (len < 3 || node.m_endtype != ClipperLib.EndType.etClosedPolygon)))\n        continue;\n      this.m_destPoly = new Array();\n      if (len == 1)\n      {\n        if (node.m_jointype == ClipperLib.JoinType.jtRound)\n        {\n          var X = 1,\n            Y = 0;\n          for (var j = 1; j <= steps; j++)\n          {\n            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n            var X2 = X;\n            X = X * this.m_cos - this.m_sin * Y;\n            Y = X2 * this.m_sin + Y * this.m_cos;\n          }\n        }\n        else\n        {\n          var X = -1,\n            Y = -1;\n          for (var j = 0; j < 4; ++j)\n          {\n            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n            if (X < 0)\n              X = 1;\n            else if (Y < 0)\n              Y = 1;\n            else\n              X = -1;\n          }\n        }\n        this.m_destPolys.push(this.m_destPoly);\n        continue;\n      }\n      //build m_normals ...\n      this.m_normals.length = 0;\n      //this.m_normals.set_Capacity(len);\n      for (var j = 0; j < len - 1; j++)\n        this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[j], this.m_srcPoly[j + 1]));\n      if (node.m_endtype == ClipperLib.EndType.etClosedLine || node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n        this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[len - 1], this.m_srcPoly[0]));\n      else\n        this.m_normals.push(new ClipperLib.DoublePoint(this.m_normals[len - 2]));\n      if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n      {\n        var k = len - 1;\n        for (var j = 0; j < len; j++)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        this.m_destPolys.push(this.m_destPoly);\n      }\n      else if (node.m_endtype == ClipperLib.EndType.etClosedLine)\n      {\n        var k = len - 1;\n        for (var j = 0; j < len; j++)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        this.m_destPolys.push(this.m_destPoly);\n        this.m_destPoly = new Array();\n        //re-build m_normals ...\n        var n = this.m_normals[len - 1];\n        for (var j = len - 1; j > 0; j--)\n          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n        this.m_normals[0] = new ClipperLib.DoublePoint(-n.X, -n.Y);\n        k = 0;\n        for (var j = len - 1; j >= 0; j--)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        this.m_destPolys.push(this.m_destPoly);\n      }\n      else\n      {\n        var k = 0;\n        for (var j = 1; j < len - 1; ++j)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        var pt1;\n        if (node.m_endtype == ClipperLib.EndType.etOpenButt)\n        {\n          var j = len - 1;\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * delta));\n          this.m_destPoly.push(pt1);\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X - this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y - this.m_normals[j].Y * delta));\n          this.m_destPoly.push(pt1);\n        }\n        else\n        {\n          var j = len - 1;\n          k = len - 2;\n          this.m_sinA = 0;\n          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j].X, -this.m_normals[j].Y);\n          if (node.m_endtype == ClipperLib.EndType.etOpenSquare)\n            this.DoSquare(j, k);\n          else\n            this.DoRound(j, k);\n        }\n        //re-build m_normals ...\n        for (var j = len - 1; j > 0; j--)\n          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n        this.m_normals[0] = new ClipperLib.DoublePoint(-this.m_normals[1].X, -this.m_normals[1].Y);\n        k = len - 1;\n        for (var j = k - 1; j > 0; --j)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        if (node.m_endtype == ClipperLib.EndType.etOpenButt)\n        {\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X - this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y - this.m_normals[0].Y * delta));\n          this.m_destPoly.push(pt1);\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + this.m_normals[0].Y * delta));\n          this.m_destPoly.push(pt1);\n        }\n        else\n        {\n          k = 1;\n          this.m_sinA = 0;\n          if (node.m_endtype == ClipperLib.EndType.etOpenSquare)\n            this.DoSquare(0, 1);\n          else\n            this.DoRound(0, 1);\n        }\n        this.m_destPolys.push(this.m_destPoly);\n      }\n    }\n  };\n  ClipperLib.ClipperOffset.prototype.Execute = function ()\n  {\n    var a = arguments,\n      ispolytree = a[0] instanceof ClipperLib.PolyTree;\n    if (!ispolytree) // function (solution, delta)\n    {\n      var solution = a[0],\n        delta = a[1];\n      ClipperLib.Clear(solution);\n      this.FixOrientations();\n      this.DoOffset(delta);\n      //now clean up 'corners' ...\n      var clpr = new ClipperLib.Clipper(0);\n      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n      if (delta > 0)\n      {\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n      }\n      else\n      {\n        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n        var outer = new ClipperLib.Path();\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n        clpr.ReverseSolution = true;\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n        if (solution.length > 0)\n          solution.splice(0, 1);\n      }\n      //console.log(JSON.stringify(solution));\n    }\n    else // function (polytree, delta)\n    {\n      var solution = a[0],\n        delta = a[1];\n      solution.Clear();\n      this.FixOrientations();\n      this.DoOffset(delta);\n      //now clean up 'corners' ...\n      var clpr = new ClipperLib.Clipper(0);\n      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n      if (delta > 0)\n      {\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n      }\n      else\n      {\n        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n        var outer = new ClipperLib.Path();\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n        clpr.ReverseSolution = true;\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n        //remove the outer PolyNode rectangle ...\n        if (solution.ChildCount() == 1 && solution.Childs()[0].ChildCount() > 0)\n        {\n          var outerNode = solution.Childs()[0];\n          //solution.Childs.set_Capacity(outerNode.ChildCount);\n          solution.Childs()[0] = outerNode.Childs()[0];\n          solution.Childs()[0].m_Parent = solution;\n          for (var i = 1; i < outerNode.ChildCount(); i++)\n            solution.AddChild(outerNode.Childs()[i]);\n        }\n        else\n          solution.Clear();\n      }\n    }\n  };\n  ClipperLib.ClipperOffset.prototype.OffsetPoint = function (j, k, jointype)\n  {\n\t\t//cross product ...\n\t\tthis.m_sinA = (this.m_normals[k].X * this.m_normals[j].Y - this.m_normals[j].X * this.m_normals[k].Y);\n\n\t\tif (Math.abs(this.m_sinA * this.m_delta) < 1.0)\n\t\t{\n\t\t\t//dot product ...\n\t\t\tvar cosA = (this.m_normals[k].X * this.m_normals[j].X + this.m_normals[j].Y * this.m_normals[k].Y);\n\t\t\tif (cosA > 0) // angle ==> 0 degrees\n\t\t\t{\n\t\t\t\tthis.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),\n\t\t\t\t\tClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n\t\t\t\treturn k;\n\t\t\t}\n\t\t\t//else angle ==> 180 degrees\n\t\t}\n    else if (this.m_sinA > 1)\n      this.m_sinA = 1.0;\n    else if (this.m_sinA < -1)\n      this.m_sinA = -1.0;\n    if (this.m_sinA * this.m_delta < 0)\n    {\n      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),\n        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n      this.m_destPoly.push(new ClipperLib.IntPoint(this.m_srcPoly[j]));\n      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n    }\n    else\n      switch (jointype)\n      {\n      case ClipperLib.JoinType.jtMiter:\n        {\n          var r = 1 + (this.m_normals[j].X * this.m_normals[k].X + this.m_normals[j].Y * this.m_normals[k].Y);\n          if (r >= this.m_miterLim)\n            this.DoMiter(j, k, r);\n          else\n            this.DoSquare(j, k);\n          break;\n        }\n      case ClipperLib.JoinType.jtSquare:\n        this.DoSquare(j, k);\n        break;\n      case ClipperLib.JoinType.jtRound:\n        this.DoRound(j, k);\n        break;\n      }\n    k = j;\n    return k;\n  };\n  ClipperLib.ClipperOffset.prototype.DoSquare = function (j, k)\n  {\n    var dx = Math.tan(Math.atan2(this.m_sinA,\n      this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y) / 4);\n    this.m_destPoly.push(new ClipperLib.IntPoint(\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[k].X - this.m_normals[k].Y * dx)),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[k].Y + this.m_normals[k].X * dx))));\n    this.m_destPoly.push(new ClipperLib.IntPoint(\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[j].X + this.m_normals[j].Y * dx)),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[j].Y - this.m_normals[j].X * dx))));\n  };\n  ClipperLib.ClipperOffset.prototype.DoMiter = function (j, k, r)\n  {\n    var q = this.m_delta / r;\n    this.m_destPoly.push(new ClipperLib.IntPoint(\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + (this.m_normals[k].X + this.m_normals[j].X) * q),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + (this.m_normals[k].Y + this.m_normals[j].Y) * q)));\n  };\n  ClipperLib.ClipperOffset.prototype.DoRound = function (j, k)\n  {\n    var a = Math.atan2(this.m_sinA,\n      this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y);\n\n    \tvar steps = Math.max(ClipperLib.Cast_Int32(ClipperLib.ClipperOffset.Round(this.m_StepsPerRad * Math.abs(a))), 1);\n\n    var X = this.m_normals[k].X,\n      Y = this.m_normals[k].Y,\n      X2;\n    for (var i = 0; i < steps; ++i)\n    {\n      this.m_destPoly.push(new ClipperLib.IntPoint(\n        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + X * this.m_delta),\n        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + Y * this.m_delta)));\n      X2 = X;\n      X = X * this.m_cos - this.m_sin * Y;\n      Y = X2 * this.m_sin + Y * this.m_cos;\n    }\n    this.m_destPoly.push(new ClipperLib.IntPoint(\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n  };\n  ClipperLib.Error = function (message)\n  {\n    try\n    {\n      throw new Error(message);\n    }\n    catch (err)\n    {\n      alert(err.message);\n    }\n  };\n  // ---------------------------------\n  // JS extension by Timo 2013\n  ClipperLib.JS = {};\n  ClipperLib.JS.AreaOfPolygon = function (poly, scale)\n  {\n    if (!scale) scale = 1;\n    return ClipperLib.Clipper.Area(poly) / (scale * scale);\n  };\n  ClipperLib.JS.AreaOfPolygons = function (poly, scale)\n  {\n    if (!scale) scale = 1;\n    var area = 0;\n    for (var i = 0; i < poly.length; i++)\n    {\n      area += ClipperLib.Clipper.Area(poly[i]);\n    }\n    return area / (scale * scale);\n  };\n  ClipperLib.JS.BoundsOfPath = function (path, scale)\n  {\n    return ClipperLib.JS.BoundsOfPaths([path], scale);\n  };\n  ClipperLib.JS.BoundsOfPaths = function (paths, scale)\n  {\n    if (!scale) scale = 1;\n    var bounds = ClipperLib.Clipper.GetBounds(paths);\n    bounds.left /= scale;\n    bounds.bottom /= scale;\n    bounds.right /= scale;\n    bounds.top /= scale;\n    return bounds;\n  };\n  // Clean() joins vertices that are too near each other\n  // and causes distortion to offsetted polygons without cleaning\n  ClipperLib.JS.Clean = function (polygon, delta)\n  {\n    if (!(polygon instanceof Array)) return [];\n    var isPolygons = polygon[0] instanceof Array;\n    var polygon = ClipperLib.JS.Clone(polygon);\n    if (typeof delta != \"number\" || delta === null)\n    {\n      ClipperLib.Error(\"Delta is not a number in Clean().\");\n      return polygon;\n    }\n    if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || delta < 0) return polygon;\n    if (!isPolygons) polygon = [polygon];\n    var k_length = polygon.length;\n    var len, poly, result, d, p, j, i;\n    var results = [];\n    for (var k = 0; k < k_length; k++)\n    {\n      poly = polygon[k];\n      len = poly.length;\n      if (len === 0) continue;\n      else if (len < 3)\n      {\n        result = poly;\n        results.push(result);\n        continue;\n      }\n      result = poly;\n      d = delta * delta;\n      //d = Math.floor(c_delta * c_delta);\n      p = poly[0];\n      j = 1;\n      for (i = 1; i < len; i++)\n      {\n        if ((poly[i].X - p.X) * (poly[i].X - p.X) +\n          (poly[i].Y - p.Y) * (poly[i].Y - p.Y) <= d)\n          continue;\n        result[j] = poly[i];\n        p = poly[i];\n        j++;\n      }\n      p = poly[j - 1];\n      if ((poly[0].X - p.X) * (poly[0].X - p.X) +\n        (poly[0].Y - p.Y) * (poly[0].Y - p.Y) <= d)\n        j--;\n      if (j < len)\n        result.splice(j, len - j);\n      if (result.length) results.push(result);\n    }\n    if (!isPolygons && results.length) results = results[0];\n    else if (!isPolygons && results.length === 0) results = [];\n    else if (isPolygons && results.length === 0) results = [\n      []\n    ];\n    return results;\n  }\n  // Make deep copy of Polygons or Polygon\n  // so that also IntPoint objects are cloned and not only referenced\n  // This should be the fastest way\n  ClipperLib.JS.Clone = function (polygon)\n  {\n    if (!(polygon instanceof Array)) return [];\n    if (polygon.length === 0) return [];\n    else if (polygon.length == 1 && polygon[0].length === 0) return [[]];\n    var isPolygons = polygon[0] instanceof Array;\n    if (!isPolygons) polygon = [polygon];\n    var len = polygon.length,\n      plen, i, j, result;\n    var results = new Array(len);\n    for (i = 0; i < len; i++)\n    {\n      plen = polygon[i].length;\n      result = new Array(plen);\n      for (j = 0; j < plen; j++)\n      {\n        result[j] = {\n          X: polygon[i][j].X,\n          Y: polygon[i][j].Y\n        };\n      }\n      results[i] = result;\n    }\n    if (!isPolygons) results = results[0];\n    return results;\n  };\n  // Removes points that doesn't affect much to the visual appearance.\n  // If middle point is at or under certain distance (tolerance) of the line segment between\n  // start and end point, the middle point is removed.\n  ClipperLib.JS.Lighten = function (polygon, tolerance)\n  {\n    if (!(polygon instanceof Array)) return [];\n    if (typeof tolerance != \"number\" || tolerance === null)\n    {\n      ClipperLib.Error(\"Tolerance is not a number in Lighten().\")\n      return ClipperLib.JS.Clone(polygon);\n    }\n    if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || tolerance < 0)\n    {\n      return ClipperLib.JS.Clone(polygon);\n    }\n    if (!(polygon[0] instanceof Array)) polygon = [polygon];\n    var i, j, poly, k, poly2, plen, A, B, P, d, rem, addlast;\n    var bxax, byay, l, ax, ay;\n    var len = polygon.length;\n    var toleranceSq = tolerance * tolerance;\n    var results = [];\n    for (i = 0; i < len; i++)\n    {\n      poly = polygon[i];\n      plen = poly.length;\n      if (plen == 0) continue;\n      for (k = 0; k < 1000000; k++) // could be forever loop, but wiser to restrict max repeat count\n      {\n        poly2 = [];\n        plen = poly.length;\n        // the first have to added to the end, if first and last are not the same\n        // this way we ensure that also the actual last point can be removed if needed\n        if (poly[plen - 1].X != poly[0].X || poly[plen - 1].Y != poly[0].Y)\n        {\n          addlast = 1;\n          poly.push(\n          {\n            X: poly[0].X,\n            Y: poly[0].Y\n          });\n          plen = poly.length;\n        }\n        else addlast = 0;\n        rem = []; // Indexes of removed points\n        for (j = 0; j < plen - 2; j++)\n        {\n          A = poly[j]; // Start point of line segment\n          P = poly[j + 1]; // Middle point. This is the one to be removed.\n          B = poly[j + 2]; // End point of line segment\n          ax = A.X;\n          ay = A.Y;\n          bxax = B.X - ax;\n          byay = B.Y - ay;\n          if (bxax !== 0 || byay !== 0) // To avoid Nan, when A==P && P==B. And to avoid peaks (A==B && A!=P), which have lenght, but not area.\n          {\n            l = ((P.X - ax) * bxax + (P.Y - ay) * byay) / (bxax * bxax + byay * byay);\n            if (l > 1)\n            {\n              ax = B.X;\n              ay = B.Y;\n            }\n            else if (l > 0)\n            {\n              ax += bxax * l;\n              ay += byay * l;\n            }\n          }\n          bxax = P.X - ax;\n          byay = P.Y - ay;\n          d = bxax * bxax + byay * byay;\n          if (d <= toleranceSq)\n          {\n            rem[j + 1] = 1;\n            j++; // when removed, transfer the pointer to the next one\n          }\n        }\n        // add all unremoved points to poly2\n        poly2.push(\n        {\n          X: poly[0].X,\n          Y: poly[0].Y\n        });\n        for (j = 1; j < plen - 1; j++)\n          if (!rem[j]) poly2.push(\n          {\n            X: poly[j].X,\n            Y: poly[j].Y\n          });\n        poly2.push(\n        {\n          X: poly[plen - 1].X,\n          Y: poly[plen - 1].Y\n        });\n        // if the first point was added to the end, remove it\n        if (addlast) poly.pop();\n        // break, if there was not anymore removed points\n        if (!rem.length) break;\n        // else continue looping using poly2, to check if there are points to remove\n        else poly = poly2;\n      }\n      plen = poly2.length;\n      // remove duplicate from end, if needed\n      if (poly2[plen - 1].X == poly2[0].X && poly2[plen - 1].Y == poly2[0].Y)\n      {\n        poly2.pop();\n      }\n      if (poly2.length > 2) // to avoid two-point-polygons\n        results.push(poly2);\n    }\n    if (!(polygon[0] instanceof Array)) results = results[0];\n    if (typeof (results) == \"undefined\") results = [\n      []\n    ];\n    return results;\n  }\n  ClipperLib.JS.PerimeterOfPath = function (path, closed, scale)\n  {\n    if (typeof (path) == \"undefined\") return 0;\n    var sqrt = Math.sqrt;\n    var perimeter = 0.0;\n    var p1, p2, p1x = 0.0,\n      p1y = 0.0,\n      p2x = 0.0,\n      p2y = 0.0;\n    var j = path.length;\n    if (j < 2) return 0;\n    if (closed)\n    {\n      path[j] = path[0];\n      j++;\n    }\n    while (--j)\n    {\n      p1 = path[j];\n      p1x = p1.X;\n      p1y = p1.Y;\n      p2 = path[j - 1];\n      p2x = p2.X;\n      p2y = p2.Y;\n      perimeter += sqrt((p1x - p2x) * (p1x - p2x) + (p1y - p2y) * (p1y - p2y));\n    }\n    if (closed) path.pop();\n    return perimeter / scale;\n  };\n  ClipperLib.JS.PerimeterOfPaths = function (paths, closed, scale)\n  {\n    if (!scale) scale = 1;\n    var perimeter = 0;\n    for (var i = 0; i < paths.length; i++)\n    {\n      perimeter += ClipperLib.JS.PerimeterOfPath(paths[i], closed, scale);\n    }\n    return perimeter;\n  };\n  ClipperLib.JS.ScaleDownPath = function (path, scale)\n  {\n    var i, p;\n    if (!scale) scale = 1;\n    i = path.length;\n    while (i--)\n    {\n      p = path[i];\n      p.X = p.X / scale;\n      p.Y = p.Y / scale;\n    }\n  };\n  ClipperLib.JS.ScaleDownPaths = function (paths, scale)\n  {\n    var i, j, p;\n    if (!scale) scale = 1;\n    i = paths.length;\n    while (i--)\n    {\n      j = paths[i].length;\n      while (j--)\n      {\n        p = paths[i][j];\n        p.X = p.X / scale;\n        p.Y = p.Y / scale;\n      }\n    }\n  };\n  ClipperLib.JS.ScaleUpPath = function (path, scale)\n  {\n    var i, p, round = Math.round;\n    if (!scale) scale = 1;\n    i = path.length;\n    while (i--)\n    {\n      p = path[i];\n      p.X = round(p.X * scale);\n      p.Y = round(p.Y * scale);\n    }\n  };\n  ClipperLib.JS.ScaleUpPaths = function (paths, scale)\n  {\n    var i, j, p, round = Math.round;\n    if (!scale) scale = 1;\n    i = paths.length;\n    while (i--)\n    {\n      j = paths[i].length;\n      while (j--)\n      {\n        p = paths[i][j];\n        p.X = round(p.X * scale);\n        p.Y = round(p.Y * scale);\n      }\n    }\n  };\n  ClipperLib.ExPolygons = function ()\n  {\n    return [];\n  }\n  ClipperLib.ExPolygon = function ()\n  {\n    this.outer = null;\n    this.holes = null;\n  };\n  ClipperLib.JS.AddOuterPolyNodeToExPolygons = function (polynode, expolygons)\n  {\n    var ep = new ClipperLib.ExPolygon();\n    ep.outer = polynode.Contour();\n    var childs = polynode.Childs();\n    var ilen = childs.length;\n    ep.holes = new Array(ilen);\n    var node, n, i, j, childs2, jlen;\n    for (i = 0; i < ilen; i++)\n    {\n      node = childs[i];\n      ep.holes[i] = node.Contour();\n      //Add outer polygons contained by (nested within) holes ...\n      for (j = 0, childs2 = node.Childs(), jlen = childs2.length; j < jlen; j++)\n      {\n        n = childs2[j];\n        ClipperLib.JS.AddOuterPolyNodeToExPolygons(n, expolygons);\n      }\n    }\n    expolygons.push(ep);\n  };\n  ClipperLib.JS.ExPolygonsToPaths = function (expolygons)\n  {\n    var a, i, alen, ilen;\n    var paths = new ClipperLib.Paths();\n    for (a = 0, alen = expolygons.length; a < alen; a++)\n    {\n      paths.push(expolygons[a].outer);\n      for (i = 0, ilen = expolygons[a].holes.length; i < ilen; i++)\n      {\n        paths.push(expolygons[a].holes[i]);\n      }\n    }\n    return paths;\n  }\n  ClipperLib.JS.PolyTreeToExPolygons = function (polytree)\n  {\n    var expolygons = new ClipperLib.ExPolygons();\n    var node, i, childs, ilen;\n    for (i = 0, childs = polytree.Childs(), ilen = childs.length; i < ilen; i++)\n    {\n      node = childs[i];\n      ClipperLib.JS.AddOuterPolyNodeToExPolygons(node, expolygons);\n    }\n    return expolygons;\n  };\n})();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/clipper-lib/clipper.js\n// module id = 5\n// module chunks = 0","!function(t,e){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=e():\"function\"==typeof define&&define.amd?define(\"SVGCurves\",[],e):\"object\"==typeof exports?exports.SVGCurves=e():t.SVGCurves=e()}(this,function(){return function(t){function e(n){if(i[n])return i[n].exports;var r=i[n]={exports:{},id:n,loaded:!1};return t[n].call(r.exports,r,r.exports,e),r.loaded=!0,r.exports}var i={};return e.m=t,e.c=i,e.p=\"\",e(0)}([function(t,e,i){t.exports=i(1)},function(t,e,i){\"use strict\";function n(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function r(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function s(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function o(t,e){return(t%e+e)%e}function h(t,e,i){return Math.min(Math.max(t,e),i)}function a(t,e){return Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2))}function u(t,e){var i=t.x*e.x+t.y*e.y,n=Math.sqrt((Math.pow(t.x,2)+Math.pow(t.y,2))*(Math.pow(e.x,2)+Math.pow(e.y,2)));return(t.x*e.y-t.y*e.x<0?-1:1)*Math.acos(i/n)}Object.defineProperty(e,\"__esModule\",{value:!0}),e.QuadricBezier=e.CubicBezier=e.Arc=void 0;var p=function t(e,i,n){null===e&&(e=Function.prototype);var r=Object.getOwnPropertyDescriptor(e,i);if(void 0===r){var s=Object.getPrototypeOf(e);return null===s?void 0:t(s,i,n)}if(\"value\"in r)return r.value;var o=r.get;if(void 0!==o)return o.call(n)},c=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e}}(),f=i(2),l=2*Math.PI,y=Math.PI/180,v=function(){function t(e){s(this,t),this.path=[],this.linear=!0,this.step=.01,this.resolution=500,this.segmentLength=.1,Object.assign(this,e||{}),this.arcLength=null,this.arcLengthMap=null}return c(t,[{key:\"_clearPath\",value:function(){this.path=[]}},{key:\"getPath\",value:function(){return this.path}},{key:\"getPointAtT\",value:function(t){return new f.Point(0,0)}},{key:\"_addPoint\",value:function(t){this.path.push(t.x,t.y)}},{key:\"_postTrace\",value:function(){}},{key:\"_approximateLength\",value:function(){var t=0,e=[],i=this.getPointAtT(0),n=void 0,r=void 0,s=void 0;for(n=0;n<this.resolution;n++)r=h(n*(1/this.resolution),0,1),s=this.getPointAtT(r),t+=a(i,s),e.push({t:r,arcLength:t}),i=s;s=this.getPointAtT(1),t+=a(i,s),e.push({t:1,arcLength:t}),Object.assign(this,{arcLength:t,arcLengthMap:e})}},{key:\"getPointAtU\",value:function(t){t=h(t,0,1);var e=t*this.arcLength,i=0,n=0,r=0;return this.arcLengthMap.every(function(t){var s=t.t,o=t.arcLength;if(o>=e){var h=o-e,a=e-n,u=a/(h+a)||0;return i=r+(s-r)*u,!1}return n=o,r=s,!0}),this.getPointAtT(i)}},{key:\"trace\",value:function(t){Object.assign(this,t||{});var e=\"getPointAtT\",i=this.step;if(this.linear){this._approximateLength();var n=Math.round(this.arcLength/this.segmentLength);e=\"getPointAtU\",i=1/n}this._clearPath();for(var r=0;r<=1;r+=i)this._addPoint(this[e](r));return this._postTrace(),this.getPath()}}]),t}(),x=function(t){function e(){return s(this,e),n(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return r(e,t),c(e,[{key:\"init\",value:function(t){if(Object.assign(this,t||{}),this.radians=o(this.angle,360)*y,this.p1.x===this.p2.x&&this.p1.y===this.p2.y)return this.path;if(this.rx=Math.abs(this.rx),this.ry=Math.abs(this.ry),0===this.rx||0===this.ry)return this.__addPoint(this.p1),this.__addPoint(this.p2),this.path;var e=(this.p1.x-this.p2.x)/2,i=(this.p1.y-this.p2.y)/2,n={x:Math.cos(this.radians)*e+Math.sin(this.radians)*i,y:-Math.sin(this.radians)*e+Math.cos(this.radians)*i},r=Math.pow(n.x,2)/Math.pow(this.rx,2)+Math.pow(n.y,2)/Math.pow(this.ry,2);r>1&&(this.rx=Math.sqrt(r)*this.rx,this.ry=Math.sqrt(r)*this.ry);var s=Math.pow(this.rx,2)*Math.pow(this.ry,2)-Math.pow(this.rx,2)*Math.pow(n.y,2)-Math.pow(this.ry,2)*Math.pow(n.x,2),h=Math.pow(this.rx,2)*Math.pow(n.y,2)+Math.pow(this.ry,2)*Math.pow(n.x,2),a=s/h;a=a<0?0:a;var p=(this.large!==this.sweep?1:-1)*Math.sqrt(a),c={x:p*(this.rx*n.y/this.ry),y:p*(-(this.ry*n.x)/this.rx)};this.center={x:Math.cos(this.radians)*c.x-Math.sin(this.radians)*c.y+(this.p1.x+this.p2.x)/2,y:Math.sin(this.radians)*c.x+Math.cos(this.radians)*c.y+(this.p1.y+this.p2.y)/2};var f={x:(n.x-c.x)/this.rx,y:(n.y-c.y)/this.ry},v={x:(-n.x-c.x)/this.rx,y:(-n.y-c.y)/this.ry};this.startAngle=u({x:1,y:0},f),this.sweepAngle=u(f,v),!this.sweep&&this.sweepAngle>0?this.sweepAngle-=l:this.sweep&&this.sweepAngle<0&&(this.sweepAngle+=l),this.sweepAngle%=l}},{key:\"trace\",value:function(t){return this.init(t),p(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),\"trace\",this).call(this)}},{key:\"getPointAtT\",value:function(t){var e=this.startAngle+this.sweepAngle*t,i=this.rx*Math.cos(e),n=this.ry*Math.sin(e);return new f.Point(Math.cos(this.radians)*i-Math.sin(this.radians)*n+this.center.x,Math.sin(this.radians)*i+Math.cos(this.radians)*n+this.center.y)}},{key:\"_postTrace\",value:function(){this._addPoint(this.p2)}}]),e}(v),d=function(t){function e(){return s(this,e),n(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return r(e,t),c(e,[{key:\"_B1\",value:function(t){return t*t*t}},{key:\"_B2\",value:function(t){return 3*t*t*(1-t)}},{key:\"_B3\",value:function(t){return 3*t*(1-t)*(1-t)}},{key:\"_B4\",value:function(t){return(1-t)*(1-t)*(1-t)}},{key:\"_C1\",value:function(t,e,i,n,r){return t*this._B1(r)+e*this._B2(r)+i*this._B3(r)+n*this._B4(r)}},{key:\"getPointAtT\",value:function(t){return new f.Point(this._C1(this.p1.x,this.p2.x,this.p3.x,this.p4.x,t),this._C1(this.p1.y,this.p2.y,this.p3.y,this.p4.y,t))}},{key:\"_addPoint\",value:function(t){this.path.unshift(t.x,t.y)}}]),e}(v),g=function(t){function e(){return s(this,e),n(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return r(e,t),c(e,[{key:\"_B1\",value:function(t){return t*t}},{key:\"_B2\",value:function(t){return 2*t*(1-t)}},{key:\"_B3\",value:function(t){return(1-t)*(1-t)}},{key:\"_C1\",value:function(t,e,i,n){return t*this._B1(n)+e*this._B2(n)+i*this._B3(n)}},{key:\"getPointAtT\",value:function(t){return new f.Point(this._C1(this.p1.x,this.p2.x,this.p3.x,t),this._C1(this.p1.y,this.p2.y,this.p3.y,t))}},{key:\"_addPoint\",value:function(t){this.path.unshift(t.x,t.y)}}]),e}(v);e.Arc=x,e.CubicBezier=d,e.QuadricBezier=g},function(t,e,i){!function(e,i){t.exports=i()}(this,function(){return function(t){function e(n){if(i[n])return i[n].exports;var r=i[n]={exports:{},id:n,loaded:!1};return t[n].call(r.exports,r,r.exports,e),r.loaded=!0,r.exports}var i={};return e.m=t,e.c=i,e.p=\"\",e(0)}([function(t,e,i){t.exports=i(1)},function(t,e){\"use strict\";function i(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}Object.defineProperty(e,\"__esModule\",{value:!0});var n=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e}}(),r=function(){function t(e,n){if(i(this,t),this.x=parseFloat(e),this.y=parseFloat(n),isNaN(this.x)||isNaN(this.y))throw console.error(\"new Point(\",e,n,\")\"),new Error(\"Invalid input: x and y params must be float.\")}return n(t,[{key:\"isEqual\",value:function(t){return this.x===t.x&&this.y===t.y}}]),t}(),s=function(){function t(){i(this,t),this.points=[],this.length=0}return n(t,[{key:\"getPoints\",value:function(){return this.points}},{key:\"getFlattenPoints\",value:function(){var t=[];return this.points.forEach(function(e){return t.push(e.x,e.y)}),t}},{key:\"getClipperPoints\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,e=[];return this.points.forEach(function(i){return e.push({X:parseInt(i.x*t),Y:parseInt(i.y*t)})}),e}},{key:\"fromClipperPoints\",value:function(t){var e=this,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return this.points=[],t.forEach(function(t){return e.addPoint(parseFloat(t.X*i),parseFloat(t.Y*i))}),this}},{key:\"getPoint\",value:function(t){return this.points[t<0?this.length+t:t]||null}},{key:\"addPoint\",value:function(t,e){this.points.push(new r(t,e)),this.length=this.points.length}},{key:\"addPoints\",value:function(t){for(var e=0,i=t.length;e<i;e+=2)this.addPoint(t[e],t[e+1])}},{key:\"isClosed\",value:function(){var t=this.getPoint(0);return t&&t.isEqual(this.getPoint(-1))}},{key:\"close\",value:function(){if(!this.isClosed()&&this.length>2){var t=this.getPoint(0);return this.addPoint(t.x,t.y),!0}return!1}},{key:\"transform\",value:function(t){this.points=this.points.map(function(e){return new r(t[0]*e.x+t[2]*e.y+t[4],t[1]*e.x+t[3]*e.y+t[5])})}}]),t}();e.Path=s,e.Point=r,e.default=s}])})}])});\n//# sourceMappingURL=lw.svg-curves.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/lw.svg-curves/dist/lw.svg-curves.js\n// module id = 6\n// module chunks = 0"],"sourceRoot":""}