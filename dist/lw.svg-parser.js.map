{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///lw.svg-parser.js","webpack:///webpack/bootstrap 987a4f71c96348849025","webpack:///./path.js","webpack:///./parser.js","webpack:///./tag.js","webpack:///./tagparser.js","webpack:///./trace.js","webpack:///../~/clipper-lib/clipper.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","prototype","Point","x","y","parseFloat","isNaN","console","error","Error","point","Path","points","forEach","push","scale","arguments","undefined","X","Y","_this","addPoint","il","firstPoint","getPoint","isEqual","isClosed","matrix","map","default","Parser","_tag","_tagparser","settings","element","editor","document","defs","tags","traceSettings","assign","linear","step","resolution","segmentLength","supportedTags","parseTags","includes","skipTags","excludes","onTag","onTagContext","input","loadFromString","File","loadFromFile","XMLDocument","loadFromXMLDocument","Element","loadFromElement","Promise","reject","resolve","nodeName","textContent","getElementsByTagName","_this2","documentElement","then","catch","_this3","_parseEditor","parser","DOMParser","XMLDoc","parseFromString","name","version","fingerprint","match","_this4","reader","FileReader","onload","event","result","onerror","readAsText","_this5","load","parse","_parseElement","applyMatrix","tag","info","callback","context","_this6","_onTag","parent","_this7","Tag","indexOf","_skipTag","tagParser","TagParser","childTag","childNodes","childNode","addChild","children","message","warn","attr","_interopRequireDefault","obj","__esModule","_path","_clipperLib","_clipperLib2","DEG_TO_RAD","Math","PI","toLowerCase","layer","attrs","paths","path","shapes","setMatrix","keys","setAttr","defaultValue","getAttr","getLayerName","clearPath","close","relative","addMatrix","angle","cos","sin","tan","transform","shape","outer","holes","hole","fillRule","log","PolyFillType","pftNonZero","pftEvenOdd","clipperPaths","clipperScale","getClipperPoints","Clipper","SimplifyPolygons","cClipper","polyTree","PolyTree","AddPaths","PolyType","ptSubject","Execute","ClipType","ctUnion","exPolygons","JS","PolyTreeToExPolygons","toPath","fromClipperPoints","exPolygon","_trace","_path2","currentCommand","lastCommand","pathData","handler","_parseTagAttrs","attributes","style","some","_normalizeTagAttr","split","nodeValue","colorsAttrs","attrName","_parseViewBoxAttr","_parseTransformAttr","replace","trim","_skipTagAttr","_normalizeTagAttrUnit","_normalizeTagAttrPoints","_normalizeTagAttrRange","_normalizeTagAttrPreserveAspectRatio","stringValue","floatValue","_parseNumbers","min","max","filter","params","defer","align","meet","slice","rawParams","substr","viewBox","width","height","scaleX","scaleY","translateX","translateY","preserveAspectRatio","newWidth","newHeight","translate","transformAttr","transformations","pop","type","raw","func","tagTransform","apply","newPath","closePath","addPoints","title","description","useTag","setLayerName","shift","concat","_polyline","w","h","rx","ry","dx","dy","r","cx","cy","num","splice","join","dAttr","commands","parseError","toUpperCase","_clearPath","_newPath","_addPoints","_closePath","every","_paths","p1","rl","x1","y1","x2","y2","p2","p3","p4","tracer","CubicBezier","coords","trace","QuadricBezier","large","sweep","Arc","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","setPrototypeOf","__proto__","mod","clamp","val","distance","p0","sqrt","pow","v0","v1","n","acos","_get","get","object","property","receiver","Function","desc","getOwnPropertyDescriptor","getPrototypeOf","getter","MATH_PI_2","TraceBase","arcLength","arcLengthMap","t","prevPoint","getPointAtT","nextPoint","u","targetDistanceFromStartingPoint","resultantT","prevArcLength","prevT","entry","endDiff","startDiff","linearFactor","_approximateLength","segments","round","_addPoint","_postTrace","getPath","_TraceBase","radians","abs","__addPoint","transformedPoint","radiiCheck","cSquareNumerator","cSquareRootDenom","cRadicand","cCoef","transformedCenter","center","startVector","endVector","startAngle","sweepAngle","init","_TraceBase2","_B1","_B2","_B3","_B4","_C1","unshift","_TraceBase3","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","BigInteger","a","b","ClipperLib","biginteger_used","fromInt","fromNumber","fromString","nbi","am1","j","v","floor","am2","xl","xh","l","am3","int2char","BI_RM","charAt","intAt","s","BI_RC","charCodeAt","bnpCopyTo","bnpFromInt","DV","nbv","bnpFromString","k","fromRadix","mi","sh","DB","ZERO","subTo","bnpClamp","DM","bnToString","negate","toString","toRadix","d","km","bnNegate","bnAbs","bnCompareTo","nbits","bnBitLength","bnpDLShiftTo","bnpDRShiftTo","bnpLShiftTo","bs","cbs","bm","ds","bnpRShiftTo","bnpSubTo","bnpMultiplyTo","am","bnpSquareTo","bnpDivRemTo","q","pm","pt","copyTo","ts","ms","nsh","lShiftTo","ys","y0","yt","F1","F2","d1","FV","d2","e","dlShiftTo","compareTo","ONE","qd","drShiftTo","rShiftTo","bnMod","divRemTo","Classic","cConvert","cRevert","cReduce","cMulTo","multiplyTo","reduce","cSqrTo","squareTo","bnpInvDigit","Montgomery","mp","invDigit","mpl","mph","um","mt2","montConvert","montRevert","montReduce","u0","montSqrTo","montMulTo","bnpIsEven","bnpExp","z","r2","g","convert","sqrTo","mulTo","revert","bnModPowInt","isEven","exp","bnClone","bnIntValue","bnByteValue","bnShortValue","bnpChunkSize","LN2","bnSigNum","bnpToRadix","signum","cs","chunkSize","intValue","bnpFromRadix","dMultiply","dAddOffset","bnpFromNumber","testBit","bitwiseTo","shiftLeft","op_or","isProbablePrime","bitLength","Array","nextBytes","bnToByteArray","bnEquals","bnMin","bnMax","bnpBitwiseTo","op","f","op_and","bnAnd","bnOr","op_xor","bnXor","op_andnot","bnAndNot","bnNot","bnShiftLeft","bnShiftRight","lbit","bnGetLowestSetBit","cbit","bnBitCount","bnTestBit","bnpChangeBit","bnSetBit","changeBit","bnClearBit","bnFlipBit","bnpAddTo","bnAdd","addTo","bnSubtract","bnMultiply","bnSquare","bnDivide","bnRemainder","bnDivideAndRemainder","bnpDMultiply","bnpDAddOffset","NullExp","nNop","nMulTo","nSqrTo","bnPow","bnpMultiplyLowerTo","bnpMultiplyUpperTo","Barrett","q3","mu","divide","barrettConvert","barrettRevert","barrettReduce","multiplyUpperTo","multiplyLowerTo","barrettSqrTo","barrettMulTo","bnModPow","k1","g2","is1","bnGCD","clone","getLowestSetBit","bnpModInt","bnModInverse","ac","subtract","add","bnIsProbablePrime","lowprimes","lplim","modInt","millerRabin","bnpMillerRabin","n1","shiftRight","random","modPow","modPowInt","use_int32","use_xyz","use_lines","isNode","window","navigator_appName","nav","navigator","userAgent","appName","browser","chrome","chromium","safari","firefox","firefox17","firefox15","firefox3","opera","msie10","msie9","msie8","msie7","msie","dbits","canary","j_lm","BI_FP","rr","vv","byteValue","shortValue","toByteArray","equals","and","or","xor","andNot","not","bitCount","setBit","clearBit","flipBit","multiply","remainder","divideAndRemainder","modInverse","gcd","square","Int128","IsNegative","op_Equality","val1","val2","op_Inequality","op_GreaterThan","op_LessThan","op_Addition","lhs","rhs","op_Subtraction","Int128Mul","op_Division","ToDouble","Inherit","ce","ce2","$baseCtor","getOwnPropertyNames","Paths","DoublePoint","DoublePoint0","DoublePoint1","dp","DoublePoint2","PolyNode","m_Parent","m_polygon","m_Index","m_jointype","m_endtype","m_Childs","IsOpen","IsHoleNode","node","ChildCount","Contour","AddChild","Child","cnt","GetNext","GetNextSiblingUp","Childs","Parent","IsHole","m_AllPolys","Clear","ilen","GetFirst","Total","Math_Abs_Int64","Math_Abs_Int32","Math_Abs_Double","Math_Max_Int32_Int32","Cast_Int32","Cast_Int64","ceil","Number","toInteger","parseInt","PI2","IntPoint","alen","Z","Round","IntPoint0","IntPoint1","IntPoint1dp","IntPoint2","IntPoint3","IntRect","left","top","right","bottom","ir","IntRect0","IntRect1","IntRect4","ctIntersection","ctDifference","ctXor","ptClip","pftPositive","pftNegative","JoinType","jtSquare","jtRound","jtMiter","EndType","etOpenSquare","etOpenRound","etOpenButt","etClosedLine","etClosedPolygon","EdgeSide","esLeft","esRight","Direction","dRightToLeft","dLeftToRight","TEdge","Bot","Curr","Top","Delta","Dx","PolyTyp","Side","WindDelta","WindCnt","WindCnt2","OutIdx","Next","Prev","NextInLML","NextInAEL","PrevInAEL","NextInSEL","PrevInSEL","IntersectNode","Edge1","Edge2","Pt","MyIntersectNodeSort","Compare","node1","node2","LocalMinima","LeftBound","RightBound","Scanbeam","OutRec","Idx","FirstLeft","Pts","BottomPt","OutPt","Join","OutPt1","OutPt2","OffPt","ClipperBase","m_MinimaList","m_CurrentLM","m_edges","m_UseFullRange","m_HasOpenPaths","PreserveCollinear","horizontal","Skip","Unassigned","tolerance","loRange","hiRange","near_zero","IsHorizontal","PointIsVertex","pp","pp2","PointOnLineSegment","linePt1","linePt2","UseFullRange","PointOnPolygon","SlopesEqual","e1","e2","pt1","pt2","pt3","pt4","SlopesEqual3","SlopesEqual4","SlopesEqual5","DisposeLocalMinimaList","jlen","tmpLm","RangeTest","useFullRange","Value","InitEdge","eNext","ePrev","InitEdge2","polyType","SetDx","FindNextLocMin","E","E2","ProcessBound","LeftBoundIsForward","EStart","Horz","Result","locMin","InsertLocalMinima","ReverseHorizontal","AddPath","pg","Closed","highI","edges","IsFlat","$1","eStart","eLoopStop","Pt2IsBetweenPt1AndPt3","RemoveEdge","leftBoundIsForward","EMin","ppg","closed","newLm","PopLocalMinima","tmp","Reset","lm","InitOptions","m_PolyOuts","m_ClipType","m_Scanbeam","m_ActiveEdges","m_SortedEdges","m_IntersectList","m_IntersectNodeComparer","m_ExecuteLocked","m_ClipFillType","m_SubjFillType","m_Joins","m_GhostJoins","m_UsingPolyTree","ReverseSolution","StrictlySimple","ZFillFunction","ioReverseSolution","ioStrictlySimple","ioPreserveCollinear","DisposeAllPolyPts","DisposeScanbeamList","sb2","InsertScanbeam","newSb","ispolytree","clipType","solution","subjFillType","clipFillType","succeeded","ExecuteInternal","BuildResult","polytree","BuildResult2","FixHoleLinkage","outRec","orfl","botY","PopScanbeam","InsertLocalMinimaIntoAEL","ProcessHorizontals","topY","ProcessIntersections","ProcessEdgesAtTopOfScanbeam","Area","ReversePolyPtLinks","JoinCommonEdges","FixupOutPolygon","DoSimplePolygons","DisposeOutRec","index","AddJoin","Op1","Op2","AddGhostJoin","Op","SetZ","lb","rb","InsertEdgeIntoAEL","SetWindingCount","IsContributing","AddOutPt","AddLocalMinPoly","AddEdgeToSEL","HorzSegmentsOverlap","IntersectEdges","edge","startEdge","E2InsertsBeforeE1","TopX","IsEvenOddFillType","IsEvenOddAltFillType","pft","pft2","Inside","CopyAELToSEL","SwapPositionsInAEL","edge1","edge2","next","prev","SwapPositionsInSEL","AddLocalMaxPoly","AppendPolygon","prevE","outPt","CreateOutRec","ToFront","newOp","SetHoleState","SwapPoints","seg1a","seg1b","seg2a","seg2b","isHole","GetDx","FirstIsBottomPt","btmPt1","btmPt2","dx1p","dx1n","dx2p","dx2n","GetBottomPt","dups","GetLowermostRec","outRec1","outRec2","bPt1","bPt2","Param1RightOfParam2","GetOutRec","idx","outrec","holeStateRec","side","p1_lft","p1_rt","p2_lft","p2_rt","OKIdx","ObsoleteIdx","pp1","SwapSides","SwapPolyIndexes","outIdx","e1Contributing","e2Contributing","oldE1WindCnt","e1FillType","e2FillType","e1FillType2","e2FillType2","e1Wc","e2Wc","e1Wc2","e2Wc2","DeleteFromAEL","AelPrev","AelNext","DeleteFromSEL","SelPrev","SelNext","UpdateEdgeIntoAEL","isTopOfScanbeam","horzEdge","ProcessHorizontal","GetHorzDirection","HorzEdge","$var","Left","Right","Dir","dir","horzLeft","horzRight","eLastHorz","eMaxPair","GetMaximaPair","IsLastHorz","GetNextInAEL","op1","eNextHorz","op2","IsMinima","IsMaxima","IsIntermediate","BuildIntersectList","FixupIntersectionOrder","ProcessIntersectList","$$e2","isModified","IntersectPoint","newNode","EdgesAdjacent","inode","IntersectNodeSort","sort","iNode","R1","R2","R3","R4","currentY","ip","b1","b2","IsMaximaEdge","DoMaxima","ReversePaths","polys","len","reverse","Orientation","poly","PointCount","pts","polyg","pn","lastOK","DupOutPt","InsertAfter","GetOverlap","a1","a2","$val","JoinHorz","op1b","op2b","DiscardLeft","Dir1","Dir2","JoinPoints","isHorizontal","reverse1","reverse2","DiscardLeftSide","Reverse1","Reverse2","GetBounds","GetBounds2","ops","opStart","PointInPolygon","ipNext","startOp","ptx","pty","poly0x","poly0y","poly1x","poly1y","Poly2ContainsPoly1","outPt1","outPt2","res","FixupFirstLefts1","OldOutRec","NewOutRec","firstLeft","ParseFirstLeft","FixupFirstLefts2","$i2","$t2","$l2","UpdateOutPtIdxs","oRec","op3","op4","outrec2","SimplifyPolygon","fillType","DistanceSqrd","DistanceFromLineSqrd","ln1","ln2","A","B","C","SlopesNearCollinear","distSqrd","PointsAreClose","ExcludeOp","CleanPolygon","outPts","CleanPolygons","Minkowski","pattern","IsSum","IsClosed","delta","polyCnt","pathCnt","quads","quad","MinkowskiSum","path_or_paths","pathIsClosed","TranslatePath","outPath","MinkowskiDiff","poly1","poly2","PolyTreeToPaths","AddPolyNodeToPaths","NodeType","ntAny","polynode","nt","ntOpen","ntClosed","$i3","$t3","$l3","OpenPathsFromPolyTree","ClosedPathsFromPolyTree","ClipperOffset","miterLimit","arcTolerance","def_arc_tolerance","m_destPolys","m_srcPoly","m_destPoly","m_normals","m_delta","m_sinA","m_sin","m_cos","m_miterLim","m_StepsPerRad","m_lowest","m_polyNodes","MiterLimit","ArcTolerance","two_pi","joinType","endType","FixOrientations","GetUnitNormal","DoOffset","steps","OffsetPoint","DoSquare","DoRound","X2","clpr","outerNode","jointype","cosA","DoMiter","atan2","err","alert","AreaOfPolygon","AreaOfPolygons","area","BoundsOfPath","BoundsOfPaths","bounds","Clean","polygon","isPolygons","Clone","k_length","results","plen","Lighten","P","rem","addlast","bxax","byay","ax","ay","toleranceSq","PerimeterOfPath","perimeter","p1x","p1y","p2x","p2y","PerimeterOfPaths","ScaleDownPath","ScaleDownPaths","ScaleUpPath","ScaleUpPaths","ExPolygons","ExPolygon","AddOuterPolyNodeToExPolygons","expolygons","ep","childs","childs2","ExPolygonsToPaths"],"mappings":"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","file":"lw.svg-parser.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"SVGParser\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SVGParser\"] = factory();\n\telse\n\t\troot[\"SVGParser\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"SVGParser\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SVGParser\"] = factory();\n\telse\n\t\troot[\"SVGParser\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(2);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar Point = function () {\n\t    // Class constructor...\n\t    function Point(x, y) {\n\t        _classCallCheck(this, Point);\n\t\n\t        // Init properties\n\t        this.x = parseFloat(x);\n\t        this.y = parseFloat(y);\n\t\n\t        if (isNaN(this.x) || isNaN(this.y)) {\n\t            console.error('x:', x, 'y:', y);\n\t            throw new Error('Float value!!!');\n\t        }\n\t    }\n\t\n\t    _createClass(Point, [{\n\t        key: 'isEqual',\n\t        value: function isEqual(point) {\n\t            return this.x === point.x && this.y === point.y;\n\t        }\n\t    }]);\n\t\n\t    return Point;\n\t}();\n\t\n\tvar Path = function () {\n\t    // Class constructor...\n\t    function Path() {\n\t        _classCallCheck(this, Path);\n\t\n\t        // Init properties\n\t        this.points = [];\n\t        this.length = 0;\n\t    }\n\t\n\t    _createClass(Path, [{\n\t        key: 'getPoints',\n\t        value: function getPoints() {\n\t            return this.points;\n\t        }\n\t    }, {\n\t        key: 'getFlattenPoints',\n\t        value: function getFlattenPoints() {\n\t            var points = [];\n\t            this.points.forEach(function (point) {\n\t                return points.push(point.x, point.y);\n\t            });\n\t            return points;\n\t        }\n\t    }, {\n\t        key: 'getClipperPoints',\n\t        value: function getClipperPoints() {\n\t            var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\t\n\t            var points = [];\n\t            this.points.forEach(function (point) {\n\t                return points.push({ X: point.x * scale, Y: point.y * scale });\n\t            });\n\t            return points;\n\t        }\n\t    }, {\n\t        key: 'fromClipperPoints',\n\t        value: function fromClipperPoints(points) {\n\t            var _this = this;\n\t\n\t            var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\t\n\t            this.points = [];\n\t            points.forEach(function (point) {\n\t                return _this.addPoint(point.X * scale, point.Y * scale);\n\t            });\n\t            return this;\n\t        }\n\t    }, {\n\t        key: 'getPoint',\n\t        value: function getPoint(i) {\n\t            return this.points[i < 0 ? this.length + i : i] || null;\n\t        }\n\t    }, {\n\t        key: 'addPoint',\n\t        value: function addPoint(x, y) {\n\t            this.points.push(new Point(x, y));\n\t            this.length = this.points.length;\n\t        }\n\t    }, {\n\t        key: 'addPoints',\n\t        value: function addPoints(points) {\n\t            // For each couple of points\n\t            for (var i = 0, il = points.length; i < il; i += 2) {\n\t                this.addPoint(points[i], points[i + 1]);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'isClosed',\n\t        value: function isClosed() {\n\t            var firstPoint = this.getPoint(0);\n\t            return firstPoint && firstPoint.isEqual(this.getPoint(-1));\n\t        }\n\t    }, {\n\t        key: 'close',\n\t        value: function close() {\n\t            if (!this.isClosed() && this.length > 2) {\n\t                var firstPoint = this.getPoint(0);\n\t                this.addPoint(firstPoint.x, firstPoint.y);\n\t                return true;\n\t            }\n\t\n\t            return false;\n\t        }\n\t    }, {\n\t        key: 'transform',\n\t        value: function transform(matrix) {\n\t            this.points = this.points.map(function (point) {\n\t                return new Point(matrix[0] * point.x + matrix[2] * point.y + matrix[4], matrix[1] * point.x + matrix[3] * point.y + matrix[5]);\n\t            });\n\t        }\n\t    }]);\n\t\n\t    return Path;\n\t}();\n\t\n\t// Exports\n\t\n\t\n\texports.Path = Path;\n\texports.Point = Point;\n\texports.default = Path;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.Parser = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Imports\n\t\n\t\n\tvar _tag = __webpack_require__(3);\n\t\n\tvar _tagparser = __webpack_require__(4);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t// SVG parser class\n\tvar Parser = function () {\n\t    // Class constructor...\n\t    function Parser(settings) {\n\t        _classCallCheck(this, Parser);\n\t\n\t        // Defaults settings\n\t        settings = settings || {};\n\t\n\t        // Init properties\n\t        this.element = null; // XML document Element object\n\t        this.editor = null; // Editor info { name, version, fingerprint }\n\t        this.document = null; // Document info { width, height, viewBox }\n\t        this.defs = null; // Defined <defs> (DOM) nodes list by id\n\t        this.tags = null; // Tag objects hierarchy\n\t\n\t        // Trace settings (Arc, Bezier)\n\t        this.traceSettings = Object.assign({\n\t            linear: true, // Linear trace mode\n\t            step: 0.01, // Step resolution if linear mode = false\n\t            resolution: 100, // Number of segments we use to approximate arc length\n\t            segmentLength: 1 }, settings.traceSettings || {});\n\t\n\t        // Supported tags by this lib\n\t        this.supportedTags = ['svg', 'g', 'defs', 'use', 'line', 'polyline', 'polygon', 'rect', 'circle', 'ellipse', 'path', 'title', 'desc'];\n\t\n\t        // Tags list to includes/excludes\n\t        this.parseTags = settings.includes || this.supportedTags;\n\t        this.skipTags = settings.excludes || ['#text', '#comment']; // silent (no warning)\n\t\n\t        // User onTag callback ?\n\t        settings.onTag && this.onTag(settings.onTag, settings.onTagContext);\n\t    }\n\t\n\t    // Load raw XML string, XMLDocument, Element or File object\n\t\n\t\n\t    _createClass(Parser, [{\n\t        key: 'load',\n\t        value: function load(input) {\n\t            // Load raw XML string\n\t            if (typeof input === 'string') {\n\t                return this.loadFromString(input);\n\t            }\n\t\n\t            // Load File object\n\t            if (input instanceof File) {\n\t                return this.loadFromFile(input);\n\t            }\n\t\n\t            // Load XMLDocument object\n\t            if (input instanceof XMLDocument) {\n\t                return this.loadFromXMLDocument(input);\n\t            }\n\t\n\t            // Load Element object\n\t            if (input instanceof Element) {\n\t                return this.loadFromElement(input);\n\t            }\n\t\n\t            // Return rejected promise with an Error object\n\t            return Promise.reject(new Error('Unsupported input format.'));\n\t        }\n\t\n\t        // Load from Element object\n\t\n\t    }, {\n\t        key: 'loadFromElement',\n\t        value: function loadFromElement(input) {\n\t            var _this = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (!(input instanceof Element)) {\n\t                    reject(new Error('Input param must be a Element object.'));\n\t                }\n\t\n\t                // Parser error\n\t                if (input.nodeName === 'parsererror') {\n\t                    // FF\n\t                    reject(new Error(input.textContent));\n\t                }\n\t\n\t                if (input.nodeName === 'html' && input.getElementsByTagName('parsererror')) {\n\t                    // Chrome\n\t                    reject(new Error(input.getElementsByTagName('parsererror')[0].textContent));\n\t                }\n\t\n\t                // Set document element\n\t                _this.element = input;\n\t\n\t                // Resolve promise\n\t                resolve(input);\n\t            });\n\t        }\n\t\n\t        // Load from XMLDocument object\n\t\n\t    }, {\n\t        key: 'loadFromXMLDocument',\n\t        value: function loadFromXMLDocument(input) {\n\t            var _this2 = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (!(input instanceof XMLDocument)) {\n\t                    reject(new Error('Input param must be a XMLDocument object.'));\n\t                }\n\t\n\t                // Load from Element...\n\t                _this2.loadFromElement(input.documentElement).then(resolve).catch(reject);\n\t            });\n\t        }\n\t\n\t        // Load raw XML string\n\t\n\t    }, {\n\t        key: 'loadFromString',\n\t        value: function loadFromString(input) {\n\t            var _this3 = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (typeof input !== 'string') {\n\t                    reject(new Error('Input param must be a string.'));\n\t                }\n\t\n\t                // Parse svg editor\n\t                _this3._parseEditor(input);\n\t\n\t                // Parse string as DOM object\n\t                var parser = new DOMParser();\n\t                var XMLDoc = parser.parseFromString(input, 'text/xml');\n\t\n\t                // Load from XMLDocument...\n\t                _this3.loadFromXMLDocument(XMLDoc).then(resolve).catch(reject);\n\t            });\n\t        }\n\t\n\t        // Try to get the svg editor from input string\n\t\n\t    }, {\n\t        key: '_parseEditor',\n\t        value: function _parseEditor(input) {\n\t            // Reset editor\n\t            this.editor = {\n\t                name: 'unknown',\n\t                version: null,\n\t                fingerprint: null\n\t            };\n\t\n\t            // Fingerprint matches\n\t            var fingerprint = void 0;\n\t\n\t            // Inkscape\n\t            fingerprint = input.match(/<!-- Created with Inkscape .*-->/i);\n\t\n\t            if (fingerprint) {\n\t                this.editor.name = 'inkscape';\n\t                this.editor.fingerprint = fingerprint[0];\n\t\n\t                return this.editor;\n\t            }\n\t\n\t            // Illustrator\n\t            fingerprint = input.match(/<!-- Generator: Adobe Illustrator ([0-9\\.]+), .*-->/i);\n\t\n\t            if (fingerprint) {\n\t                this.editor.name = 'illustrator';\n\t                this.editor.version = fingerprint[1];\n\t                this.editor.fingerprint = fingerprint[0];\n\t\n\t                return this.editor;\n\t            }\n\t\n\t            // Return default\n\t            return this.editor;\n\t        }\n\t\n\t        // Load from File object\n\t\n\t    }, {\n\t        key: 'loadFromFile',\n\t        value: function loadFromFile(input) {\n\t            var _this4 = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (!(input instanceof File)) {\n\t                    reject(new Error('Input param must be a File object.'));\n\t                }\n\t\n\t                // Create file reader\n\t                var reader = new FileReader();\n\t\n\t                // Register reader events handlers\n\t                reader.onload = function (event) {\n\t                    _this4.loadFromString(event.target.result).then(resolve).catch(reject);\n\t                };\n\t\n\t                reader.onerror = function (event) {\n\t                    reject(new Error('Error reading file : ' + input.name));\n\t                };\n\t\n\t                // Finally read input file as text\n\t                reader.readAsText(input);\n\t            });\n\t        }\n\t\n\t        // Parse the (loaded) element\n\t\n\t    }, {\n\t        key: 'parse',\n\t        value: function parse(input) {\n\t            var _this5 = this;\n\t\n\t            // Reset properties\n\t            this.document = null;\n\t            this.defs = {};\n\t            this.tags = null;\n\t\n\t            // Load input if provided\n\t            if (input) {\n\t                return new Promise(function (resolve, reject) {\n\t                    _this5.load(input).then(function () {\n\t                        resolve(_this5.parse());\n\t                    }).catch(reject);\n\t                });\n\t            }\n\t\n\t            // Start parsing element\n\t            return new Promise(function (resolve, reject) {\n\t                // If no element is loaded\n\t                if (!_this5.element) {\n\t                    reject(new Error('No element is loaded, call the load method before.'));\n\t                }\n\t\n\t                // Parse the main Element (recursive)\n\t                _this5.tags = _this5._parseElement(_this5.element);\n\t\n\t                if (!_this5.tags) {\n\t                    reject(new Error('No supported tags found.'));\n\t                }\n\t\n\t                // Apply matrix (recursive)\n\t                _this5.tags.applyMatrix();\n\t\n\t                // Resolve the promise\n\t                resolve(_this5.tags);\n\t            });\n\t        }\n\t\n\t        // On tag callback\n\t\n\t    }, {\n\t        key: '_onTag',\n\t        value: function _onTag(tag) {\n\t            console.info('onTag:', tag);\n\t        }\n\t\n\t        // Register on tag callback\n\t\n\t    }, {\n\t        key: 'onTag',\n\t        value: function onTag(callback, context) {\n\t            var _this6 = this;\n\t\n\t            this._onTag = function (tag) {\n\t                return callback.call(context || _this6, tag);\n\t            };\n\t        }\n\t\n\t        // Parse the provided Element and return an Tag collection (recursive)\n\t\n\t    }, {\n\t        key: '_parseElement',\n\t        value: function _parseElement(element, parent) {\n\t            var _this7 = this;\n\t\n\t            // Create base tag object\n\t            var tag = new _tag.Tag(element, parent);\n\t\n\t            // Exluded tag ?\n\t            if (this.skipTags.indexOf(tag.name) !== -1) {\n\t                return null; // silent\n\t            }\n\t\n\t            // Supported tag ?\n\t            if (this.parseTags.indexOf(tag.name) === -1) {\n\t                return this._skipTag(tag, 'unsupported');\n\t            }\n\t\n\t            // Parse the tag\n\t            var tagParser = new _tagparser.TagParser(tag, this);\n\t\n\t            if (!tagParser.parse()) {\n\t                return false;\n\t            }\n\t\n\t            // Call the on tag callback\n\t            this._onTag(tag);\n\t\n\t            // Parse child nodes\n\t            var childTag = void 0;\n\t\n\t            element.childNodes.forEach(function (childNode) {\n\t                // Parse child element\n\t                if (childTag = _this7._parseElement(childNode, tag)) {\n\t                    tag.addChild(childTag);\n\t                }\n\t            });\n\t\n\t            // Empty group\n\t            if (['svg', 'g'].indexOf(tag.name) !== -1 && !tag.children.length) {\n\t                return this._skipTag(tag, 'empty');\n\t            }\n\t\n\t            // Return tag object\n\t            return tag;\n\t        }\n\t\n\t        // Log skip tag warning message\n\t\n\t    }, {\n\t        key: '_skipTag',\n\t        value: function _skipTag(tag, message) {\n\t            console.warn('Skip tag :', message + ':', tag);\n\t            return false;\n\t        }\n\t\n\t        // Log skip tag attribute warning message\n\t\n\t    }, {\n\t        key: '_skipTagAttr',\n\t        value: function _skipTagAttr(tag, attr, message) {\n\t            console.warn('Skip tag attribute :', message + ':', attr, tag);\n\t            return false;\n\t        }\n\t    }]);\n\t\n\t    return Parser;\n\t}();\n\t\n\t// Exports\n\t\n\t\n\texports.Parser = Parser;\n\texports.default = Parser;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.Tag = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _path = __webpack_require__(1);\n\t\n\tvar _clipperLib = __webpack_require__(6);\n\t\n\tvar _clipperLib2 = _interopRequireDefault(_clipperLib);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar DEG_TO_RAD = Math.PI / 180;\n\t\n\t// SVG tag class\n\t\n\tvar Tag = function () {\n\t    // Class constructor...\n\t    function Tag(element, parent) {\n\t        var _this = this;\n\t\n\t        _classCallCheck(this, Tag);\n\t\n\t        // Init properties\n\t        this.element = element;\n\t        this.name = element.nodeName.toLowerCase();\n\t        this.parent = parent || null;\n\t        this.layer = null;\n\t        this.attrs = {};\n\t        this.children = [];\n\t        this.paths = [];\n\t        this.matrix = null;\n\t        this.path = new _path.Path();\n\t        this.point = new _path.Point(0, 0);\n\t        this.shapes = [];\n\t\n\t        // Add first path\n\t        this.paths.push(this.path);\n\t\n\t        // Set the matrix\n\t        this.setMatrix(this.parent && this.parent.matrix);\n\t\n\t        // Clone parent attributes\n\t        if (this.parent && (this.parent.name === 'g' || this.parent.name === 'svg')) {\n\t            (function () {\n\t                // Inherit layer name\n\t                _this.layer = _this.parent.layer;\n\t\n\t                // Inherit parent attributes\n\t                var excludes = ['transform', 'width', 'height'];\n\t\n\t                Object.keys(_this.parent.attrs).forEach(function (key) {\n\t                    if (excludes.indexOf(key) === -1) {\n\t                        _this.setAttr(key, _this.parent.attrs[key]);\n\t                    }\n\t                });\n\t            })();\n\t        }\n\t    }\n\t\n\t    _createClass(Tag, [{\n\t        key: 'setAttr',\n\t        value: function setAttr(name, value) {\n\t            this.attrs[name] = value;\n\t        }\n\t    }, {\n\t        key: 'getAttr',\n\t        value: function getAttr(name, defaultValue) {\n\t            return this.attrs[name] !== undefined ? this.attrs[name] : defaultValue !== undefined ? defaultValue : null;\n\t        }\n\t    }, {\n\t        key: 'getLayerName',\n\t        value: function getLayerName() {\n\t            if (this.name === 'g') {\n\t                return this.getAttr('inkscape:label', this.getAttr('id', null));\n\t            }\n\t        }\n\t    }, {\n\t        key: 'setLayerName',\n\t        value: function setLayerName(name) {\n\t            if (this.name === 'g') {\n\t                this.layer = name || this.getLayerName();\n\t            }\n\t        }\n\t    }, {\n\t        key: 'addChild',\n\t        value: function addChild(childTag) {\n\t            this.children.push(childTag);\n\t        }\n\t    }, {\n\t        key: 'clearPath',\n\t        value: function clearPath() {\n\t            this.path = new _path.Path();\n\t        }\n\t    }, {\n\t        key: 'newPath',\n\t        value: function newPath() {\n\t            if (this.path.length > 0) {\n\t                this.clearPath();\n\t                this.paths.push(this.path);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'closePath',\n\t        value: function closePath() {\n\t            return this.path.close();\n\t        }\n\t    }, {\n\t        key: 'addPoint',\n\t        value: function addPoint(x, y, relative) {\n\t            // Relative from the last point\n\t            if (relative) {\n\t                x += this.point.x;\n\t                y += this.point.y;\n\t            }\n\t\n\t            // Add current point\n\t            this.path.addPoint(x, y);\n\t\n\t            // Update current point\n\t            this.point = this.path.getPoint(-1);\n\t        }\n\t    }, {\n\t        key: 'addPoints',\n\t        value: function addPoints(points, relative) {\n\t            // For each couple of points\n\t            for (var i = 0, il = points.length; i < il; i += 2) {\n\t                this.addPoint(points[i], points[i + 1], relative);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'setMatrix',\n\t        value: function setMatrix(matrix) {\n\t            this.matrix = matrix || [1, 0, 0, 1, 0, 0];\n\t        }\n\t    }, {\n\t        key: 'addMatrix',\n\t        value: function addMatrix(matrix) {\n\t            this.matrix = [this.matrix[0] * matrix[0] + this.matrix[2] * matrix[1], this.matrix[1] * matrix[0] + this.matrix[3] * matrix[1], this.matrix[0] * matrix[2] + this.matrix[2] * matrix[3], this.matrix[1] * matrix[2] + this.matrix[3] * matrix[3], this.matrix[0] * matrix[4] + this.matrix[2] * matrix[5] + this.matrix[4], this.matrix[1] * matrix[4] + this.matrix[3] * matrix[5] + this.matrix[5]];\n\t        }\n\t    }, {\n\t        key: 'translate',\n\t        value: function translate(x, y) {\n\t            y = y === undefined ? 0 : y;\n\t            this.addMatrix([1, 0, 0, 1, x, y]);\n\t        }\n\t    }, {\n\t        key: 'rotate',\n\t        value: function rotate(angle, x, y) {\n\t            angle = angle * DEG_TO_RAD;\n\t\n\t            if (arguments.length == 2) {\n\t                this.addMatrix([1, 0, 0, 1, x, y]);\n\t            }\n\t\n\t            this.addMatrix([Math.cos(angle), Math.sin(angle), -Math.sin(angle), Math.cos(angle), 0, 0]);\n\t\n\t            if (arguments.length == 2) {\n\t                this.addMatrix([1, 0, 0, 1, -x, -y]);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'scale',\n\t        value: function scale(x, y) {\n\t            y = y === undefined ? x : y;\n\t            this.addMatrix([x, 0, 0, y, 0, 0]);\n\t        }\n\t    }, {\n\t        key: 'skewX',\n\t        value: function skewX(angle) {\n\t            this.addMatrix([1, 0, Math.tan(angle * DEG_TO_RAD), 1, 0, 0]);\n\t        }\n\t    }, {\n\t        key: 'skewY',\n\t        value: function skewY(angle) {\n\t            this.addMatrix([1, Math.tan(angle * DEG_TO_RAD), 0, 1, 0, 0]);\n\t        }\n\t    }, {\n\t        key: 'applyMatrix',\n\t        value: function applyMatrix(matrix) {\n\t            var _this2 = this;\n\t\n\t            matrix && this.addMatrix(matrix);\n\t\n\t            this.paths.forEach(function (path) {\n\t                path.transform(_this2.matrix);\n\t            });\n\t\n\t            this.shapes.forEach(function (shape) {\n\t                shape.outer.transform(_this2.matrix);\n\t                shape.holes.forEach(function (hole) {\n\t                    hole.transform(_this2.matrix);\n\t                });\n\t            });\n\t\n\t            this.setMatrix(null);\n\t\n\t            this.children.forEach(function (tag) {\n\t                tag.applyMatrix(matrix);\n\t            });\n\t        }\n\t    }, {\n\t        key: 'getPaths',\n\t        value: function getPaths() {\n\t            return this.paths;\n\t        }\n\t    }, {\n\t        key: 'getShapes',\n\t        value: function getShapes() {\n\t            // No shapes...\n\t            if (this.getAttr('fill', 'none') === 'none' || !this.paths[0].length) {\n\t                return this.shapes;\n\t            }\n\t\n\t            // Get fill rule\n\t            var fillRule = this.getAttr('fill-rule', 'nonzero');\n\t            console.log(fillRule);\n\t            fillRule = fillRule === 'nonzero' ? _clipperLib2.default.PolyFillType.pftNonZero : _clipperLib2.default.PolyFillType.pftEvenOdd;\n\t\n\t            // Create clipper path\n\t            var clipperPaths = [];\n\t            var clipperScale = 1000000.0;\n\t\n\t            this.paths.forEach(function (path) {\n\t                clipperPaths.push(path.getClipperPoints(clipperScale));\n\t            });\n\t\n\t            // Simplify paths (self-intersecting)\n\t            clipperPaths = _clipperLib2.default.Clipper.SimplifyPolygons(clipperPaths, fillRule);\n\t\n\t            // Clipper paths to PolyTree\n\t            var cClipper = new _clipperLib2.default.Clipper();\n\t            var polyTree = new _clipperLib2.default.PolyTree();\n\t\n\t            cClipper.AddPaths(clipperPaths, _clipperLib2.default.PolyType.ptSubject, true);\n\t            cClipper.Execute(_clipperLib2.default.ClipType.ctUnion, polyTree, fillRule, fillRule);\n\t\n\t            // PolyTree to ExPolygons\n\t            var exPolygons = _clipperLib2.default.JS.PolyTreeToExPolygons(polyTree);\n\t\n\t            var toPath = function toPath(path) {\n\t                return new _path.Path().fromClipperPoints(path, 1 / clipperScale);\n\t            };\n\t\n\t            this.shapes = exPolygons.map(function (exPolygon) {\n\t                return {\n\t                    outer: toPath(exPolygon.outer),\n\t                    holes: exPolygon.holes.map(toPath)\n\t                };\n\t            });\n\t\n\t            // console.log('clipperPaths:', clipperPaths)\n\t            // console.log('polyTree:', polyTree)\n\t            // console.log('shapes:', this.shapes)\n\t\n\t            return this.shapes;\n\t        }\n\t    }]);\n\t\n\t    return Tag;\n\t}();\n\t\n\t// Exports\n\t\n\t\n\texports.Tag = Tag;\n\texports.default = Tag;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.TagParser = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _trace = __webpack_require__(5);\n\t\n\tvar _path2 = __webpack_require__(1);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t// SVG tag parser\n\tvar TagParser = function () {\n\t    // Class constructor...\n\t    function TagParser(tag, parser) {\n\t        _classCallCheck(this, TagParser);\n\t\n\t        // Init properties\n\t        this.tag = tag;\n\t        this.parser = parser;\n\t        this.currentCommand = null;\n\t        this.lastCommand = null;\n\t        this.pathData = null;\n\t        this.traceSettings = parser.traceSettings;\n\t    }\n\t\n\t    _createClass(TagParser, [{\n\t        key: 'parse',\n\t        value: function parse() {\n\t            // Get internal parser from node name\n\t            var handler = this['_' + this.tag.name];\n\t\n\t            // Implemented tag handler?\n\t            if (!handler || typeof handler !== 'function') {\n\t                return this.parser._skipTag(this.tag, 'not yet implemented');\n\t            }\n\t\n\t            // Parse tag attributes\n\t            this._parseTagAttrs();\n\t\n\t            // Parse tag\n\t            return handler.call(this);\n\t        }\n\t\n\t        // Parse the tag attributes\n\t\n\t    }, {\n\t        key: '_parseTagAttrs',\n\t        value: function _parseTagAttrs() {\n\t            var _this = this;\n\t\n\t            // Get tag attributes\n\t            var attrs = this.tag.element.attributes;\n\t\n\t            if (!attrs) {\n\t                return null;\n\t            }\n\t\n\t            // For each attribute\n\t            var attr = void 0,\n\t                value = void 0,\n\t                style = void 0;\n\t\n\t            Object.keys(attrs).some(function (key) {\n\t                // Current attribute\n\t                attr = attrs[key];\n\t\n\t                // Normalize attribute value\n\t                value = _this._normalizeTagAttr(attr);\n\t\n\t                if (value === false) {\n\t                    return false; // continue\n\t                }\n\t\n\t                // Special case\n\t                if (attr.nodeName === 'style') {\n\t                    style = value;\n\t                } else {\n\t                    // Set new attribute name/value\n\t                    _this.tag.setAttr(attr.nodeName, value);\n\t                }\n\t            });\n\t\n\t            // If style attribute (override tag attributes)\n\t            // TODO get/parse global style and override this one...\n\t            style && style.split(';').some(function (attr) {\n\t                // Current style\n\t                attr = attr.split(':');\n\t                attr = { nodeName: attr[0], nodeValue: attr[1] };\n\t\n\t                // Normalize attribute value\n\t                value = _this._normalizeTagAttr(attr);\n\t\n\t                if (value === false) {\n\t                    return false; // continue\n\t                }\n\t\n\t                // Set new attribute name/value\n\t                _this.tag.setAttr(attr.nodeName, value);\n\t            });\n\t\n\t            // Set inherited color\n\t            var colorsAttrs = ['fill', 'stroke', 'color'];\n\t\n\t            colorsAttrs.forEach(function (attrName) {\n\t                if (_this.tag.getAttr(attrName) === 'inherit') {\n\t                    _this.tag.setAttr(attrName, _this.tag.parent.getAttr(attrName, 'none'));\n\t                }\n\t            });\n\t\n\t            // Parse viewBox attribute\n\t            this._parseViewBoxAttr();\n\t\n\t            // Parse transform attribute\n\t            this._parseTransformAttr();\n\t        }\n\t\n\t        // Normalize tag attribute\n\t\n\t    }, {\n\t        key: '_normalizeTagAttr',\n\t        value: function _normalizeTagAttr(attr) {\n\t            // Normalize whitespaces\n\t            var value = attr.nodeValue.replace(/(\\r?\\n|\\r)+/gm, ' ') // Remove all new line chars\n\t            .replace(/\\s+/gm, ' ') // Reduce multiple whitespaces\n\t            .trim(); // Remove trailing whitespaces\n\t\n\t            if (!value.length) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'empty');\n\t            }\n\t\n\t            // Filters\n\t            switch (attr.nodeName) {\n\t                // Normalize size unit -> to px\n\t                case 'x':\n\t                case 'y':\n\t                case 'x1':\n\t                case 'y1':\n\t                case 'x2':\n\t                case 'y2':\n\t                case 'r':\n\t                case 'rx':\n\t                case 'ry':\n\t                case 'cx':\n\t                case 'cy':\n\t                case 'width':\n\t                case 'height':\n\t                case 'fontSize':\n\t                case 'strokeWidth':\n\t                    value = this._normalizeTagAttrUnit(attr);\n\t                    break;\n\t\n\t                // Normalize points attribute\n\t                case 'points':\n\t                case 'viewBox':\n\t                    value = this._normalizeTagAttrPoints(attr);\n\t                    break;\n\t\n\t                // Range limit to [0 - 1]\n\t                case 'opacity':\n\t                case 'fillOpacity':\n\t                case 'strokeOpacity':\n\t                    value = this._normalizeTagAttrRange(attr, 0, 1);\n\t                    break;\n\t\n\t                case 'preserveAspectRatio':\n\t                    value = this._normalizeTagAttrPreserveAspectRatio(attr);\n\t                    break;\n\t            }\n\t\n\t            // Return normalized value\n\t            return value;\n\t        }\n\t\n\t        // Normalize attribute unit to px\n\t\n\t    }, {\n\t        key: '_normalizeTagAttrUnit',\n\t        value: function _normalizeTagAttrUnit(attr) {\n\t            var stringValue = attr.nodeValue.toLowerCase();\n\t            var floatValue = parseFloat(stringValue);\n\t\n\t            if (isNaN(floatValue)) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'only numeric value allowed');\n\t            }\n\t\n\t            if (stringValue.indexOf('mm') !== -1) {\n\t                return floatValue * 3.5433070869;\n\t            }\n\t\n\t            if (stringValue.indexOf('cm') !== -1) {\n\t                return floatValue * 35.433070869;\n\t            }\n\t\n\t            if (stringValue.indexOf('in') !== -1) {\n\t                return floatValue * 90.0;\n\t            }\n\t\n\t            if (stringValue.indexOf('pt') !== -1) {\n\t                return floatValue * 1.25;\n\t            }\n\t\n\t            if (stringValue.indexOf('pc') !== -1) {\n\t                return floatValue * 15.0;\n\t            }\n\t\n\t            return floatValue;\n\t        }\n\t\n\t        // Normalize points attribute\n\t\n\t    }, {\n\t        key: '_normalizeTagAttrPoints',\n\t        value: function _normalizeTagAttrPoints(attr) {\n\t            var points = this._parseNumbers(attr.nodeValue);\n\t\n\t            if (points === false) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'only numeric values are allowed');\n\t            }\n\t\n\t            if (!points.length) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'empty points list');\n\t            }\n\t\n\t            if (points.length % 0) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'the number of points must be even');\n\t            }\n\t\n\t            return points;\n\t        }\n\t\n\t        // Normalize range attribute like \"opacity\"\n\t\n\t    }, {\n\t        key: '_normalizeTagAttrRange',\n\t        value: function _normalizeTagAttrRange(attr, min, max) {\n\t            var stringValue = attr.nodeValue.trim();\n\t            var floatValue = parseFloat(stringValue);\n\t\n\t            if (isNaN(floatValue)) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'only numeric values are allowed');\n\t            }\n\t\n\t            if (floatValue < min || floatValue > max) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'out of range [' + min + ', ' + max + ']');\n\t            }\n\t\n\t            return floatValue;\n\t        }\n\t\n\t        // Parse points string as numbers array\n\t\n\t    }, {\n\t        key: '_parseNumbers',\n\t        value: function _parseNumbers(points) {\n\t            // http://stackoverflow.com/questions/638565/parsing-scientific-notation-sensibly\n\t            if (typeof points === 'string') {\n\t                points = points.split(/([+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)?/g).filter(function (point) {\n\t                    return point && ['', ','].indexOf(point.trim()) === -1;\n\t                });\n\t            }\n\t\n\t            // Normalize to float values\n\t            points = points.map(parseFloat);\n\t\n\t            // Test if all numbers is valid\n\t            if (points.some(isNaN)) {\n\t                return false;\n\t            }\n\t\n\t            return points;\n\t        }\n\t\n\t        // Normalize the preserveAspectRatio attribute\n\t\n\t    }, {\n\t        key: '_normalizeTagAttrPreserveAspectRatio',\n\t        value: function _normalizeTagAttrPreserveAspectRatio(attr) {\n\t            var params = {\n\t                defer: false,\n\t                align: 'none',\n\t                meet: true,\n\t                slice: false\n\t            };\n\t\n\t            var rawParams = attr.nodeValue;\n\t\n\t            if (rawParams.indexOf('defer') === 0) {\n\t                rawParams = rawParams.substr(6);\n\t                params.defer = true;\n\t            }\n\t\n\t            rawParams = rawParams.split(' ');\n\t            params.align = rawParams[0];\n\t            params.meet = rawParams[1] || 'meet';\n\t            params.meet = params.meet === 'meet';\n\t            params.slice = !params.meet;\n\t\n\t            return params;\n\t        }\n\t\n\t        // Parse viewBox attribute and set transformations\n\t\n\t    }, {\n\t        key: '_parseViewBoxAttr',\n\t        value: function _parseViewBoxAttr() {\n\t            // Get viewBox attribute\n\t            var viewBox = this.tag.getAttr('viewBox', null);\n\t\n\t            // No viewBox...\n\t            if (viewBox === null) {\n\t                return null;\n\t            }\n\t\n\t            // Update size attributes\n\t            var width = this.tag.getAttr('width', viewBox[2]);\n\t            var height = this.tag.getAttr('height', viewBox[3]);\n\t\n\t            this.tag.setAttr('width', width);\n\t            this.tag.setAttr('height', height);\n\t\n\t            // Scale to match viewBox\n\t            // TODO clip path if preserveAspectRatio.slice\n\t            var scaleX = width / viewBox[2];\n\t            var scaleY = height / viewBox[3];\n\t            var translateX = viewBox[0];\n\t            var translateY = viewBox[1];\n\t\n\t            var preserveAspectRatio = this.tag.getAttr('preserveAspectRatio', 'meet xMidYMid');\n\t\n\t            if (preserveAspectRatio) {\n\t                var newWidth = void 0,\n\t                    newHeight = void 0;\n\t\n\t                if (preserveAspectRatio.meet) {\n\t                    if (scaleX > scaleY) {\n\t                        scaleX = scaleY;\n\t                        newWidth = viewBox[2] * scaleX;\n\t                    } else if (scaleX < scaleY) {\n\t                        scaleY = scaleX;\n\t                        newHeight = viewBox[3] * scaleY;\n\t                    }\n\t                } else if (preserveAspectRatio.slice) {\n\t                    if (scaleX < scaleY) {\n\t                        scaleX = scaleY;\n\t                        newWidth = viewBox[2] * scaleX;\n\t                    } else if (scaleX > scaleY) {\n\t                        scaleY = scaleX;\n\t                        newHeight = viewBox[3] * scaleY;\n\t                    }\n\t                }\n\t\n\t                if (newWidth !== undefined) {\n\t                    if (preserveAspectRatio.align === 'xMidYMid') {\n\t                        this.tag.translate((width - newWidth) / 2, 0);\n\t                    } else if (preserveAspectRatio.align === 'xMaxYMax') {\n\t                        this.tag.translate(width - newWidth, 0);\n\t                    }\n\t                } else if (newHeight !== undefined) {\n\t                    if (preserveAspectRatio.align === 'xMidYMid') {\n\t                        this.tag.translate(0, (height - newHeight) / 2);\n\t                    } else if (preserveAspectRatio.align === 'xMaxYMax') {\n\t                        this.tag.translate(0, height - newHeight);\n\t                    }\n\t                }\n\t            }\n\t\n\t            this.tag.scale(scaleX, scaleY);\n\t            this.tag.translate(-translateX, -translateY);\n\t        }\n\t\n\t        // Parse transform attribute and set transformations\n\t\n\t    }, {\n\t        key: '_parseTransformAttr',\n\t        value: function _parseTransformAttr() {\n\t            var _this2 = this;\n\t\n\t            // Get transform attribute\n\t            var transformAttr = this.tag.getAttr('transform', null);\n\t\n\t            // No transformation...\n\t            if (transformAttr === null || !transformAttr.length) {\n\t                return null;\n\t            }\n\t\n\t            // Parse attribute (split group on closing parenthesis)\n\t            var transformations = transformAttr.split(')');\n\t\n\t            // Remove last entry due to last \")\" found\n\t            transformations.pop();\n\t\n\t            // For each transformation\n\t            var transform = void 0,\n\t                type = void 0,\n\t                params = void 0;\n\t\n\t            transformations.some(function (raw) {\n\t                // Split name and value on opening parenthesis\n\t                transform = raw.split('(');\n\t\n\t                // Invalid parts number\n\t                if (transform.length !== 2) {\n\t                    return _this2.parser._skipTagAttr(_this2.tag, transformAttr, 'malformed'); // continue\n\t                }\n\t\n\t                type = transform[0].trim();\n\t\n\t                // Quik hack 1/2\n\t                var func = type;\n\t                if (func === 'matrix') {\n\t                    func = 'addMatrix';\n\t                }\n\t\n\t                // Get tag transform method\n\t                var tagTransform = _this2.tag[func];\n\t\n\t                if (typeof tagTransform !== 'function') {\n\t                    return _this2.parser._skipTagAttr(_this2.tag, transformAttr, 'unsupported transform type :' + type);\n\t                }\n\t\n\t                params = transform[1].trim();\n\t                params = _this2._parseNumbers(params);\n\t\n\t                // Skip empty value\n\t                if (!params.length) {\n\t                    return _this2.parser._skipTagAttr(_this2.tag, transformAttr, 'malformed transform type :' + type);\n\t                }\n\t\n\t                // Quik hack 2/2\n\t                if (func == 'addMatrix') {\n\t                    params = [params];\n\t                }\n\t\n\t                // Call tag transform method like \"tag.translate(param1, ..., paramN)\"\n\t                tagTransform.apply(_this2.tag, params);\n\t            });\n\t        }\n\t    }, {\n\t        key: '_newPath',\n\t        value: function _newPath() {\n\t            this.tag.newPath();\n\t        }\n\t    }, {\n\t        key: '_clearPath',\n\t        value: function _clearPath() {\n\t            this.tag.clearPath();\n\t        }\n\t    }, {\n\t        key: '_closePath',\n\t        value: function _closePath() {\n\t            return this.tag.closePath();\n\t        }\n\t    }, {\n\t        key: '_addPoints',\n\t        value: function _addPoints(points, relative) {\n\t            if (!points.length) {\n\t                return this.parser._skipTag(this.tag, 'empty points list');\n\t            }\n\t\n\t            if (points.length % 0) {\n\t                return this.parser._skipTag(this.tag, 'the number of points must be even');\n\t            }\n\t\n\t            relative = arguments.length < 2 && this.currentCommand.relative;\n\t\n\t            this.tag.addPoints(points, relative);\n\t            return true;\n\t        }\n\t\n\t        // SVG specs at https://www.w3.org/TR/SVG11/\n\t\n\t    }, {\n\t        key: '_svg',\n\t        value: function _svg() {\n\t            // Only parse the root SVG tag as main document\n\t            if (this.parser.document) {\n\t                // Handled tag\n\t                return true;\n\t            }\n\t\n\t            // Get the document size\n\t            var width = this.tag.getAttr('width');\n\t            var height = this.tag.getAttr('height');\n\t\n\t            // Invalid size\n\t            if (!width || width < 0 || !height || height < 0) {\n\t                throw new Error('Invalid document size: ' + width + ' / ' + height);\n\t            }\n\t\n\t            // Set document size\n\t            this.parser.document = {\n\t                width: width,\n\t                height: height\n\t            };\n\t\n\t            // Get document viewBox or set default to document size\n\t            var viewBox = this.tag.getAttr('viewBox', [0, 0, width, height]);\n\t\n\t            this.parser.document.viewBox = {\n\t                x: viewBox[0],\n\t                y: viewBox[1],\n\t                width: viewBox[2],\n\t                height: viewBox[3]\n\t            };\n\t\n\t            // Check inkscape version\n\t            if (this.parser.editor.name === 'inkscape') {\n\t                this.parser.editor.version = this.tag.getAttr('inkscape:version');\n\t            }\n\t\n\t            // Handled tag\n\t            return true;\n\t        }\n\t    }, {\n\t        key: '_title',\n\t        value: function _title() {\n\t            // Register the first encountered title tag as document title\n\t            if (this.parser.document && !this.parser.document.title) {\n\t                this.parser.document.title = this.tag.element.textContent;\n\t            }\n\t\n\t            // Skipped tag\n\t            return false;\n\t        }\n\t    }, {\n\t        key: '_desc',\n\t        value: function _desc() {\n\t            // Register the first encountered desc tag as document description\n\t            if (this.parser.document && !this.parser.document.description) {\n\t                this.parser.document.description = this.tag.element.textContent;\n\t            }\n\t\n\t            // Skipped tag\n\t            return false;\n\t        }\n\t    }, {\n\t        key: '_defs',\n\t        value: function _defs() {\n\t            var _this3 = this;\n\t\n\t            // Register all child element with an id attribute\n\t            this.tag.element.childNodes.forEach(function (childNode) {\n\t                childNode.id && (_this3.parser.defs[childNode.id] = childNode);\n\t            });\n\t\n\t            // Skipped tag\n\t            return false;\n\t        }\n\t    }, {\n\t        key: '_use',\n\t        value: function _use() {\n\t            // Get the target id\n\t            var target = this.tag.getAttr('xlink:href').replace(/^#/, '');\n\t\n\t            // Try to get the defined element\n\t            var element = this.parser.defs[target];\n\t\n\t            if (!element) {\n\t                return this.parser._skipTag(this.tag, 'undefined reference [' + target + ']');\n\t            }\n\t\n\t            // Parse the defined element and set new parent from <use> tag parent\n\t            var useTag = this.parser._parseElement(element, this.tag.parent);\n\t\n\t            if (!useTag) {\n\t                return this.parser._skipTag(this.tag, 'empty reference [' + target + ']');\n\t            }\n\t\n\t            // Set matrix from real parent (<use>)\n\t            useTag.setMatrix(this.tag.matrix);\n\t\n\t            // Replace the use tag with new one\n\t            this.tag.parent.addChild(useTag);\n\t\n\t            // Skipped tag\n\t            return false;\n\t        }\n\t    }, {\n\t        key: '_g',\n\t        value: function _g() {\n\t            // Set the tag layer name\n\t            this.tag.setLayerName();\n\t\n\t            // Handled tag\n\t            return true;\n\t        }\n\t    }, {\n\t        key: '_line',\n\t        value: function _line() {\n\t            // Handled tag\n\t            return this._path(['M', this.tag.getAttr('x1'), this.tag.getAttr('y1'), 'L', this.tag.getAttr('x2'), this.tag.getAttr('y2')]);\n\t        }\n\t    }, {\n\t        key: '_polyline',\n\t        value: function _polyline() {\n\t            var close = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\t\n\t            var points = this.tag.getAttr('points');\n\t            var path = ['M', points.shift(), points.shift(), 'L'];\n\t\n\t            path = path.concat(points);\n\t            close && path.push('Z');\n\t\n\t            // Handled tag\n\t            return this._path(path);\n\t        }\n\t    }, {\n\t        key: '_polygon',\n\t        value: function _polygon() {\n\t            // Handled like polyline but closed\n\t            return this._polyline(true);\n\t        }\n\t    }, {\n\t        key: '_rect',\n\t        value: function _rect() {\n\t            // Get rectangle attributes\n\t            var w = this.tag.getAttr('width');\n\t            var h = this.tag.getAttr('height');\n\t            var x = this.tag.getAttr('x', 0);\n\t            var y = this.tag.getAttr('y', 0);\n\t            var rx = this.tag.getAttr('rx', null);\n\t            var ry = this.tag.getAttr('ry', null);\n\t\n\t            // Simple rect\n\t            if (!rx && !ry) {\n\t                // Handled tag\n\t                return this._path(['M', x, y, 'h', w, 'v', h, 'h', -w, 'z']);\n\t            }\n\t\n\t            // If a properly specified value is provided for rx, but not for ry,\n\t            // then set both rx and ry to the value of rx and vis-vera...\n\t            if (rx === null) rx = ry;\n\t            if (ry === null) ry = rx;\n\t\n\t            // A negative value is an error\n\t            if (rx === null || rx === null || rx < 0 || ry < 0) {\n\t                // Skip tag\n\t                return this.parser._skipTag(this.tag, 'negative value for \"rx/ry\" not allowed');\n\t            }\n\t\n\t            // If rx is greater than half of width, then set rx to half of width.\n\t            // If ry is greater than half of height, then set ry to half of height.\n\t            if (rx > w / 2) rx = w / 2;\n\t            if (ry > h / 2) ry = h / 2;\n\t\n\t            var dx = rx * 2;\n\t            var dy = ry * 2;\n\t\n\t            // Handled tag\n\t            return this._path(['M', x + rx, y, 'h', w - dx, 'c', rx, 0, rx, ry, rx, ry, 'v', h - dy, 'c', 0, ry, -rx, ry, -rx, ry, 'h', -w + dx, 'c', -rx, 0, -rx, -ry, -rx, -ry, 'v', -h + dy, 'c', 0, 0, 0, -ry, rx, -ry, 'z']);\n\t        }\n\t    }, {\n\t        key: '_circle',\n\t        value: function _circle() {\n\t            var r = this.tag.getAttr('r', 0);\n\t\n\t            if (r <= 0) {\n\t                // Skipped tag\n\t                return false;\n\t            }\n\t\n\t            var cx = this.tag.getAttr('cx', 0);\n\t            var cy = this.tag.getAttr('cy', 0);\n\t\n\t            // Handled tag\n\t            return this._path(['M', cx - r, cy, 'A', r, r, 0, 0, 0, cx, cy + r, 'A', r, r, 0, 0, 0, cx + r, cy, 'A', r, r, 0, 0, 0, cx, cy - r, 'A', r, r, 0, 0, 0, cx - r, cy, 'Z']);\n\t        }\n\t    }, {\n\t        key: '_ellipse',\n\t        value: function _ellipse() {\n\t            var rx = this.tag.getAttr('rx', 0);\n\t            var ry = this.tag.getAttr('ry', 0);\n\t\n\t            if (rx <= 0 || ry <= 0) {\n\t                // Skipped tag\n\t                return false;\n\t            }\n\t\n\t            var cx = this.tag.getAttr('cx', 0);\n\t            var cy = this.tag.getAttr('cy', 0);\n\t\n\t            // Handled tag\n\t            return this._path(['M', cx - rx, cy, 'A', rx, ry, 0, 0, 0, cx, cy + ry, 'A', rx, ry, 0, 0, 0, cx + rx, cy, 'A', rx, ry, 0, 0, 0, cx, cy - ry, 'A', rx, ry, 0, 0, 0, cx - rx, cy, 'Z']);\n\t        }\n\t    }, {\n\t        key: '_paths',\n\t        value: function _paths(type, num, points) {\n\t            if (points.length > num) {\n\t                var handler = void 0,\n\t                    result = true;\n\t\n\t                while (result && points.length) {\n\t                    handler = this['_path' + type];\n\t                    result = handler.call(this, points.splice(0, num));\n\t                }\n\t\n\t                return result;\n\t            }\n\t\n\t            return null;\n\t        }\n\t    }, {\n\t        key: '_path',\n\t        value: function _path(path) {\n\t            var _this4 = this;\n\t\n\t            // Provided path\n\t            if (path && typeof path !== 'string') {\n\t                path = path.join(' ');\n\t            }\n\t\n\t            // Get the paths data attribute value\n\t            var dAttr = path || this.tag.getAttr('d', null);\n\t\n\t            if (!dAttr) {\n\t                // Skipped tag\n\t                return false;\n\t            }\n\t\n\t            // Split on each commands\n\t            var commands = dAttr.match(/([M|Z|L|H|V|C|S|Q|T|A]+([^M|Z|L|H|V|C|S|Q|T|A]+)?)/gi);\n\t\n\t            if (!commands) {\n\t                return this.parser._skipTag(this.tag, 'malformed \"d\" attribute');\n\t            }\n\t\n\t            // For each command...\n\t            this.currentCommand = {\n\t                raw: null,\n\t                type: null,\n\t                params: null,\n\t                relative: null\n\t            };\n\t            this.lastCommand = this.currentCommand;\n\t            this.pathData = {};\n\t\n\t            var handler = null;\n\t            var parseError = false;\n\t\n\t            commands.some(function (raw) {\n\t                // Remove trailing whitespaces\n\t                raw = raw.trim();\n\t\n\t                // Extract command char and params\n\t                _this4.currentCommand.raw = raw;\n\t                _this4.currentCommand.type = raw[0].toUpperCase();\n\t                _this4.currentCommand.params = raw.substr(1).trim();\n\t                _this4.currentCommand.relative = _this4.currentCommand.type !== raw[0];\n\t\n\t                // Get path handler from command char\n\t                handler = _this4['_path' + _this4.currentCommand.type];\n\t\n\t                if (!handler || typeof handler !== 'function') {\n\t                    _this4.parser._skipTag(_this4.tag, 'unsupported path command [' + raw[0] + ']');\n\t                    return parseError = true; // break\n\t                }\n\t\n\t                // Extract all numbers from arguments string\n\t                _this4.currentCommand.params = _this4._parseNumbers(_this4.currentCommand.params);\n\t\n\t                if (_this4.currentCommand.params === false) {\n\t                    _this4.parser._skipTag(_this4.tag, 'only numeric values are allowed in [' + _this4.currentCommand.raw + ']');\n\t                    return parseError = true; // break\n\t                }\n\t\n\t                // Execute command parser\n\t                if (!handler.call(_this4, _this4.currentCommand.params)) {\n\t                    return parseError = true; // break\n\t                }\n\t\n\t                // Update last command\n\t                _this4.lastCommand = {};\n\t\n\t                Object.keys(_this4.currentCommand).forEach(function (key) {\n\t                    _this4.lastCommand[key] = _this4.currentCommand[key];\n\t                });\n\t            });\n\t\n\t            // Skip tag\n\t            if (parseError) {\n\t                this._clearPath();\n\t                return false;\n\t            }\n\t\n\t            // Handled tag\n\t            return true;\n\t        }\n\t    }, {\n\t        key: '_pathM',\n\t        value: function _pathM(points) {\n\t            // New path\n\t            this._newPath();\n\t\n\t            // Set the current point (start of new path)\n\t            // If is followed by multiple pairs of coordinates,\n\t            // the subsequent pairs are treated as implicit lineto commands.\n\t            return this._addPoints(points);\n\t        }\n\t    }, {\n\t        key: '_pathZ',\n\t        value: function _pathZ() {\n\t            this._closePath();\n\t            return true;\n\t        }\n\t    }, {\n\t        key: '_pathL',\n\t        value: function _pathL(points) {\n\t            return this._addPoints(points);\n\t        }\n\t    }, {\n\t        key: '_pathH',\n\t        value: function _pathH(points) {\n\t            var _this5 = this;\n\t\n\t            return points.every(function (x) {\n\t                return _this5._addPoints([x, _this5.currentCommand.relative ? 0 : _this5.tag.point.y]);\n\t            });\n\t        }\n\t    }, {\n\t        key: '_pathV',\n\t        value: function _pathV(points) {\n\t            var _this6 = this;\n\t\n\t            return points.every(function (y) {\n\t                return _this6._addPoints([_this6.currentCommand.relative ? 0 : _this6.tag.point.x, y]);\n\t            });\n\t        }\n\t    }, {\n\t        key: '_pathC',\n\t        value: function _pathC(points) {\n\t            // Multiple paths\n\t            var result = this._paths('C', 6, points);\n\t\n\t            if (result !== null) {\n\t                return result;\n\t            }\n\t\n\t            // Single path\n\t            var p1 = this.tag.point;\n\t            var rl = this.currentCommand.relative;\n\t\n\t            var x1 = points[0] + (rl ? p1.x : 0);\n\t            var y1 = points[1] + (rl ? p1.y : 0);\n\t            var x2 = points[2] + (rl ? p1.x : 0);\n\t            var y2 = points[3] + (rl ? p1.y : 0);\n\t            var x = points[4] + (rl ? p1.x : 0);\n\t            var y = points[5] + (rl ? p1.y : 0);\n\t\n\t            this.pathData.x2 = x2;\n\t            this.pathData.y2 = y2;\n\t\n\t            var p2 = new _path2.Point(x1, y1);\n\t            var p3 = new _path2.Point(x2, y2);\n\t            var p4 = new _path2.Point(x, y);\n\t\n\t            //console.log('C', p1, p2, p3, p4)\n\t\n\t            // p1  : starting point\n\t            // p2  : control point\n\t            // p3  : control point\n\t            // p4  : end point\n\t            var tracer = new _trace.CubicBezier(this.traceSettings);\n\t            var coords = tracer.trace({ p1: p1, p2: p2, p3: p3, p4: p4 }); // => [x,y, x,y, ...]\n\t            // let tracer = trace(CubicBezier, this.traceSettings)\n\t            // let coords = tracer({ p1, p2, p3, p4 })\n\t\n\t            // Trace the line\n\t            return this._addPoints(coords, false);\n\t        }\n\t    }, {\n\t        key: '_pathS',\n\t        value: function _pathS(points) {\n\t            // Multiple paths\n\t            var result = this._paths('S', 4, points);\n\t\n\t            if (result !== null) {\n\t                return result;\n\t            }\n\t\n\t            // Single path\n\t            var p1 = this.tag.point;\n\t            var rl = this.currentCommand.relative;\n\t\n\t            var x1 = p1.x;\n\t            var y1 = p1.y;\n\t\n\t            if (this.lastCommand.type === 'S' || this.lastCommand.type === 'C') {\n\t                x1 -= this.pathData.x2 - x1;\n\t                y1 -= this.pathData.y2 - y1;\n\t            }\n\t\n\t            var x2 = points[0] + (rl ? p1.x : 0);\n\t            var y2 = points[1] + (rl ? p1.y : 0);\n\t            var x = points[2] + (rl ? p1.x : 0);\n\t            var y = points[3] + (rl ? p1.y : 0);\n\t\n\t            this.pathData.x2 = x2;\n\t            this.pathData.y2 = y2;\n\t\n\t            var p2 = new _path2.Point(x1, y1);\n\t            var p3 = new _path2.Point(x2, y2);\n\t            var p4 = new _path2.Point(x, y);\n\t\n\t            //console.log('S', p1, p2, p3, p4)\n\t\n\t            // p1  : starting point\n\t            // p2  : control point\n\t            // p3  : control point\n\t            // p4  : end point\n\t            var tracer = new _trace.CubicBezier(this.traceSettings);\n\t            var coords = tracer.trace({ p1: p1, p2: p2, p3: p3, p4: p4 }); // => [x,y, x,y, ...]\n\t            // let tracer = trace(CubicBezier, this.traceSettings)\n\t            // let coords = tracer({ p1, p2, p3, p4 })\n\t\n\t            // Trace the line\n\t            return this._addPoints(coords, false);\n\t        }\n\t    }, {\n\t        key: '_pathQ',\n\t        value: function _pathQ(points) {\n\t            // Multiple paths\n\t            var result = this._paths('Q', 4, points);\n\t\n\t            if (result !== null) {\n\t                return result;\n\t            }\n\t\n\t            // Single path\n\t            var p1 = this.tag.point;\n\t            var rl = this.currentCommand.relative;\n\t\n\t            var x1 = points[0] + (rl ? p1.x : 0);\n\t            var y1 = points[1] + (rl ? p1.y : 0);\n\t            var x = points[2] + (rl ? p1.x : 0);\n\t            var y = points[3] + (rl ? p1.y : 0);\n\t\n\t            this.pathData.x1 = x1;\n\t            this.pathData.y1 = y1;\n\t\n\t            var p2 = new _path2.Point(x1, y1);\n\t            var p3 = new _path2.Point(x, y);\n\t\n\t            //console.log('Q', p1, p2, p3)\n\t\n\t            // p1  : starting point\n\t            // p2  : control point\n\t            // p3  : end point\n\t            var tracer = new _trace.QuadricBezier(this.traceSettings);\n\t            var coords = tracer.trace({ p1: p1, p2: p2, p3: p3 }); // => [x,y, x,y, ...]\n\t\n\t            // Trace the line\n\t            return this._addPoints(coords, false);\n\t        }\n\t    }, {\n\t        key: '_pathT',\n\t        value: function _pathT(points) {\n\t            // Multiple paths\n\t            var result = this._paths('T', 2, points);\n\t\n\t            if (result !== null) {\n\t                return result;\n\t            }\n\t\n\t            // Single path\n\t            var p1 = this.tag.point;\n\t            var rl = this.currentCommand.relative;\n\t\n\t            var x1 = p1.x;\n\t            var y1 = p1.y;\n\t\n\t            if (this.lastCommand.type === 'Q' || this.lastCommand.type === 'T') {\n\t                x1 -= this.pathData.x1 - x1;\n\t                y1 -= this.pathData.y1 - y1;\n\t            }\n\t\n\t            var x = points[0] + (rl ? p1.x : 0);\n\t            var y = points[1] + (rl ? p1.y : 0);\n\t\n\t            this.pathData.x1 = x1;\n\t            this.pathData.y1 = y1;\n\t\n\t            var p2 = new _path2.Point(x1, y1);\n\t            var p3 = new _path2.Point(x, y);\n\t\n\t            //console.log('T', p1, p2, p3)\n\t\n\t            // p1  : starting point\n\t            // p2  : control point\n\t            // p3  : end point\n\t            var tracer = new _trace.QuadricBezier(this.traceSettings);\n\t            var coords = tracer.trace({ p1: p1, p2: p2, p3: p3 }); // => [x,y, x,y, ...]\n\t\n\t            // Trace the line\n\t            return this._addPoints(coords, false);\n\t        }\n\t    }, {\n\t        key: '_pathA',\n\t        value: function _pathA(points) {\n\t            // Multiple paths\n\t            var result = this._paths('A', 7, points);\n\t\n\t            if (result !== null) {\n\t                return result;\n\t            }\n\t\n\t            // Single path\n\t            var rl = this.currentCommand.relative;\n\t            var p1 = this.tag.point;\n\t            var rx = points[0];\n\t            var ry = points[1];\n\t            var angle = points[2];\n\t            var large = !!points[3];\n\t            var sweep = !!points[4];\n\t            var x = points[5] + (rl ? p1.x : 0);\n\t            var y = points[6] + (rl ? p1.y : 0);\n\t            var p2 = new _path2.Point(x, y);\n\t\n\t            //console.log('A', p1, rx, ry, angle, large, sweep, p2)\n\t\n\t            var tracer = new _trace.Arc(this.traceSettings);\n\t            var coords = tracer.trace({ p1: p1, rx: rx, ry: ry, angle: angle, large: large, sweep: sweep, p2: p2 }); // => [x,y, x,y, ...]\n\t\n\t            // Trace the line\n\t            return this._addPoints(coords, false);\n\t        }\n\t    }]);\n\t\n\t    return TagParser;\n\t}();\n\t\n\t// Exports\n\t\n\t\n\texports.TagParser = TagParser;\n\texports.default = TagParser;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.QuadricBezier = exports.CubicBezier = exports.Arc = undefined;\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Base code from : https://github.com/MadLittleMods/svg-curve-lib/blob/master/src/js/svg-curve-lib.js\n\t\n\t\n\tvar _path = __webpack_require__(1);\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar MATH_PI_2 = Math.PI * 2;\n\tvar DEG_TO_RAD = Math.PI / 180;\n\t\n\tfunction mod(x, m) {\n\t    return (x % m + m) % m;\n\t}\n\t\n\tfunction clamp(val, min, max) {\n\t    return Math.min(Math.max(val, min), max);\n\t}\n\t\n\tfunction distance(p0, p1) {\n\t    return Math.sqrt(Math.pow(p1.x - p0.x, 2) + Math.pow(p1.y - p0.y, 2));\n\t}\n\t\n\tfunction angle(v0, v1) {\n\t    var p = v0.x * v1.x + v0.y * v1.y;\n\t    var n = Math.sqrt((Math.pow(v0.x, 2) + Math.pow(v0.y, 2)) * (Math.pow(v1.x, 2) + Math.pow(v1.y, 2)));\n\t    return (v0.x * v1.y - v0.y * v1.x < 0 ? -1 : 1) * Math.acos(p / n);\n\t}\n\t\n\t// Abstract class\n\t\n\tvar TraceBase = function () {\n\t    function TraceBase(settings) {\n\t        _classCallCheck(this, TraceBase);\n\t\n\t        // Set defaults properties\n\t        this.path = []; // Points collection [x,y, x,y, ...]\n\t        this.linear = true; // Linear trace mode\n\t        this.step = 0.01; // Step resolution if linear mode = false\n\t        this.resolution = 500; // Number of segments we use to approximate arc length\n\t        this.segmentLength = 0.1; // Segment length\n\t\n\t        // Update properties from user settings\n\t        Object.assign(this, settings || {});\n\t\n\t        // Arc length properties\n\t        this.arcLength = null;\n\t        this.arcLengthMap = null;\n\t    }\n\t\n\t    _createClass(TraceBase, [{\n\t        key: '_clearPath',\n\t        value: function _clearPath() {\n\t            this.path = [];\n\t        }\n\t    }, {\n\t        key: 'getPath',\n\t        value: function getPath() {\n\t            return this.path;\n\t        }\n\t    }, {\n\t        key: 'getPointAtT',\n\t        value: function getPointAtT(t) {\n\t            return new _path.Point(0, 0);\n\t        }\n\t    }, {\n\t        key: '_addPoint',\n\t        value: function _addPoint(point) {\n\t            this.path.push(point.x, point.y);\n\t        }\n\t    }, {\n\t        key: '_postTrace',\n\t        value: function _postTrace() {\n\t            // Do additional tasks\n\t        }\n\t    }, {\n\t        key: '_approximateLength',\n\t        value: function _approximateLength() {\n\t            var arcLength = 0;\n\t            var arcLengthMap = [];\n\t            var prevPoint = this.getPointAtT(0);\n\t\n\t            var i = void 0,\n\t                t = void 0,\n\t                nextPoint = void 0;\n\t\n\t            for (i = 0; i < this.resolution; i++) {\n\t                t = clamp(i * (1 / this.resolution), 0, 1);\n\t                nextPoint = this.getPointAtT(t);\n\t                arcLength += distance(prevPoint, nextPoint);\n\t\n\t                arcLengthMap.push({ t: t, arcLength: arcLength });\n\t\n\t                prevPoint = nextPoint;\n\t            }\n\t\n\t            // Last stretch to the endpoint\n\t            nextPoint = this.getPointAtT(1);\n\t            arcLength += distance(prevPoint, nextPoint);\n\t\n\t            arcLengthMap.push({ t: 1, arcLength: arcLength });\n\t            Object.assign(this, { arcLength: arcLength, arcLengthMap: arcLengthMap });\n\t        }\n\t    }, {\n\t        key: 'getPointAtU',\n\t        value: function getPointAtU(u) {\n\t            u = clamp(u, 0, 1);\n\t\n\t            var targetDistanceFromStartingPoint = u * this.arcLength;\n\t\n\t            var resultantT = 0;\n\t            var prevArcLength = 0;\n\t            var prevT = 0;\n\t\n\t            this.arcLengthMap.every(function (entry) {\n\t                var t = entry.t;\n\t                var arcLength = entry.arcLength;\n\t\n\t                // Once we go a past our target\n\t                // Lets interpolate from a previous to current\n\t                if (arcLength >= targetDistanceFromStartingPoint) {\n\t                    var endDiff = arcLength - targetDistanceFromStartingPoint;\n\t                    var startDiff = targetDistanceFromStartingPoint - prevArcLength;\n\t                    var linearFactor = startDiff / (endDiff + startDiff) || 0;\n\t\n\t                    resultantT = prevT + (t - prevT) * linearFactor;\n\t\n\t                    // Break\n\t                    return false;\n\t                }\n\t\n\t                prevArcLength = arcLength;\n\t                prevT = t;\n\t\n\t                return true;\n\t            });\n\t\n\t            return this.getPointAtT(resultantT);\n\t        }\n\t    }, {\n\t        key: 'trace',\n\t        value: function trace(settings) {\n\t            // Update properties from user settings\n\t            Object.assign(this, settings || {});\n\t\n\t            // Default getPoint settings\n\t            var getPoint = 'getPointAtT';\n\t            var step = this.step;\n\t\n\t            // Linear mode ?\n\t            if (this.linear) {\n\t                this._approximateLength();\n\t\n\t                var segments = Math.round(this.arcLength / this.segmentLength);\n\t\n\t                getPoint = 'getPointAtU';\n\t                step = 1 / segments;\n\t            }\n\t\n\t            // Clear points list\n\t            this._clearPath();\n\t\n\t            // Trace the path\n\t            for (var t = 0; t <= 1; t += step) {\n\t                this._addPoint(this[getPoint](t));\n\t            }\n\t\n\t            // Do additional tasks\n\t            this._postTrace();\n\t\n\t            // Return the path\n\t            return this.getPath();\n\t        }\n\t    }]);\n\t\n\t    return TraceBase;\n\t}();\n\t\n\t// Rewrite from https://github.com/MadLittleMods/svg-curve-lib/blob/master/src/js/svg-curve-lib.js#L84\n\t\n\t\n\tvar Arc = function (_TraceBase) {\n\t    _inherits(Arc, _TraceBase);\n\t\n\t    function Arc() {\n\t        _classCallCheck(this, Arc);\n\t\n\t        return _possibleConstructorReturn(this, (Arc.__proto__ || Object.getPrototypeOf(Arc)).apply(this, arguments));\n\t    }\n\t\n\t    _createClass(Arc, [{\n\t        key: 'init',\n\t        value: function init(settings) {\n\t            // Update properties from user settings\n\t            Object.assign(this, settings || {});\n\t\n\t            // Get angle in radians\n\t            this.radians = mod(this.angle, 360) * DEG_TO_RAD;\n\t\n\t            // If the endpoints are identical, then this is equivalent\n\t            // to omitting the elliptical arc segment entirely.\n\t            if (this.p1.x === this.p2.x && this.p1.y === this.p2.y) {\n\t                return this.path;\n\t            }\n\t\n\t            this.rx = Math.abs(this.rx);\n\t            this.ry = Math.abs(this.ry);\n\t\n\t            // If rx = 0 or ry = 0 then this arc is treated as\n\t            // a straight line segment joining the endpoints.\n\t            if (this.rx === 0 || this.ry === 0) {\n\t                this.__addPoint(this.p1);\n\t                this.__addPoint(this.p2);\n\t                return this.path;\n\t            }\n\t\n\t            // Following \"Conversion from endpoint to center parameterization\"\n\t            // http://www.w3.org/TR/SVG/implnote.html#ArcConversionEndpointToCenter\n\t\n\t            // Step #1: Compute transformedPoint\n\t            var dx = (this.p1.x - this.p2.x) / 2;\n\t            var dy = (this.p1.y - this.p2.y) / 2;\n\t\n\t            var transformedPoint = {\n\t                x: Math.cos(this.radians) * dx + Math.sin(this.radians) * dy,\n\t                y: -Math.sin(this.radians) * dx + Math.cos(this.radians) * dy\n\t            };\n\t\n\t            // Ensure radii are large enough\n\t            var radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(this.rx, 2) + Math.pow(transformedPoint.y, 2) / Math.pow(this.ry, 2);\n\t\n\t            if (radiiCheck > 1) {\n\t                this.rx = Math.sqrt(radiiCheck) * this.rx;\n\t                this.ry = Math.sqrt(radiiCheck) * this.ry;\n\t            }\n\t\n\t            // Step #2: Compute transformedCenter\n\t            var cSquareNumerator = Math.pow(this.rx, 2) * Math.pow(this.ry, 2) - Math.pow(this.rx, 2) * Math.pow(transformedPoint.y, 2) - Math.pow(this.ry, 2) * Math.pow(transformedPoint.x, 2);\n\t            var cSquareRootDenom = Math.pow(this.rx, 2) * Math.pow(transformedPoint.y, 2) + Math.pow(this.ry, 2) * Math.pow(transformedPoint.x, 2);\n\t            var cRadicand = cSquareNumerator / cSquareRootDenom;\n\t\n\t            // Make sure this never drops below zero because of precision\n\t            cRadicand = cRadicand < 0 ? 0 : cRadicand;\n\t            var cCoef = (this.large !== this.sweep ? 1 : -1) * Math.sqrt(cRadicand);\n\t            var transformedCenter = {\n\t                x: cCoef * (this.rx * transformedPoint.y / this.ry),\n\t                y: cCoef * (-(this.ry * transformedPoint.x) / this.rx)\n\t            };\n\t\n\t            // Step #3: Compute center\n\t            this.center = {\n\t                x: Math.cos(this.radians) * transformedCenter.x - Math.sin(this.radians) * transformedCenter.y + (this.p1.x + this.p2.x) / 2,\n\t                y: Math.sin(this.radians) * transformedCenter.x + Math.cos(this.radians) * transformedCenter.y + (this.p1.y + this.p2.y) / 2\n\t            };\n\t\n\t            // Step #4: Compute start/sweep angles\n\t            // Start angle of the elliptical arc prior to the stretch and rotate operations.\n\t            // Difference between the start and end angles\n\t            var startVector = {\n\t                x: (transformedPoint.x - transformedCenter.x) / this.rx,\n\t                y: (transformedPoint.y - transformedCenter.y) / this.ry\n\t            };\n\t\n\t            var endVector = {\n\t                x: (-transformedPoint.x - transformedCenter.x) / this.rx,\n\t                y: (-transformedPoint.y - transformedCenter.y) / this.ry\n\t            };\n\t\n\t            this.startAngle = angle({ x: 1, y: 0 }, startVector);\n\t            this.sweepAngle = angle(startVector, endVector);\n\t\n\t            if (!this.sweep && this.sweepAngle > 0) {\n\t                this.sweepAngle -= MATH_PI_2;\n\t            } else if (this.sweep && this.sweepAngle < 0) {\n\t                this.sweepAngle += MATH_PI_2;\n\t            }\n\t\n\t            // We use % instead of `mod(..)` because we want it to be -360deg to 360deg(but actually in radians)\n\t            this.sweepAngle %= MATH_PI_2;\n\t        }\n\t    }, {\n\t        key: 'trace',\n\t        value: function trace(settings) {\n\t            this.init(settings);\n\t            return _get(Arc.prototype.__proto__ || Object.getPrototypeOf(Arc.prototype), 'trace', this).call(this);\n\t        }\n\t    }, {\n\t        key: 'getPointAtT',\n\t        value: function getPointAtT(t) {\n\t            var angle = this.startAngle + this.sweepAngle * t;\n\t\n\t            var x = this.rx * Math.cos(angle);\n\t            var y = this.ry * Math.sin(angle);\n\t\n\t            return new _path.Point(Math.cos(this.radians) * x - Math.sin(this.radians) * y + this.center.x, Math.sin(this.radians) * x + Math.cos(this.radians) * y + this.center.y);\n\t        }\n\t    }, {\n\t        key: '_postTrace',\n\t        value: function _postTrace() {\n\t            // Add last point in the path\n\t            this._addPoint(this.p2);\n\t        }\n\t    }]);\n\t\n\t    return Arc;\n\t}(TraceBase);\n\t\n\tvar CubicBezier = function (_TraceBase2) {\n\t    _inherits(CubicBezier, _TraceBase2);\n\t\n\t    function CubicBezier() {\n\t        _classCallCheck(this, CubicBezier);\n\t\n\t        return _possibleConstructorReturn(this, (CubicBezier.__proto__ || Object.getPrototypeOf(CubicBezier)).apply(this, arguments));\n\t    }\n\t\n\t    _createClass(CubicBezier, [{\n\t        key: '_B1',\n\t        value: function _B1(t) {\n\t            return t * t * t;\n\t        }\n\t    }, {\n\t        key: '_B2',\n\t        value: function _B2(t) {\n\t            return 3 * t * t * (1 - t);\n\t        }\n\t    }, {\n\t        key: '_B3',\n\t        value: function _B3(t) {\n\t            return 3 * t * (1 - t) * (1 - t);\n\t        }\n\t    }, {\n\t        key: '_B4',\n\t        value: function _B4(t) {\n\t            return (1 - t) * (1 - t) * (1 - t);\n\t        }\n\t    }, {\n\t        key: '_C1',\n\t        value: function _C1(p1, p2, p3, p4, t) {\n\t            return p1 * this._B1(t) + p2 * this._B2(t) + p3 * this._B3(t) + p4 * this._B4(t);\n\t        }\n\t    }, {\n\t        key: 'getPointAtT',\n\t        value: function getPointAtT(t) {\n\t            return new _path.Point(this._C1(this.p1.x, this.p2.x, this.p3.x, this.p4.x, t), this._C1(this.p1.y, this.p2.y, this.p3.y, this.p4.y, t));\n\t        }\n\t    }, {\n\t        key: '_addPoint',\n\t        value: function _addPoint(point) {\n\t            this.path.unshift(point.x, point.y);\n\t        }\n\t    }]);\n\t\n\t    return CubicBezier;\n\t}(TraceBase);\n\t\n\tvar QuadricBezier = function (_TraceBase3) {\n\t    _inherits(QuadricBezier, _TraceBase3);\n\t\n\t    function QuadricBezier() {\n\t        _classCallCheck(this, QuadricBezier);\n\t\n\t        return _possibleConstructorReturn(this, (QuadricBezier.__proto__ || Object.getPrototypeOf(QuadricBezier)).apply(this, arguments));\n\t    }\n\t\n\t    _createClass(QuadricBezier, [{\n\t        key: '_B1',\n\t        value: function _B1(t) {\n\t            return t * t;\n\t        }\n\t    }, {\n\t        key: '_B2',\n\t        value: function _B2(t) {\n\t            return 2 * t * (1 - t);\n\t        }\n\t    }, {\n\t        key: '_B3',\n\t        value: function _B3(t) {\n\t            return (1 - t) * (1 - t);\n\t        }\n\t    }, {\n\t        key: '_C1',\n\t        value: function _C1(p1, p2, p3, t) {\n\t            return p1 * this._B1(t) + p2 * this._B2(t) + p3 * this._B3(t);\n\t        }\n\t    }, {\n\t        key: 'getPointAtT',\n\t        value: function getPointAtT(t) {\n\t            return new _path.Point(this._C1(this.p1.x, this.p2.x, this.p3.x, t), this._C1(this.p1.y, this.p2.y, this.p3.y, t));\n\t        }\n\t    }, {\n\t        key: '_addPoint',\n\t        value: function _addPoint(point) {\n\t            this.path.unshift(point.x, point.y);\n\t        }\n\t    }]);\n\t\n\t    return QuadricBezier;\n\t}(TraceBase);\n\t\n\t// Exports\n\t\n\t\n\texports.Arc = Arc;\n\texports.CubicBezier = CubicBezier;\n\texports.QuadricBezier = QuadricBezier;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;// rev 482\n\t/********************************************************************************\n\t *                                                                              *\n\t * Author    :  Angus Johnson                                                   *\n\t * Version   :  6.2.1                                                          *\n\t * Date      :  31 October 2014                                                 *\n\t * Website   :  http://www.angusj.com                                           *\n\t * Copyright :  Angus Johnson 2010-2014                                         *\n\t *                                                                              *\n\t * License:                                                                     *\n\t * Use, modification & distribution is subject to Boost Software License Ver 1. *\n\t * http://www.boost.org/LICENSE_1_0.txt                                         *\n\t *                                                                              *\n\t * Attributions:                                                                *\n\t * The code in this library is an extension of Bala Vatti's clipping algorithm: *\n\t * \"A generic solution to polygon clipping\"                                     *\n\t * Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *\n\t * http://portal.acm.org/citation.cfm?id=129906                                 *\n\t *                                                                              *\n\t * Computer graphics and geometric modeling: implementation and algorithms      *\n\t * By Max K. Agoston                                                            *\n\t * Springer; 1 edition (January 4, 2005)                                        *\n\t * http://books.google.com/books?q=vatti+clipping+agoston                       *\n\t *                                                                              *\n\t * See also:                                                                    *\n\t * \"Polygon Offsetting by Computing Winding Numbers\"                            *\n\t * Paper no. DETC2005-85513 pp. 565-575                                         *\n\t * ASME 2005 International Design Engineering Technical Conferences             *\n\t * and Computers and Information in Engineering Conference (IDETC/CIE2005)      *\n\t * September 24-28, 2005 , Long Beach, California, USA                          *\n\t * http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *\n\t *                                                                              *\n\t *******************************************************************************/\n\t/*******************************************************************************\n\t *                                                                              *\n\t * Author    :  Timo                                                            *\n\t * Version   :  6.2.1.0                                                         *\n\t * Date      :  17 June 2016                                                 *\n\t *                                                                              *\n\t * This is a translation of the C# Clipper library to Javascript.               *\n\t * Int128 struct of C# is implemented using JSBN of Tom Wu.                     *\n\t * Because Javascript lacks support for 64-bit integers, the space              *\n\t * is a little more restricted than in C# version.                              *\n\t *                                                                              *\n\t * C# version has support for coordinate space:                                 *\n\t * +-4611686018427387903 ( sqrt(2^127 -1)/2 )                                   *\n\t * while Javascript version has support for space:                              *\n\t * +-4503599627370495 ( sqrt(2^106 -1)/2 )                                      *\n\t *                                                                              *\n\t * Tom Wu's JSBN proved to be the fastest big integer library:                  *\n\t * http://jsperf.com/big-integer-library-test                                   *\n\t *                                                                              *\n\t * This class can be made simpler when (if ever) 64-bit integer support comes.  *\n\t *                                                                              *\n\t *******************************************************************************/\n\t/*******************************************************************************\n\t *                                                                              *\n\t * Basic JavaScript BN library - subset useful for RSA encryption.              *\n\t * http://www-cs-students.stanford.edu/~tjw/jsbn/                               *\n\t * Copyright (c) 2005  Tom Wu                                                   *\n\t * All Rights Reserved.                                                         *\n\t * See \"LICENSE\" for details:                                                   *\n\t * http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE                        *\n\t *                                                                              *\n\t *******************************************************************************/\n\t(function ()\n\t{\n\t  \"use strict\";\n\t  //use_int32: When enabled 32bit ints are used instead of 64bit ints. This\n\t  //improve performance but coordinate values are limited to the range +/- 46340\n\t  var use_int32 = false;\n\t  //use_xyz: adds a Z member to IntPoint. Adds a minor cost to performance.\n\t  var use_xyz = false;\n\t  //UseLines: Enables open path clipping. Adds a very minor cost to performance.\n\t  var use_lines = true;\n\t\n\t  var ClipperLib = {};\n\t  var isNode = false;\n\t  if (typeof module !== 'undefined' && module.exports)\n\t  {\n\t    module.exports = ClipperLib;\n\t    isNode = true;\n\t  }\n\t  else\n\t  {\n\t    if (true) {\n\t      !(__WEBPACK_AMD_DEFINE_FACTORY__ = (ClipperLib), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t    if (typeof (document) !== \"undefined\") window.ClipperLib = ClipperLib;\n\t    else self['ClipperLib'] = ClipperLib;\n\t  }\n\t  var navigator_appName;\n\t  if (!isNode)\n\t  {\n\t    var nav = navigator.userAgent.toString().toLowerCase();\n\t    navigator_appName = navigator.appName;\n\t  }\n\t  else\n\t  {\n\t    var nav = \"chrome\"; // Node.js uses Chrome's V8 engine\n\t    navigator_appName = \"Netscape\"; // Firefox, Chrome and Safari returns \"Netscape\", so Node.js should also\n\t  }\n\t  // Browser test to speedup performance critical functions\n\t  var browser = {};\n\t  if (nav.indexOf(\"chrome\") != -1 && nav.indexOf(\"chromium\") == -1) browser.chrome = 1;\n\t  else browser.chrome = 0;\n\t  if (nav.indexOf(\"chromium\") != -1) browser.chromium = 1;\n\t  else browser.chromium = 0;\n\t  if (nav.indexOf(\"safari\") != -1 && nav.indexOf(\"chrome\") == -1 && nav.indexOf(\"chromium\") == -1) browser.safari = 1;\n\t  else browser.safari = 0;\n\t  if (nav.indexOf(\"firefox\") != -1) browser.firefox = 1;\n\t  else browser.firefox = 0;\n\t  if (nav.indexOf(\"firefox/17\") != -1) browser.firefox17 = 1;\n\t  else browser.firefox17 = 0;\n\t  if (nav.indexOf(\"firefox/15\") != -1) browser.firefox15 = 1;\n\t  else browser.firefox15 = 0;\n\t  if (nav.indexOf(\"firefox/3\") != -1) browser.firefox3 = 1;\n\t  else browser.firefox3 = 0;\n\t  if (nav.indexOf(\"opera\") != -1) browser.opera = 1;\n\t  else browser.opera = 0;\n\t  if (nav.indexOf(\"msie 10\") != -1) browser.msie10 = 1;\n\t  else browser.msie10 = 0;\n\t  if (nav.indexOf(\"msie 9\") != -1) browser.msie9 = 1;\n\t  else browser.msie9 = 0;\n\t  if (nav.indexOf(\"msie 8\") != -1) browser.msie8 = 1;\n\t  else browser.msie8 = 0;\n\t  if (nav.indexOf(\"msie 7\") != -1) browser.msie7 = 1;\n\t  else browser.msie7 = 0;\n\t  if (nav.indexOf(\"msie \") != -1) browser.msie = 1;\n\t  else browser.msie = 0;\n\t  ClipperLib.biginteger_used = null;\n\t\n\t  // Copyright (c) 2005  Tom Wu\n\t  // All Rights Reserved.\n\t  // See \"LICENSE\" for details.\n\t  // Basic JavaScript BN library - subset useful for RSA encryption.\n\t  // Bits per digit\n\t  var dbits;\n\t  // JavaScript engine analysis\n\t  var canary = 0xdeadbeefcafe;\n\t  var j_lm = ((canary & 0xffffff) == 0xefcafe);\n\t  // (public) Constructor\n\t  function BigInteger(a, b, c)\n\t  {\n\t    // This test variable can be removed,\n\t    // but at least for performance tests it is useful piece of knowledge\n\t    // This is the only ClipperLib related variable in BigInteger library\n\t    ClipperLib.biginteger_used = 1;\n\t    if (a != null)\n\t      if (\"number\" == typeof a && \"undefined\" == typeof (b)) this.fromInt(a); // faster conversion\n\t      else if (\"number\" == typeof a) this.fromNumber(a, b, c);\n\t    else if (b == null && \"string\" != typeof a) this.fromString(a, 256);\n\t    else this.fromString(a, b);\n\t  }\n\t  // return new, unset BigInteger\n\t  function nbi()\n\t  {\n\t    return new BigInteger(null,undefined,undefined);\n\t  }\n\t  // am: Compute w_j += (x*this_i), propagate carries,\n\t  // c is initial carry, returns final carry.\n\t  // c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n\t  // We need to select the fastest one that works in this environment.\n\t  // am1: use a single mult and divide to get the high bits,\n\t  // max digit bits should be 26 because\n\t  // max internal value = 2*dvalue^2-2*dvalue (< 2^53)\n\t  function am1(i, x, w, j, c, n)\n\t  {\n\t    while (--n >= 0)\n\t    {\n\t      var v = x * this[i++] + w[j] + c;\n\t      c = Math.floor(v / 0x4000000);\n\t      w[j++] = v & 0x3ffffff;\n\t    }\n\t    return c;\n\t  }\n\t  // am2 avoids a big mult-and-extract completely.\n\t  // Max digit bits should be <= 30 because we do bitwise ops\n\t  // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\n\t  function am2(i, x, w, j, c, n)\n\t  {\n\t    var xl = x & 0x7fff,\n\t      xh = x >> 15;\n\t    while (--n >= 0)\n\t    {\n\t      var l = this[i] & 0x7fff;\n\t      var h = this[i++] >> 15;\n\t      var m = xh * l + h * xl;\n\t      l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);\n\t      c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);\n\t      w[j++] = l & 0x3fffffff;\n\t    }\n\t    return c;\n\t  }\n\t  // Alternately, set max digit bits to 28 since some\n\t  // browsers slow down when dealing with 32-bit numbers.\n\t  function am3(i, x, w, j, c, n)\n\t  {\n\t    var xl = x & 0x3fff,\n\t      xh = x >> 14;\n\t    while (--n >= 0)\n\t    {\n\t      var l = this[i] & 0x3fff;\n\t      var h = this[i++] >> 14;\n\t      var m = xh * l + h * xl;\n\t      l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;\n\t      c = (l >> 28) + (m >> 14) + xh * h;\n\t      w[j++] = l & 0xfffffff;\n\t    }\n\t    return c;\n\t  }\n\t  if (j_lm && (navigator_appName == \"Microsoft Internet Explorer\"))\n\t  {\n\t    BigInteger.prototype.am = am2;\n\t    dbits = 30;\n\t  }\n\t  else if (j_lm && (navigator_appName != \"Netscape\"))\n\t  {\n\t    BigInteger.prototype.am = am1;\n\t    dbits = 26;\n\t  }\n\t  else\n\t  { // Mozilla/Netscape seems to prefer am3\n\t    BigInteger.prototype.am = am3;\n\t    dbits = 28;\n\t  }\n\t  BigInteger.prototype.DB = dbits;\n\t  BigInteger.prototype.DM = ((1 << dbits) - 1);\n\t  BigInteger.prototype.DV = (1 << dbits);\n\t  var BI_FP = 52;\n\t  BigInteger.prototype.FV = Math.pow(2, BI_FP);\n\t  BigInteger.prototype.F1 = BI_FP - dbits;\n\t  BigInteger.prototype.F2 = 2 * dbits - BI_FP;\n\t  // Digit conversions\n\t  var BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\t  var BI_RC = new Array();\n\t  var rr, vv;\n\t  rr = \"0\".charCodeAt(0);\n\t  for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\n\t  rr = \"a\".charCodeAt(0);\n\t  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\t  rr = \"A\".charCodeAt(0);\n\t  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\t\n\t  function int2char(n)\n\t  {\n\t    return BI_RM.charAt(n);\n\t  }\n\t\n\t  function intAt(s, i)\n\t  {\n\t    var c = BI_RC[s.charCodeAt(i)];\n\t    return (c == null) ? -1 : c;\n\t  }\n\t  // (protected) copy this to r\n\t  function bnpCopyTo(r)\n\t  {\n\t    for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];\n\t    r.t = this.t;\n\t    r.s = this.s;\n\t  }\n\t  // (protected) set from integer value x, -DV <= x < DV\n\t  function bnpFromInt(x)\n\t  {\n\t    this.t = 1;\n\t    this.s = (x < 0) ? -1 : 0;\n\t    if (x > 0) this[0] = x;\n\t    else if (x < -1) this[0] = x + this.DV;\n\t    else this.t = 0;\n\t  }\n\t  // return bigint initialized to value\n\t  function nbv(i)\n\t  {\n\t    var r = nbi();\n\t    r.fromInt(i);\n\t    return r;\n\t  }\n\t  // (protected) set from string and radix\n\t  function bnpFromString(s, b)\n\t  {\n\t    var k;\n\t    if (b == 16) k = 4;\n\t    else if (b == 8) k = 3;\n\t    else if (b == 256) k = 8; // byte array\n\t    else if (b == 2) k = 1;\n\t    else if (b == 32) k = 5;\n\t    else if (b == 4) k = 2;\n\t    else\n\t    {\n\t      this.fromRadix(s, b);\n\t      return;\n\t    }\n\t    this.t = 0;\n\t    this.s = 0;\n\t    var i = s.length,\n\t      mi = false,\n\t      sh = 0;\n\t    while (--i >= 0)\n\t    {\n\t      var x = (k == 8) ? s[i] & 0xff : intAt(s, i);\n\t      if (x < 0)\n\t      {\n\t        if (s.charAt(i) == \"-\") mi = true;\n\t        continue;\n\t      }\n\t      mi = false;\n\t      if (sh == 0)\n\t        this[this.t++] = x;\n\t      else if (sh + k > this.DB)\n\t      {\n\t        this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;\n\t        this[this.t++] = (x >> (this.DB - sh));\n\t      }\n\t      else\n\t        this[this.t - 1] |= x << sh;\n\t      sh += k;\n\t      if (sh >= this.DB) sh -= this.DB;\n\t    }\n\t    if (k == 8 && (s[0] & 0x80) != 0)\n\t    {\n\t      this.s = -1;\n\t      if (sh > 0) this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;\n\t    }\n\t    this.clamp();\n\t    if (mi) BigInteger.ZERO.subTo(this, this);\n\t  }\n\t  // (protected) clamp off excess high words\n\t  function bnpClamp()\n\t  {\n\t    var c = this.s & this.DM;\n\t    while (this.t > 0 && this[this.t - 1] == c)--this.t;\n\t  }\n\t  // (public) return string representation in given radix\n\t  function bnToString(b)\n\t  {\n\t    if (this.s < 0) return \"-\" + this.negate().toString(b);\n\t    var k;\n\t    if (b == 16) k = 4;\n\t    else if (b == 8) k = 3;\n\t    else if (b == 2) k = 1;\n\t    else if (b == 32) k = 5;\n\t    else if (b == 4) k = 2;\n\t    else return this.toRadix(b);\n\t    var km = (1 << k) - 1,\n\t      d, m = false,\n\t      r = \"\",\n\t      i = this.t;\n\t    var p = this.DB - (i * this.DB) % k;\n\t    if (i-- > 0)\n\t    {\n\t      if (p < this.DB && (d = this[i] >> p) > 0)\n\t      {\n\t        m = true;\n\t        r = int2char(d);\n\t      }\n\t      while (i >= 0)\n\t      {\n\t        if (p < k)\n\t        {\n\t          d = (this[i] & ((1 << p) - 1)) << (k - p);\n\t          d |= this[--i] >> (p += this.DB - k);\n\t        }\n\t        else\n\t        {\n\t          d = (this[i] >> (p -= k)) & km;\n\t          if (p <= 0)\n\t          {\n\t            p += this.DB;\n\t            --i;\n\t          }\n\t        }\n\t        if (d > 0) m = true;\n\t        if (m) r += int2char(d);\n\t      }\n\t    }\n\t    return m ? r : \"0\";\n\t  }\n\t  // (public) -this\n\t  function bnNegate()\n\t  {\n\t    var r = nbi();\n\t    BigInteger.ZERO.subTo(this, r);\n\t    return r;\n\t  }\n\t  // (public) |this|\n\t  function bnAbs()\n\t  {\n\t    return (this.s < 0) ? this.negate() : this;\n\t  }\n\t  // (public) return + if this > a, - if this < a, 0 if equal\n\t  function bnCompareTo(a)\n\t  {\n\t    var r = this.s - a.s;\n\t    if (r != 0) return r;\n\t    var i = this.t;\n\t    r = i - a.t;\n\t    if (r != 0) return (this.s < 0) ? -r : r;\n\t    while (--i >= 0)\n\t      if ((r = this[i] - a[i]) != 0) return r;\n\t    return 0;\n\t  }\n\t  // returns bit length of the integer x\n\t  function nbits(x)\n\t  {\n\t    var r = 1,\n\t      t;\n\t    if ((t = x >>> 16) != 0)\n\t    {\n\t      x = t;\n\t      r += 16;\n\t    }\n\t    if ((t = x >> 8) != 0)\n\t    {\n\t      x = t;\n\t      r += 8;\n\t    }\n\t    if ((t = x >> 4) != 0)\n\t    {\n\t      x = t;\n\t      r += 4;\n\t    }\n\t    if ((t = x >> 2) != 0)\n\t    {\n\t      x = t;\n\t      r += 2;\n\t    }\n\t    if ((t = x >> 1) != 0)\n\t    {\n\t      x = t;\n\t      r += 1;\n\t    }\n\t    return r;\n\t  }\n\t  // (public) return the number of bits in \"this\"\n\t  function bnBitLength()\n\t  {\n\t    if (this.t <= 0) return 0;\n\t    return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));\n\t  }\n\t  // (protected) r = this << n*DB\n\t  function bnpDLShiftTo(n, r)\n\t  {\n\t    var i;\n\t    for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];\n\t    for (i = n - 1; i >= 0; --i) r[i] = 0;\n\t    r.t = this.t + n;\n\t    r.s = this.s;\n\t  }\n\t  // (protected) r = this >> n*DB\n\t  function bnpDRShiftTo(n, r)\n\t  {\n\t    for (var i = n; i < this.t; ++i) r[i - n] = this[i];\n\t    r.t = Math.max(this.t - n, 0);\n\t    r.s = this.s;\n\t  }\n\t  // (protected) r = this << n\n\t  function bnpLShiftTo(n, r)\n\t  {\n\t    var bs = n % this.DB;\n\t    var cbs = this.DB - bs;\n\t    var bm = (1 << cbs) - 1;\n\t    var ds = Math.floor(n / this.DB),\n\t      c = (this.s << bs) & this.DM,\n\t      i;\n\t    for (i = this.t - 1; i >= 0; --i)\n\t    {\n\t      r[i + ds + 1] = (this[i] >> cbs) | c;\n\t      c = (this[i] & bm) << bs;\n\t    }\n\t    for (i = ds - 1; i >= 0; --i) r[i] = 0;\n\t    r[ds] = c;\n\t    r.t = this.t + ds + 1;\n\t    r.s = this.s;\n\t    r.clamp();\n\t  }\n\t  // (protected) r = this >> n\n\t  function bnpRShiftTo(n, r)\n\t  {\n\t    r.s = this.s;\n\t    var ds = Math.floor(n / this.DB);\n\t    if (ds >= this.t)\n\t    {\n\t      r.t = 0;\n\t      return;\n\t    }\n\t    var bs = n % this.DB;\n\t    var cbs = this.DB - bs;\n\t    var bm = (1 << bs) - 1;\n\t    r[0] = this[ds] >> bs;\n\t    for (var i = ds + 1; i < this.t; ++i)\n\t    {\n\t      r[i - ds - 1] |= (this[i] & bm) << cbs;\n\t      r[i - ds] = this[i] >> bs;\n\t    }\n\t    if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;\n\t    r.t = this.t - ds;\n\t    r.clamp();\n\t  }\n\t  // (protected) r = this - a\n\t  function bnpSubTo(a, r)\n\t  {\n\t    var i = 0,\n\t      c = 0,\n\t      m = Math.min(a.t, this.t);\n\t    while (i < m)\n\t    {\n\t      c += this[i] - a[i];\n\t      r[i++] = c & this.DM;\n\t      c >>= this.DB;\n\t    }\n\t    if (a.t < this.t)\n\t    {\n\t      c -= a.s;\n\t      while (i < this.t)\n\t      {\n\t        c += this[i];\n\t        r[i++] = c & this.DM;\n\t        c >>= this.DB;\n\t      }\n\t      c += this.s;\n\t    }\n\t    else\n\t    {\n\t      c += this.s;\n\t      while (i < a.t)\n\t      {\n\t        c -= a[i];\n\t        r[i++] = c & this.DM;\n\t        c >>= this.DB;\n\t      }\n\t      c -= a.s;\n\t    }\n\t    r.s = (c < 0) ? -1 : 0;\n\t    if (c < -1) r[i++] = this.DV + c;\n\t    else if (c > 0) r[i++] = c;\n\t    r.t = i;\n\t    r.clamp();\n\t  }\n\t  // (protected) r = this * a, r != this,a (HAC 14.12)\n\t  // \"this\" should be the larger one if appropriate.\n\t  function bnpMultiplyTo(a, r)\n\t  {\n\t    var x = this.abs(),\n\t      y = a.abs();\n\t    var i = x.t;\n\t    r.t = i + y.t;\n\t    while (--i >= 0) r[i] = 0;\n\t    for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);\n\t    r.s = 0;\n\t    r.clamp();\n\t    if (this.s != a.s) BigInteger.ZERO.subTo(r, r);\n\t  }\n\t  // (protected) r = this^2, r != this (HAC 14.16)\n\t  function bnpSquareTo(r)\n\t  {\n\t    var x = this.abs();\n\t    var i = r.t = 2 * x.t;\n\t    while (--i >= 0) r[i] = 0;\n\t    for (i = 0; i < x.t - 1; ++i)\n\t    {\n\t      var c = x.am(i, x[i], r, 2 * i, 0, 1);\n\t      if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV)\n\t      {\n\t        r[i + x.t] -= x.DV;\n\t        r[i + x.t + 1] = 1;\n\t      }\n\t    }\n\t    if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);\n\t    r.s = 0;\n\t    r.clamp();\n\t  }\n\t  // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n\t  // r != q, this != m.  q or r may be null.\n\t  function bnpDivRemTo(m, q, r)\n\t  {\n\t    var pm = m.abs();\n\t    if (pm.t <= 0) return;\n\t    var pt = this.abs();\n\t    if (pt.t < pm.t)\n\t    {\n\t      if (q != null) q.fromInt(0);\n\t      if (r != null) this.copyTo(r);\n\t      return;\n\t    }\n\t    if (r == null) r = nbi();\n\t    var y = nbi(),\n\t      ts = this.s,\n\t      ms = m.s;\n\t    var nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus\n\t    if (nsh > 0)\n\t    {\n\t      pm.lShiftTo(nsh, y);\n\t      pt.lShiftTo(nsh, r);\n\t    }\n\t    else\n\t    {\n\t      pm.copyTo(y);\n\t      pt.copyTo(r);\n\t    }\n\t    var ys = y.t;\n\t    var y0 = y[ys - 1];\n\t    if (y0 == 0) return;\n\t    var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);\n\t    var d1 = this.FV / yt,\n\t      d2 = (1 << this.F1) / yt,\n\t      e = 1 << this.F2;\n\t    var i = r.t,\n\t      j = i - ys,\n\t      t = (q == null) ? nbi() : q;\n\t    y.dlShiftTo(j, t);\n\t    if (r.compareTo(t) >= 0)\n\t    {\n\t      r[r.t++] = 1;\n\t      r.subTo(t, r);\n\t    }\n\t    BigInteger.ONE.dlShiftTo(ys, t);\n\t    t.subTo(y, y); // \"negative\" y so we can replace sub with am later\n\t    while (y.t < ys) y[y.t++] = 0;\n\t    while (--j >= 0)\n\t    {\n\t      // Estimate quotient digit\n\t      var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);\n\t      if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd)\n\t      { // Try it out\n\t        y.dlShiftTo(j, t);\n\t        r.subTo(t, r);\n\t        while (r[i] < --qd) r.subTo(t, r);\n\t      }\n\t    }\n\t    if (q != null)\n\t    {\n\t      r.drShiftTo(ys, q);\n\t      if (ts != ms) BigInteger.ZERO.subTo(q, q);\n\t    }\n\t    r.t = ys;\n\t    r.clamp();\n\t    if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder\n\t    if (ts < 0) BigInteger.ZERO.subTo(r, r);\n\t  }\n\t  // (public) this mod a\n\t  function bnMod(a)\n\t  {\n\t    var r = nbi();\n\t    this.abs().divRemTo(a, null, r);\n\t    if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);\n\t    return r;\n\t  }\n\t  // Modular reduction using \"classic\" algorithm\n\t  function Classic(m)\n\t  {\n\t    this.m = m;\n\t  }\n\t\n\t  function cConvert(x)\n\t  {\n\t    if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n\t    else return x;\n\t  }\n\t\n\t  function cRevert(x)\n\t  {\n\t    return x;\n\t  }\n\t\n\t  function cReduce(x)\n\t  {\n\t    x.divRemTo(this.m, null, x);\n\t  }\n\t\n\t  function cMulTo(x, y, r)\n\t  {\n\t    x.multiplyTo(y, r);\n\t    this.reduce(r);\n\t  }\n\t\n\t  function cSqrTo(x, r)\n\t  {\n\t    x.squareTo(r);\n\t    this.reduce(r);\n\t  }\n\t  Classic.prototype.convert = cConvert;\n\t  Classic.prototype.revert = cRevert;\n\t  Classic.prototype.reduce = cReduce;\n\t  Classic.prototype.mulTo = cMulTo;\n\t  Classic.prototype.sqrTo = cSqrTo;\n\t  // (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n\t  // justification:\n\t  //         xy == 1 (mod m)\n\t  //         xy =  1+km\n\t  //   xy(2-xy) = (1+km)(1-km)\n\t  // x[y(2-xy)] = 1-k^2m^2\n\t  // x[y(2-xy)] == 1 (mod m^2)\n\t  // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n\t  // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n\t  // JS multiply \"overflows\" differently from C/C++, so care is needed here.\n\t  function bnpInvDigit()\n\t  {\n\t    if (this.t < 1) return 0;\n\t    var x = this[0];\n\t    if ((x & 1) == 0) return 0;\n\t    var y = x & 3; // y == 1/x mod 2^2\n\t    y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4\n\t    y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8\n\t    y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16\n\t    // last step - calculate inverse mod DV directly;\n\t    // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n\t    y = (y * (2 - x * y % this.DV)) % this.DV; // y == 1/x mod 2^dbits\n\t    // we really want the negative inverse, and -DV < y < DV\n\t    return (y > 0) ? this.DV - y : -y;\n\t  }\n\t  // Montgomery reduction\n\t  function Montgomery(m)\n\t  {\n\t    this.m = m;\n\t    this.mp = m.invDigit();\n\t    this.mpl = this.mp & 0x7fff;\n\t    this.mph = this.mp >> 15;\n\t    this.um = (1 << (m.DB - 15)) - 1;\n\t    this.mt2 = 2 * m.t;\n\t  }\n\t  // xR mod m\n\t  function montConvert(x)\n\t  {\n\t    var r = nbi();\n\t    x.abs().dlShiftTo(this.m.t, r);\n\t    r.divRemTo(this.m, null, r);\n\t    if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);\n\t    return r;\n\t  }\n\t  // x/R mod m\n\t  function montRevert(x)\n\t  {\n\t    var r = nbi();\n\t    x.copyTo(r);\n\t    this.reduce(r);\n\t    return r;\n\t  }\n\t  // x = x/R mod m (HAC 14.32)\n\t  function montReduce(x)\n\t  {\n\t    while (x.t <= this.mt2) // pad x so am has enough room later\n\t      x[x.t++] = 0;\n\t    for (var i = 0; i < this.m.t; ++i)\n\t    {\n\t      // faster way of calculating u0 = x[i]*mp mod DV\n\t      var j = x[i] & 0x7fff;\n\t      var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;\n\t      // use am to combine the multiply-shift-add into one call\n\t      j = i + this.m.t;\n\t      x[j] += this.m.am(0, u0, x, i, 0, this.m.t);\n\t      // propagate carry\n\t      while (x[j] >= x.DV)\n\t      {\n\t        x[j] -= x.DV;\n\t        x[++j]++;\n\t      }\n\t    }\n\t    x.clamp();\n\t    x.drShiftTo(this.m.t, x);\n\t    if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n\t  }\n\t  // r = \"x^2/R mod m\"; x != r\n\t  function montSqrTo(x, r)\n\t  {\n\t    x.squareTo(r);\n\t    this.reduce(r);\n\t  }\n\t  // r = \"xy/R mod m\"; x,y != r\n\t  function montMulTo(x, y, r)\n\t  {\n\t    x.multiplyTo(y, r);\n\t    this.reduce(r);\n\t  }\n\t  Montgomery.prototype.convert = montConvert;\n\t  Montgomery.prototype.revert = montRevert;\n\t  Montgomery.prototype.reduce = montReduce;\n\t  Montgomery.prototype.mulTo = montMulTo;\n\t  Montgomery.prototype.sqrTo = montSqrTo;\n\t  // (protected) true iff this is even\n\t  function bnpIsEven()\n\t  {\n\t    return ((this.t > 0) ? (this[0] & 1) : this.s) == 0;\n\t  }\n\t  // (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\n\t  function bnpExp(e, z)\n\t  {\n\t    if (e > 0xffffffff || e < 1) return BigInteger.ONE;\n\t    var r = nbi(),\n\t      r2 = nbi(),\n\t      g = z.convert(this),\n\t      i = nbits(e) - 1;\n\t    g.copyTo(r);\n\t    while (--i >= 0)\n\t    {\n\t      z.sqrTo(r, r2);\n\t      if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);\n\t      else\n\t      {\n\t        var t = r;\n\t        r = r2;\n\t        r2 = t;\n\t      }\n\t    }\n\t    return z.revert(r);\n\t  }\n\t  // (public) this^e % m, 0 <= e < 2^32\n\t  function bnModPowInt(e, m)\n\t  {\n\t    var z;\n\t    if (e < 256 || m.isEven()) z = new Classic(m);\n\t    else z = new Montgomery(m);\n\t    return this.exp(e, z);\n\t  }\n\t  // protected\n\t  BigInteger.prototype.copyTo = bnpCopyTo;\n\t  BigInteger.prototype.fromInt = bnpFromInt;\n\t  BigInteger.prototype.fromString = bnpFromString;\n\t  BigInteger.prototype.clamp = bnpClamp;\n\t  BigInteger.prototype.dlShiftTo = bnpDLShiftTo;\n\t  BigInteger.prototype.drShiftTo = bnpDRShiftTo;\n\t  BigInteger.prototype.lShiftTo = bnpLShiftTo;\n\t  BigInteger.prototype.rShiftTo = bnpRShiftTo;\n\t  BigInteger.prototype.subTo = bnpSubTo;\n\t  BigInteger.prototype.multiplyTo = bnpMultiplyTo;\n\t  BigInteger.prototype.squareTo = bnpSquareTo;\n\t  BigInteger.prototype.divRemTo = bnpDivRemTo;\n\t  BigInteger.prototype.invDigit = bnpInvDigit;\n\t  BigInteger.prototype.isEven = bnpIsEven;\n\t  BigInteger.prototype.exp = bnpExp;\n\t  // public\n\t  BigInteger.prototype.toString = bnToString;\n\t  BigInteger.prototype.negate = bnNegate;\n\t  BigInteger.prototype.abs = bnAbs;\n\t  BigInteger.prototype.compareTo = bnCompareTo;\n\t  BigInteger.prototype.bitLength = bnBitLength;\n\t  BigInteger.prototype.mod = bnMod;\n\t  BigInteger.prototype.modPowInt = bnModPowInt;\n\t  // \"constants\"\n\t  BigInteger.ZERO = nbv(0);\n\t  BigInteger.ONE = nbv(1);\n\t  // Copyright (c) 2005-2009  Tom Wu\n\t  // All Rights Reserved.\n\t  // See \"LICENSE\" for details.\n\t  // Extended JavaScript BN functions, required for RSA private ops.\n\t  // Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\n\t  // Version 1.2: square() API, isProbablePrime fix\n\t  // (public)\n\t  function bnClone()\n\t  {\n\t    var r = nbi();\n\t    this.copyTo(r);\n\t    return r;\n\t  }\n\t  // (public) return value as integer\n\t  function bnIntValue()\n\t  {\n\t    if (this.s < 0)\n\t    {\n\t      if (this.t == 1) return this[0] - this.DV;\n\t      else if (this.t == 0) return -1;\n\t    }\n\t    else if (this.t == 1) return this[0];\n\t    else if (this.t == 0) return 0;\n\t    // assumes 16 < DB < 32\n\t    return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];\n\t  }\n\t  // (public) return value as byte\n\t  function bnByteValue()\n\t  {\n\t    return (this.t == 0) ? this.s : (this[0] << 24) >> 24;\n\t  }\n\t  // (public) return value as short (assumes DB>=16)\n\t  function bnShortValue()\n\t  {\n\t    return (this.t == 0) ? this.s : (this[0] << 16) >> 16;\n\t  }\n\t  // (protected) return x s.t. r^x < DV\n\t  function bnpChunkSize(r)\n\t  {\n\t    return Math.floor(Math.LN2 * this.DB / Math.log(r));\n\t  }\n\t  // (public) 0 if this == 0, 1 if this > 0\n\t  function bnSigNum()\n\t  {\n\t    if (this.s < 0) return -1;\n\t    else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n\t    else return 1;\n\t  }\n\t  // (protected) convert to radix string\n\t  function bnpToRadix(b)\n\t  {\n\t    if (b == null) b = 10;\n\t    if (this.signum() == 0 || b < 2 || b > 36) return \"0\";\n\t    var cs = this.chunkSize(b);\n\t    var a = Math.pow(b, cs);\n\t    var d = nbv(a),\n\t      y = nbi(),\n\t      z = nbi(),\n\t      r = \"\";\n\t    this.divRemTo(d, y, z);\n\t    while (y.signum() > 0)\n\t    {\n\t      r = (a + z.intValue()).toString(b).substr(1) + r;\n\t      y.divRemTo(d, y, z);\n\t    }\n\t    return z.intValue().toString(b) + r;\n\t  }\n\t  // (protected) convert from radix string\n\t  function bnpFromRadix(s, b)\n\t  {\n\t    this.fromInt(0);\n\t    if (b == null) b = 10;\n\t    var cs = this.chunkSize(b);\n\t    var d = Math.pow(b, cs),\n\t      mi = false,\n\t      j = 0,\n\t      w = 0;\n\t    for (var i = 0; i < s.length; ++i)\n\t    {\n\t      var x = intAt(s, i);\n\t      if (x < 0)\n\t      {\n\t        if (s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\n\t        continue;\n\t      }\n\t      w = b * w + x;\n\t      if (++j >= cs)\n\t      {\n\t        this.dMultiply(d);\n\t        this.dAddOffset(w, 0);\n\t        j = 0;\n\t        w = 0;\n\t      }\n\t    }\n\t    if (j > 0)\n\t    {\n\t      this.dMultiply(Math.pow(b, j));\n\t      this.dAddOffset(w, 0);\n\t    }\n\t    if (mi) BigInteger.ZERO.subTo(this, this);\n\t  }\n\t  // (protected) alternate constructor\n\t  function bnpFromNumber(a, b, c)\n\t  {\n\t    if (\"number\" == typeof b)\n\t    {\n\t      // new BigInteger(int,int,RNG)\n\t      if (a < 2) this.fromInt(1);\n\t      else\n\t      {\n\t        this.fromNumber(a, c);\n\t        if (!this.testBit(a - 1)) // force MSB set\n\t          this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);\n\t        if (this.isEven()) this.dAddOffset(1, 0); // force odd\n\t        while (!this.isProbablePrime(b))\n\t        {\n\t          this.dAddOffset(2, 0);\n\t          if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);\n\t        }\n\t      }\n\t    }\n\t    else\n\t    {\n\t      // new BigInteger(int,RNG)\n\t      var x = new Array(),\n\t        t = a & 7;\n\t      x.length = (a >> 3) + 1;\n\t      b.nextBytes(x);\n\t      if (t > 0) x[0] &= ((1 << t) - 1);\n\t      else x[0] = 0;\n\t      this.fromString(x, 256);\n\t    }\n\t  }\n\t  // (public) convert to bigendian byte array\n\t  function bnToByteArray()\n\t  {\n\t    var i = this.t,\n\t      r = new Array();\n\t    r[0] = this.s;\n\t    var p = this.DB - (i * this.DB) % 8,\n\t      d, k = 0;\n\t    if (i-- > 0)\n\t    {\n\t      if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)\n\t        r[k++] = d | (this.s << (this.DB - p));\n\t      while (i >= 0)\n\t      {\n\t        if (p < 8)\n\t        {\n\t          d = (this[i] & ((1 << p) - 1)) << (8 - p);\n\t          d |= this[--i] >> (p += this.DB - 8);\n\t        }\n\t        else\n\t        {\n\t          d = (this[i] >> (p -= 8)) & 0xff;\n\t          if (p <= 0)\n\t          {\n\t            p += this.DB;\n\t            --i;\n\t          }\n\t        }\n\t        if ((d & 0x80) != 0) d |= -256;\n\t        if (k == 0 && (this.s & 0x80) != (d & 0x80))++k;\n\t        if (k > 0 || d != this.s) r[k++] = d;\n\t      }\n\t    }\n\t    return r;\n\t  }\n\t\n\t  function bnEquals(a)\n\t  {\n\t    return (this.compareTo(a) == 0);\n\t  }\n\t\n\t  function bnMin(a)\n\t  {\n\t    return (this.compareTo(a) < 0) ? this : a;\n\t  }\n\t\n\t  function bnMax(a)\n\t  {\n\t    return (this.compareTo(a) > 0) ? this : a;\n\t  }\n\t  // (protected) r = this op a (bitwise)\n\t  function bnpBitwiseTo(a, op, r)\n\t  {\n\t    var i, f, m = Math.min(a.t, this.t);\n\t    for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);\n\t    if (a.t < this.t)\n\t    {\n\t      f = a.s & this.DM;\n\t      for (i = m; i < this.t; ++i) r[i] = op(this[i], f);\n\t      r.t = this.t;\n\t    }\n\t    else\n\t    {\n\t      f = this.s & this.DM;\n\t      for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);\n\t      r.t = a.t;\n\t    }\n\t    r.s = op(this.s, a.s);\n\t    r.clamp();\n\t  }\n\t  // (public) this & a\n\t  function op_and(x, y)\n\t  {\n\t    return x & y;\n\t  }\n\t\n\t  function bnAnd(a)\n\t  {\n\t    var r = nbi();\n\t    this.bitwiseTo(a, op_and, r);\n\t    return r;\n\t  }\n\t  // (public) this | a\n\t  function op_or(x, y)\n\t  {\n\t    return x | y;\n\t  }\n\t\n\t  function bnOr(a)\n\t  {\n\t    var r = nbi();\n\t    this.bitwiseTo(a, op_or, r);\n\t    return r;\n\t  }\n\t  // (public) this ^ a\n\t  function op_xor(x, y)\n\t  {\n\t    return x ^ y;\n\t  }\n\t\n\t  function bnXor(a)\n\t  {\n\t    var r = nbi();\n\t    this.bitwiseTo(a, op_xor, r);\n\t    return r;\n\t  }\n\t  // (public) this & ~a\n\t  function op_andnot(x, y)\n\t  {\n\t    return x & ~y;\n\t  }\n\t\n\t  function bnAndNot(a)\n\t  {\n\t    var r = nbi();\n\t    this.bitwiseTo(a, op_andnot, r);\n\t    return r;\n\t  }\n\t  // (public) ~this\n\t  function bnNot()\n\t  {\n\t    var r = nbi();\n\t    for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];\n\t    r.t = this.t;\n\t    r.s = ~this.s;\n\t    return r;\n\t  }\n\t  // (public) this << n\n\t  function bnShiftLeft(n)\n\t  {\n\t    var r = nbi();\n\t    if (n < 0) this.rShiftTo(-n, r);\n\t    else this.lShiftTo(n, r);\n\t    return r;\n\t  }\n\t  // (public) this >> n\n\t  function bnShiftRight(n)\n\t  {\n\t    var r = nbi();\n\t    if (n < 0) this.lShiftTo(-n, r);\n\t    else this.rShiftTo(n, r);\n\t    return r;\n\t  }\n\t  // return index of lowest 1-bit in x, x < 2^31\n\t  function lbit(x)\n\t  {\n\t    if (x == 0) return -1;\n\t    var r = 0;\n\t    if ((x & 0xffff) == 0)\n\t    {\n\t      x >>= 16;\n\t      r += 16;\n\t    }\n\t    if ((x & 0xff) == 0)\n\t    {\n\t      x >>= 8;\n\t      r += 8;\n\t    }\n\t    if ((x & 0xf) == 0)\n\t    {\n\t      x >>= 4;\n\t      r += 4;\n\t    }\n\t    if ((x & 3) == 0)\n\t    {\n\t      x >>= 2;\n\t      r += 2;\n\t    }\n\t    if ((x & 1) == 0)++r;\n\t    return r;\n\t  }\n\t  // (public) returns index of lowest 1-bit (or -1 if none)\n\t  function bnGetLowestSetBit()\n\t  {\n\t    for (var i = 0; i < this.t; ++i)\n\t      if (this[i] != 0) return i * this.DB + lbit(this[i]);\n\t    if (this.s < 0) return this.t * this.DB;\n\t    return -1;\n\t  }\n\t  // return number of 1 bits in x\n\t  function cbit(x)\n\t  {\n\t    var r = 0;\n\t    while (x != 0)\n\t    {\n\t      x &= x - 1;\n\t      ++r;\n\t    }\n\t    return r;\n\t  }\n\t  // (public) return number of set bits\n\t  function bnBitCount()\n\t  {\n\t    var r = 0,\n\t      x = this.s & this.DM;\n\t    for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);\n\t    return r;\n\t  }\n\t  // (public) true iff nth bit is set\n\t  function bnTestBit(n)\n\t  {\n\t    var j = Math.floor(n / this.DB);\n\t    if (j >= this.t) return (this.s != 0);\n\t    return ((this[j] & (1 << (n % this.DB))) != 0);\n\t  }\n\t  // (protected) this op (1<<n)\n\t  function bnpChangeBit(n, op)\n\t  {\n\t    var r = BigInteger.ONE.shiftLeft(n);\n\t    this.bitwiseTo(r, op, r);\n\t    return r;\n\t  }\n\t  // (public) this | (1<<n)\n\t  function bnSetBit(n)\n\t  {\n\t    return this.changeBit(n, op_or);\n\t  }\n\t  // (public) this & ~(1<<n)\n\t  function bnClearBit(n)\n\t  {\n\t    return this.changeBit(n, op_andnot);\n\t  }\n\t  // (public) this ^ (1<<n)\n\t  function bnFlipBit(n)\n\t  {\n\t    return this.changeBit(n, op_xor);\n\t  }\n\t  // (protected) r = this + a\n\t  function bnpAddTo(a, r)\n\t  {\n\t    var i = 0,\n\t      c = 0,\n\t      m = Math.min(a.t, this.t);\n\t    while (i < m)\n\t    {\n\t      c += this[i] + a[i];\n\t      r[i++] = c & this.DM;\n\t      c >>= this.DB;\n\t    }\n\t    if (a.t < this.t)\n\t    {\n\t      c += a.s;\n\t      while (i < this.t)\n\t      {\n\t        c += this[i];\n\t        r[i++] = c & this.DM;\n\t        c >>= this.DB;\n\t      }\n\t      c += this.s;\n\t    }\n\t    else\n\t    {\n\t      c += this.s;\n\t      while (i < a.t)\n\t      {\n\t        c += a[i];\n\t        r[i++] = c & this.DM;\n\t        c >>= this.DB;\n\t      }\n\t      c += a.s;\n\t    }\n\t    r.s = (c < 0) ? -1 : 0;\n\t    if (c > 0) r[i++] = c;\n\t    else if (c < -1) r[i++] = this.DV + c;\n\t    r.t = i;\n\t    r.clamp();\n\t  }\n\t  // (public) this + a\n\t  function bnAdd(a)\n\t  {\n\t    var r = nbi();\n\t    this.addTo(a, r);\n\t    return r;\n\t  }\n\t  // (public) this - a\n\t  function bnSubtract(a)\n\t  {\n\t    var r = nbi();\n\t    this.subTo(a, r);\n\t    return r;\n\t  }\n\t  // (public) this * a\n\t  function bnMultiply(a)\n\t  {\n\t    var r = nbi();\n\t    this.multiplyTo(a, r);\n\t    return r;\n\t  }\n\t  // (public) this^2\n\t  function bnSquare()\n\t  {\n\t    var r = nbi();\n\t    this.squareTo(r);\n\t    return r;\n\t  }\n\t  // (public) this / a\n\t  function bnDivide(a)\n\t  {\n\t    var r = nbi();\n\t    this.divRemTo(a, r, null);\n\t    return r;\n\t  }\n\t  // (public) this % a\n\t  function bnRemainder(a)\n\t  {\n\t    var r = nbi();\n\t    this.divRemTo(a, null, r);\n\t    return r;\n\t  }\n\t  // (public) [this/a,this%a]\n\t  function bnDivideAndRemainder(a)\n\t  {\n\t    var q = nbi(),\n\t      r = nbi();\n\t    this.divRemTo(a, q, r);\n\t    return new Array(q, r);\n\t  }\n\t  // (protected) this *= n, this >= 0, 1 < n < DV\n\t  function bnpDMultiply(n)\n\t  {\n\t    this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);\n\t    ++this.t;\n\t    this.clamp();\n\t  }\n\t  // (protected) this += n << w words, this >= 0\n\t  function bnpDAddOffset(n, w)\n\t  {\n\t    if (n == 0) return;\n\t    while (this.t <= w) this[this.t++] = 0;\n\t    this[w] += n;\n\t    while (this[w] >= this.DV)\n\t    {\n\t      this[w] -= this.DV;\n\t      if (++w >= this.t) this[this.t++] = 0;\n\t      ++this[w];\n\t    }\n\t  }\n\t  // A \"null\" reducer\n\t  function NullExp()\n\t  {}\n\t\n\t  function nNop(x)\n\t  {\n\t    return x;\n\t  }\n\t\n\t  function nMulTo(x, y, r)\n\t  {\n\t    x.multiplyTo(y, r);\n\t  }\n\t\n\t  function nSqrTo(x, r)\n\t  {\n\t    x.squareTo(r);\n\t  }\n\t  NullExp.prototype.convert = nNop;\n\t  NullExp.prototype.revert = nNop;\n\t  NullExp.prototype.mulTo = nMulTo;\n\t  NullExp.prototype.sqrTo = nSqrTo;\n\t  // (public) this^e\n\t  function bnPow(e)\n\t  {\n\t    return this.exp(e, new NullExp());\n\t  }\n\t  // (protected) r = lower n words of \"this * a\", a.t <= n\n\t  // \"this\" should be the larger one if appropriate.\n\t  function bnpMultiplyLowerTo(a, n, r)\n\t  {\n\t    var i = Math.min(this.t + a.t, n);\n\t    r.s = 0; // assumes a,this >= 0\n\t    r.t = i;\n\t    while (i > 0) r[--i] = 0;\n\t    var j;\n\t    for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);\n\t    for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);\n\t    r.clamp();\n\t  }\n\t  // (protected) r = \"this * a\" without lower n words, n > 0\n\t  // \"this\" should be the larger one if appropriate.\n\t  function bnpMultiplyUpperTo(a, n, r)\n\t  {\n\t    --n;\n\t    var i = r.t = this.t + a.t - n;\n\t    r.s = 0; // assumes a,this >= 0\n\t    while (--i >= 0) r[i] = 0;\n\t    for (i = Math.max(n - this.t, 0); i < a.t; ++i)\n\t      r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);\n\t    r.clamp();\n\t    r.drShiftTo(1, r);\n\t  }\n\t  // Barrett modular reduction\n\t  function Barrett(m)\n\t  {\n\t    // setup Barrett\n\t    this.r2 = nbi();\n\t    this.q3 = nbi();\n\t    BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);\n\t    this.mu = this.r2.divide(m);\n\t    this.m = m;\n\t  }\n\t\n\t  function barrettConvert(x)\n\t  {\n\t    if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);\n\t    else if (x.compareTo(this.m) < 0) return x;\n\t    else\n\t    {\n\t      var r = nbi();\n\t      x.copyTo(r);\n\t      this.reduce(r);\n\t      return r;\n\t    }\n\t  }\n\t\n\t  function barrettRevert(x)\n\t  {\n\t    return x;\n\t  }\n\t  // x = x mod m (HAC 14.42)\n\t  function barrettReduce(x)\n\t  {\n\t    x.drShiftTo(this.m.t - 1, this.r2);\n\t    if (x.t > this.m.t + 1)\n\t    {\n\t      x.t = this.m.t + 1;\n\t      x.clamp();\n\t    }\n\t    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);\n\t    this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);\n\t    while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);\n\t    x.subTo(this.r2, x);\n\t    while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n\t  }\n\t  // r = x^2 mod m; x != r\n\t  function barrettSqrTo(x, r)\n\t  {\n\t    x.squareTo(r);\n\t    this.reduce(r);\n\t  }\n\t  // r = x*y mod m; x,y != r\n\t  function barrettMulTo(x, y, r)\n\t  {\n\t    x.multiplyTo(y, r);\n\t    this.reduce(r);\n\t  }\n\t  Barrett.prototype.convert = barrettConvert;\n\t  Barrett.prototype.revert = barrettRevert;\n\t  Barrett.prototype.reduce = barrettReduce;\n\t  Barrett.prototype.mulTo = barrettMulTo;\n\t  Barrett.prototype.sqrTo = barrettSqrTo;\n\t  // (public) this^e % m (HAC 14.85)\n\t  function bnModPow(e, m)\n\t  {\n\t    var i = e.bitLength(),\n\t      k, r = nbv(1),\n\t      z;\n\t    if (i <= 0) return r;\n\t    else if (i < 18) k = 1;\n\t    else if (i < 48) k = 3;\n\t    else if (i < 144) k = 4;\n\t    else if (i < 768) k = 5;\n\t    else k = 6;\n\t    if (i < 8)\n\t      z = new Classic(m);\n\t    else if (m.isEven())\n\t      z = new Barrett(m);\n\t    else\n\t      z = new Montgomery(m);\n\t    // precomputation\n\t    var g = new Array(),\n\t      n = 3,\n\t      k1 = k - 1,\n\t      km = (1 << k) - 1;\n\t    g[1] = z.convert(this);\n\t    if (k > 1)\n\t    {\n\t      var g2 = nbi();\n\t      z.sqrTo(g[1], g2);\n\t      while (n <= km)\n\t      {\n\t        g[n] = nbi();\n\t        z.mulTo(g2, g[n - 2], g[n]);\n\t        n += 2;\n\t      }\n\t    }\n\t    var j = e.t - 1,\n\t      w, is1 = true,\n\t      r2 = nbi(),\n\t      t;\n\t    i = nbits(e[j]) - 1;\n\t    while (j >= 0)\n\t    {\n\t      if (i >= k1) w = (e[j] >> (i - k1)) & km;\n\t      else\n\t      {\n\t        w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);\n\t        if (j > 0) w |= e[j - 1] >> (this.DB + i - k1);\n\t      }\n\t      n = k;\n\t      while ((w & 1) == 0)\n\t      {\n\t        w >>= 1;\n\t        --n;\n\t      }\n\t      if ((i -= n) < 0)\n\t      {\n\t        i += this.DB;\n\t        --j;\n\t      }\n\t      if (is1)\n\t      { // ret == 1, don't bother squaring or multiplying it\n\t        g[w].copyTo(r);\n\t        is1 = false;\n\t      }\n\t      else\n\t      {\n\t        while (n > 1)\n\t        {\n\t          z.sqrTo(r, r2);\n\t          z.sqrTo(r2, r);\n\t          n -= 2;\n\t        }\n\t        if (n > 0) z.sqrTo(r, r2);\n\t        else\n\t        {\n\t          t = r;\n\t          r = r2;\n\t          r2 = t;\n\t        }\n\t        z.mulTo(r2, g[w], r);\n\t      }\n\t      while (j >= 0 && (e[j] & (1 << i)) == 0)\n\t      {\n\t        z.sqrTo(r, r2);\n\t        t = r;\n\t        r = r2;\n\t        r2 = t;\n\t        if (--i < 0)\n\t        {\n\t          i = this.DB - 1;\n\t          --j;\n\t        }\n\t      }\n\t    }\n\t    return z.revert(r);\n\t  }\n\t  // (public) gcd(this,a) (HAC 14.54)\n\t  function bnGCD(a)\n\t  {\n\t    var x = (this.s < 0) ? this.negate() : this.clone();\n\t    var y = (a.s < 0) ? a.negate() : a.clone();\n\t    if (x.compareTo(y) < 0)\n\t    {\n\t      var t = x;\n\t      x = y;\n\t      y = t;\n\t    }\n\t    var i = x.getLowestSetBit(),\n\t      g = y.getLowestSetBit();\n\t    if (g < 0) return x;\n\t    if (i < g) g = i;\n\t    if (g > 0)\n\t    {\n\t      x.rShiftTo(g, x);\n\t      y.rShiftTo(g, y);\n\t    }\n\t    while (x.signum() > 0)\n\t    {\n\t      if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);\n\t      if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);\n\t      if (x.compareTo(y) >= 0)\n\t      {\n\t        x.subTo(y, x);\n\t        x.rShiftTo(1, x);\n\t      }\n\t      else\n\t      {\n\t        y.subTo(x, y);\n\t        y.rShiftTo(1, y);\n\t      }\n\t    }\n\t    if (g > 0) y.lShiftTo(g, y);\n\t    return y;\n\t  }\n\t  // (protected) this % n, n < 2^26\n\t  function bnpModInt(n)\n\t  {\n\t    if (n <= 0) return 0;\n\t    var d = this.DV % n,\n\t      r = (this.s < 0) ? n - 1 : 0;\n\t    if (this.t > 0)\n\t      if (d == 0) r = this[0] % n;\n\t      else\n\t        for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;\n\t    return r;\n\t  }\n\t  // (public) 1/this % m (HAC 14.61)\n\t  function bnModInverse(m)\n\t  {\n\t    var ac = m.isEven();\n\t    if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n\t    var u = m.clone(),\n\t      v = this.clone();\n\t    var a = nbv(1),\n\t      b = nbv(0),\n\t      c = nbv(0),\n\t      d = nbv(1);\n\t    while (u.signum() != 0)\n\t    {\n\t      while (u.isEven())\n\t      {\n\t        u.rShiftTo(1, u);\n\t        if (ac)\n\t        {\n\t          if (!a.isEven() || !b.isEven())\n\t          {\n\t            a.addTo(this, a);\n\t            b.subTo(m, b);\n\t          }\n\t          a.rShiftTo(1, a);\n\t        }\n\t        else if (!b.isEven()) b.subTo(m, b);\n\t        b.rShiftTo(1, b);\n\t      }\n\t      while (v.isEven())\n\t      {\n\t        v.rShiftTo(1, v);\n\t        if (ac)\n\t        {\n\t          if (!c.isEven() || !d.isEven())\n\t          {\n\t            c.addTo(this, c);\n\t            d.subTo(m, d);\n\t          }\n\t          c.rShiftTo(1, c);\n\t        }\n\t        else if (!d.isEven()) d.subTo(m, d);\n\t        d.rShiftTo(1, d);\n\t      }\n\t      if (u.compareTo(v) >= 0)\n\t      {\n\t        u.subTo(v, u);\n\t        if (ac) a.subTo(c, a);\n\t        b.subTo(d, b);\n\t      }\n\t      else\n\t      {\n\t        v.subTo(u, v);\n\t        if (ac) c.subTo(a, c);\n\t        d.subTo(b, d);\n\t      }\n\t    }\n\t    if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n\t    if (d.compareTo(m) >= 0) return d.subtract(m);\n\t    if (d.signum() < 0) d.addTo(m, d);\n\t    else return d;\n\t    if (d.signum() < 0) return d.add(m);\n\t    else return d;\n\t  }\n\t  var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\n\t  var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];\n\t  // (public) test primality with certainty >= 1-.5^t\n\t  function bnIsProbablePrime(t)\n\t  {\n\t    var i, x = this.abs();\n\t    if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1])\n\t    {\n\t      for (i = 0; i < lowprimes.length; ++i)\n\t        if (x[0] == lowprimes[i]) return true;\n\t      return false;\n\t    }\n\t    if (x.isEven()) return false;\n\t    i = 1;\n\t    while (i < lowprimes.length)\n\t    {\n\t      var m = lowprimes[i],\n\t        j = i + 1;\n\t      while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n\t      m = x.modInt(m);\n\t      while (i < j)\n\t        if (m % lowprimes[i++] == 0) return false;\n\t    }\n\t    return x.millerRabin(t);\n\t  }\n\t  // (protected) true if probably prime (HAC 4.24, Miller-Rabin)\n\t  function bnpMillerRabin(t)\n\t  {\n\t    var n1 = this.subtract(BigInteger.ONE);\n\t    var k = n1.getLowestSetBit();\n\t    if (k <= 0) return false;\n\t    var r = n1.shiftRight(k);\n\t    t = (t + 1) >> 1;\n\t    if (t > lowprimes.length) t = lowprimes.length;\n\t    var a = nbi();\n\t    for (var i = 0; i < t; ++i)\n\t    {\n\t      //Pick bases at random, instead of starting at 2\n\t      a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);\n\t      var y = a.modPow(r, this);\n\t      if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0)\n\t      {\n\t        var j = 1;\n\t        while (j++ < k && y.compareTo(n1) != 0)\n\t        {\n\t          y = y.modPowInt(2, this);\n\t          if (y.compareTo(BigInteger.ONE) == 0) return false;\n\t        }\n\t        if (y.compareTo(n1) != 0) return false;\n\t      }\n\t    }\n\t    return true;\n\t  }\n\t  // protected\n\t  BigInteger.prototype.chunkSize = bnpChunkSize;\n\t  BigInteger.prototype.toRadix = bnpToRadix;\n\t  BigInteger.prototype.fromRadix = bnpFromRadix;\n\t  BigInteger.prototype.fromNumber = bnpFromNumber;\n\t  BigInteger.prototype.bitwiseTo = bnpBitwiseTo;\n\t  BigInteger.prototype.changeBit = bnpChangeBit;\n\t  BigInteger.prototype.addTo = bnpAddTo;\n\t  BigInteger.prototype.dMultiply = bnpDMultiply;\n\t  BigInteger.prototype.dAddOffset = bnpDAddOffset;\n\t  BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\n\t  BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\n\t  BigInteger.prototype.modInt = bnpModInt;\n\t  BigInteger.prototype.millerRabin = bnpMillerRabin;\n\t  // public\n\t  BigInteger.prototype.clone = bnClone;\n\t  BigInteger.prototype.intValue = bnIntValue;\n\t  BigInteger.prototype.byteValue = bnByteValue;\n\t  BigInteger.prototype.shortValue = bnShortValue;\n\t  BigInteger.prototype.signum = bnSigNum;\n\t  BigInteger.prototype.toByteArray = bnToByteArray;\n\t  BigInteger.prototype.equals = bnEquals;\n\t  BigInteger.prototype.min = bnMin;\n\t  BigInteger.prototype.max = bnMax;\n\t  BigInteger.prototype.and = bnAnd;\n\t  BigInteger.prototype.or = bnOr;\n\t  BigInteger.prototype.xor = bnXor;\n\t  BigInteger.prototype.andNot = bnAndNot;\n\t  BigInteger.prototype.not = bnNot;\n\t  BigInteger.prototype.shiftLeft = bnShiftLeft;\n\t  BigInteger.prototype.shiftRight = bnShiftRight;\n\t  BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\n\t  BigInteger.prototype.bitCount = bnBitCount;\n\t  BigInteger.prototype.testBit = bnTestBit;\n\t  BigInteger.prototype.setBit = bnSetBit;\n\t  BigInteger.prototype.clearBit = bnClearBit;\n\t  BigInteger.prototype.flipBit = bnFlipBit;\n\t  BigInteger.prototype.add = bnAdd;\n\t  BigInteger.prototype.subtract = bnSubtract;\n\t  BigInteger.prototype.multiply = bnMultiply;\n\t  BigInteger.prototype.divide = bnDivide;\n\t  BigInteger.prototype.remainder = bnRemainder;\n\t  BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\n\t  BigInteger.prototype.modPow = bnModPow;\n\t  BigInteger.prototype.modInverse = bnModInverse;\n\t  BigInteger.prototype.pow = bnPow;\n\t  BigInteger.prototype.gcd = bnGCD;\n\t  BigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n\t  // JSBN-specific extension\n\t  BigInteger.prototype.square = bnSquare;\n\t  var Int128 = BigInteger;\n\t  // BigInteger interfaces not implemented in jsbn:\n\t  // BigInteger(int signum, byte[] magnitude)\n\t  // double doubleValue()\n\t  // float floatValue()\n\t  // int hashCode()\n\t  // long longValue()\n\t  // static BigInteger valueOf(long val)\n\t  // Helper functions to make BigInteger functions callable with two parameters\n\t  // as in original C# Clipper\n\t  Int128.prototype.IsNegative = function ()\n\t  {\n\t    if (this.compareTo(Int128.ZERO) == -1) return true;\n\t    else return false;\n\t  };\n\t  Int128.op_Equality = function (val1, val2)\n\t  {\n\t    if (val1.compareTo(val2) == 0) return true;\n\t    else return false;\n\t  };\n\t  Int128.op_Inequality = function (val1, val2)\n\t  {\n\t    if (val1.compareTo(val2) != 0) return true;\n\t    else return false;\n\t  };\n\t  Int128.op_GreaterThan = function (val1, val2)\n\t  {\n\t    if (val1.compareTo(val2) > 0) return true;\n\t    else return false;\n\t  };\n\t  Int128.op_LessThan = function (val1, val2)\n\t  {\n\t    if (val1.compareTo(val2) < 0) return true;\n\t    else return false;\n\t  };\n\t  Int128.op_Addition = function (lhs, rhs)\n\t  {\n\t    return new Int128(lhs).add(new Int128(rhs));\n\t  };\n\t  Int128.op_Subtraction = function (lhs, rhs)\n\t  {\n\t    return new Int128(lhs).subtract(new Int128(rhs));\n\t  };\n\t  Int128.Int128Mul = function (lhs, rhs)\n\t  {\n\t    return new Int128(lhs).multiply(new Int128(rhs));\n\t  };\n\t  Int128.op_Division = function (lhs, rhs)\n\t  {\n\t    return lhs.divide(rhs);\n\t  };\n\t  Int128.prototype.ToDouble = function ()\n\t  {\n\t    return parseFloat(this.toString()); // This could be something faster\n\t  };\n\t  // end of Int128 section\n\t  /*\n\t  // Uncomment the following two lines if you want to use Int128 outside ClipperLib\n\t  if (typeof(document) !== \"undefined\") window.Int128 = Int128;\n\t  else self.Int128 = Int128;\n\t  */\n\t\n\t\n\t  // ---------------------------------------------\n\t  // Here starts the actual Clipper library:\n\t  // Helper function to support Inheritance in Javascript\n\t\tvar Inherit = function (ce, ce2)\n\t\t{\n\t\t\tvar p;\n\t\t\tif (typeof (Object.getOwnPropertyNames) == 'undefined')\n\t\t\t{\n\t\t\t\tfor (p in ce2.prototype)\n\t\t\t\t\tif (typeof (ce.prototype[p]) == 'undefined' || ce.prototype[p] == Object.prototype[p]) ce.prototype[p] = ce2.prototype[p];\n\t\t\t\tfor (p in ce2)\n\t\t\t\t\tif (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];\n\t\t\t\tce.$baseCtor = ce2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar props = Object.getOwnPropertyNames(ce2.prototype);\n\t\t\t\tfor (var i = 0; i < props.length; i++)\n\t\t\t\t\tif (typeof (Object.getOwnPropertyDescriptor(ce.prototype, props[i])) == 'undefined') Object.defineProperty(ce.prototype, props[i], Object.getOwnPropertyDescriptor(ce2.prototype, props[i]));\n\t\t\t\tfor (p in ce2)\n\t\t\t\t\tif (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];\n\t\t\t\tce.$baseCtor = ce2;\n\t\t\t}\n\t\t};\n\t  ClipperLib.Path = function ()\n\t  {\n\t    return [];\n\t  };\n\t  ClipperLib.Paths = function ()\n\t  {\n\t    return []; // Was previously [[]], but caused problems when pushed\n\t  };\n\t  // Preserves the calling way of original C# Clipper\n\t  // Is essential due to compatibility, because DoublePoint is public class in original C# version\n\t  ClipperLib.DoublePoint = function ()\n\t  {\n\t    var a = arguments;\n\t    this.X = 0;\n\t    this.Y = 0;\n\t    // public DoublePoint(DoublePoint dp)\n\t    // public DoublePoint(IntPoint ip)\n\t    if (a.length == 1)\n\t    {\n\t      this.X = a[0].X;\n\t      this.Y = a[0].Y;\n\t    }\n\t    else if (a.length == 2)\n\t    {\n\t      this.X = a[0];\n\t      this.Y = a[1];\n\t    }\n\t  }; // This is internal faster function when called without arguments\n\t  ClipperLib.DoublePoint0 = function ()\n\t  {\n\t    this.X = 0;\n\t    this.Y = 0;\n\t  };\n\t  // This is internal faster function when called with 1 argument (dp or ip)\n\t  ClipperLib.DoublePoint1 = function (dp)\n\t  {\n\t    this.X = dp.X;\n\t    this.Y = dp.Y;\n\t  };\n\t  // This is internal faster function when called with 2 arguments (x and y)\n\t  ClipperLib.DoublePoint2 = function (x, y)\n\t  {\n\t    this.X = x;\n\t    this.Y = y;\n\t  };\n\t  // PolyTree & PolyNode start\n\t  // -------------------------------\n\t  ClipperLib.PolyNode = function ()\n\t  {\n\t    this.m_Parent = null;\n\t    this.m_polygon = new ClipperLib.Path();\n\t    this.m_Index = 0;\n\t    this.m_jointype = 0;\n\t    this.m_endtype = 0;\n\t    this.m_Childs = [];\n\t    this.IsOpen = false;\n\t  };\n\t  ClipperLib.PolyNode.prototype.IsHoleNode = function ()\n\t  {\n\t    var result = true;\n\t    var node = this.m_Parent;\n\t    while (node !== null)\n\t    {\n\t      result = !result;\n\t      node = node.m_Parent;\n\t    }\n\t    return result;\n\t  };\n\t  ClipperLib.PolyNode.prototype.ChildCount = function ()\n\t  {\n\t    return this.m_Childs.length;\n\t  };\n\t  ClipperLib.PolyNode.prototype.Contour = function ()\n\t  {\n\t    return this.m_polygon;\n\t  };\n\t  ClipperLib.PolyNode.prototype.AddChild = function (Child)\n\t  {\n\t    var cnt = this.m_Childs.length;\n\t    this.m_Childs.push(Child);\n\t    Child.m_Parent = this;\n\t    Child.m_Index = cnt;\n\t  };\n\t  ClipperLib.PolyNode.prototype.GetNext = function ()\n\t  {\n\t    if (this.m_Childs.length > 0)\n\t      return this.m_Childs[0];\n\t    else\n\t      return this.GetNextSiblingUp();\n\t  };\n\t  ClipperLib.PolyNode.prototype.GetNextSiblingUp = function ()\n\t  {\n\t    if (this.m_Parent === null)\n\t      return null;\n\t    else if (this.m_Index == this.m_Parent.m_Childs.length - 1)\n\t      return this.m_Parent.GetNextSiblingUp();\n\t    else\n\t      return this.m_Parent.m_Childs[this.m_Index + 1];\n\t  };\n\t  ClipperLib.PolyNode.prototype.Childs = function ()\n\t  {\n\t    return this.m_Childs;\n\t  };\n\t  ClipperLib.PolyNode.prototype.Parent = function ()\n\t  {\n\t    return this.m_Parent;\n\t  };\n\t  ClipperLib.PolyNode.prototype.IsHole = function ()\n\t  {\n\t    return this.IsHoleNode();\n\t  };\n\t  // PolyTree : PolyNode\n\t  ClipperLib.PolyTree = function ()\n\t  {\n\t    this.m_AllPolys = [];\n\t    ClipperLib.PolyNode.call(this);\n\t  };\n\t  ClipperLib.PolyTree.prototype.Clear = function ()\n\t  {\n\t    for (var i = 0, ilen = this.m_AllPolys.length; i < ilen; i++)\n\t      this.m_AllPolys[i] = null;\n\t    this.m_AllPolys.length = 0;\n\t    this.m_Childs.length = 0;\n\t  };\n\t  ClipperLib.PolyTree.prototype.GetFirst = function ()\n\t  {\n\t    if (this.m_Childs.length > 0)\n\t      return this.m_Childs[0];\n\t    else\n\t      return null;\n\t  };\n\t  ClipperLib.PolyTree.prototype.Total = function ()\n\t  {\n\t\t\tvar result = this.m_AllPolys.length;\n\t\t\t//with negative offsets, ignore the hidden outer polygon ...\n\t\t\tif (result > 0 && this.m_Childs[0] != this.m_AllPolys[0]) result--;\n\t\t\treturn result;\n\t  };\n\t  Inherit(ClipperLib.PolyTree, ClipperLib.PolyNode);\n\t  // -------------------------------\n\t  // PolyTree & PolyNode end\n\t  ClipperLib.Math_Abs_Int64 = ClipperLib.Math_Abs_Int32 = ClipperLib.Math_Abs_Double = function (a)\n\t  {\n\t    return Math.abs(a);\n\t  };\n\t  ClipperLib.Math_Max_Int32_Int32 = function (a, b)\n\t  {\n\t    return Math.max(a, b);\n\t  };\n\t  /*\n\t  -----------------------------------\n\t  cast_32 speedtest: http://jsperf.com/truncate-float-to-integer/2\n\t  -----------------------------------\n\t  */\n\t  if (browser.msie || browser.opera || browser.safari) ClipperLib.Cast_Int32 = function (a)\n\t  {\n\t    return a | 0;\n\t  };\n\t  else ClipperLib.Cast_Int32 = function (a)\n\t  { // eg. browser.chrome || browser.chromium || browser.firefox\n\t    return~~ a;\n\t  };\n\t  /*\n\t  --------------------------\n\t  cast_64 speedtests: http://jsperf.com/truncate-float-to-integer\n\t  Chrome: bitwise_not_floor\n\t  Firefox17: toInteger (typeof test)\n\t  IE9: bitwise_or_floor\n\t  IE7 and IE8: to_parseint\n\t  Chromium: to_floor_or_ceil\n\t  Firefox3: to_floor_or_ceil\n\t  Firefox15: to_floor_or_ceil\n\t  Opera: to_floor_or_ceil\n\t  Safari: to_floor_or_ceil\n\t  --------------------------\n\t  */\n\t  if (browser.chrome) ClipperLib.Cast_Int64 = function (a)\n\t  {\n\t    if (a < -2147483648 || a > 2147483647)\n\t      return a < 0 ? Math.ceil(a) : Math.floor(a);\n\t    else return~~ a;\n\t  };\n\t  else if (browser.firefox && typeof (Number.toInteger) == \"function\") ClipperLib.Cast_Int64 = function (a)\n\t  {\n\t    return Number.toInteger(a);\n\t  };\n\t  else if (browser.msie7 || browser.msie8) ClipperLib.Cast_Int64 = function (a)\n\t  {\n\t    return parseInt(a, 10);\n\t  };\n\t  else if (browser.msie) ClipperLib.Cast_Int64 = function (a)\n\t  {\n\t    if (a < -2147483648 || a > 2147483647)\n\t      return a < 0 ? Math.ceil(a) : Math.floor(a);\n\t    return a | 0;\n\t  };\n\t  // eg. browser.chromium || browser.firefox || browser.opera || browser.safari\n\t  else ClipperLib.Cast_Int64 = function (a)\n\t  {\n\t    return a < 0 ? Math.ceil(a) : Math.floor(a);\n\t  };\n\t  ClipperLib.Clear = function (a)\n\t  {\n\t    a.length = 0;\n\t  };\n\t  //ClipperLib.MaxSteps = 64; // How many steps at maximum in arc in BuildArc() function\n\t  ClipperLib.PI = 3.141592653589793;\n\t  ClipperLib.PI2 = 2 * 3.141592653589793;\n\t  ClipperLib.IntPoint = function ()\n\t  {\n\t    var a = arguments,\n\t      alen = a.length;\n\t    this.X = 0;\n\t    this.Y = 0;\n\t    if (use_xyz)\n\t    {\n\t      this.Z = 0;\n\t      if (alen == 3) // public IntPoint(cInt x, cInt y, cInt z = 0)\n\t      {\n\t        this.X = a[0];\n\t        this.Y = a[1];\n\t        this.Z = a[2];\n\t      }\n\t      else if (alen == 2) // public IntPoint(cInt x, cInt y)\n\t      {\n\t        this.X = a[0];\n\t        this.Y = a[1];\n\t        this.Z = 0;\n\t      }\n\t      else if (alen == 1)\n\t      {\n\t        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n\t        {\n\t          var dp = a[0];\n\t          this.X = ClipperLib.Clipper.Round(dp.X);\n\t          this.Y = ClipperLib.Clipper.Round(dp.Y);\n\t          this.Z = 0;\n\t        }\n\t        else // public IntPoint(IntPoint pt)\n\t        {\n\t          var pt = a[0];\n\t          if (typeof (pt.Z) == \"undefined\") pt.Z = 0;\n\t          this.X = pt.X;\n\t          this.Y = pt.Y;\n\t          this.Z = pt.Z;\n\t        }\n\t      }\n\t      else // public IntPoint()\n\t      {\n\t        this.X = 0;\n\t        this.Y = 0;\n\t        this.Z = 0;\n\t      }\n\t    }\n\t    else // if (!use_xyz)\n\t    {\n\t      if (alen == 2) // public IntPoint(cInt X, cInt Y)\n\t      {\n\t        this.X = a[0];\n\t        this.Y = a[1];\n\t      }\n\t      else if (alen == 1)\n\t      {\n\t        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n\t        {\n\t          var dp = a[0];\n\t          this.X = ClipperLib.Clipper.Round(dp.X);\n\t          this.Y = ClipperLib.Clipper.Round(dp.Y);\n\t        }\n\t        else // public IntPoint(IntPoint pt)\n\t        {\n\t          var pt = a[0];\n\t          this.X = pt.X;\n\t          this.Y = pt.Y;\n\t        }\n\t      }\n\t      else // public IntPoint(IntPoint pt)\n\t      {\n\t        this.X = 0;\n\t        this.Y = 0;\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.IntPoint.op_Equality = function (a, b)\n\t  {\n\t    //return a == b;\n\t    return a.X == b.X && a.Y == b.Y;\n\t  };\n\t  ClipperLib.IntPoint.op_Inequality = function (a, b)\n\t  {\n\t    //return a != b;\n\t    return a.X != b.X || a.Y != b.Y;\n\t  };\n\t  /*\n\t  ClipperLib.IntPoint.prototype.Equals = function (obj)\n\t  {\n\t    if (obj === null)\n\t        return false;\n\t    if (obj instanceof ClipperLib.IntPoint)\n\t    {\n\t        var a = Cast(obj, ClipperLib.IntPoint);\n\t        return (this.X == a.X) && (this.Y == a.Y);\n\t    }\n\t    else\n\t        return false;\n\t  };\n\t*/\n\t  if (use_xyz)\n\t  {\n\t    ClipperLib.IntPoint0 = function ()\n\t    {\n\t      this.X = 0;\n\t      this.Y = 0;\n\t      this.Z = 0;\n\t    };\n\t    ClipperLib.IntPoint1 = function (pt)\n\t    {\n\t      this.X = pt.X;\n\t      this.Y = pt.Y;\n\t      this.Z = pt.Z;\n\t    };\n\t    ClipperLib.IntPoint1dp = function (dp)\n\t    {\n\t      this.X = ClipperLib.Clipper.Round(dp.X);\n\t      this.Y = ClipperLib.Clipper.Round(dp.Y);\n\t      this.Z = 0;\n\t    };\n\t    ClipperLib.IntPoint2 = function (x, y)\n\t    {\n\t      this.X = x;\n\t      this.Y = y;\n\t      this.Z = 0;\n\t    };\n\t    ClipperLib.IntPoint3 = function (x, y, z)\n\t    {\n\t      this.X = x;\n\t      this.Y = y;\n\t      this.Z = z;\n\t    };\n\t  }\n\t  else // if (!use_xyz)\n\t  {\n\t    ClipperLib.IntPoint0 = function ()\n\t    {\n\t      this.X = 0;\n\t      this.Y = 0;\n\t    };\n\t    ClipperLib.IntPoint1 = function (pt)\n\t    {\n\t      this.X = pt.X;\n\t      this.Y = pt.Y;\n\t    };\n\t    ClipperLib.IntPoint1dp = function (dp)\n\t    {\n\t      this.X = ClipperLib.Clipper.Round(dp.X);\n\t      this.Y = ClipperLib.Clipper.Round(dp.Y);\n\t    };\n\t    ClipperLib.IntPoint2 = function (x, y)\n\t    {\n\t      this.X = x;\n\t      this.Y = y;\n\t    };\n\t  }\n\t  ClipperLib.IntRect = function ()\n\t  {\n\t    var a = arguments,\n\t      alen = a.length;\n\t    if (alen == 4) // function (l, t, r, b)\n\t    {\n\t      this.left = a[0];\n\t      this.top = a[1];\n\t      this.right = a[2];\n\t      this.bottom = a[3];\n\t    }\n\t    else if (alen == 1) // function (ir)\n\t    {\n\t      this.left = ir.left;\n\t      this.top = ir.top;\n\t      this.right = ir.right;\n\t      this.bottom = ir.bottom;\n\t    }\n\t    else // function ()\n\t    {\n\t      this.left = 0;\n\t      this.top = 0;\n\t      this.right = 0;\n\t      this.bottom = 0;\n\t    }\n\t  };\n\t  ClipperLib.IntRect0 = function ()\n\t  {\n\t    this.left = 0;\n\t    this.top = 0;\n\t    this.right = 0;\n\t    this.bottom = 0;\n\t  };\n\t  ClipperLib.IntRect1 = function (ir)\n\t  {\n\t    this.left = ir.left;\n\t    this.top = ir.top;\n\t    this.right = ir.right;\n\t    this.bottom = ir.bottom;\n\t  };\n\t  ClipperLib.IntRect4 = function (l, t, r, b)\n\t  {\n\t    this.left = l;\n\t    this.top = t;\n\t    this.right = r;\n\t    this.bottom = b;\n\t  };\n\t  ClipperLib.ClipType = {\n\t    ctIntersection: 0,\n\t    ctUnion: 1,\n\t    ctDifference: 2,\n\t    ctXor: 3\n\t  };\n\t  ClipperLib.PolyType = {\n\t    ptSubject: 0,\n\t    ptClip: 1\n\t  };\n\t  ClipperLib.PolyFillType = {\n\t    pftEvenOdd: 0,\n\t    pftNonZero: 1,\n\t    pftPositive: 2,\n\t    pftNegative: 3\n\t  };\n\t  ClipperLib.JoinType = {\n\t    jtSquare: 0,\n\t    jtRound: 1,\n\t    jtMiter: 2\n\t  };\n\t  ClipperLib.EndType = {\n\t    etOpenSquare: 0,\n\t    etOpenRound: 1,\n\t    etOpenButt: 2,\n\t    etClosedLine: 3,\n\t    etClosedPolygon: 4\n\t  };\n\t  ClipperLib.EdgeSide = {\n\t    esLeft: 0,\n\t    esRight: 1\n\t  };\n\t  ClipperLib.Direction = {\n\t    dRightToLeft: 0,\n\t    dLeftToRight: 1\n\t  };\n\t  ClipperLib.TEdge = function ()\n\t  {\n\t    this.Bot = new ClipperLib.IntPoint();\n\t    this.Curr = new ClipperLib.IntPoint();\n\t    this.Top = new ClipperLib.IntPoint();\n\t    this.Delta = new ClipperLib.IntPoint();\n\t    this.Dx = 0;\n\t    this.PolyTyp = ClipperLib.PolyType.ptSubject;\n\t    this.Side = ClipperLib.EdgeSide.esLeft;\n\t    this.WindDelta = 0;\n\t    this.WindCnt = 0;\n\t    this.WindCnt2 = 0;\n\t    this.OutIdx = 0;\n\t    this.Next = null;\n\t    this.Prev = null;\n\t    this.NextInLML = null;\n\t    this.NextInAEL = null;\n\t    this.PrevInAEL = null;\n\t    this.NextInSEL = null;\n\t    this.PrevInSEL = null;\n\t  };\n\t  ClipperLib.IntersectNode = function ()\n\t  {\n\t    this.Edge1 = null;\n\t    this.Edge2 = null;\n\t    this.Pt = new ClipperLib.IntPoint();\n\t  };\n\t  ClipperLib.MyIntersectNodeSort = function () {};\n\t  ClipperLib.MyIntersectNodeSort.Compare = function (node1, node2)\n\t  {\n\t    var i = node2.Pt.Y - node1.Pt.Y;\n\t    if (i > 0) return 1;\n\t    else if (i < 0) return -1;\n\t    else return 0;\n\t  };\n\t\n\t  ClipperLib.LocalMinima = function ()\n\t  {\n\t    this.Y = 0;\n\t    this.LeftBound = null;\n\t    this.RightBound = null;\n\t    this.Next = null;\n\t  };\n\t  ClipperLib.Scanbeam = function ()\n\t  {\n\t    this.Y = 0;\n\t    this.Next = null;\n\t  };\n\t  ClipperLib.OutRec = function ()\n\t  {\n\t    this.Idx = 0;\n\t    this.IsHole = false;\n\t    this.IsOpen = false;\n\t    this.FirstLeft = null;\n\t    this.Pts = null;\n\t    this.BottomPt = null;\n\t    this.PolyNode = null;\n\t  };\n\t  ClipperLib.OutPt = function ()\n\t  {\n\t    this.Idx = 0;\n\t    this.Pt = new ClipperLib.IntPoint();\n\t    this.Next = null;\n\t    this.Prev = null;\n\t  };\n\t  ClipperLib.Join = function ()\n\t  {\n\t    this.OutPt1 = null;\n\t    this.OutPt2 = null;\n\t    this.OffPt = new ClipperLib.IntPoint();\n\t  };\n\t  ClipperLib.ClipperBase = function ()\n\t  {\n\t    this.m_MinimaList = null;\n\t    this.m_CurrentLM = null;\n\t    this.m_edges = new Array();\n\t    this.m_UseFullRange = false;\n\t    this.m_HasOpenPaths = false;\n\t    this.PreserveCollinear = false;\n\t    this.m_MinimaList = null;\n\t    this.m_CurrentLM = null;\n\t    this.m_UseFullRange = false;\n\t    this.m_HasOpenPaths = false;\n\t  };\n\t  // Ranges are in original C# too high for Javascript (in current state 2013 september):\n\t  // protected const double horizontal = -3.4E+38;\n\t  // internal const cInt loRange = 0x3FFFFFFF; // = 1073741823 = sqrt(2^63 -1)/2\n\t  // internal const cInt hiRange = 0x3FFFFFFFFFFFFFFFL; // = 4611686018427387903 = sqrt(2^127 -1)/2\n\t  // So had to adjust them to more suitable for Javascript.\n\t  // If JS some day supports truly 64-bit integers, then these ranges can be as in C#\n\t  // and biginteger library can be more simpler (as then 128bit can be represented as two 64bit numbers)\n\t  ClipperLib.ClipperBase.horizontal = -9007199254740992; //-2^53\n\t  ClipperLib.ClipperBase.Skip = -2;\n\t  ClipperLib.ClipperBase.Unassigned = -1;\n\t  ClipperLib.ClipperBase.tolerance = 1E-20;\n\t  if (use_int32)\n\t  {\n\t    ClipperLib.ClipperBase.loRange = 0x7FFF;\n\t    ClipperLib.ClipperBase.hiRange = 0x7FFF;\n\t  }\n\t  else\n\t  {\n\t    ClipperLib.ClipperBase.loRange = 47453132; // sqrt(2^53 -1)/2\n\t    ClipperLib.ClipperBase.hiRange = 4503599627370495; // sqrt(2^106 -1)/2\n\t  }\n\t\n\t  ClipperLib.ClipperBase.near_zero = function (val)\n\t  {\n\t    return (val > -ClipperLib.ClipperBase.tolerance) && (val < ClipperLib.ClipperBase.tolerance);\n\t  };\n\t  ClipperLib.ClipperBase.IsHorizontal = function (e)\n\t  {\n\t    return e.Delta.Y === 0;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.PointIsVertex = function (pt, pp)\n\t  {\n\t    var pp2 = pp;\n\t    do {\n\t      if (ClipperLib.IntPoint.op_Equality(pp2.Pt, pt))\n\t        return true;\n\t      pp2 = pp2.Next;\n\t    }\n\t    while (pp2 != pp)\n\t    return false;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.PointOnLineSegment = function (pt, linePt1, linePt2, UseFullRange)\n\t  {\n\t    if (UseFullRange)\n\t      return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) ||\n\t        ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) ||\n\t        (((pt.X > linePt1.X) == (pt.X < linePt2.X)) &&\n\t        ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) &&\n\t        (Int128.op_Equality(Int128.Int128Mul((pt.X - linePt1.X), (linePt2.Y - linePt1.Y)),\n\t          Int128.Int128Mul((linePt2.X - linePt1.X), (pt.Y - linePt1.Y)))));\n\t    else\n\t      return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) || ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) || (((pt.X > linePt1.X) == (pt.X < linePt2.X)) && ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) && ((pt.X - linePt1.X) * (linePt2.Y - linePt1.Y) == (linePt2.X - linePt1.X) * (pt.Y - linePt1.Y)));\n\t  };\n\t  ClipperLib.ClipperBase.prototype.PointOnPolygon = function (pt, pp, UseFullRange)\n\t  {\n\t    var pp2 = pp;\n\t    while (true)\n\t    {\n\t      if (this.PointOnLineSegment(pt, pp2.Pt, pp2.Next.Pt, UseFullRange))\n\t        return true;\n\t      pp2 = pp2.Next;\n\t      if (pp2 == pp)\n\t        break;\n\t    }\n\t    return false;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.SlopesEqual = ClipperLib.ClipperBase.SlopesEqual = function ()\n\t  {\n\t    var a = arguments,\n\t      alen = a.length;\n\t    var e1, e2, pt1, pt2, pt3, pt4, UseFullRange;\n\t    if (alen == 3) // function (e1, e2, UseFullRange)\n\t    {\n\t      e1 = a[0];\n\t      e2 = a[1];\n\t      UseFullRange = a[2];\n\t      if (UseFullRange)\n\t        return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n\t      else\n\t        return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n\t    }\n\t    else if (alen == 4) // function (pt1, pt2, pt3, UseFullRange)\n\t    {\n\t      pt1 = a[0];\n\t      pt2 = a[1];\n\t      pt3 = a[2];\n\t      UseFullRange = a[3];\n\t      if (UseFullRange)\n\t        return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n\t      else\n\t        return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n\t    }\n\t    else // function (pt1, pt2, pt3, pt4, UseFullRange)\n\t    {\n\t      pt1 = a[0];\n\t      pt2 = a[1];\n\t      pt3 = a[2];\n\t      pt4 = a[3];\n\t      UseFullRange = a[4];\n\t      if (UseFullRange)\n\t        return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n\t      else\n\t        return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n\t    }\n\t  };\n\t  ClipperLib.ClipperBase.SlopesEqual3 = function (e1, e2, UseFullRange)\n\t  {\n\t    if (UseFullRange)\n\t      return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n\t    else\n\t      return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n\t  };\n\t  ClipperLib.ClipperBase.SlopesEqual4 = function (pt1, pt2, pt3, UseFullRange)\n\t  {\n\t    if (UseFullRange)\n\t      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n\t    else\n\t      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n\t  };\n\t  ClipperLib.ClipperBase.SlopesEqual5 = function (pt1, pt2, pt3, pt4, UseFullRange)\n\t  {\n\t    if (UseFullRange)\n\t      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n\t    else\n\t      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.Clear = function ()\n\t  {\n\t    this.DisposeLocalMinimaList();\n\t    for (var i = 0, ilen = this.m_edges.length; i < ilen; ++i)\n\t    {\n\t      for (var j = 0, jlen = this.m_edges[i].length; j < jlen; ++j)\n\t        this.m_edges[i][j] = null;\n\t      ClipperLib.Clear(this.m_edges[i]);\n\t    }\n\t    ClipperLib.Clear(this.m_edges);\n\t    this.m_UseFullRange = false;\n\t    this.m_HasOpenPaths = false;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.DisposeLocalMinimaList = function ()\n\t  {\n\t    while (this.m_MinimaList !== null)\n\t    {\n\t      var tmpLm = this.m_MinimaList.Next;\n\t      this.m_MinimaList = null;\n\t      this.m_MinimaList = tmpLm;\n\t    }\n\t    this.m_CurrentLM = null;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.RangeTest = function (Pt, useFullRange)\n\t  {\n\t    if (useFullRange.Value)\n\t    {\n\t      if (Pt.X > ClipperLib.ClipperBase.hiRange || Pt.Y > ClipperLib.ClipperBase.hiRange || -Pt.X > ClipperLib.ClipperBase.hiRange || -Pt.Y > ClipperLib.ClipperBase.hiRange)\n\t        ClipperLib.Error(\"Coordinate outside allowed range in RangeTest().\");\n\t    }\n\t    else if (Pt.X > ClipperLib.ClipperBase.loRange || Pt.Y > ClipperLib.ClipperBase.loRange || -Pt.X > ClipperLib.ClipperBase.loRange || -Pt.Y > ClipperLib.ClipperBase.loRange)\n\t    {\n\t      useFullRange.Value = true;\n\t      this.RangeTest(Pt, useFullRange);\n\t    }\n\t  };\n\t  ClipperLib.ClipperBase.prototype.InitEdge = function (e, eNext, ePrev, pt)\n\t  {\n\t    e.Next = eNext;\n\t    e.Prev = ePrev;\n\t    //e.Curr = pt;\n\t    e.Curr.X = pt.X;\n\t    e.Curr.Y = pt.Y;\n\t    e.OutIdx = -1;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.InitEdge2 = function (e, polyType)\n\t  {\n\t    if (e.Curr.Y >= e.Next.Curr.Y)\n\t    {\n\t      //e.Bot = e.Curr;\n\t      e.Bot.X = e.Curr.X;\n\t      e.Bot.Y = e.Curr.Y;\n\t      //e.Top = e.Next.Curr;\n\t      e.Top.X = e.Next.Curr.X;\n\t      e.Top.Y = e.Next.Curr.Y;\n\t    }\n\t    else\n\t    {\n\t      //e.Top = e.Curr;\n\t      e.Top.X = e.Curr.X;\n\t      e.Top.Y = e.Curr.Y;\n\t      //e.Bot = e.Next.Curr;\n\t      e.Bot.X = e.Next.Curr.X;\n\t      e.Bot.Y = e.Next.Curr.Y;\n\t    }\n\t    this.SetDx(e);\n\t    e.PolyTyp = polyType;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.FindNextLocMin = function (E)\n\t  {\n\t    var E2;\n\t    for (;;)\n\t    {\n\t      while (ClipperLib.IntPoint.op_Inequality(E.Bot, E.Prev.Bot) || ClipperLib.IntPoint.op_Equality(E.Curr, E.Top))\n\t        E = E.Next;\n\t      if (E.Dx != ClipperLib.ClipperBase.horizontal && E.Prev.Dx != ClipperLib.ClipperBase.horizontal)\n\t        break;\n\t      while (E.Prev.Dx == ClipperLib.ClipperBase.horizontal)\n\t        E = E.Prev;\n\t      E2 = E;\n\t      while (E.Dx == ClipperLib.ClipperBase.horizontal)\n\t        E = E.Next;\n\t      if (E.Top.Y == E.Prev.Bot.Y)\n\t        continue;\n\t      //ie just an intermediate horz.\n\t      if (E2.Prev.Bot.X < E.Bot.X)\n\t        E = E2;\n\t      break;\n\t    }\n\t    return E;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.ProcessBound = function (E, LeftBoundIsForward)\n\t  {\n\t    var EStart;\n\t    var Result = E;\n\t    var Horz;\n\t\n\t      if (Result.OutIdx == ClipperLib.ClipperBase.Skip)\n\t      {\n\t        //check if there are edges beyond the skip edge in the bound and if so\n\t        //create another LocMin and calling ProcessBound once more ...\n\t        E = Result;\n\t        if (LeftBoundIsForward)\n\t        {\n\t          while (E.Top.Y == E.Next.Bot.Y) E = E.Next;\n\t          while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Prev;\n\t        }\n\t        else\n\t        {\n\t          while (E.Top.Y == E.Prev.Bot.Y) E = E.Prev;\n\t          while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Next;\n\t        }\n\t        if (E == Result)\n\t        {\n\t          if (LeftBoundIsForward) Result = E.Next;\n\t          else Result = E.Prev;\n\t        }\n\t        else\n\t        {\n\t          //there are more edges in the bound beyond result starting with E\n\t          if (LeftBoundIsForward)\n\t            E = Result.Next;\n\t          else\n\t            E = Result.Prev;\n\t          var locMin = new ClipperLib.LocalMinima();\n\t          locMin.Next = null;\n\t          locMin.Y = E.Bot.Y;\n\t          locMin.LeftBound = null;\n\t          locMin.RightBound = E;\n\t          E.WindDelta = 0;\n\t          Result = this.ProcessBound(E, LeftBoundIsForward);\n\t          this.InsertLocalMinima(locMin);\n\t        }\n\t        return Result;\n\t      }\n\t\n\t      if (E.Dx == ClipperLib.ClipperBase.horizontal)\n\t      {\n\t        //We need to be careful with open paths because this may not be a\n\t        //true local minima (ie E may be following a skip edge).\n\t        //Also, consecutive horz. edges may start heading left before going right.\n\t        if (LeftBoundIsForward) EStart = E.Prev;\n\t        else EStart = E.Next;\n\t        if (EStart.OutIdx != ClipperLib.ClipperBase.Skip)\n\t        {\n\t          if (EStart.Dx == ClipperLib.ClipperBase.horizontal) //ie an adjoining horizontal skip edge\n\t          {\n\t            if (EStart.Bot.X != E.Bot.X && EStart.Top.X != E.Bot.X)\n\t              this.ReverseHorizontal(E);\n\t          }\n\t          else if (EStart.Bot.X != E.Bot.X)\n\t            this.ReverseHorizontal(E);\n\t        }\n\t      }\n\t\n\t      EStart = E;\n\t      if (LeftBoundIsForward)\n\t      {\n\t        while (Result.Top.Y == Result.Next.Bot.Y && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n\t          Result = Result.Next;\n\t        if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n\t        {\n\t          //nb: at the top of a bound, horizontals are added to the bound\n\t          //only when the preceding edge attaches to the horizontal's left vertex\n\t          //unless a Skip edge is encountered when that becomes the top divide\n\t          Horz = Result;\n\t          while (Horz.Prev.Dx == ClipperLib.ClipperBase.horizontal)\n\t            Horz = Horz.Prev;\n\t          if (Horz.Prev.Top.X == Result.Next.Top.X)\n\t          {\n\t            if (!LeftBoundIsForward)\n\t              Result = Horz.Prev;\n\t          }\n\t          else if (Horz.Prev.Top.X > Result.Next.Top.X)\n\t            Result = Horz.Prev;\n\t        }\n\t        while (E != Result)\n\t        {\n\t          E.NextInLML = E.Next;\n\t          if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)\n\t            this.ReverseHorizontal(E);\n\t          E = E.Next;\n\t        }\n\t        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)\n\t          this.ReverseHorizontal(E);\n\t        Result = Result.Next;\n\t        //move to the edge just beyond current bound\n\t      }\n\t      else\n\t      {\n\t        while (Result.Top.Y == Result.Prev.Bot.Y && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)\n\t          Result = Result.Prev;\n\t        if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)\n\t        {\n\t          Horz = Result;\n\t          while (Horz.Next.Dx == ClipperLib.ClipperBase.horizontal)\n\t            Horz = Horz.Next;\n\t          if (Horz.Next.Top.X == Result.Prev.Top.X)\n\t          {\n\t            if (!LeftBoundIsForward)\n\t              Result = Horz.Next;\n\t          }\n\t          else if (Horz.Next.Top.X > Result.Prev.Top.X)\n\t            Result = Horz.Next;\n\t        }\n\t        while (E != Result)\n\t        {\n\t          E.NextInLML = E.Prev;\n\t          if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)\n\t            this.ReverseHorizontal(E);\n\t          E = E.Prev;\n\t        }\n\t        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)\n\t          this.ReverseHorizontal(E);\n\t        Result = Result.Prev;\n\t        //move to the edge just beyond current bound\n\t      }\n\t\n\t    return Result;\n\t  };\n\t\n\t  ClipperLib.ClipperBase.prototype.AddPath = function (pg, polyType, Closed)\n\t  {\n\t    if (use_lines)\n\t    {\n\t      if (!Closed && polyType == ClipperLib.PolyType.ptClip)\n\t        ClipperLib.Error(\"AddPath: Open paths must be subject.\");\n\t    }\n\t    else\n\t    {\n\t      if (!Closed)\n\t        ClipperLib.Error(\"AddPath: Open paths have been disabled.\");\n\t    }\n\t    var highI = pg.length - 1;\n\t    if (Closed)\n\t      while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[0])))\n\t    --highI;\n\t    while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[highI - 1])))\n\t    --highI;\n\t    if ((Closed && highI < 2) || (!Closed && highI < 1))\n\t      return false;\n\t    //create a new edge array ...\n\t    var edges = new Array();\n\t    for (var i = 0; i <= highI; i++)\n\t      edges.push(new ClipperLib.TEdge());\n\t    var IsFlat = true;\n\t    //1. Basic (first) edge initialization ...\n\t\n\t    //edges[1].Curr = pg[1];\n\t    edges[1].Curr.X = pg[1].X;\n\t    edges[1].Curr.Y = pg[1].Y;\n\t\n\t    var $1 = {Value: this.m_UseFullRange};\n\t    this.RangeTest(pg[0], $1);\n\t    this.m_UseFullRange = $1.Value;\n\t\n\t    $1.Value = this.m_UseFullRange;\n\t    this.RangeTest(pg[highI], $1);\n\t    this.m_UseFullRange = $1.Value;\n\t\n\t    this.InitEdge(edges[0], edges[1], edges[highI], pg[0]);\n\t    this.InitEdge(edges[highI], edges[0], edges[highI - 1], pg[highI]);\n\t    for (var i = highI - 1; i >= 1; --i)\n\t    {\n\t      $1.Value = this.m_UseFullRange;\n\t      this.RangeTest(pg[i], $1);\n\t      this.m_UseFullRange = $1.Value;\n\t\n\t      this.InitEdge(edges[i], edges[i + 1], edges[i - 1], pg[i]);\n\t    }\n\t\n\t    var eStart = edges[0];\n\t    //2. Remove duplicate vertices, and (when closed) collinear edges ...\n\t    var E = eStart,\n\t      eLoopStop = eStart;\n\t    for (;;)\n\t    {\n\t    //console.log(E.Next, eStart);\n\t    \t//nb: allows matching start and end points when not Closed ...\n\t      if (E.Curr == E.Next.Curr && (Closed || E.Next != eStart))\n\t      {\n\t        if (E == E.Next)\n\t          break;\n\t        if (E == eStart)\n\t          eStart = E.Next;\n\t        E = this.RemoveEdge(E);\n\t        eLoopStop = E;\n\t        continue;\n\t      }\n\t      if (E.Prev == E.Next)\n\t        break;\n\t      else if (Closed && ClipperLib.ClipperBase.SlopesEqual(E.Prev.Curr, E.Curr, E.Next.Curr, this.m_UseFullRange) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(E.Prev.Curr, E.Curr, E.Next.Curr)))\n\t      {\n\t        //Collinear edges are allowed for open paths but in closed paths\n\t        //the default is to merge adjacent collinear edges into a single edge.\n\t        //However, if the PreserveCollinear property is enabled, only overlapping\n\t        //collinear edges (ie spikes) will be removed from closed paths.\n\t        if (E == eStart)\n\t          eStart = E.Next;\n\t        E = this.RemoveEdge(E);\n\t        E = E.Prev;\n\t        eLoopStop = E;\n\t        continue;\n\t      }\n\t      E = E.Next;\n\t      if ((E == eLoopStop) || (!Closed && E.Next == eStart)) break;\n\t    }\n\t    if ((!Closed && (E == E.Next)) || (Closed && (E.Prev == E.Next)))\n\t      return false;\n\t    if (!Closed)\n\t    {\n\t      this.m_HasOpenPaths = true;\n\t      eStart.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n\t    }\n\t    //3. Do second stage of edge initialization ...\n\t    E = eStart;\n\t    do {\n\t      this.InitEdge2(E, polyType);\n\t      E = E.Next;\n\t      if (IsFlat && E.Curr.Y != eStart.Curr.Y)\n\t        IsFlat = false;\n\t    }\n\t    while (E != eStart)\n\t    //4. Finally, add edge bounds to LocalMinima list ...\n\t    //Totally flat paths must be handled differently when adding them\n\t    //to LocalMinima list to avoid endless loops etc ...\n\t    if (IsFlat)\n\t    {\n\t      if (Closed)\n\t        return false;\n\t      E.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n\t      if (E.Prev.Bot.X < E.Prev.Top.X)\n\t        this.ReverseHorizontal(E.Prev);\n\t      var locMin = new ClipperLib.LocalMinima();\n\t      locMin.Next = null;\n\t      locMin.Y = E.Bot.Y;\n\t      locMin.LeftBound = null;\n\t      locMin.RightBound = E;\n\t      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n\t      locMin.RightBound.WindDelta = 0;\n\t      while (E.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n\t      {\n\t        E.NextInLML = E.Next;\n\t        if (E.Bot.X != E.Prev.Top.X)\n\t          this.ReverseHorizontal(E);\n\t        E = E.Next;\n\t      }\n\t      this.InsertLocalMinima(locMin);\n\t      this.m_edges.push(edges);\n\t      return true;\n\t    }\n\t    this.m_edges.push(edges);\n\t    var leftBoundIsForward;\n\t    var EMin = null;\n\t\n\t\t\t//workaround to avoid an endless loop in the while loop below when\n\t    //open paths have matching start and end points ...\n\t    if(ClipperLib.IntPoint.op_Equality(E.Prev.Bot, E.Prev.Top))\n\t    \tE = E.Next;\n\t\n\t    for (;;)\n\t    {\n\t      E = this.FindNextLocMin(E);\n\t      if (E == EMin)\n\t        break;\n\t      else if (EMin == null)\n\t        EMin = E;\n\t      //E and E.Prev now share a local minima (left aligned if horizontal).\n\t      //Compare their slopes to find which starts which bound ...\n\t      var locMin = new ClipperLib.LocalMinima();\n\t      locMin.Next = null;\n\t      locMin.Y = E.Bot.Y;\n\t      if (E.Dx < E.Prev.Dx)\n\t      {\n\t        locMin.LeftBound = E.Prev;\n\t        locMin.RightBound = E;\n\t        leftBoundIsForward = false;\n\t        //Q.nextInLML = Q.prev\n\t      }\n\t      else\n\t      {\n\t        locMin.LeftBound = E;\n\t        locMin.RightBound = E.Prev;\n\t        leftBoundIsForward = true;\n\t        //Q.nextInLML = Q.next\n\t      }\n\t      locMin.LeftBound.Side = ClipperLib.EdgeSide.esLeft;\n\t      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n\t      if (!Closed)\n\t        locMin.LeftBound.WindDelta = 0;\n\t      else if (locMin.LeftBound.Next == locMin.RightBound)\n\t        locMin.LeftBound.WindDelta = -1;\n\t      else\n\t        locMin.LeftBound.WindDelta = 1;\n\t      locMin.RightBound.WindDelta = -locMin.LeftBound.WindDelta;\n\t      E = this.ProcessBound(locMin.LeftBound, leftBoundIsForward);\n\t      if (E.OutIdx == ClipperLib.ClipperBase.Skip)\n\t      \tE = this.ProcessBound(E, leftBoundIsForward);\n\t      var E2 = this.ProcessBound(locMin.RightBound, !leftBoundIsForward);\n\t      if (E2.OutIdx == ClipperLib.ClipperBase.Skip) E2 = this.ProcessBound(E2, !leftBoundIsForward);\n\t      if (locMin.LeftBound.OutIdx == ClipperLib.ClipperBase.Skip)\n\t        locMin.LeftBound = null;\n\t      else if (locMin.RightBound.OutIdx == ClipperLib.ClipperBase.Skip)\n\t        locMin.RightBound = null;\n\t      this.InsertLocalMinima(locMin);\n\t      if (!leftBoundIsForward)\n\t        E = E2;\n\t    }\n\t    return true;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.AddPaths = function (ppg, polyType, closed)\n\t  {\n\t    //  console.log(\"-------------------------------------------\");\n\t    //  console.log(JSON.stringify(ppg));\n\t    var result = false;\n\t    for (var i = 0, ilen = ppg.length; i < ilen; ++i)\n\t      if (this.AddPath(ppg[i], polyType, closed))\n\t        result = true;\n\t    return result;\n\t  };\n\t  //------------------------------------------------------------------------------\n\t  ClipperLib.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3 = function (pt1, pt2, pt3)\n\t  {\n\t    if ((ClipperLib.IntPoint.op_Equality(pt1, pt3)) || (ClipperLib.IntPoint.op_Equality(pt1, pt2)) ||       (ClipperLib.IntPoint.op_Equality(pt3, pt2)))\n\t\n\t   //if ((pt1 == pt3) || (pt1 == pt2) || (pt3 == pt2))\n\t   return false;\n\t\n\t    else if (pt1.X != pt3.X)\n\t      return (pt2.X > pt1.X) == (pt2.X < pt3.X);\n\t    else\n\t      return (pt2.Y > pt1.Y) == (pt2.Y < pt3.Y);\n\t  };\n\t  ClipperLib.ClipperBase.prototype.RemoveEdge = function (e)\n\t  {\n\t    //removes e from double_linked_list (but without removing from memory)\n\t    e.Prev.Next = e.Next;\n\t    e.Next.Prev = e.Prev;\n\t    var result = e.Next;\n\t    e.Prev = null; //flag as removed (see ClipperBase.Clear)\n\t    return result;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.SetDx = function (e)\n\t  {\n\t    e.Delta.X = (e.Top.X - e.Bot.X);\n\t    e.Delta.Y = (e.Top.Y - e.Bot.Y);\n\t    if (e.Delta.Y === 0) e.Dx = ClipperLib.ClipperBase.horizontal;\n\t    else e.Dx = (e.Delta.X) / (e.Delta.Y);\n\t  };\n\t  ClipperLib.ClipperBase.prototype.InsertLocalMinima = function (newLm)\n\t  {\n\t    if (this.m_MinimaList === null)\n\t    {\n\t      this.m_MinimaList = newLm;\n\t    }\n\t    else if (newLm.Y >= this.m_MinimaList.Y)\n\t    {\n\t      newLm.Next = this.m_MinimaList;\n\t      this.m_MinimaList = newLm;\n\t    }\n\t    else\n\t    {\n\t      var tmpLm = this.m_MinimaList;\n\t      while (tmpLm.Next !== null && (newLm.Y < tmpLm.Next.Y))\n\t        tmpLm = tmpLm.Next;\n\t      newLm.Next = tmpLm.Next;\n\t      tmpLm.Next = newLm;\n\t    }\n\t  };\n\t  ClipperLib.ClipperBase.prototype.PopLocalMinima = function ()\n\t  {\n\t    if (this.m_CurrentLM === null)\n\t      return;\n\t    this.m_CurrentLM = this.m_CurrentLM.Next;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.ReverseHorizontal = function (e)\n\t  {\n\t    //swap horizontal edges' top and bottom x's so they follow the natural\n\t    //progression of the bounds - ie so their xbots will align with the\n\t    //adjoining lower edge. [Helpful in the ProcessHorizontal() method.]\n\t    var tmp = e.Top.X;\n\t    e.Top.X = e.Bot.X;\n\t    e.Bot.X = tmp;\n\t    if (use_xyz)\n\t    {\n\t      tmp = e.Top.Z;\n\t      e.Top.Z = e.Bot.Z;\n\t      e.Bot.Z = tmp;\n\t    }\n\t  };\n\t  ClipperLib.ClipperBase.prototype.Reset = function ()\n\t  {\n\t    this.m_CurrentLM = this.m_MinimaList;\n\t    if (this.m_CurrentLM == null)\n\t      return;\n\t    //ie nothing to process\n\t    //reset all edges ...\n\t    var lm = this.m_MinimaList;\n\t    while (lm != null)\n\t    {\n\t      var e = lm.LeftBound;\n\t      if (e != null)\n\t      {\n\t        //e.Curr = e.Bot;\n\t        e.Curr.X = e.Bot.X;\n\t        e.Curr.Y = e.Bot.Y;\n\t        e.Side = ClipperLib.EdgeSide.esLeft;\n\t        e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n\t      }\n\t      e = lm.RightBound;\n\t      if (e != null)\n\t      {\n\t        //e.Curr = e.Bot;\n\t        e.Curr.X = e.Bot.X;\n\t        e.Curr.Y = e.Bot.Y;\n\t        e.Side = ClipperLib.EdgeSide.esRight;\n\t        e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n\t      }\n\t      lm = lm.Next;\n\t    }\n\t  };\n\t  ClipperLib.Clipper = function (InitOptions) // public Clipper(int InitOptions = 0)\n\t  {\n\t    if (typeof (InitOptions) == \"undefined\") InitOptions = 0;\n\t    this.m_PolyOuts = null;\n\t    this.m_ClipType = ClipperLib.ClipType.ctIntersection;\n\t    this.m_Scanbeam = null;\n\t    this.m_ActiveEdges = null;\n\t    this.m_SortedEdges = null;\n\t    this.m_IntersectList = null;\n\t    this.m_IntersectNodeComparer = null;\n\t    this.m_ExecuteLocked = false;\n\t    this.m_ClipFillType = ClipperLib.PolyFillType.pftEvenOdd;\n\t    this.m_SubjFillType = ClipperLib.PolyFillType.pftEvenOdd;\n\t    this.m_Joins = null;\n\t    this.m_GhostJoins = null;\n\t    this.m_UsingPolyTree = false;\n\t    this.ReverseSolution = false;\n\t    this.StrictlySimple = false;\n\t    ClipperLib.ClipperBase.call(this);\n\t    this.m_Scanbeam = null;\n\t    this.m_ActiveEdges = null;\n\t    this.m_SortedEdges = null;\n\t    this.m_IntersectList = new Array();\n\t    this.m_IntersectNodeComparer = ClipperLib.MyIntersectNodeSort.Compare;\n\t    this.m_ExecuteLocked = false;\n\t    this.m_UsingPolyTree = false;\n\t    this.m_PolyOuts = new Array();\n\t    this.m_Joins = new Array();\n\t    this.m_GhostJoins = new Array();\n\t    this.ReverseSolution = (1 & InitOptions) !== 0;\n\t    this.StrictlySimple = (2 & InitOptions) !== 0;\n\t    this.PreserveCollinear = (4 & InitOptions) !== 0;\n\t    if (use_xyz)\n\t    {\n\t      this.ZFillFunction = null; // function (IntPoint vert1, IntPoint vert2, ref IntPoint intersectPt);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.ioReverseSolution = 1;\n\t  ClipperLib.Clipper.ioStrictlySimple = 2;\n\t  ClipperLib.Clipper.ioPreserveCollinear = 4;\n\t\n\t  ClipperLib.Clipper.prototype.Clear = function ()\n\t  {\n\t    if (this.m_edges.length === 0)\n\t      return;\n\t    //avoids problems with ClipperBase destructor\n\t    this.DisposeAllPolyPts();\n\t    ClipperLib.ClipperBase.prototype.Clear.call(this);\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.DisposeScanbeamList = function ()\n\t  {\n\t    while (this.m_Scanbeam !== null)\n\t    {\n\t      var sb2 = this.m_Scanbeam.Next;\n\t      this.m_Scanbeam = null;\n\t      this.m_Scanbeam = sb2;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.Reset = function ()\n\t  {\n\t    ClipperLib.ClipperBase.prototype.Reset.call(this);\n\t    this.m_Scanbeam = null;\n\t    this.m_ActiveEdges = null;\n\t    this.m_SortedEdges = null;\n\t\n\t    var lm = this.m_MinimaList;\n\t    while (lm !== null)\n\t    {\n\t      this.InsertScanbeam(lm.Y);\n\t      lm = lm.Next;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.InsertScanbeam = function (Y)\n\t  {\n\t    if (this.m_Scanbeam === null)\n\t    {\n\t      this.m_Scanbeam = new ClipperLib.Scanbeam();\n\t      this.m_Scanbeam.Next = null;\n\t      this.m_Scanbeam.Y = Y;\n\t    }\n\t    else if (Y > this.m_Scanbeam.Y)\n\t    {\n\t      var newSb = new ClipperLib.Scanbeam();\n\t      newSb.Y = Y;\n\t      newSb.Next = this.m_Scanbeam;\n\t      this.m_Scanbeam = newSb;\n\t    }\n\t    else\n\t    {\n\t      var sb2 = this.m_Scanbeam;\n\t      while (sb2.Next !== null && (Y <= sb2.Next.Y))\n\t        sb2 = sb2.Next;\n\t      if (Y == sb2.Y)\n\t        return;\n\t      //ie ignores duplicates\n\t      var newSb = new ClipperLib.Scanbeam();\n\t      newSb.Y = Y;\n\t      newSb.Next = sb2.Next;\n\t      sb2.Next = newSb;\n\t    }\n\t  };\n\t  // ************************************\n\t  ClipperLib.Clipper.prototype.Execute = function ()\n\t  {\n\t    var a = arguments,\n\t      alen = a.length,\n\t      ispolytree = a[1] instanceof ClipperLib.PolyTree;\n\t    if (alen == 4 && !ispolytree) // function (clipType, solution, subjFillType, clipFillType)\n\t    {\n\t      var clipType = a[0],\n\t        solution = a[1],\n\t        subjFillType = a[2],\n\t        clipFillType = a[3];\n\t      if (this.m_ExecuteLocked)\n\t        return false;\n\t      if (this.m_HasOpenPaths)\n\t        ClipperLib.Error(\"Error: PolyTree struct is need for open path clipping.\");\n\t      this.m_ExecuteLocked = true;\n\t      ClipperLib.Clear(solution);\n\t      this.m_SubjFillType = subjFillType;\n\t      this.m_ClipFillType = clipFillType;\n\t      this.m_ClipType = clipType;\n\t      this.m_UsingPolyTree = false;\n\t      try\n\t      {\n\t        var succeeded = this.ExecuteInternal();\n\t        //build the return polygons ...\n\t        if (succeeded) this.BuildResult(solution);\n\t      }\n\t      finally\n\t      {\n\t        this.DisposeAllPolyPts();\n\t        this.m_ExecuteLocked = false;\n\t      }\n\t      return succeeded;\n\t    }\n\t    else if (alen == 4 && ispolytree) // function (clipType, polytree, subjFillType, clipFillType)\n\t    {\n\t      var clipType = a[0],\n\t        polytree = a[1],\n\t        subjFillType = a[2],\n\t        clipFillType = a[3];\n\t      if (this.m_ExecuteLocked)\n\t        return false;\n\t      this.m_ExecuteLocked = true;\n\t      this.m_SubjFillType = subjFillType;\n\t      this.m_ClipFillType = clipFillType;\n\t      this.m_ClipType = clipType;\n\t      this.m_UsingPolyTree = true;\n\t      try\n\t      {\n\t        var succeeded = this.ExecuteInternal();\n\t        //build the return polygons ...\n\t        if (succeeded) this.BuildResult2(polytree);\n\t      }\n\t      finally\n\t      {\n\t        this.DisposeAllPolyPts();\n\t        this.m_ExecuteLocked = false;\n\t      }\n\t      return succeeded;\n\t    }\n\t    else if (alen == 2 && !ispolytree) // function (clipType, solution)\n\t    {\n\t      var clipType = a[0],\n\t        solution = a[1];\n\t      return this.Execute(clipType, solution, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n\t    }\n\t    else if (alen == 2 && ispolytree) // function (clipType, polytree)\n\t    {\n\t      var clipType = a[0],\n\t        polytree = a[1];\n\t      return this.Execute(clipType, polytree, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.FixHoleLinkage = function (outRec)\n\t  {\n\t    //skip if an outermost polygon or\n\t    //already already points to the correct FirstLeft ...\n\t    if (outRec.FirstLeft === null || (outRec.IsHole != outRec.FirstLeft.IsHole && outRec.FirstLeft.Pts !== null))\n\t      return;\n\t    var orfl = outRec.FirstLeft;\n\t    while (orfl !== null && ((orfl.IsHole == outRec.IsHole) || orfl.Pts === null))\n\t      orfl = orfl.FirstLeft;\n\t    outRec.FirstLeft = orfl;\n\t  };\n\t  ClipperLib.Clipper.prototype.ExecuteInternal = function ()\n\t  {\n\t    try\n\t    {\n\t      this.Reset();\n\t      if (this.m_CurrentLM === null)\n\t        return false;\n\t      var botY = this.PopScanbeam();\n\t      do {\n\t        this.InsertLocalMinimaIntoAEL(botY);\n\t        ClipperLib.Clear(this.m_GhostJoins);\n\t        this.ProcessHorizontals(false);\n\t        if (this.m_Scanbeam === null)\n\t          break;\n\t        var topY = this.PopScanbeam();\n\t        if (!this.ProcessIntersections(topY)) return false;\n\t\n\t        this.ProcessEdgesAtTopOfScanbeam(topY);\n\t        botY = topY;\n\t      }\n\t      while (this.m_Scanbeam !== null || this.m_CurrentLM !== null)\n\t      //fix orientations ...\n\t      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t      {\n\t        var outRec = this.m_PolyOuts[i];\n\t        if (outRec.Pts === null || outRec.IsOpen)\n\t          continue;\n\t        if ((outRec.IsHole ^ this.ReverseSolution) == (this.Area(outRec) > 0))\n\t          this.ReversePolyPtLinks(outRec.Pts);\n\t      }\n\t      this.JoinCommonEdges();\n\t      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t      {\n\t        var outRec = this.m_PolyOuts[i];\n\t        if (outRec.Pts !== null && !outRec.IsOpen)\n\t          this.FixupOutPolygon(outRec);\n\t      }\n\t      if (this.StrictlySimple)\n\t        this.DoSimplePolygons();\n\t      return true;\n\t    }\n\t    finally\n\t    {\n\t      ClipperLib.Clear(this.m_Joins);\n\t      ClipperLib.Clear(this.m_GhostJoins);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.PopScanbeam = function ()\n\t  {\n\t    var Y = this.m_Scanbeam.Y;\n\t    this.m_Scanbeam = this.m_Scanbeam.Next;\n\t    return Y;\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.DisposeAllPolyPts = function ()\n\t  {\n\t    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; ++i)\n\t      this.DisposeOutRec(i);\n\t    ClipperLib.Clear(this.m_PolyOuts);\n\t  };\n\t  ClipperLib.Clipper.prototype.DisposeOutRec = function (index)\n\t  {\n\t    var outRec = this.m_PolyOuts[index];\n\t    outRec.Pts = null;\n\t    outRec = null;\n\t    this.m_PolyOuts[index] = null;\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.AddJoin = function (Op1, Op2, OffPt)\n\t  {\n\t    var j = new ClipperLib.Join();\n\t    j.OutPt1 = Op1;\n\t    j.OutPt2 = Op2;\n\t    //j.OffPt = OffPt;\n\t    j.OffPt.X = OffPt.X;\n\t    j.OffPt.Y = OffPt.Y;\n\t    this.m_Joins.push(j);\n\t  };\n\t  ClipperLib.Clipper.prototype.AddGhostJoin = function (Op, OffPt)\n\t  {\n\t    var j = new ClipperLib.Join();\n\t    j.OutPt1 = Op;\n\t    //j.OffPt = OffPt;\n\t    j.OffPt.X = OffPt.X;\n\t    j.OffPt.Y = OffPt.Y;\n\t    this.m_GhostJoins.push(j);\n\t  };\n\t  if (use_xyz)\n\t  {\n\t    ClipperLib.Clipper.prototype.SetZ = function (pt, e1, e2)\n\t    {\n\t      if (this.ZFillFunction !== null)\n\t      {\n\t        if (pt.Z != 0 || this.ZFillFunction === null) return;\n\t        else if (ClipperLib.IntPoint.op_Equality(pt, e1.Bot)) pt.Z = e1.Bot.Z;\n\t        else if (ClipperLib.IntPoint.op_Equality(pt, e1.Top)) pt.Z = e1.Top.Z;\n\t        else if (ClipperLib.IntPoint.op_Equality(pt, e2.Bot)) pt.Z = e2.Bot.Z;\n\t        else if (ClipperLib.IntPoint.op_Equality(pt, e2.Top)) pt.Z = e2.Top.Z;\n\t        else ZFillFunction(e1.Bot, e1.Top, e2.Bot, e2.Top, pt);\n\t      }\n\t    };\n\t\n\t    //------------------------------------------------------------------------------\n\t  }\n\t\n\t  ClipperLib.Clipper.prototype.InsertLocalMinimaIntoAEL = function (botY)\n\t  {\n\t    while (this.m_CurrentLM !== null && (this.m_CurrentLM.Y == botY))\n\t    {\n\t      var lb = this.m_CurrentLM.LeftBound;\n\t      var rb = this.m_CurrentLM.RightBound;\n\t      this.PopLocalMinima();\n\t      var Op1 = null;\n\t      if (lb === null)\n\t      {\n\t        this.InsertEdgeIntoAEL(rb, null);\n\t        this.SetWindingCount(rb);\n\t        if (this.IsContributing(rb))\n\t          Op1 = this.AddOutPt(rb, rb.Bot);\n\t      }\n\t      else if (rb == null)\n\t      {\n\t        this.InsertEdgeIntoAEL(lb, null);\n\t        this.SetWindingCount(lb);\n\t        if (this.IsContributing(lb))\n\t          Op1 = this.AddOutPt(lb, lb.Bot);\n\t        this.InsertScanbeam(lb.Top.Y);\n\t      }\n\t      else\n\t      {\n\t        this.InsertEdgeIntoAEL(lb, null);\n\t        this.InsertEdgeIntoAEL(rb, lb);\n\t        this.SetWindingCount(lb);\n\t        rb.WindCnt = lb.WindCnt;\n\t        rb.WindCnt2 = lb.WindCnt2;\n\t        if (this.IsContributing(lb))\n\t          Op1 = this.AddLocalMinPoly(lb, rb, lb.Bot);\n\t        this.InsertScanbeam(lb.Top.Y);\n\t      }\n\t      if (rb != null)\n\t      {\n\t        if (ClipperLib.ClipperBase.IsHorizontal(rb))\n\t          this.AddEdgeToSEL(rb);\n\t        else\n\t          this.InsertScanbeam(rb.Top.Y);\n\t      }\n\t      if (lb == null || rb == null) continue;\n\t      //if output polygons share an Edge with a horizontal rb, they'll need joining later ...\n\t      if (Op1 !== null && ClipperLib.ClipperBase.IsHorizontal(rb) && this.m_GhostJoins.length > 0 && rb.WindDelta !== 0)\n\t      {\n\t        for (var i = 0, ilen = this.m_GhostJoins.length; i < ilen; i++)\n\t        {\n\t          //if the horizontal Rb and a 'ghost' horizontal overlap, then convert\n\t          //the 'ghost' join to a real join ready for later ...\n\t          var j = this.m_GhostJoins[i];\n\t\n\t\t\t\t\t\tif (this.HorzSegmentsOverlap(j.OutPt1.Pt.X, j.OffPt.X, rb.Bot.X, rb.Top.X))\n\t            this.AddJoin(j.OutPt1, Op1, j.OffPt);\n\t        }\n\t      }\n\t      if (lb.OutIdx >= 0 && lb.PrevInAEL !== null &&\n\t        lb.PrevInAEL.Curr.X == lb.Bot.X &&\n\t        lb.PrevInAEL.OutIdx >= 0 &&\n\t        ClipperLib.ClipperBase.SlopesEqual(lb.PrevInAEL, lb, this.m_UseFullRange) &&\n\t        lb.WindDelta !== 0 && lb.PrevInAEL.WindDelta !== 0)\n\t      {\n\t        var Op2 = this.AddOutPt(lb.PrevInAEL, lb.Bot);\n\t        this.AddJoin(Op1, Op2, lb.Top);\n\t      }\n\t      if (lb.NextInAEL != rb)\n\t      {\n\t        if (rb.OutIdx >= 0 && rb.PrevInAEL.OutIdx >= 0 &&\n\t          ClipperLib.ClipperBase.SlopesEqual(rb.PrevInAEL, rb, this.m_UseFullRange) &&\n\t          rb.WindDelta !== 0 && rb.PrevInAEL.WindDelta !== 0)\n\t        {\n\t          var Op2 = this.AddOutPt(rb.PrevInAEL, rb.Bot);\n\t          this.AddJoin(Op1, Op2, rb.Top);\n\t        }\n\t        var e = lb.NextInAEL;\n\t        if (e !== null)\n\t          while (e != rb)\n\t          {\n\t            //nb: For calculating winding counts etc, IntersectEdges() assumes\n\t            //that param1 will be to the right of param2 ABOVE the intersection ...\n\t            this.IntersectEdges(rb, e, lb.Curr, false);\n\t            //order important here\n\t            e = e.NextInAEL;\n\t          }\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.InsertEdgeIntoAEL = function (edge, startEdge)\n\t  {\n\t    if (this.m_ActiveEdges === null)\n\t    {\n\t      edge.PrevInAEL = null;\n\t      edge.NextInAEL = null;\n\t      this.m_ActiveEdges = edge;\n\t    }\n\t    else if (startEdge === null && this.E2InsertsBeforeE1(this.m_ActiveEdges, edge))\n\t    {\n\t      edge.PrevInAEL = null;\n\t      edge.NextInAEL = this.m_ActiveEdges;\n\t      this.m_ActiveEdges.PrevInAEL = edge;\n\t      this.m_ActiveEdges = edge;\n\t    }\n\t    else\n\t    {\n\t      if (startEdge === null)\n\t        startEdge = this.m_ActiveEdges;\n\t      while (startEdge.NextInAEL !== null && !this.E2InsertsBeforeE1(startEdge.NextInAEL, edge))\n\t        startEdge = startEdge.NextInAEL;\n\t      edge.NextInAEL = startEdge.NextInAEL;\n\t      if (startEdge.NextInAEL !== null)\n\t        startEdge.NextInAEL.PrevInAEL = edge;\n\t      edge.PrevInAEL = startEdge;\n\t      startEdge.NextInAEL = edge;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.E2InsertsBeforeE1 = function (e1, e2)\n\t  {\n\t    if (e2.Curr.X == e1.Curr.X)\n\t    {\n\t      if (e2.Top.Y > e1.Top.Y)\n\t        return e2.Top.X < ClipperLib.Clipper.TopX(e1, e2.Top.Y);\n\t      else\n\t        return e1.Top.X > ClipperLib.Clipper.TopX(e2, e1.Top.Y);\n\t    }\n\t    else\n\t      return e2.Curr.X < e1.Curr.X;\n\t  };\n\t  ClipperLib.Clipper.prototype.IsEvenOddFillType = function (edge)\n\t  {\n\t    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t      return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n\t    else\n\t      return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n\t  };\n\t  ClipperLib.Clipper.prototype.IsEvenOddAltFillType = function (edge)\n\t  {\n\t    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t      return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n\t    else\n\t      return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n\t  };\n\t  ClipperLib.Clipper.prototype.IsContributing = function (edge)\n\t  {\n\t    var pft, pft2;\n\t    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t    {\n\t      pft = this.m_SubjFillType;\n\t      pft2 = this.m_ClipFillType;\n\t    }\n\t    else\n\t    {\n\t      pft = this.m_ClipFillType;\n\t      pft2 = this.m_SubjFillType;\n\t    }\n\t    switch (pft)\n\t    {\n\t    case ClipperLib.PolyFillType.pftEvenOdd:\n\t      if (edge.WindDelta === 0 && edge.WindCnt != 1)\n\t        return false;\n\t      break;\n\t    case ClipperLib.PolyFillType.pftNonZero:\n\t      if (Math.abs(edge.WindCnt) != 1)\n\t        return false;\n\t      break;\n\t    case ClipperLib.PolyFillType.pftPositive:\n\t      if (edge.WindCnt != 1)\n\t        return false;\n\t      break;\n\t    default:\n\t      if (edge.WindCnt != -1)\n\t        return false;\n\t      break;\n\t    }\n\t    switch (this.m_ClipType)\n\t    {\n\t    case ClipperLib.ClipType.ctIntersection:\n\t      switch (pft2)\n\t      {\n\t      case ClipperLib.PolyFillType.pftEvenOdd:\n\t      case ClipperLib.PolyFillType.pftNonZero:\n\t        return (edge.WindCnt2 !== 0);\n\t      case ClipperLib.PolyFillType.pftPositive:\n\t        return (edge.WindCnt2 > 0);\n\t      default:\n\t        return (edge.WindCnt2 < 0);\n\t      }\n\t    case ClipperLib.ClipType.ctUnion:\n\t      switch (pft2)\n\t      {\n\t      case ClipperLib.PolyFillType.pftEvenOdd:\n\t      case ClipperLib.PolyFillType.pftNonZero:\n\t        return (edge.WindCnt2 === 0);\n\t      case ClipperLib.PolyFillType.pftPositive:\n\t        return (edge.WindCnt2 <= 0);\n\t      default:\n\t        return (edge.WindCnt2 >= 0);\n\t      }\n\t    case ClipperLib.ClipType.ctDifference:\n\t      if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t        switch (pft2)\n\t        {\n\t        case ClipperLib.PolyFillType.pftEvenOdd:\n\t        case ClipperLib.PolyFillType.pftNonZero:\n\t          return (edge.WindCnt2 === 0);\n\t        case ClipperLib.PolyFillType.pftPositive:\n\t          return (edge.WindCnt2 <= 0);\n\t        default:\n\t          return (edge.WindCnt2 >= 0);\n\t        }\n\t      else\n\t        switch (pft2)\n\t        {\n\t        case ClipperLib.PolyFillType.pftEvenOdd:\n\t        case ClipperLib.PolyFillType.pftNonZero:\n\t          return (edge.WindCnt2 !== 0);\n\t        case ClipperLib.PolyFillType.pftPositive:\n\t          return (edge.WindCnt2 > 0);\n\t        default:\n\t          return (edge.WindCnt2 < 0);\n\t        }\n\t    case ClipperLib.ClipType.ctXor:\n\t      if (edge.WindDelta === 0)\n\t        switch (pft2)\n\t        {\n\t        case ClipperLib.PolyFillType.pftEvenOdd:\n\t        case ClipperLib.PolyFillType.pftNonZero:\n\t          return (edge.WindCnt2 === 0);\n\t        case ClipperLib.PolyFillType.pftPositive:\n\t          return (edge.WindCnt2 <= 0);\n\t        default:\n\t          return (edge.WindCnt2 >= 0);\n\t        }\n\t      else\n\t        return true;\n\t    }\n\t    return true;\n\t  };\n\t  ClipperLib.Clipper.prototype.SetWindingCount = function (edge)\n\t  {\n\t    var e = edge.PrevInAEL;\n\t    //find the edge of the same polytype that immediately preceeds 'edge' in AEL\n\t    while (e !== null && ((e.PolyTyp != edge.PolyTyp) || (e.WindDelta === 0)))\n\t      e = e.PrevInAEL;\n\t    if (e === null)\n\t    {\n\t      edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n\t      edge.WindCnt2 = 0;\n\t      e = this.m_ActiveEdges;\n\t      //ie get ready to calc WindCnt2\n\t    }\n\t    else if (edge.WindDelta === 0 && this.m_ClipType != ClipperLib.ClipType.ctUnion)\n\t    {\n\t      edge.WindCnt = 1;\n\t      edge.WindCnt2 = e.WindCnt2;\n\t      e = e.NextInAEL;\n\t      //ie get ready to calc WindCnt2\n\t    }\n\t    else if (this.IsEvenOddFillType(edge))\n\t    {\n\t      //EvenOdd filling ...\n\t      if (edge.WindDelta === 0)\n\t      {\n\t        //are we inside a subj polygon ...\n\t        var Inside = true;\n\t        var e2 = e.PrevInAEL;\n\t        while (e2 !== null)\n\t        {\n\t          if (e2.PolyTyp == e.PolyTyp && e2.WindDelta !== 0)\n\t            Inside = !Inside;\n\t          e2 = e2.PrevInAEL;\n\t        }\n\t        edge.WindCnt = (Inside ? 0 : 1);\n\t      }\n\t      else\n\t      {\n\t        edge.WindCnt = edge.WindDelta;\n\t      }\n\t      edge.WindCnt2 = e.WindCnt2;\n\t      e = e.NextInAEL;\n\t      //ie get ready to calc WindCnt2\n\t    }\n\t    else\n\t    {\n\t      //nonZero, Positive or Negative filling ...\n\t      if (e.WindCnt * e.WindDelta < 0)\n\t      {\n\t        //prev edge is 'decreasing' WindCount (WC) toward zero\n\t        //so we're outside the previous polygon ...\n\t        if (Math.abs(e.WindCnt) > 1)\n\t        {\n\t          //outside prev poly but still inside another.\n\t          //when reversing direction of prev poly use the same WC\n\t          if (e.WindDelta * edge.WindDelta < 0)\n\t            edge.WindCnt = e.WindCnt;\n\t          else\n\t            edge.WindCnt = e.WindCnt + edge.WindDelta;\n\t        }\n\t        else\n\t          edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n\t      }\n\t      else\n\t      {\n\t        //prev edge is 'increasing' WindCount (WC) away from zero\n\t        //so we're inside the previous polygon ...\n\t        if (edge.WindDelta === 0)\n\t          edge.WindCnt = (e.WindCnt < 0 ? e.WindCnt - 1 : e.WindCnt + 1);\n\t        else if (e.WindDelta * edge.WindDelta < 0)\n\t          edge.WindCnt = e.WindCnt;\n\t        else\n\t          edge.WindCnt = e.WindCnt + edge.WindDelta;\n\t      }\n\t      edge.WindCnt2 = e.WindCnt2;\n\t      e = e.NextInAEL;\n\t      //ie get ready to calc WindCnt2\n\t    }\n\t    //update WindCnt2 ...\n\t    if (this.IsEvenOddAltFillType(edge))\n\t    {\n\t      //EvenOdd filling ...\n\t      while (e != edge)\n\t      {\n\t        if (e.WindDelta !== 0)\n\t          edge.WindCnt2 = (edge.WindCnt2 === 0 ? 1 : 0);\n\t        e = e.NextInAEL;\n\t      }\n\t    }\n\t    else\n\t    {\n\t      //nonZero, Positive or Negative filling ...\n\t      while (e != edge)\n\t      {\n\t        edge.WindCnt2 += e.WindDelta;\n\t        e = e.NextInAEL;\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.AddEdgeToSEL = function (edge)\n\t  {\n\t    //SEL pointers in PEdge are reused to build a list of horizontal edges.\n\t    //However, we don't need to worry about order with horizontal edge processing.\n\t    if (this.m_SortedEdges === null)\n\t    {\n\t      this.m_SortedEdges = edge;\n\t      edge.PrevInSEL = null;\n\t      edge.NextInSEL = null;\n\t    }\n\t    else\n\t    {\n\t      edge.NextInSEL = this.m_SortedEdges;\n\t      edge.PrevInSEL = null;\n\t      this.m_SortedEdges.PrevInSEL = edge;\n\t      this.m_SortedEdges = edge;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.CopyAELToSEL = function ()\n\t  {\n\t    var e = this.m_ActiveEdges;\n\t    this.m_SortedEdges = e;\n\t    while (e !== null)\n\t    {\n\t      e.PrevInSEL = e.PrevInAEL;\n\t      e.NextInSEL = e.NextInAEL;\n\t      e = e.NextInAEL;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.SwapPositionsInAEL = function (edge1, edge2)\n\t  {\n\t    //check that one or other edge hasn't already been removed from AEL ...\n\t    if (edge1.NextInAEL == edge1.PrevInAEL || edge2.NextInAEL == edge2.PrevInAEL)\n\t      return;\n\t    if (edge1.NextInAEL == edge2)\n\t    {\n\t      var next = edge2.NextInAEL;\n\t      if (next !== null)\n\t        next.PrevInAEL = edge1;\n\t      var prev = edge1.PrevInAEL;\n\t      if (prev !== null)\n\t        prev.NextInAEL = edge2;\n\t      edge2.PrevInAEL = prev;\n\t      edge2.NextInAEL = edge1;\n\t      edge1.PrevInAEL = edge2;\n\t      edge1.NextInAEL = next;\n\t    }\n\t    else if (edge2.NextInAEL == edge1)\n\t    {\n\t      var next = edge1.NextInAEL;\n\t      if (next !== null)\n\t        next.PrevInAEL = edge2;\n\t      var prev = edge2.PrevInAEL;\n\t      if (prev !== null)\n\t        prev.NextInAEL = edge1;\n\t      edge1.PrevInAEL = prev;\n\t      edge1.NextInAEL = edge2;\n\t      edge2.PrevInAEL = edge1;\n\t      edge2.NextInAEL = next;\n\t    }\n\t    else\n\t    {\n\t      var next = edge1.NextInAEL;\n\t      var prev = edge1.PrevInAEL;\n\t      edge1.NextInAEL = edge2.NextInAEL;\n\t      if (edge1.NextInAEL !== null)\n\t        edge1.NextInAEL.PrevInAEL = edge1;\n\t      edge1.PrevInAEL = edge2.PrevInAEL;\n\t      if (edge1.PrevInAEL !== null)\n\t        edge1.PrevInAEL.NextInAEL = edge1;\n\t      edge2.NextInAEL = next;\n\t      if (edge2.NextInAEL !== null)\n\t        edge2.NextInAEL.PrevInAEL = edge2;\n\t      edge2.PrevInAEL = prev;\n\t      if (edge2.PrevInAEL !== null)\n\t        edge2.PrevInAEL.NextInAEL = edge2;\n\t    }\n\t    if (edge1.PrevInAEL === null)\n\t      this.m_ActiveEdges = edge1;\n\t    else if (edge2.PrevInAEL === null)\n\t      this.m_ActiveEdges = edge2;\n\t  };\n\t  ClipperLib.Clipper.prototype.SwapPositionsInSEL = function (edge1, edge2)\n\t  {\n\t    if (edge1.NextInSEL === null && edge1.PrevInSEL === null)\n\t      return;\n\t    if (edge2.NextInSEL === null && edge2.PrevInSEL === null)\n\t      return;\n\t    if (edge1.NextInSEL == edge2)\n\t    {\n\t      var next = edge2.NextInSEL;\n\t      if (next !== null)\n\t        next.PrevInSEL = edge1;\n\t      var prev = edge1.PrevInSEL;\n\t      if (prev !== null)\n\t        prev.NextInSEL = edge2;\n\t      edge2.PrevInSEL = prev;\n\t      edge2.NextInSEL = edge1;\n\t      edge1.PrevInSEL = edge2;\n\t      edge1.NextInSEL = next;\n\t    }\n\t    else if (edge2.NextInSEL == edge1)\n\t    {\n\t      var next = edge1.NextInSEL;\n\t      if (next !== null)\n\t        next.PrevInSEL = edge2;\n\t      var prev = edge2.PrevInSEL;\n\t      if (prev !== null)\n\t        prev.NextInSEL = edge1;\n\t      edge1.PrevInSEL = prev;\n\t      edge1.NextInSEL = edge2;\n\t      edge2.PrevInSEL = edge1;\n\t      edge2.NextInSEL = next;\n\t    }\n\t    else\n\t    {\n\t      var next = edge1.NextInSEL;\n\t      var prev = edge1.PrevInSEL;\n\t      edge1.NextInSEL = edge2.NextInSEL;\n\t      if (edge1.NextInSEL !== null)\n\t        edge1.NextInSEL.PrevInSEL = edge1;\n\t      edge1.PrevInSEL = edge2.PrevInSEL;\n\t      if (edge1.PrevInSEL !== null)\n\t        edge1.PrevInSEL.NextInSEL = edge1;\n\t      edge2.NextInSEL = next;\n\t      if (edge2.NextInSEL !== null)\n\t        edge2.NextInSEL.PrevInSEL = edge2;\n\t      edge2.PrevInSEL = prev;\n\t      if (edge2.PrevInSEL !== null)\n\t        edge2.PrevInSEL.NextInSEL = edge2;\n\t    }\n\t    if (edge1.PrevInSEL === null)\n\t      this.m_SortedEdges = edge1;\n\t    else if (edge2.PrevInSEL === null)\n\t      this.m_SortedEdges = edge2;\n\t  };\n\t  ClipperLib.Clipper.prototype.AddLocalMaxPoly = function (e1, e2, pt)\n\t  {\n\t    this.AddOutPt(e1, pt);\n\t    if (e2.WindDelta == 0) this.AddOutPt(e2, pt);\n\t    if (e1.OutIdx == e2.OutIdx)\n\t    {\n\t      e1.OutIdx = -1;\n\t      e2.OutIdx = -1;\n\t    }\n\t    else if (e1.OutIdx < e2.OutIdx)\n\t      this.AppendPolygon(e1, e2);\n\t    else\n\t      this.AppendPolygon(e2, e1);\n\t  };\n\t  ClipperLib.Clipper.prototype.AddLocalMinPoly = function (e1, e2, pt)\n\t  {\n\t    var result;\n\t    var e, prevE;\n\t    if (ClipperLib.ClipperBase.IsHorizontal(e2) || (e1.Dx > e2.Dx))\n\t    {\n\t      result = this.AddOutPt(e1, pt);\n\t      e2.OutIdx = e1.OutIdx;\n\t      e1.Side = ClipperLib.EdgeSide.esLeft;\n\t      e2.Side = ClipperLib.EdgeSide.esRight;\n\t      e = e1;\n\t      if (e.PrevInAEL == e2)\n\t        prevE = e2.PrevInAEL;\n\t      else\n\t        prevE = e.PrevInAEL;\n\t    }\n\t    else\n\t    {\n\t      result = this.AddOutPt(e2, pt);\n\t      e1.OutIdx = e2.OutIdx;\n\t      e1.Side = ClipperLib.EdgeSide.esRight;\n\t      e2.Side = ClipperLib.EdgeSide.esLeft;\n\t      e = e2;\n\t      if (e.PrevInAEL == e1)\n\t        prevE = e1.PrevInAEL;\n\t      else\n\t        prevE = e.PrevInAEL;\n\t    }\n\t    if (prevE !== null && prevE.OutIdx >= 0 && (ClipperLib.Clipper.TopX(prevE, pt.Y) == ClipperLib.Clipper.TopX(e, pt.Y)) && ClipperLib.ClipperBase.SlopesEqual(e, prevE, this.m_UseFullRange) && (e.WindDelta !== 0) && (prevE.WindDelta !== 0))\n\t    {\n\t      var outPt = this.AddOutPt(prevE, pt);\n\t      this.AddJoin(result, outPt, e.Top);\n\t    }\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.prototype.CreateOutRec = function ()\n\t  {\n\t    var result = new ClipperLib.OutRec();\n\t    result.Idx = -1;\n\t    result.IsHole = false;\n\t    result.IsOpen = false;\n\t    result.FirstLeft = null;\n\t    result.Pts = null;\n\t    result.BottomPt = null;\n\t    result.PolyNode = null;\n\t    this.m_PolyOuts.push(result);\n\t    result.Idx = this.m_PolyOuts.length - 1;\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.prototype.AddOutPt = function (e, pt)\n\t  {\n\t    var ToFront = (e.Side == ClipperLib.EdgeSide.esLeft);\n\t    if (e.OutIdx < 0)\n\t    {\n\t      var outRec = this.CreateOutRec();\n\t      outRec.IsOpen = (e.WindDelta === 0);\n\t      var newOp = new ClipperLib.OutPt();\n\t      outRec.Pts = newOp;\n\t      newOp.Idx = outRec.Idx;\n\t      //newOp.Pt = pt;\n\t      newOp.Pt.X = pt.X;\n\t      newOp.Pt.Y = pt.Y;\n\t      newOp.Next = newOp;\n\t      newOp.Prev = newOp;\n\t      if (!outRec.IsOpen)\n\t        this.SetHoleState(e, outRec);\n\t      e.OutIdx = outRec.Idx;\n\t      //nb: do this after SetZ !\n\t      return newOp;\n\t    }\n\t    else\n\t    {\n\t      var outRec = this.m_PolyOuts[e.OutIdx];\n\t      //OutRec.Pts is the 'Left-most' point & OutRec.Pts.Prev is the 'Right-most'\n\t      var op = outRec.Pts;\n\t      if (ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Pt))\n\t        return op;\n\t      else if (!ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Prev.Pt))\n\t        return op.Prev;\n\t      var newOp = new ClipperLib.OutPt();\n\t      newOp.Idx = outRec.Idx;\n\t      //newOp.Pt = pt;\n\t      newOp.Pt.X = pt.X;\n\t      newOp.Pt.Y = pt.Y;\n\t      newOp.Next = op;\n\t      newOp.Prev = op.Prev;\n\t      newOp.Prev.Next = newOp;\n\t      op.Prev = newOp;\n\t      if (ToFront)\n\t        outRec.Pts = newOp;\n\t      return newOp;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.SwapPoints = function (pt1, pt2)\n\t  {\n\t    var tmp = new ClipperLib.IntPoint(pt1.Value);\n\t    //pt1.Value = pt2.Value;\n\t    pt1.Value.X = pt2.Value.X;\n\t    pt1.Value.Y = pt2.Value.Y;\n\t    //pt2.Value = tmp;\n\t    pt2.Value.X = tmp.X;\n\t    pt2.Value.Y = tmp.Y;\n\t  };\n\t  ClipperLib.Clipper.prototype.HorzSegmentsOverlap = function (seg1a, seg1b, seg2a, seg2b)\n\t\t{\n\t\t\tvar tmp;\n\t\t\tif (seg1a > seg1b)\n\t\t\t{\n\t\t\t\ttmp = seg1a;\n\t\t\t\tseg1a = seg1b;\n\t\t\t\tseg1b = tmp;\n\t\t\t}\n\t\t\tif (seg2a > seg2b)\n\t\t\t{\n\t\t\t\ttmp = seg2a;\n\t\t\t\tseg2a = seg2b;\n\t\t\t\tseg2b = tmp;\n\t\t\t}\n\t\t\treturn (seg1a < seg2b) && (seg2a < seg1b);\n\t\t}\n\t\n\t  ClipperLib.Clipper.prototype.SetHoleState = function (e, outRec)\n\t  {\n\t    var isHole = false;\n\t    var e2 = e.PrevInAEL;\n\t    while (e2 !== null)\n\t    {\n\t      if (e2.OutIdx >= 0 && e2.WindDelta != 0)\n\t      {\n\t        isHole = !isHole;\n\t        if (outRec.FirstLeft === null)\n\t          outRec.FirstLeft = this.m_PolyOuts[e2.OutIdx];\n\t      }\n\t      e2 = e2.PrevInAEL;\n\t    }\n\t    if (isHole)\n\t      outRec.IsHole = true;\n\t  };\n\t  ClipperLib.Clipper.prototype.GetDx = function (pt1, pt2)\n\t  {\n\t    if (pt1.Y == pt2.Y)\n\t      return ClipperLib.ClipperBase.horizontal;\n\t    else\n\t      return (pt2.X - pt1.X) / (pt2.Y - pt1.Y);\n\t  };\n\t  ClipperLib.Clipper.prototype.FirstIsBottomPt = function (btmPt1, btmPt2)\n\t  {\n\t    var p = btmPt1.Prev;\n\t    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))\n\t      p = p.Prev;\n\t    var dx1p = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n\t    p = btmPt1.Next;\n\t    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))\n\t      p = p.Next;\n\t    var dx1n = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n\t    p = btmPt2.Prev;\n\t    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))\n\t      p = p.Prev;\n\t    var dx2p = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n\t    p = btmPt2.Next;\n\t    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))\n\t      p = p.Next;\n\t    var dx2n = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n\t    return (dx1p >= dx2p && dx1p >= dx2n) || (dx1n >= dx2p && dx1n >= dx2n);\n\t  };\n\t  ClipperLib.Clipper.prototype.GetBottomPt = function (pp)\n\t  {\n\t    var dups = null;\n\t    var p = pp.Next;\n\t    while (p != pp)\n\t    {\n\t      if (p.Pt.Y > pp.Pt.Y)\n\t      {\n\t        pp = p;\n\t        dups = null;\n\t      }\n\t      else if (p.Pt.Y == pp.Pt.Y && p.Pt.X <= pp.Pt.X)\n\t      {\n\t        if (p.Pt.X < pp.Pt.X)\n\t        {\n\t          dups = null;\n\t          pp = p;\n\t        }\n\t        else\n\t        {\n\t          if (p.Next != pp && p.Prev != pp)\n\t            dups = p;\n\t        }\n\t      }\n\t      p = p.Next;\n\t    }\n\t    if (dups !== null)\n\t    {\n\t      //there appears to be at least 2 vertices at bottomPt so ...\n\t      while (dups != p)\n\t      {\n\t        if (!this.FirstIsBottomPt(p, dups))\n\t          pp = dups;\n\t        dups = dups.Next;\n\t        while (ClipperLib.IntPoint.op_Inequality(dups.Pt, pp.Pt))\n\t          dups = dups.Next;\n\t      }\n\t    }\n\t    return pp;\n\t  };\n\t  ClipperLib.Clipper.prototype.GetLowermostRec = function (outRec1, outRec2)\n\t  {\n\t    //work out which polygon fragment has the correct hole state ...\n\t    if (outRec1.BottomPt === null)\n\t      outRec1.BottomPt = this.GetBottomPt(outRec1.Pts);\n\t    if (outRec2.BottomPt === null)\n\t      outRec2.BottomPt = this.GetBottomPt(outRec2.Pts);\n\t    var bPt1 = outRec1.BottomPt;\n\t    var bPt2 = outRec2.BottomPt;\n\t    if (bPt1.Pt.Y > bPt2.Pt.Y)\n\t      return outRec1;\n\t    else if (bPt1.Pt.Y < bPt2.Pt.Y)\n\t      return outRec2;\n\t    else if (bPt1.Pt.X < bPt2.Pt.X)\n\t      return outRec1;\n\t    else if (bPt1.Pt.X > bPt2.Pt.X)\n\t      return outRec2;\n\t    else if (bPt1.Next == bPt1)\n\t      return outRec2;\n\t    else if (bPt2.Next == bPt2)\n\t      return outRec1;\n\t    else if (this.FirstIsBottomPt(bPt1, bPt2))\n\t      return outRec1;\n\t    else\n\t      return outRec2;\n\t  };\n\t  ClipperLib.Clipper.prototype.Param1RightOfParam2 = function (outRec1, outRec2)\n\t  {\n\t    do {\n\t      outRec1 = outRec1.FirstLeft;\n\t      if (outRec1 == outRec2)\n\t        return true;\n\t    }\n\t    while (outRec1 !== null)\n\t    return false;\n\t  };\n\t  ClipperLib.Clipper.prototype.GetOutRec = function (idx)\n\t  {\n\t    var outrec = this.m_PolyOuts[idx];\n\t    while (outrec != this.m_PolyOuts[outrec.Idx])\n\t      outrec = this.m_PolyOuts[outrec.Idx];\n\t    return outrec;\n\t  };\n\t  ClipperLib.Clipper.prototype.AppendPolygon = function (e1, e2)\n\t  {\n\t    //get the start and ends of both output polygons ...\n\t    var outRec1 = this.m_PolyOuts[e1.OutIdx];\n\t    var outRec2 = this.m_PolyOuts[e2.OutIdx];\n\t    var holeStateRec;\n\t    if (this.Param1RightOfParam2(outRec1, outRec2))\n\t      holeStateRec = outRec2;\n\t    else if (this.Param1RightOfParam2(outRec2, outRec1))\n\t      holeStateRec = outRec1;\n\t    else\n\t      holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\t    var p1_lft = outRec1.Pts;\n\t    var p1_rt = p1_lft.Prev;\n\t    var p2_lft = outRec2.Pts;\n\t    var p2_rt = p2_lft.Prev;\n\t    var side;\n\t    //join e2 poly onto e1 poly and delete pointers to e2 ...\n\t    if (e1.Side == ClipperLib.EdgeSide.esLeft)\n\t    {\n\t      if (e2.Side == ClipperLib.EdgeSide.esLeft)\n\t      {\n\t        //z y x a b c\n\t        this.ReversePolyPtLinks(p2_lft);\n\t        p2_lft.Next = p1_lft;\n\t        p1_lft.Prev = p2_lft;\n\t        p1_rt.Next = p2_rt;\n\t        p2_rt.Prev = p1_rt;\n\t        outRec1.Pts = p2_rt;\n\t      }\n\t      else\n\t      {\n\t        //x y z a b c\n\t        p2_rt.Next = p1_lft;\n\t        p1_lft.Prev = p2_rt;\n\t        p2_lft.Prev = p1_rt;\n\t        p1_rt.Next = p2_lft;\n\t        outRec1.Pts = p2_lft;\n\t      }\n\t      side = ClipperLib.EdgeSide.esLeft;\n\t    }\n\t    else\n\t    {\n\t      if (e2.Side == ClipperLib.EdgeSide.esRight)\n\t      {\n\t        //a b c z y x\n\t        this.ReversePolyPtLinks(p2_lft);\n\t        p1_rt.Next = p2_rt;\n\t        p2_rt.Prev = p1_rt;\n\t        p2_lft.Next = p1_lft;\n\t        p1_lft.Prev = p2_lft;\n\t      }\n\t      else\n\t      {\n\t        //a b c x y z\n\t        p1_rt.Next = p2_lft;\n\t        p2_lft.Prev = p1_rt;\n\t        p1_lft.Prev = p2_rt;\n\t        p2_rt.Next = p1_lft;\n\t      }\n\t      side = ClipperLib.EdgeSide.esRight;\n\t    }\n\t    outRec1.BottomPt = null;\n\t    if (holeStateRec == outRec2)\n\t    {\n\t      if (outRec2.FirstLeft != outRec1)\n\t        outRec1.FirstLeft = outRec2.FirstLeft;\n\t      outRec1.IsHole = outRec2.IsHole;\n\t    }\n\t    outRec2.Pts = null;\n\t    outRec2.BottomPt = null;\n\t    outRec2.FirstLeft = outRec1;\n\t    var OKIdx = e1.OutIdx;\n\t    var ObsoleteIdx = e2.OutIdx;\n\t    e1.OutIdx = -1;\n\t    //nb: safe because we only get here via AddLocalMaxPoly\n\t    e2.OutIdx = -1;\n\t    var e = this.m_ActiveEdges;\n\t    while (e !== null)\n\t    {\n\t      if (e.OutIdx == ObsoleteIdx)\n\t      {\n\t        e.OutIdx = OKIdx;\n\t        e.Side = side;\n\t        break;\n\t      }\n\t      e = e.NextInAEL;\n\t    }\n\t    outRec2.Idx = outRec1.Idx;\n\t  };\n\t  ClipperLib.Clipper.prototype.ReversePolyPtLinks = function (pp)\n\t  {\n\t    if (pp === null)\n\t      return;\n\t    var pp1;\n\t    var pp2;\n\t    pp1 = pp;\n\t    do {\n\t      pp2 = pp1.Next;\n\t      pp1.Next = pp1.Prev;\n\t      pp1.Prev = pp2;\n\t      pp1 = pp2;\n\t    }\n\t    while (pp1 != pp)\n\t  };\n\t  ClipperLib.Clipper.SwapSides = function (edge1, edge2)\n\t  {\n\t    var side = edge1.Side;\n\t    edge1.Side = edge2.Side;\n\t    edge2.Side = side;\n\t  };\n\t  ClipperLib.Clipper.SwapPolyIndexes = function (edge1, edge2)\n\t  {\n\t    var outIdx = edge1.OutIdx;\n\t    edge1.OutIdx = edge2.OutIdx;\n\t    edge2.OutIdx = outIdx;\n\t  };\n\t  ClipperLib.Clipper.prototype.IntersectEdges = function (e1, e2, pt)\n\t  {\n\t    //e1 will be to the left of e2 BELOW the intersection. Therefore e1 is before\n\t    //e2 in AEL except when e1 is being inserted at the intersection point ...\n\t    var e1Contributing = (e1.OutIdx >= 0);\n\t    var e2Contributing = (e2.OutIdx >= 0);\n\t\n\t    if (use_xyz)\n\t    \tthis.SetZ(pt, e1, e2);\n\t\n\t    if (use_lines)\n\t    {\n\t      //if either edge is on an OPEN path ...\n\t      if (e1.WindDelta === 0 || e2.WindDelta === 0)\n\t      {\n\t        //ignore subject-subject open path intersections UNLESS they\n\t        //are both open paths, AND they are both 'contributing maximas' ...\n\t\t\t\t\tif (e1.WindDelta == 0 && e2.WindDelta == 0) return;\n\t        //if intersecting a subj line with a subj poly ...\n\t        else if (e1.PolyTyp == e2.PolyTyp &&\n\t          e1.WindDelta != e2.WindDelta && this.m_ClipType == ClipperLib.ClipType.ctUnion)\n\t        {\n\t          if (e1.WindDelta === 0)\n\t          {\n\t            if (e2Contributing)\n\t            {\n\t              this.AddOutPt(e1, pt);\n\t              if (e1Contributing)\n\t                e1.OutIdx = -1;\n\t            }\n\t          }\n\t          else\n\t          {\n\t            if (e1Contributing)\n\t            {\n\t              this.AddOutPt(e2, pt);\n\t              if (e2Contributing)\n\t                e2.OutIdx = -1;\n\t            }\n\t          }\n\t        }\n\t        else if (e1.PolyTyp != e2.PolyTyp)\n\t        {\n\t          if ((e1.WindDelta === 0) && Math.abs(e2.WindCnt) == 1 &&\n\t            (this.m_ClipType != ClipperLib.ClipType.ctUnion || e2.WindCnt2 === 0))\n\t          {\n\t            this.AddOutPt(e1, pt);\n\t            if (e1Contributing)\n\t              e1.OutIdx = -1;\n\t          }\n\t          else if ((e2.WindDelta === 0) && (Math.abs(e1.WindCnt) == 1) &&\n\t            (this.m_ClipType != ClipperLib.ClipType.ctUnion || e1.WindCnt2 === 0))\n\t          {\n\t            this.AddOutPt(e2, pt);\n\t            if (e2Contributing)\n\t              e2.OutIdx = -1;\n\t          }\n\t        }\n\t        return;\n\t      }\n\t    }\n\t    //update winding counts...\n\t    //assumes that e1 will be to the Right of e2 ABOVE the intersection\n\t    if (e1.PolyTyp == e2.PolyTyp)\n\t    {\n\t      if (this.IsEvenOddFillType(e1))\n\t      {\n\t        var oldE1WindCnt = e1.WindCnt;\n\t        e1.WindCnt = e2.WindCnt;\n\t        e2.WindCnt = oldE1WindCnt;\n\t      }\n\t      else\n\t      {\n\t        if (e1.WindCnt + e2.WindDelta === 0)\n\t          e1.WindCnt = -e1.WindCnt;\n\t        else\n\t          e1.WindCnt += e2.WindDelta;\n\t        if (e2.WindCnt - e1.WindDelta === 0)\n\t          e2.WindCnt = -e2.WindCnt;\n\t        else\n\t          e2.WindCnt -= e1.WindDelta;\n\t      }\n\t    }\n\t    else\n\t    {\n\t      if (!this.IsEvenOddFillType(e2))\n\t        e1.WindCnt2 += e2.WindDelta;\n\t      else\n\t        e1.WindCnt2 = (e1.WindCnt2 === 0) ? 1 : 0;\n\t      if (!this.IsEvenOddFillType(e1))\n\t        e2.WindCnt2 -= e1.WindDelta;\n\t      else\n\t        e2.WindCnt2 = (e2.WindCnt2 === 0) ? 1 : 0;\n\t    }\n\t    var e1FillType, e2FillType, e1FillType2, e2FillType2;\n\t    if (e1.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t    {\n\t      e1FillType = this.m_SubjFillType;\n\t      e1FillType2 = this.m_ClipFillType;\n\t    }\n\t    else\n\t    {\n\t      e1FillType = this.m_ClipFillType;\n\t      e1FillType2 = this.m_SubjFillType;\n\t    }\n\t    if (e2.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t    {\n\t      e2FillType = this.m_SubjFillType;\n\t      e2FillType2 = this.m_ClipFillType;\n\t    }\n\t    else\n\t    {\n\t      e2FillType = this.m_ClipFillType;\n\t      e2FillType2 = this.m_SubjFillType;\n\t    }\n\t    var e1Wc, e2Wc;\n\t    switch (e1FillType)\n\t    {\n\t    case ClipperLib.PolyFillType.pftPositive:\n\t      e1Wc = e1.WindCnt;\n\t      break;\n\t    case ClipperLib.PolyFillType.pftNegative:\n\t      e1Wc = -e1.WindCnt;\n\t      break;\n\t    default:\n\t      e1Wc = Math.abs(e1.WindCnt);\n\t      break;\n\t    }\n\t    switch (e2FillType)\n\t    {\n\t    case ClipperLib.PolyFillType.pftPositive:\n\t      e2Wc = e2.WindCnt;\n\t      break;\n\t    case ClipperLib.PolyFillType.pftNegative:\n\t      e2Wc = -e2.WindCnt;\n\t      break;\n\t    default:\n\t      e2Wc = Math.abs(e2.WindCnt);\n\t      break;\n\t    }\n\t    if (e1Contributing && e2Contributing)\n\t    {\n\t\t\t\tif ((e1Wc != 0 && e1Wc != 1) || (e2Wc != 0 && e2Wc != 1) ||\n\t\t\t\t(e1.PolyTyp != e2.PolyTyp && this.m_ClipType != ClipperLib.ClipType.ctXor))\n\t\t\t\t{\n\t\t\t\t\tthis.AddLocalMaxPoly(e1, e2, pt);\n\t\t\t\t}\n\t      else\n\t      {\n\t        this.AddOutPt(e1, pt);\n\t        this.AddOutPt(e2, pt);\n\t        ClipperLib.Clipper.SwapSides(e1, e2);\n\t        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n\t      }\n\t    }\n\t    else if (e1Contributing)\n\t    {\n\t      if (e2Wc === 0 || e2Wc == 1)\n\t      {\n\t        this.AddOutPt(e1, pt);\n\t        ClipperLib.Clipper.SwapSides(e1, e2);\n\t        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n\t      }\n\t    }\n\t    else if (e2Contributing)\n\t    {\n\t      if (e1Wc === 0 || e1Wc == 1)\n\t      {\n\t        this.AddOutPt(e2, pt);\n\t        ClipperLib.Clipper.SwapSides(e1, e2);\n\t        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n\t      }\n\t    }\n\t\t\telse if ( (e1Wc == 0 || e1Wc == 1) && (e2Wc == 0 || e2Wc == 1))\n\t    {\n\t      //neither edge is currently contributing ...\n\t      var e1Wc2, e2Wc2;\n\t      switch (e1FillType2)\n\t      {\n\t      case ClipperLib.PolyFillType.pftPositive:\n\t        e1Wc2 = e1.WindCnt2;\n\t        break;\n\t      case ClipperLib.PolyFillType.pftNegative:\n\t        e1Wc2 = -e1.WindCnt2;\n\t        break;\n\t      default:\n\t        e1Wc2 = Math.abs(e1.WindCnt2);\n\t        break;\n\t      }\n\t      switch (e2FillType2)\n\t      {\n\t      case ClipperLib.PolyFillType.pftPositive:\n\t        e2Wc2 = e2.WindCnt2;\n\t        break;\n\t      case ClipperLib.PolyFillType.pftNegative:\n\t        e2Wc2 = -e2.WindCnt2;\n\t        break;\n\t      default:\n\t        e2Wc2 = Math.abs(e2.WindCnt2);\n\t        break;\n\t      }\n\t      if (e1.PolyTyp != e2.PolyTyp)\n\t      {\n\t        this.AddLocalMinPoly(e1, e2, pt);\n\t      }\n\t      else if (e1Wc == 1 && e2Wc == 1)\n\t        switch (this.m_ClipType)\n\t        {\n\t        case ClipperLib.ClipType.ctIntersection:\n\t          if (e1Wc2 > 0 && e2Wc2 > 0)\n\t            this.AddLocalMinPoly(e1, e2, pt);\n\t          break;\n\t        case ClipperLib.ClipType.ctUnion:\n\t          if (e1Wc2 <= 0 && e2Wc2 <= 0)\n\t            this.AddLocalMinPoly(e1, e2, pt);\n\t          break;\n\t        case ClipperLib.ClipType.ctDifference:\n\t          if (((e1.PolyTyp == ClipperLib.PolyType.ptClip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||\n\t            ((e1.PolyTyp == ClipperLib.PolyType.ptSubject) && (e1Wc2 <= 0) && (e2Wc2 <= 0)))\n\t            this.AddLocalMinPoly(e1, e2, pt);\n\t          break;\n\t        case ClipperLib.ClipType.ctXor:\n\t          this.AddLocalMinPoly(e1, e2, pt);\n\t          break;\n\t        }\n\t      else\n\t        ClipperLib.Clipper.SwapSides(e1, e2);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.DeleteFromAEL = function (e)\n\t  {\n\t    var AelPrev = e.PrevInAEL;\n\t    var AelNext = e.NextInAEL;\n\t    if (AelPrev === null && AelNext === null && (e != this.m_ActiveEdges))\n\t      return;\n\t    //already deleted\n\t    if (AelPrev !== null)\n\t      AelPrev.NextInAEL = AelNext;\n\t    else\n\t      this.m_ActiveEdges = AelNext;\n\t    if (AelNext !== null)\n\t      AelNext.PrevInAEL = AelPrev;\n\t    e.NextInAEL = null;\n\t    e.PrevInAEL = null;\n\t  };\n\t  ClipperLib.Clipper.prototype.DeleteFromSEL = function (e)\n\t  {\n\t    var SelPrev = e.PrevInSEL;\n\t    var SelNext = e.NextInSEL;\n\t    if (SelPrev === null && SelNext === null && (e != this.m_SortedEdges))\n\t      return;\n\t    //already deleted\n\t    if (SelPrev !== null)\n\t      SelPrev.NextInSEL = SelNext;\n\t    else\n\t      this.m_SortedEdges = SelNext;\n\t    if (SelNext !== null)\n\t      SelNext.PrevInSEL = SelPrev;\n\t    e.NextInSEL = null;\n\t    e.PrevInSEL = null;\n\t  };\n\t  ClipperLib.Clipper.prototype.UpdateEdgeIntoAEL = function (e)\n\t  {\n\t    if (e.NextInLML === null)\n\t      ClipperLib.Error(\"UpdateEdgeIntoAEL: invalid call\");\n\t    var AelPrev = e.PrevInAEL;\n\t    var AelNext = e.NextInAEL;\n\t    e.NextInLML.OutIdx = e.OutIdx;\n\t    if (AelPrev !== null)\n\t      AelPrev.NextInAEL = e.NextInLML;\n\t    else\n\t      this.m_ActiveEdges = e.NextInLML;\n\t    if (AelNext !== null)\n\t      AelNext.PrevInAEL = e.NextInLML;\n\t    e.NextInLML.Side = e.Side;\n\t    e.NextInLML.WindDelta = e.WindDelta;\n\t    e.NextInLML.WindCnt = e.WindCnt;\n\t    e.NextInLML.WindCnt2 = e.WindCnt2;\n\t    e = e.NextInLML;\n\t    //    e.Curr = e.Bot;\n\t    e.Curr.X = e.Bot.X;\n\t    e.Curr.Y = e.Bot.Y;\n\t    e.PrevInAEL = AelPrev;\n\t    e.NextInAEL = AelNext;\n\t    if (!ClipperLib.ClipperBase.IsHorizontal(e))\n\t      this.InsertScanbeam(e.Top.Y);\n\t    return e;\n\t  };\n\t  ClipperLib.Clipper.prototype.ProcessHorizontals = function (isTopOfScanbeam)\n\t  {\n\t    var horzEdge = this.m_SortedEdges;\n\t    while (horzEdge !== null)\n\t    {\n\t      this.DeleteFromSEL(horzEdge);\n\t      this.ProcessHorizontal(horzEdge, isTopOfScanbeam);\n\t      horzEdge = this.m_SortedEdges;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.GetHorzDirection = function (HorzEdge, $var)\n\t  {\n\t    if (HorzEdge.Bot.X < HorzEdge.Top.X)\n\t    {\n\t        $var.Left = HorzEdge.Bot.X;\n\t        $var.Right = HorzEdge.Top.X;\n\t        $var.Dir = ClipperLib.Direction.dLeftToRight;\n\t    }\n\t    else\n\t    {\n\t        $var.Left = HorzEdge.Top.X;\n\t        $var.Right = HorzEdge.Bot.X;\n\t        $var.Dir = ClipperLib.Direction.dRightToLeft;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.ProcessHorizontal = function (horzEdge, isTopOfScanbeam)\n\t  {\n\t    var $var = {Dir: null, Left: null, Right: null};\n\t    this.GetHorzDirection(horzEdge, $var);\n\t    var dir = $var.Dir;\n\t    var horzLeft = $var.Left;\n\t    var horzRight = $var.Right;\n\t\n\t    var eLastHorz = horzEdge,\n\t      eMaxPair = null;\n\t    while (eLastHorz.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(eLastHorz.NextInLML))\n\t      eLastHorz = eLastHorz.NextInLML;\n\t    if (eLastHorz.NextInLML === null)\n\t      eMaxPair = this.GetMaximaPair(eLastHorz);\n\t    for (;;)\n\t    {\n\t      var IsLastHorz = (horzEdge == eLastHorz);\n\t      var e = this.GetNextInAEL(horzEdge, dir);\n\t      while (e !== null)\n\t      {\n\t        //Break if we've got to the end of an intermediate horizontal edge ...\n\t        //nb: Smaller Dx's are to the right of larger Dx's ABOVE the horizontal.\n\t        if (e.Curr.X == horzEdge.Top.X && horzEdge.NextInLML !== null && e.Dx < horzEdge.NextInLML.Dx)\n\t          break;\n\t        var eNext = this.GetNextInAEL(e, dir);\n\t        //saves eNext for later\n\t        if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X <= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X >= horzLeft))\n\t        {\n\t          //so far we're still in range of the horizontal Edge  but make sure\n\t          //we're at the last of consec. horizontals when matching with eMaxPair\n\t          if (e == eMaxPair && IsLastHorz)\n\t          {\n\t\t\t\t\t\t\tif (horzEdge.OutIdx >= 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\t\t\t\t\t\t\t\tvar eNextHorz = this.m_SortedEdges;\n\t\t\t\t\t\t\t\twhile (eNextHorz !== null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (eNextHorz.OutIdx >= 0 &&\n\t\t\t\t\t\t\t\t\t\tthis.HorzSegmentsOverlap(horzEdge.Bot.X,\n\t\t\t\t\t\t\t\t\t\thorzEdge.Top.X, eNextHorz.Bot.X, eNextHorz.Top.X))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tvar op2 = this.AddOutPt(eNextHorz, eNextHorz.Bot);\n\t\t\t\t\t\t\t\t\t\tthis.AddJoin(op2, op1, eNextHorz.Top);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\teNextHorz = eNextHorz.NextInSEL;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthis.AddGhostJoin(op1, horzEdge.Bot);\n\t\t\t\t\t\t\t\tthis.AddLocalMaxPoly(horzEdge, eMaxPair, horzEdge.Top);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.DeleteFromAEL(horzEdge);\n\t\t\t\t\t\t\tthis.DeleteFromAEL(eMaxPair);\n\t            return;\n\t          }\n\t          else if (dir == ClipperLib.Direction.dLeftToRight)\n\t          {\n\t            var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n\t            this.IntersectEdges(horzEdge, e, Pt);\n\t          }\n\t          else\n\t          {\n\t            var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n\t            this.IntersectEdges(e, horzEdge, Pt);\n\t          }\n\t          this.SwapPositionsInAEL(horzEdge, e);\n\t        }\n\t        else if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X >= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X <= horzLeft))\n\t          break;\n\t        e = eNext;\n\t      }\n\t      //end while\n\t      if (horzEdge.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(horzEdge.NextInLML))\n\t      {\n\t        horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n\t        if (horzEdge.OutIdx >= 0)\n\t          this.AddOutPt(horzEdge, horzEdge.Bot);\n\t\n\t          var $var = {Dir: dir, Left: horzLeft, Right: horzRight};\n\t          this.GetHorzDirection(horzEdge, $var);\n\t          dir = $var.Dir;\n\t          horzLeft = $var.Left;\n\t          horzRight = $var.Right;\n\t      }\n\t      else\n\t        break;\n\t    }\n\t    //end for (;;)\n\t    if (horzEdge.NextInLML !== null)\n\t    {\n\t      if (horzEdge.OutIdx >= 0)\n\t      {\n\t        var op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\t\t\t\t\tif (isTopOfScanbeam) this.AddGhostJoin(op1, horzEdge.Bot);\n\t        horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n\t        if (horzEdge.WindDelta === 0)\n\t          return;\n\t        //nb: HorzEdge is no longer horizontal here\n\t        var ePrev = horzEdge.PrevInAEL;\n\t        var eNext = horzEdge.NextInAEL;\n\t        if (ePrev !== null && ePrev.Curr.X == horzEdge.Bot.X &&\n\t          ePrev.Curr.Y == horzEdge.Bot.Y && ePrev.WindDelta !== 0 &&\n\t          (ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&\n\t            ClipperLib.ClipperBase.SlopesEqual(horzEdge, ePrev, this.m_UseFullRange)))\n\t        {\n\t          var op2 = this.AddOutPt(ePrev, horzEdge.Bot);\n\t          this.AddJoin(op1, op2, horzEdge.Top);\n\t        }\n\t        else if (eNext !== null && eNext.Curr.X == horzEdge.Bot.X &&\n\t          eNext.Curr.Y == horzEdge.Bot.Y && eNext.WindDelta !== 0 &&\n\t          eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&\n\t          ClipperLib.ClipperBase.SlopesEqual(horzEdge, eNext, this.m_UseFullRange))\n\t        {\n\t          var op2 = this.AddOutPt(eNext, horzEdge.Bot);\n\t          this.AddJoin(op1, op2, horzEdge.Top);\n\t        }\n\t      }\n\t      else horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n\t    }\n\t  \telse\n\t    {\n\t      if (horzEdge.OutIdx >= 0)\n\t        this.AddOutPt(horzEdge, horzEdge.Top);\n\t      this.DeleteFromAEL(horzEdge);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.GetNextInAEL = function (e, Direction)\n\t  {\n\t    return Direction == ClipperLib.Direction.dLeftToRight ? e.NextInAEL : e.PrevInAEL;\n\t  };\n\t  ClipperLib.Clipper.prototype.IsMinima = function (e)\n\t  {\n\t    return e !== null && (e.Prev.NextInLML != e) && (e.Next.NextInLML != e);\n\t  };\n\t  ClipperLib.Clipper.prototype.IsMaxima = function (e, Y)\n\t  {\n\t    return (e !== null && e.Top.Y == Y && e.NextInLML === null);\n\t  };\n\t  ClipperLib.Clipper.prototype.IsIntermediate = function (e, Y)\n\t  {\n\t    return (e.Top.Y == Y && e.NextInLML !== null);\n\t  };\n\t  ClipperLib.Clipper.prototype.GetMaximaPair = function (e)\n\t  {\n\t    var result = null;\n\t    if ((ClipperLib.IntPoint.op_Equality(e.Next.Top, e.Top)) && e.Next.NextInLML === null)\n\t      result = e.Next;\n\t    else if ((ClipperLib.IntPoint.op_Equality(e.Prev.Top, e.Top)) && e.Prev.NextInLML === null)\n\t      result = e.Prev;\n\t    if (result !== null && (result.OutIdx == -2 || (result.NextInAEL == result.PrevInAEL && !ClipperLib.ClipperBase.IsHorizontal(result))))\n\t      return null;\n\t    return result;\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.ProcessIntersections = function (topY)\n\t  {\n\t    if (this.m_ActiveEdges == null)\n\t      return true;\n\t    try\n\t    {\n\t      this.BuildIntersectList(topY);\n\t      if (this.m_IntersectList.length == 0)\n\t        return true;\n\t      if (this.m_IntersectList.length == 1 || this.FixupIntersectionOrder())\n\t        this.ProcessIntersectList();\n\t      else\n\t        return false;\n\t    }\n\t    catch ($$e2)\n\t    {\n\t      this.m_SortedEdges = null;\n\t      this.m_IntersectList.length = 0;\n\t      ClipperLib.Error(\"ProcessIntersections error\");\n\t    }\n\t    this.m_SortedEdges = null;\n\t    return true;\n\t  };\n\t  ClipperLib.Clipper.prototype.BuildIntersectList = function (topY)\n\t  {\n\t    if (this.m_ActiveEdges === null)\n\t      return;\n\t    //prepare for sorting ...\n\t    var e = this.m_ActiveEdges;\n\t    //console.log(JSON.stringify(JSON.decycle( e )));\n\t    this.m_SortedEdges = e;\n\t    while (e !== null)\n\t    {\n\t      e.PrevInSEL = e.PrevInAEL;\n\t      e.NextInSEL = e.NextInAEL;\n\t      e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n\t      e = e.NextInAEL;\n\t    }\n\t    //bubblesort ...\n\t    var isModified = true;\n\t    while (isModified && this.m_SortedEdges !== null)\n\t    {\n\t      isModified = false;\n\t      e = this.m_SortedEdges;\n\t      while (e.NextInSEL !== null)\n\t      {\n\t        var eNext = e.NextInSEL;\n\t        var pt = new ClipperLib.IntPoint();\n\t        //console.log(\"e.Curr.X: \" + e.Curr.X + \" eNext.Curr.X\" + eNext.Curr.X);\n\t        if (e.Curr.X > eNext.Curr.X)\n\t        {\n\t\t\t\t\t\tthis.IntersectPoint(e, eNext, pt);\n\t          var newNode = new ClipperLib.IntersectNode();\n\t          newNode.Edge1 = e;\n\t          newNode.Edge2 = eNext;\n\t          //newNode.Pt = pt;\n\t          newNode.Pt.X = pt.X;\n\t          newNode.Pt.Y = pt.Y;\n\t          this.m_IntersectList.push(newNode);\n\t          this.SwapPositionsInSEL(e, eNext);\n\t          isModified = true;\n\t        }\n\t        else\n\t          e = eNext;\n\t      }\n\t      if (e.PrevInSEL !== null)\n\t        e.PrevInSEL.NextInSEL = null;\n\t      else\n\t        break;\n\t    }\n\t    this.m_SortedEdges = null;\n\t  };\n\t  ClipperLib.Clipper.prototype.EdgesAdjacent = function (inode)\n\t  {\n\t    return (inode.Edge1.NextInSEL == inode.Edge2) || (inode.Edge1.PrevInSEL == inode.Edge2);\n\t  };\n\t  ClipperLib.Clipper.IntersectNodeSort = function (node1, node2)\n\t  {\n\t    //the following typecast is safe because the differences in Pt.Y will\n\t    //be limited to the height of the scanbeam.\n\t    return (node2.Pt.Y - node1.Pt.Y);\n\t  };\n\t  ClipperLib.Clipper.prototype.FixupIntersectionOrder = function ()\n\t  {\n\t    //pre-condition: intersections are sorted bottom-most first.\n\t    //Now it's crucial that intersections are made only between adjacent edges,\n\t    //so to ensure this the order of intersections may need adjusting ...\n\t    this.m_IntersectList.sort(this.m_IntersectNodeComparer);\n\t    this.CopyAELToSEL();\n\t    var cnt = this.m_IntersectList.length;\n\t    for (var i = 0; i < cnt; i++)\n\t    {\n\t      if (!this.EdgesAdjacent(this.m_IntersectList[i]))\n\t      {\n\t        var j = i + 1;\n\t        while (j < cnt && !this.EdgesAdjacent(this.m_IntersectList[j]))\n\t          j++;\n\t        if (j == cnt)\n\t          return false;\n\t        var tmp = this.m_IntersectList[i];\n\t        this.m_IntersectList[i] = this.m_IntersectList[j];\n\t        this.m_IntersectList[j] = tmp;\n\t      }\n\t      this.SwapPositionsInSEL(this.m_IntersectList[i].Edge1, this.m_IntersectList[i].Edge2);\n\t    }\n\t    return true;\n\t  };\n\t  ClipperLib.Clipper.prototype.ProcessIntersectList = function ()\n\t  {\n\t    for (var i = 0, ilen = this.m_IntersectList.length; i < ilen; i++)\n\t    {\n\t      var iNode = this.m_IntersectList[i];\n\t      this.IntersectEdges(iNode.Edge1, iNode.Edge2, iNode.Pt);\n\t      this.SwapPositionsInAEL(iNode.Edge1, iNode.Edge2);\n\t    }\n\t    this.m_IntersectList.length = 0;\n\t  };\n\t  /*\n\t  --------------------------------\n\t  Round speedtest: http://jsperf.com/fastest-round\n\t  --------------------------------\n\t  */\n\t  var R1 = function (a)\n\t  {\n\t    return a < 0 ? Math.ceil(a - 0.5) : Math.round(a)\n\t  };\n\t  var R2 = function (a)\n\t  {\n\t    return a < 0 ? Math.ceil(a - 0.5) : Math.floor(a + 0.5)\n\t  };\n\t  var R3 = function (a)\n\t  {\n\t    return a < 0 ? -Math.round(Math.abs(a)) : Math.round(a)\n\t  };\n\t  var R4 = function (a)\n\t  {\n\t    if (a < 0)\n\t    {\n\t      a -= 0.5;\n\t      return a < -2147483648 ? Math.ceil(a) : a | 0;\n\t    }\n\t    else\n\t    {\n\t      a += 0.5;\n\t      return a > 2147483647 ? Math.floor(a) : a | 0;\n\t    }\n\t  };\n\t  if (browser.msie) ClipperLib.Clipper.Round = R1;\n\t  else if (browser.chromium) ClipperLib.Clipper.Round = R3;\n\t  else if (browser.safari) ClipperLib.Clipper.Round = R4;\n\t  else ClipperLib.Clipper.Round = R2; // eg. browser.chrome || browser.firefox || browser.opera\n\t  ClipperLib.Clipper.TopX = function (edge, currentY)\n\t  {\n\t    //if (edge.Bot == edge.Curr) alert (\"edge.Bot = edge.Curr\");\n\t    //if (edge.Bot == edge.Top) alert (\"edge.Bot = edge.Top\");\n\t    if (currentY == edge.Top.Y)\n\t      return edge.Top.X;\n\t    return edge.Bot.X + ClipperLib.Clipper.Round(edge.Dx * (currentY - edge.Bot.Y));\n\t  };\n\t  ClipperLib.Clipper.prototype.IntersectPoint = function (edge1, edge2, ip)\n\t  {\n\t    ip.X = 0;\n\t    ip.Y = 0;\n\t    var b1, b2;\n\t    //nb: with very large coordinate values, it's possible for SlopesEqual() to\n\t    //return false but for the edge.Dx value be equal due to double precision rounding.\n\t    if (edge1.Dx == edge2.Dx)\n\t\t\t{\n\t\t\t\tip.Y = edge1.Curr.Y;\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t\t\treturn;\n\t    }\n\t    if (edge1.Delta.X === 0)\n\t    {\n\t      ip.X = edge1.Bot.X;\n\t      if (ClipperLib.ClipperBase.IsHorizontal(edge2))\n\t      {\n\t        ip.Y = edge2.Bot.Y;\n\t      }\n\t      else\n\t      {\n\t        b2 = edge2.Bot.Y - (edge2.Bot.X / edge2.Dx);\n\t        ip.Y = ClipperLib.Clipper.Round(ip.X / edge2.Dx + b2);\n\t      }\n\t    }\n\t    else if (edge2.Delta.X === 0)\n\t    {\n\t      ip.X = edge2.Bot.X;\n\t      if (ClipperLib.ClipperBase.IsHorizontal(edge1))\n\t      {\n\t        ip.Y = edge1.Bot.Y;\n\t      }\n\t      else\n\t      {\n\t        b1 = edge1.Bot.Y - (edge1.Bot.X / edge1.Dx);\n\t        ip.Y = ClipperLib.Clipper.Round(ip.X / edge1.Dx + b1);\n\t      }\n\t    }\n\t    else\n\t    {\n\t      b1 = edge1.Bot.X - edge1.Bot.Y * edge1.Dx;\n\t      b2 = edge2.Bot.X - edge2.Bot.Y * edge2.Dx;\n\t      var q = (b2 - b1) / (edge1.Dx - edge2.Dx);\n\t      ip.Y = ClipperLib.Clipper.Round(q);\n\t      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n\t        ip.X = ClipperLib.Clipper.Round(edge1.Dx * q + b1);\n\t      else\n\t        ip.X = ClipperLib.Clipper.Round(edge2.Dx * q + b2);\n\t    }\n\t    if (ip.Y < edge1.Top.Y || ip.Y < edge2.Top.Y)\n\t    {\n\t      if (edge1.Top.Y > edge2.Top.Y)\n\t      {\n\t        ip.Y = edge1.Top.Y;\n\t        ip.X = ClipperLib.Clipper.TopX(edge2, edge1.Top.Y);\n\t        return ip.X < edge1.Top.X;\n\t      }\n\t      else\n\t        ip.Y = edge2.Top.Y;\n\t      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n\t        ip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t      else\n\t        ip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n\t    }\n\t\t\t//finally, don't allow 'ip' to be BELOW curr.Y (ie bottom of scanbeam) ...\n\t\t\tif (ip.Y > edge1.Curr.Y)\n\t\t\t{\n\t\t\t\tip.Y = edge1.Curr.Y;\n\t\t\t\t//better to use the more vertical edge to derive X ...\n\t\t\t\tif (Math.abs(edge1.Dx) > Math.abs(edge2.Dx))\n\t\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n\t\t\t\telse\n\t\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t\t}\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function (topY)\n\t  {\n\t    var e = this.m_ActiveEdges;\n\t    while (e !== null)\n\t    {\n\t      //1. process maxima, treating them as if they're 'bent' horizontal edges,\n\t      //   but exclude maxima with horizontal edges. nb: e can't be a horizontal.\n\t      var IsMaximaEdge = this.IsMaxima(e, topY);\n\t      if (IsMaximaEdge)\n\t      {\n\t        var eMaxPair = this.GetMaximaPair(e);\n\t        IsMaximaEdge = (eMaxPair === null || !ClipperLib.ClipperBase.IsHorizontal(eMaxPair));\n\t      }\n\t      if (IsMaximaEdge)\n\t      {\n\t        var ePrev = e.PrevInAEL;\n\t        this.DoMaxima(e);\n\t        if (ePrev === null)\n\t          e = this.m_ActiveEdges;\n\t        else\n\t          e = ePrev.NextInAEL;\n\t      }\n\t      else\n\t      {\n\t        //2. promote horizontal edges, otherwise update Curr.X and Curr.Y ...\n\t        if (this.IsIntermediate(e, topY) && ClipperLib.ClipperBase.IsHorizontal(e.NextInLML))\n\t        {\n\t          e = this.UpdateEdgeIntoAEL(e);\n\t          if (e.OutIdx >= 0)\n\t            this.AddOutPt(e, e.Bot);\n\t          this.AddEdgeToSEL(e);\n\t        }\n\t        else\n\t        {\n\t          e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n\t          e.Curr.Y = topY;\n\t        }\n\t        if (this.StrictlySimple)\n\t        {\n\t          var ePrev = e.PrevInAEL;\n\t          if ((e.OutIdx >= 0) && (e.WindDelta !== 0) && ePrev !== null &&\n\t            (ePrev.OutIdx >= 0) && (ePrev.Curr.X == e.Curr.X) &&\n\t            (ePrev.WindDelta !== 0))\n\t          {\n\t           \tvar ip = new ClipperLib.IntPoint(e.Curr);\n\t\n\t\t\t\t\t\t\tif(use_xyz)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tthis.SetZ(ip, ePrev, e);\n\t\t\t\t\t\t\t}\n\t\n\t            var op = this.AddOutPt(ePrev, ip);\n\t            var op2 = this.AddOutPt(e, ip);\n\t            this.AddJoin(op, op2, ip);\n\t            //StrictlySimple (type-3) join\n\t          }\n\t        }\n\t        e = e.NextInAEL;\n\t      }\n\t    }\n\t    //3. Process horizontals at the Top of the scanbeam ...\n\t    this.ProcessHorizontals(true);\n\t    //4. Promote intermediate vertices ...\n\t    e = this.m_ActiveEdges;\n\t    while (e !== null)\n\t    {\n\t      if (this.IsIntermediate(e, topY))\n\t      {\n\t        var op = null;\n\t        if (e.OutIdx >= 0)\n\t          op = this.AddOutPt(e, e.Top);\n\t        e = this.UpdateEdgeIntoAEL(e);\n\t        //if output polygons share an edge, they'll need joining later ...\n\t        var ePrev = e.PrevInAEL;\n\t        var eNext = e.NextInAEL;\n\t        if (ePrev !== null && ePrev.Curr.X == e.Bot.X &&\n\t          ePrev.Curr.Y == e.Bot.Y && op !== null &&\n\t          ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&\n\t          ClipperLib.ClipperBase.SlopesEqual(e, ePrev, this.m_UseFullRange) &&\n\t          (e.WindDelta !== 0) && (ePrev.WindDelta !== 0))\n\t        {\n\t          var op2 = this.AddOutPt(ePrev, e.Bot);\n\t          this.AddJoin(op, op2, e.Top);\n\t        }\n\t        else if (eNext !== null && eNext.Curr.X == e.Bot.X &&\n\t          eNext.Curr.Y == e.Bot.Y && op !== null &&\n\t          eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&\n\t          ClipperLib.ClipperBase.SlopesEqual(e, eNext, this.m_UseFullRange) &&\n\t          (e.WindDelta !== 0) && (eNext.WindDelta !== 0))\n\t        {\n\t          var op2 = this.AddOutPt(eNext, e.Bot);\n\t          this.AddJoin(op, op2, e.Top);\n\t        }\n\t      }\n\t      e = e.NextInAEL;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.DoMaxima = function (e)\n\t  {\n\t    var eMaxPair = this.GetMaximaPair(e);\n\t    if (eMaxPair === null)\n\t    {\n\t      if (e.OutIdx >= 0)\n\t        this.AddOutPt(e, e.Top);\n\t      this.DeleteFromAEL(e);\n\t      return;\n\t    }\n\t    var eNext = e.NextInAEL;\n\t    var use_lines = true;\n\t    while (eNext !== null && eNext != eMaxPair)\n\t    {\n\t      this.IntersectEdges(e, eNext, e.Top);\n\t      this.SwapPositionsInAEL(e, eNext);\n\t      eNext = e.NextInAEL;\n\t    }\n\t    if (e.OutIdx == -1 && eMaxPair.OutIdx == -1)\n\t    {\n\t      this.DeleteFromAEL(e);\n\t      this.DeleteFromAEL(eMaxPair);\n\t    }\n\t    else if (e.OutIdx >= 0 && eMaxPair.OutIdx >= 0)\n\t    {\n\t    \tif (e.OutIdx >= 0) this.AddLocalMaxPoly(e, eMaxPair, e.Top);\n\t      this.DeleteFromAEL(e);\n\t      this.DeleteFromAEL(eMaxPair);\n\t    }\n\t    else if (use_lines && e.WindDelta === 0)\n\t    {\n\t      if (e.OutIdx >= 0)\n\t      {\n\t        this.AddOutPt(e, e.Top);\n\t        e.OutIdx = -1;\n\t      }\n\t      this.DeleteFromAEL(e);\n\t      if (eMaxPair.OutIdx >= 0)\n\t      {\n\t        this.AddOutPt(eMaxPair, e.Top);\n\t        eMaxPair.OutIdx = -1;\n\t      }\n\t      this.DeleteFromAEL(eMaxPair);\n\t    }\n\t    else\n\t      ClipperLib.Error(\"DoMaxima error\");\n\t  };\n\t  ClipperLib.Clipper.ReversePaths = function (polys)\n\t  {\n\t    for (var i = 0, len = polys.length; i < len; i++)\n\t      polys[i].reverse();\n\t  };\n\t  ClipperLib.Clipper.Orientation = function (poly)\n\t  {\n\t    return ClipperLib.Clipper.Area(poly) >= 0;\n\t  };\n\t  ClipperLib.Clipper.prototype.PointCount = function (pts)\n\t  {\n\t    if (pts === null)\n\t      return 0;\n\t    var result = 0;\n\t    var p = pts;\n\t    do {\n\t      result++;\n\t      p = p.Next;\n\t    }\n\t    while (p != pts)\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.prototype.BuildResult = function (polyg)\n\t  {\n\t    ClipperLib.Clear(polyg);\n\t    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t    {\n\t      var outRec = this.m_PolyOuts[i];\n\t      if (outRec.Pts === null)\n\t        continue;\n\t      var p = outRec.Pts.Prev;\n\t      var cnt = this.PointCount(p);\n\t      if (cnt < 2)\n\t        continue;\n\t      var pg = new Array(cnt);\n\t      for (var j = 0; j < cnt; j++)\n\t      {\n\t        pg[j] = p.Pt;\n\t        p = p.Prev;\n\t      }\n\t      polyg.push(pg);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.BuildResult2 = function (polytree)\n\t  {\n\t    polytree.Clear();\n\t    //add each output polygon/contour to polytree ...\n\t    //polytree.m_AllPolys.set_Capacity(this.m_PolyOuts.length);\n\t    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t    {\n\t      var outRec = this.m_PolyOuts[i];\n\t      var cnt = this.PointCount(outRec.Pts);\n\t      if ((outRec.IsOpen && cnt < 2) || (!outRec.IsOpen && cnt < 3))\n\t        continue;\n\t      this.FixHoleLinkage(outRec);\n\t      var pn = new ClipperLib.PolyNode();\n\t      polytree.m_AllPolys.push(pn);\n\t      outRec.PolyNode = pn;\n\t      pn.m_polygon.length = cnt;\n\t      var op = outRec.Pts.Prev;\n\t      for (var j = 0; j < cnt; j++)\n\t      {\n\t        pn.m_polygon[j] = op.Pt;\n\t        op = op.Prev;\n\t      }\n\t    }\n\t    //fixup PolyNode links etc ...\n\t    //polytree.m_Childs.set_Capacity(this.m_PolyOuts.length);\n\t    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t    {\n\t      var outRec = this.m_PolyOuts[i];\n\t      if (outRec.PolyNode === null)\n\t        continue;\n\t      else if (outRec.IsOpen)\n\t      {\n\t        outRec.PolyNode.IsOpen = true;\n\t        polytree.AddChild(outRec.PolyNode);\n\t      }\n\t      else if (outRec.FirstLeft !== null && outRec.FirstLeft.PolyNode != null)\n\t        outRec.FirstLeft.PolyNode.AddChild(outRec.PolyNode);\n\t      else\n\t        polytree.AddChild(outRec.PolyNode);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.FixupOutPolygon = function (outRec)\n\t  {\n\t    //FixupOutPolygon() - removes duplicate points and simplifies consecutive\n\t    //parallel edges by removing the middle vertex.\n\t    var lastOK = null;\n\t    outRec.BottomPt = null;\n\t    var pp = outRec.Pts;\n\t    for (;;)\n\t    {\n\t      if (pp.Prev == pp || pp.Prev == pp.Next)\n\t      {\n\t        outRec.Pts = null;\n\t        return;\n\t      }\n\t      //test for duplicate points and collinear edges ...\n\t      if ((ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Next.Pt)) || (ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Prev.Pt)) ||\n\t        (ClipperLib.ClipperBase.SlopesEqual(pp.Prev.Pt, pp.Pt, pp.Next.Pt, this.m_UseFullRange) &&\n\t          (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(pp.Prev.Pt, pp.Pt, pp.Next.Pt))))\n\t      {\n\t        lastOK = null;\n\t        pp.Prev.Next = pp.Next;\n\t        pp.Next.Prev = pp.Prev;\n\t        pp = pp.Prev;\n\t      }\n\t      else if (pp == lastOK)\n\t        break;\n\t      else\n\t      {\n\t        if (lastOK === null)\n\t          lastOK = pp;\n\t        pp = pp.Next;\n\t      }\n\t    }\n\t    outRec.Pts = pp;\n\t  };\n\t  ClipperLib.Clipper.prototype.DupOutPt = function (outPt, InsertAfter)\n\t  {\n\t    var result = new ClipperLib.OutPt();\n\t    //result.Pt = outPt.Pt;\n\t    result.Pt.X = outPt.Pt.X;\n\t    result.Pt.Y = outPt.Pt.Y;\n\t    result.Idx = outPt.Idx;\n\t    if (InsertAfter)\n\t    {\n\t      result.Next = outPt.Next;\n\t      result.Prev = outPt;\n\t      outPt.Next.Prev = result;\n\t      outPt.Next = result;\n\t    }\n\t    else\n\t    {\n\t      result.Prev = outPt.Prev;\n\t      result.Next = outPt;\n\t      outPt.Prev.Next = result;\n\t      outPt.Prev = result;\n\t    }\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.prototype.GetOverlap = function (a1, a2, b1, b2, $val)\n\t  {\n\t    if (a1 < a2)\n\t    {\n\t      if (b1 < b2)\n\t      {\n\t        $val.Left = Math.max(a1, b1);\n\t        $val.Right = Math.min(a2, b2);\n\t      }\n\t      else\n\t      {\n\t        $val.Left = Math.max(a1, b2);\n\t        $val.Right = Math.min(a2, b1);\n\t      }\n\t    }\n\t    else\n\t    {\n\t      if (b1 < b2)\n\t      {\n\t        $val.Left = Math.max(a2, b1);\n\t        $val.Right = Math.min(a1, b2);\n\t      }\n\t      else\n\t      {\n\t        $val.Left = Math.max(a2, b2);\n\t        $val.Right = Math.min(a1, b1);\n\t      }\n\t    }\n\t    return $val.Left < $val.Right;\n\t  };\n\t  ClipperLib.Clipper.prototype.JoinHorz = function (op1, op1b, op2, op2b, Pt, DiscardLeft)\n\t  {\n\t    var Dir1 = (op1.Pt.X > op1b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n\t    var Dir2 = (op2.Pt.X > op2b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n\t    if (Dir1 == Dir2)\n\t      return false;\n\t    //When DiscardLeft, we want Op1b to be on the Left of Op1, otherwise we\n\t    //want Op1b to be on the Right. (And likewise with Op2 and Op2b.)\n\t    //So, to facilitate this while inserting Op1b and Op2b ...\n\t    //when DiscardLeft, make sure we're AT or RIGHT of Pt before adding Op1b,\n\t    //otherwise make sure we're AT or LEFT of Pt. (Likewise with Op2b.)\n\t    if (Dir1 == ClipperLib.Direction.dLeftToRight)\n\t    {\n\t      while (op1.Next.Pt.X <= Pt.X &&\n\t        op1.Next.Pt.X >= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)\n\t        op1 = op1.Next;\n\t      if (DiscardLeft && (op1.Pt.X != Pt.X))\n\t        op1 = op1.Next;\n\t      op1b = this.DupOutPt(op1, !DiscardLeft);\n\t      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n\t      {\n\t        op1 = op1b;\n\t        //op1.Pt = Pt;\n\t        op1.Pt.X = Pt.X;\n\t        op1.Pt.Y = Pt.Y;\n\t        op1b = this.DupOutPt(op1, !DiscardLeft);\n\t      }\n\t    }\n\t    else\n\t    {\n\t      while (op1.Next.Pt.X >= Pt.X &&\n\t        op1.Next.Pt.X <= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)\n\t        op1 = op1.Next;\n\t      if (!DiscardLeft && (op1.Pt.X != Pt.X))\n\t        op1 = op1.Next;\n\t      op1b = this.DupOutPt(op1, DiscardLeft);\n\t      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n\t      {\n\t        op1 = op1b;\n\t        //op1.Pt = Pt;\n\t        op1.Pt.X = Pt.X;\n\t        op1.Pt.Y = Pt.Y;\n\t        op1b = this.DupOutPt(op1, DiscardLeft);\n\t      }\n\t    }\n\t    if (Dir2 == ClipperLib.Direction.dLeftToRight)\n\t    {\n\t      while (op2.Next.Pt.X <= Pt.X &&\n\t        op2.Next.Pt.X >= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)\n\t        op2 = op2.Next;\n\t      if (DiscardLeft && (op2.Pt.X != Pt.X))\n\t        op2 = op2.Next;\n\t      op2b = this.DupOutPt(op2, !DiscardLeft);\n\t      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n\t      {\n\t        op2 = op2b;\n\t        //op2.Pt = Pt;\n\t        op2.Pt.X = Pt.X;\n\t        op2.Pt.Y = Pt.Y;\n\t        op2b = this.DupOutPt(op2, !DiscardLeft);\n\t      }\n\t    }\n\t    else\n\t    {\n\t      while (op2.Next.Pt.X >= Pt.X &&\n\t        op2.Next.Pt.X <= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)\n\t        op2 = op2.Next;\n\t      if (!DiscardLeft && (op2.Pt.X != Pt.X))\n\t        op2 = op2.Next;\n\t      op2b = this.DupOutPt(op2, DiscardLeft);\n\t      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n\t      {\n\t        op2 = op2b;\n\t        //op2.Pt = Pt;\n\t        op2.Pt.X = Pt.X;\n\t        op2.Pt.Y = Pt.Y;\n\t        op2b = this.DupOutPt(op2, DiscardLeft);\n\t      }\n\t    }\n\t    if ((Dir1 == ClipperLib.Direction.dLeftToRight) == DiscardLeft)\n\t    {\n\t      op1.Prev = op2;\n\t      op2.Next = op1;\n\t      op1b.Next = op2b;\n\t      op2b.Prev = op1b;\n\t    }\n\t    else\n\t    {\n\t      op1.Next = op2;\n\t      op2.Prev = op1;\n\t      op1b.Prev = op2b;\n\t      op2b.Next = op1b;\n\t    }\n\t    return true;\n\t  };\n\t  ClipperLib.Clipper.prototype.JoinPoints = function (j, outRec1, outRec2)\n\t  {\n\t    var op1 = j.OutPt1,\n\t      op1b = new ClipperLib.OutPt();\n\t    var op2 = j.OutPt2,\n\t      op2b = new ClipperLib.OutPt();\n\t    //There are 3 kinds of joins for output polygons ...\n\t    //1. Horizontal joins where Join.OutPt1 & Join.OutPt2 are a vertices anywhere\n\t    //along (horizontal) collinear edges (& Join.OffPt is on the same horizontal).\n\t    //2. Non-horizontal joins where Join.OutPt1 & Join.OutPt2 are at the same\n\t    //location at the Bottom of the overlapping segment (& Join.OffPt is above).\n\t    //3. StrictlySimple joins where edges touch but are not collinear and where\n\t    //Join.OutPt1, Join.OutPt2 & Join.OffPt all share the same point.\n\t    var isHorizontal = (j.OutPt1.Pt.Y == j.OffPt.Y);\n\t    if (isHorizontal && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt1.Pt)) && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt2.Pt)))\n\t    {\n\t      //Strictly Simple join ...\n\t\t\t\tif (outRec1 != outRec2) return false;\n\t\n\t      op1b = j.OutPt1.Next;\n\t      while (op1b != op1 && (ClipperLib.IntPoint.op_Equality(op1b.Pt, j.OffPt)))\n\t        op1b = op1b.Next;\n\t      var reverse1 = (op1b.Pt.Y > j.OffPt.Y);\n\t      op2b = j.OutPt2.Next;\n\t      while (op2b != op2 && (ClipperLib.IntPoint.op_Equality(op2b.Pt, j.OffPt)))\n\t        op2b = op2b.Next;\n\t      var reverse2 = (op2b.Pt.Y > j.OffPt.Y);\n\t      if (reverse1 == reverse2)\n\t        return false;\n\t      if (reverse1)\n\t      {\n\t        op1b = this.DupOutPt(op1, false);\n\t        op2b = this.DupOutPt(op2, true);\n\t        op1.Prev = op2;\n\t        op2.Next = op1;\n\t        op1b.Next = op2b;\n\t        op2b.Prev = op1b;\n\t        j.OutPt1 = op1;\n\t        j.OutPt2 = op1b;\n\t        return true;\n\t      }\n\t      else\n\t      {\n\t        op1b = this.DupOutPt(op1, true);\n\t        op2b = this.DupOutPt(op2, false);\n\t        op1.Next = op2;\n\t        op2.Prev = op1;\n\t        op1b.Prev = op2b;\n\t        op2b.Next = op1b;\n\t        j.OutPt1 = op1;\n\t        j.OutPt2 = op1b;\n\t        return true;\n\t      }\n\t    }\n\t    else if (isHorizontal)\n\t    {\n\t      //treat horizontal joins differently to non-horizontal joins since with\n\t      //them we're not yet sure where the overlapping is. OutPt1.Pt & OutPt2.Pt\n\t      //may be anywhere along the horizontal edge.\n\t      op1b = op1;\n\t      while (op1.Prev.Pt.Y == op1.Pt.Y && op1.Prev != op1b && op1.Prev != op2)\n\t        op1 = op1.Prev;\n\t      while (op1b.Next.Pt.Y == op1b.Pt.Y && op1b.Next != op1 && op1b.Next != op2)\n\t        op1b = op1b.Next;\n\t      if (op1b.Next == op1 || op1b.Next == op2)\n\t        return false;\n\t      //a flat 'polygon'\n\t      op2b = op2;\n\t      while (op2.Prev.Pt.Y == op2.Pt.Y && op2.Prev != op2b && op2.Prev != op1b)\n\t        op2 = op2.Prev;\n\t      while (op2b.Next.Pt.Y == op2b.Pt.Y && op2b.Next != op2 && op2b.Next != op1)\n\t        op2b = op2b.Next;\n\t      if (op2b.Next == op2 || op2b.Next == op1)\n\t        return false;\n\t      //a flat 'polygon'\n\t      //Op1 -. Op1b & Op2 -. Op2b are the extremites of the horizontal edges\n\t\n\t      var $val = {Left: null, Right: null};\n\t      if (!this.GetOverlap(op1.Pt.X, op1b.Pt.X, op2.Pt.X, op2b.Pt.X, $val))\n\t        return false;\n\t      var Left = $val.Left;\n\t      var Right = $val.Right;\n\t\n\t      //DiscardLeftSide: when overlapping edges are joined, a spike will created\n\t      //which needs to be cleaned up. However, we don't want Op1 or Op2 caught up\n\t      //on the discard Side as either may still be needed for other joins ...\n\t      var Pt = new ClipperLib.IntPoint();\n\t      var DiscardLeftSide;\n\t      if (op1.Pt.X >= Left && op1.Pt.X <= Right)\n\t      {\n\t        //Pt = op1.Pt;\n\t        Pt.X = op1.Pt.X;\n\t        Pt.Y = op1.Pt.Y;\n\t        DiscardLeftSide = (op1.Pt.X > op1b.Pt.X);\n\t      }\n\t      else if (op2.Pt.X >= Left && op2.Pt.X <= Right)\n\t      {\n\t        //Pt = op2.Pt;\n\t        Pt.X = op2.Pt.X;\n\t        Pt.Y = op2.Pt.Y;\n\t        DiscardLeftSide = (op2.Pt.X > op2b.Pt.X);\n\t      }\n\t      else if (op1b.Pt.X >= Left && op1b.Pt.X <= Right)\n\t      {\n\t        //Pt = op1b.Pt;\n\t        Pt.X = op1b.Pt.X;\n\t        Pt.Y = op1b.Pt.Y;\n\t        DiscardLeftSide = op1b.Pt.X > op1.Pt.X;\n\t      }\n\t      else\n\t      {\n\t        //Pt = op2b.Pt;\n\t        Pt.X = op2b.Pt.X;\n\t        Pt.Y = op2b.Pt.Y;\n\t        DiscardLeftSide = (op2b.Pt.X > op2.Pt.X);\n\t      }\n\t      j.OutPt1 = op1;\n\t      j.OutPt2 = op2;\n\t      return this.JoinHorz(op1, op1b, op2, op2b, Pt, DiscardLeftSide);\n\t    }\n\t    else\n\t    {\n\t      //nb: For non-horizontal joins ...\n\t      //    1. Jr.OutPt1.Pt.Y == Jr.OutPt2.Pt.Y\n\t      //    2. Jr.OutPt1.Pt > Jr.OffPt.Y\n\t      //make sure the polygons are correctly oriented ...\n\t      op1b = op1.Next;\n\t      while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))\n\t        op1b = op1b.Next;\n\t      var Reverse1 = ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange));\n\t      if (Reverse1)\n\t      {\n\t        op1b = op1.Prev;\n\t        while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))\n\t          op1b = op1b.Prev;\n\t        if ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange))\n\t          return false;\n\t      }\n\t      op2b = op2.Next;\n\t      while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))\n\t        op2b = op2b.Next;\n\t      var Reverse2 = ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange));\n\t      if (Reverse2)\n\t      {\n\t        op2b = op2.Prev;\n\t        while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))\n\t          op2b = op2b.Prev;\n\t        if ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange))\n\t          return false;\n\t      }\n\t      if ((op1b == op1) || (op2b == op2) || (op1b == op2b) ||\n\t        ((outRec1 == outRec2) && (Reverse1 == Reverse2)))\n\t        return false;\n\t      if (Reverse1)\n\t      {\n\t        op1b = this.DupOutPt(op1, false);\n\t        op2b = this.DupOutPt(op2, true);\n\t        op1.Prev = op2;\n\t        op2.Next = op1;\n\t        op1b.Next = op2b;\n\t        op2b.Prev = op1b;\n\t        j.OutPt1 = op1;\n\t        j.OutPt2 = op1b;\n\t        return true;\n\t      }\n\t      else\n\t      {\n\t        op1b = this.DupOutPt(op1, true);\n\t        op2b = this.DupOutPt(op2, false);\n\t        op1.Next = op2;\n\t        op2.Prev = op1;\n\t        op1b.Prev = op2b;\n\t        op2b.Next = op1b;\n\t        j.OutPt1 = op1;\n\t        j.OutPt2 = op1b;\n\t        return true;\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.Clipper.GetBounds = function (paths)\n\t  {\n\t    var i = 0,\n\t      cnt = paths.length;\n\t    while (i < cnt && paths[i].length == 0) i++;\n\t    if (i == cnt) return new ClipperLib.IntRect(0, 0, 0, 0);\n\t    var result = new ClipperLib.IntRect();\n\t    result.left = paths[i][0].X;\n\t    result.right = result.left;\n\t    result.top = paths[i][0].Y;\n\t    result.bottom = result.top;\n\t    for (; i < cnt; i++)\n\t      for (var j = 0, jlen = paths[i].length; j < jlen; j++)\n\t      {\n\t        if (paths[i][j].X < result.left) result.left = paths[i][j].X;\n\t        else if (paths[i][j].X > result.right) result.right = paths[i][j].X;\n\t        if (paths[i][j].Y < result.top) result.top = paths[i][j].Y;\n\t        else if (paths[i][j].Y > result.bottom) result.bottom = paths[i][j].Y;\n\t      }\n\t    return result;\n\t  }\n\t  ClipperLib.Clipper.prototype.GetBounds2 = function (ops)\n\t  {\n\t    var opStart = ops;\n\t    var result = new ClipperLib.IntRect();\n\t    result.left = ops.Pt.X;\n\t    result.right = ops.Pt.X;\n\t    result.top = ops.Pt.Y;\n\t    result.bottom = ops.Pt.Y;\n\t    ops = ops.Next;\n\t    while (ops != opStart)\n\t    {\n\t      if (ops.Pt.X < result.left)\n\t        result.left = ops.Pt.X;\n\t      if (ops.Pt.X > result.right)\n\t        result.right = ops.Pt.X;\n\t      if (ops.Pt.Y < result.top)\n\t        result.top = ops.Pt.Y;\n\t      if (ops.Pt.Y > result.bottom)\n\t        result.bottom = ops.Pt.Y;\n\t      ops = ops.Next;\n\t    }\n\t    return result;\n\t  };\n\t\n\t  ClipperLib.Clipper.PointInPolygon = function (pt, path)\n\t  {\n\t    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t\t\t//See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n\t    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n\t    var result = 0,\n\t      cnt = path.length;\n\t    if (cnt < 3)\n\t      return 0;\n\t    var ip = path[0];\n\t    for (var i = 1; i <= cnt; ++i)\n\t    {\n\t      var ipNext = (i == cnt ? path[0] : path[i]);\n\t      if (ipNext.Y == pt.Y)\n\t      {\n\t        if ((ipNext.X == pt.X) || (ip.Y == pt.Y && ((ipNext.X > pt.X) == (ip.X < pt.X))))\n\t          return -1;\n\t      }\n\t      if ((ip.Y < pt.Y) != (ipNext.Y < pt.Y))\n\t      {\n\t        if (ip.X >= pt.X)\n\t        {\n\t          if (ipNext.X > pt.X)\n\t            result = 1 - result;\n\t          else\n\t          {\n\t            var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n\t            if (d == 0)\n\t              return -1;\n\t            else if ((d > 0) == (ipNext.Y > ip.Y))\n\t              result = 1 - result;\n\t          }\n\t        }\n\t        else\n\t        {\n\t          if (ipNext.X > pt.X)\n\t          {\n\t            var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n\t            if (d == 0)\n\t              return -1;\n\t            else if ((d > 0) == (ipNext.Y > ip.Y))\n\t              result = 1 - result;\n\t          }\n\t        }\n\t      }\n\t      ip = ipNext;\n\t    }\n\t    return result;\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.PointInPolygon = function (pt, op)\n\t  {\n\t    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t\t\t//See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n\t    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n\t    var result = 0;\n\t    var startOp = op;\n\t\t\tvar ptx = pt.X, pty = pt.Y;\n\t    var poly0x = op.Pt.X, poly0y = op.Pt.Y;\n\t    do\n\t    {\n\t\t\t\top = op.Next;\n\t\t\t\tvar poly1x = op.Pt.X, poly1y = op.Pt.Y;\n\t      if (poly1y == pty)\n\t      {\n\t        if ((poly1x == ptx) || (poly0y == pty && ((poly1x > ptx) == (poly0x < ptx))))\n\t          return -1;\n\t      }\n\t      if ((poly0y < pty) != (poly1y < pty))\n\t      {\n\t        if (poly0x >= ptx)\n\t        {\n\t          if (poly1x > ptx)\n\t            result = 1 - result;\n\t          else\n\t          {\n\t            var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n\t            if (d == 0)\n\t              return -1;\n\t            if ((d > 0) == (poly1y > poly0y))\n\t              result = 1 - result;\n\t          }\n\t        }\n\t        else\n\t        {\n\t          if (poly1x > ptx)\n\t          {\n\t            var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n\t            if (d == 0)\n\t              return -1;\n\t            if ((d > 0) == (poly1y > poly0y))\n\t              result = 1 - result;\n\t          }\n\t        }\n\t      }\n\t      poly0x = poly1x;\n\t      poly0y = poly1y;\n\t    } while (startOp != op);\n\t\n\t    return result;\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.Poly2ContainsPoly1 = function (outPt1, outPt2)\n\t  {\n\t    var op = outPt1;\n\t    do\n\t    {\n\t\t\t\t//nb: PointInPolygon returns 0 if false, +1 if true, -1 if pt on polygon\n\t      var res = this.PointInPolygon(op.Pt, outPt2);\n\t      if (res >= 0)\n\t        return res > 0;\n\t      op = op.Next;\n\t    }\n\t    while (op != outPt1)\n\t    return true;\n\t  };\n\t  ClipperLib.Clipper.prototype.FixupFirstLefts1 = function (OldOutRec, NewOutRec)\n\t  {\n\t    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t    {\n\t\t\t\tvar outRec = this.m_PolyOuts[i];\n\t\t\t\tif (outRec.Pts == null || outRec.FirstLeft == null)\n\t\t\t\t\tcontinue;\n\t\t\t\tvar firstLeft = this.ParseFirstLeft(outRec.FirstLeft);\n\t\t\t\tif (firstLeft == OldOutRec)\n\t\t\t\t{\n\t        if (this.Poly2ContainsPoly1(outRec.Pts, NewOutRec.Pts))\n\t          outRec.FirstLeft = NewOutRec;\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.FixupFirstLefts2 = function (OldOutRec, NewOutRec)\n\t  {\n\t    for (var $i2 = 0, $t2 = this.m_PolyOuts, $l2 = $t2.length, outRec = $t2[$i2]; $i2 < $l2; $i2++, outRec = $t2[$i2])\n\t      if (outRec.FirstLeft == OldOutRec)\n\t        outRec.FirstLeft = NewOutRec;\n\t  };\n\t  ClipperLib.Clipper.ParseFirstLeft = function (FirstLeft)\n\t  {\n\t    while (FirstLeft != null && FirstLeft.Pts == null)\n\t      FirstLeft = FirstLeft.FirstLeft;\n\t    return FirstLeft;\n\t  };\n\t  ClipperLib.Clipper.prototype.JoinCommonEdges = function ()\n\t  {\n\t    for (var i = 0, ilen = this.m_Joins.length; i < ilen; i++)\n\t    {\n\t      var join = this.m_Joins[i];\n\t      var outRec1 = this.GetOutRec(join.OutPt1.Idx);\n\t      var outRec2 = this.GetOutRec(join.OutPt2.Idx);\n\t      if (outRec1.Pts == null || outRec2.Pts == null)\n\t        continue;\n\t      //get the polygon fragment with the correct hole state (FirstLeft)\n\t      //before calling JoinPoints() ...\n\t      var holeStateRec;\n\t      if (outRec1 == outRec2)\n\t        holeStateRec = outRec1;\n\t      else if (this.Param1RightOfParam2(outRec1, outRec2))\n\t        holeStateRec = outRec2;\n\t      else if (this.Param1RightOfParam2(outRec2, outRec1))\n\t        holeStateRec = outRec1;\n\t      else\n\t        holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\t\n\t      if (!this.JoinPoints(join, outRec1, outRec2)) continue;\n\t\n\t      if (outRec1 == outRec2)\n\t      {\n\t        //instead of joining two polygons, we've just created a new one by\n\t        //splitting one polygon into two.\n\t        outRec1.Pts = join.OutPt1;\n\t        outRec1.BottomPt = null;\n\t        outRec2 = this.CreateOutRec();\n\t        outRec2.Pts = join.OutPt2;\n\t        //update all OutRec2.Pts Idx's ...\n\t        this.UpdateOutPtIdxs(outRec2);\n\t        //We now need to check every OutRec.FirstLeft pointer. If it points\n\t        //to OutRec1 it may need to point to OutRec2 instead ...\n\t        if (this.m_UsingPolyTree)\n\t          for (var j = 0, jlen = this.m_PolyOuts.length; j < jlen - 1; j++)\n\t          {\n\t            var oRec = this.m_PolyOuts[j];\n\t            if (oRec.Pts == null || ClipperLib.Clipper.ParseFirstLeft(oRec.FirstLeft) != outRec1 || oRec.IsHole == outRec1.IsHole)\n\t              continue;\n\t            if (this.Poly2ContainsPoly1(oRec.Pts, join.OutPt2))\n\t              oRec.FirstLeft = outRec2;\n\t          }\n\t        if (this.Poly2ContainsPoly1(outRec2.Pts, outRec1.Pts))\n\t        {\n\t          //outRec2 is contained by outRec1 ...\n\t          outRec2.IsHole = !outRec1.IsHole;\n\t          outRec2.FirstLeft = outRec1;\n\t          //fixup FirstLeft pointers that may need reassigning to OutRec1\n\t          if (this.m_UsingPolyTree)\n\t            this.FixupFirstLefts2(outRec2, outRec1);\n\t          if ((outRec2.IsHole ^ this.ReverseSolution) == (this.Area(outRec2) > 0))\n\t            this.ReversePolyPtLinks(outRec2.Pts);\n\t        }\n\t        else if (this.Poly2ContainsPoly1(outRec1.Pts, outRec2.Pts))\n\t        {\n\t          //outRec1 is contained by outRec2 ...\n\t          outRec2.IsHole = outRec1.IsHole;\n\t          outRec1.IsHole = !outRec2.IsHole;\n\t          outRec2.FirstLeft = outRec1.FirstLeft;\n\t          outRec1.FirstLeft = outRec2;\n\t          //fixup FirstLeft pointers that may need reassigning to OutRec1\n\t          if (this.m_UsingPolyTree)\n\t            this.FixupFirstLefts2(outRec1, outRec2);\n\t          if ((outRec1.IsHole ^ this.ReverseSolution) == (this.Area(outRec1) > 0))\n\t            this.ReversePolyPtLinks(outRec1.Pts);\n\t        }\n\t        else\n\t        {\n\t          //the 2 polygons are completely separate ...\n\t          outRec2.IsHole = outRec1.IsHole;\n\t          outRec2.FirstLeft = outRec1.FirstLeft;\n\t          //fixup FirstLeft pointers that may need reassigning to OutRec2\n\t          if (this.m_UsingPolyTree)\n\t            this.FixupFirstLefts1(outRec1, outRec2);\n\t        }\n\t      }\n\t      else\n\t      {\n\t        //joined 2 polygons together ...\n\t        outRec2.Pts = null;\n\t        outRec2.BottomPt = null;\n\t        outRec2.Idx = outRec1.Idx;\n\t        outRec1.IsHole = holeStateRec.IsHole;\n\t        if (holeStateRec == outRec2)\n\t          outRec1.FirstLeft = outRec2.FirstLeft;\n\t        outRec2.FirstLeft = outRec1;\n\t        //fixup FirstLeft pointers that may need reassigning to OutRec1\n\t        if (this.m_UsingPolyTree)\n\t          this.FixupFirstLefts2(outRec2, outRec1);\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.UpdateOutPtIdxs = function (outrec)\n\t  {\n\t    var op = outrec.Pts;\n\t    do {\n\t      op.Idx = outrec.Idx;\n\t      op = op.Prev;\n\t    }\n\t    while (op != outrec.Pts)\n\t  };\n\t  ClipperLib.Clipper.prototype.DoSimplePolygons = function ()\n\t  {\n\t    var i = 0;\n\t    while (i < this.m_PolyOuts.length)\n\t    {\n\t      var outrec = this.m_PolyOuts[i++];\n\t      var op = outrec.Pts;\n\t\t\t\tif (op == null || outrec.IsOpen)\n\t\t\t\t\tcontinue;\n\t      do //for each Pt in Polygon until duplicate found do ...\n\t      {\n\t        var op2 = op.Next;\n\t        while (op2 != outrec.Pts)\n\t        {\n\t          if ((ClipperLib.IntPoint.op_Equality(op.Pt, op2.Pt)) && op2.Next != op && op2.Prev != op)\n\t          {\n\t            //split the polygon into two ...\n\t            var op3 = op.Prev;\n\t            var op4 = op2.Prev;\n\t            op.Prev = op4;\n\t            op4.Next = op;\n\t            op2.Prev = op3;\n\t            op3.Next = op2;\n\t            outrec.Pts = op;\n\t            var outrec2 = this.CreateOutRec();\n\t            outrec2.Pts = op2;\n\t            this.UpdateOutPtIdxs(outrec2);\n\t            if (this.Poly2ContainsPoly1(outrec2.Pts, outrec.Pts))\n\t            {\n\t              //OutRec2 is contained by OutRec1 ...\n\t              outrec2.IsHole = !outrec.IsHole;\n\t              outrec2.FirstLeft = outrec;\n\t\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec2, outrec);\n\t\n\t            }\n\t            else if (this.Poly2ContainsPoly1(outrec.Pts, outrec2.Pts))\n\t            {\n\t              //OutRec1 is contained by OutRec2 ...\n\t              outrec2.IsHole = outrec.IsHole;\n\t              outrec.IsHole = !outrec2.IsHole;\n\t              outrec2.FirstLeft = outrec.FirstLeft;\n\t              outrec.FirstLeft = outrec2;\n\t              if (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec, outrec2);\n\t            }\n\t            else\n\t            {\n\t              //the 2 polygons are separate ...\n\t              outrec2.IsHole = outrec.IsHole;\n\t              outrec2.FirstLeft = outrec.FirstLeft;\n\t\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts1(outrec, outrec2);\n\t            }\n\t            op2 = op;\n\t            //ie get ready for the next iteration\n\t          }\n\t          op2 = op2.Next;\n\t        }\n\t        op = op.Next;\n\t      }\n\t      while (op != outrec.Pts)\n\t    }\n\t  };\n\t  ClipperLib.Clipper.Area = function (poly)\n\t  {\n\t    var cnt = poly.length;\n\t    if (cnt < 3)\n\t      return 0;\n\t    var a = 0;\n\t    for (var i = 0, j = cnt - 1; i < cnt; ++i)\n\t    {\n\t      a += (poly[j].X + poly[i].X) * (poly[j].Y - poly[i].Y);\n\t      j = i;\n\t    }\n\t    return -a * 0.5;\n\t  };\n\t  ClipperLib.Clipper.prototype.Area = function (outRec)\n\t  {\n\t    var op = outRec.Pts;\n\t    if (op == null)\n\t      return 0;\n\t    var a = 0;\n\t    do {\n\t      a = a + (op.Prev.Pt.X + op.Pt.X) * (op.Prev.Pt.Y - op.Pt.Y);\n\t      op = op.Next;\n\t    }\n\t    while (op != outRec.Pts)\n\t    return a * 0.5;\n\t  };\n\t  ClipperLib.Clipper.SimplifyPolygon = function (poly, fillType)\n\t  {\n\t    var result = new Array();\n\t    var c = new ClipperLib.Clipper(0);\n\t    c.StrictlySimple = true;\n\t    c.AddPath(poly, ClipperLib.PolyType.ptSubject, true);\n\t    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.SimplifyPolygons = function (polys, fillType)\n\t  {\n\t    if (typeof (fillType) == \"undefined\") fillType = ClipperLib.PolyFillType.pftEvenOdd;\n\t    var result = new Array();\n\t    var c = new ClipperLib.Clipper(0);\n\t    c.StrictlySimple = true;\n\t    c.AddPaths(polys, ClipperLib.PolyType.ptSubject, true);\n\t    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.DistanceSqrd = function (pt1, pt2)\n\t  {\n\t    var dx = (pt1.X - pt2.X);\n\t    var dy = (pt1.Y - pt2.Y);\n\t    return (dx * dx + dy * dy);\n\t  };\n\t  ClipperLib.Clipper.DistanceFromLineSqrd = function (pt, ln1, ln2)\n\t  {\n\t    //The equation of a line in general form (Ax + By + C = 0)\n\t    //given 2 points (x,y) & (x,y) is ...\n\t    //(y - y)x + (x - x)y + (y - y)x - (x - x)y = 0\n\t    //A = (y - y); B = (x - x); C = (y - y)x - (x - x)y\n\t    //perpendicular distance of point (x,y) = (Ax + By + C)/Sqrt(A + B)\n\t    //see http://en.wikipedia.org/wiki/Perpendicular_distance\n\t    var A = ln1.Y - ln2.Y;\n\t    var B = ln2.X - ln1.X;\n\t    var C = A * ln1.X + B * ln1.Y;\n\t    C = A * pt.X + B * pt.Y - C;\n\t    return (C * C) / (A * A + B * B);\n\t  };\n\t\n\t\tClipperLib.Clipper.SlopesNearCollinear = function(pt1, pt2, pt3, distSqrd)\n\t\t{\n\t\t\t//this function is more accurate when the point that's GEOMETRICALLY\n\t\t\t//between the other 2 points is the one that's tested for distance.\n\t\t\t//nb: with 'spikes', either pt1 or pt3 is geometrically between the other pts\n\t\t\tif (Math.abs(pt1.X - pt2.X) > Math.abs(pt1.Y - pt2.Y))\n\t\t\t{\n\t\t\tif ((pt1.X > pt2.X) == (pt1.X < pt3.X))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n\t\t\telse if ((pt2.X > pt1.X) == (pt2.X < pt3.X))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t\t\t\t\telse\n\t\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\tif ((pt1.Y > pt2.Y) == (pt1.Y < pt3.Y))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n\t\t\telse if ((pt2.Y > pt1.Y) == (pt2.Y < pt3.Y))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t\t\t\t\telse\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n\t\t\t}\n\t\t}\n\t\n\t  ClipperLib.Clipper.PointsAreClose = function (pt1, pt2, distSqrd)\n\t  {\n\t    var dx = pt1.X - pt2.X;\n\t    var dy = pt1.Y - pt2.Y;\n\t    return ((dx * dx) + (dy * dy) <= distSqrd);\n\t  };\n\t  //------------------------------------------------------------------------------\n\t  ClipperLib.Clipper.ExcludeOp = function (op)\n\t  {\n\t    var result = op.Prev;\n\t    result.Next = op.Next;\n\t    op.Next.Prev = result;\n\t    result.Idx = 0;\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.CleanPolygon = function (path, distance)\n\t  {\n\t    if (typeof (distance) == \"undefined\") distance = 1.415;\n\t    //distance = proximity in units/pixels below which vertices will be stripped.\n\t    //Default ~= sqrt(2) so when adjacent vertices or semi-adjacent vertices have\n\t    //both x & y coords within 1 unit, then the second vertex will be stripped.\n\t    var cnt = path.length;\n\t    if (cnt == 0)\n\t      return new Array();\n\t    var outPts = new Array(cnt);\n\t    for (var i = 0; i < cnt; ++i)\n\t      outPts[i] = new ClipperLib.OutPt();\n\t    for (var i = 0; i < cnt; ++i)\n\t    {\n\t      outPts[i].Pt = path[i];\n\t      outPts[i].Next = outPts[(i + 1) % cnt];\n\t      outPts[i].Next.Prev = outPts[i];\n\t      outPts[i].Idx = 0;\n\t    }\n\t    var distSqrd = distance * distance;\n\t    var op = outPts[0];\n\t    while (op.Idx == 0 && op.Next != op.Prev)\n\t    {\n\t      if (ClipperLib.Clipper.PointsAreClose(op.Pt, op.Prev.Pt, distSqrd))\n\t      {\n\t        op = ClipperLib.Clipper.ExcludeOp(op);\n\t        cnt--;\n\t      }\n\t      else if (ClipperLib.Clipper.PointsAreClose(op.Prev.Pt, op.Next.Pt, distSqrd))\n\t      {\n\t        ClipperLib.Clipper.ExcludeOp(op.Next);\n\t        op = ClipperLib.Clipper.ExcludeOp(op);\n\t        cnt -= 2;\n\t      }\n\t      else if (ClipperLib.Clipper.SlopesNearCollinear(op.Prev.Pt, op.Pt, op.Next.Pt, distSqrd))\n\t      {\n\t        op = ClipperLib.Clipper.ExcludeOp(op);\n\t        cnt--;\n\t      }\n\t      else\n\t      {\n\t        op.Idx = 1;\n\t        op = op.Next;\n\t      }\n\t    }\n\t    if (cnt < 3)\n\t      cnt = 0;\n\t    var result = new Array(cnt);\n\t    for (var i = 0; i < cnt; ++i)\n\t    {\n\t      result[i] = new ClipperLib.IntPoint(op.Pt);\n\t      op = op.Next;\n\t    }\n\t    outPts = null;\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.CleanPolygons = function (polys, distance)\n\t  {\n\t    var result = new Array(polys.length);\n\t    for (var i = 0, ilen = polys.length; i < ilen; i++)\n\t      result[i] = ClipperLib.Clipper.CleanPolygon(polys[i], distance);\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.Minkowski = function (pattern, path, IsSum, IsClosed)\n\t  {\n\t    var delta = (IsClosed ? 1 : 0);\n\t    var polyCnt = pattern.length;\n\t    var pathCnt = path.length;\n\t    var result = new Array();\n\t    if (IsSum)\n\t      for (var i = 0; i < pathCnt; i++)\n\t      {\n\t        var p = new Array(polyCnt);\n\t        for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n\t          p[j] = new ClipperLib.IntPoint(path[i].X + ip.X, path[i].Y + ip.Y);\n\t        result.push(p);\n\t      }\n\t    else\n\t      for (var i = 0; i < pathCnt; i++)\n\t      {\n\t        var p = new Array(polyCnt);\n\t        for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n\t          p[j] = new ClipperLib.IntPoint(path[i].X - ip.X, path[i].Y - ip.Y);\n\t        result.push(p);\n\t      }\n\t    var quads = new Array();\n\t    for (var i = 0; i < pathCnt - 1 + delta; i++)\n\t      for (var j = 0; j < polyCnt; j++)\n\t      {\n\t        var quad = new Array();\n\t        quad.push(result[i % pathCnt][j % polyCnt]);\n\t        quad.push(result[(i + 1) % pathCnt][j % polyCnt]);\n\t        quad.push(result[(i + 1) % pathCnt][(j + 1) % polyCnt]);\n\t        quad.push(result[i % pathCnt][(j + 1) % polyCnt]);\n\t        if (!ClipperLib.Clipper.Orientation(quad))\n\t          quad.reverse();\n\t        quads.push(quad);\n\t      }\n\t\t\t\treturn quads;\n\t  };\n\t\n\t\tClipperLib.Clipper.MinkowskiSum = function(pattern, path_or_paths, pathIsClosed)\n\t\t{\n\t\t\tif(!(path_or_paths[0] instanceof Array))\n\t\t\t{\n\t\t\t\tvar path = path_or_paths;\n\t\t\t\tvar paths = ClipperLib.Clipper.Minkowski(pattern, path, true, pathIsClosed);\n\t\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\t\tc.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n\t\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\t\treturn paths;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t \t\t\tvar paths = path_or_paths;\n\t\t\t\tvar solution = new ClipperLib.Paths();\n\t\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\t\tfor (var i = 0; i < paths.length; ++i)\n\t\t\t\t{\n\t\t\t\t\tvar tmp = ClipperLib.Clipper.Minkowski(pattern, paths[i], true, pathIsClosed);\n\t\t\t\t\tc.AddPaths(tmp, ClipperLib.PolyType.ptSubject, true);\n\t\t\t\t\tif (pathIsClosed)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar path = ClipperLib.Clipper.TranslatePath(paths[i], pattern[0]);\n\t\t\t\t\t\tc.AddPath(path, ClipperLib.PolyType.ptClip, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, solution,\n\t\t\t\t\tClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\t\treturn solution;\n\t\t\t}\n\t\t}\n\t\t//------------------------------------------------------------------------------\n\t\n\t\tClipperLib.Clipper.TranslatePath = function (path, delta)\n\t\t{\n\t\t\tvar outPath = new ClipperLib.Path();\n\t\t\tfor (var i = 0; i < path.length; i++)\n\t\t\t\toutPath.push(new ClipperLib.IntPoint(path[i].X + delta.X, path[i].Y + delta.Y));\n\t\t\treturn outPath;\n\t\t}\n\t\t//------------------------------------------------------------------------------\n\t\n\t\tClipperLib.Clipper.MinkowskiDiff = function (poly1, poly2)\n\t\t{\n\t\t\tvar paths = ClipperLib.Clipper.Minkowski(poly1, poly2, false, true);\n\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\tc.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\treturn paths;\n\t\t}\n\t\n\t  ClipperLib.Clipper.PolyTreeToPaths = function (polytree)\n\t  {\n\t    var result = new Array();\n\t    //result.set_Capacity(polytree.get_Total());\n\t    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntAny, result);\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.AddPolyNodeToPaths = function (polynode, nt, paths)\n\t  {\n\t    var match = true;\n\t    switch (nt)\n\t    {\n\t    case ClipperLib.Clipper.NodeType.ntOpen:\n\t      return;\n\t    case ClipperLib.Clipper.NodeType.ntClosed:\n\t      match = !polynode.IsOpen;\n\t      break;\n\t    default:\n\t      break;\n\t    }\n\t    if (polynode.m_polygon.length > 0 && match)\n\t      paths.push(polynode.m_polygon);\n\t    for (var $i3 = 0, $t3 = polynode.Childs(), $l3 = $t3.length, pn = $t3[$i3]; $i3 < $l3; $i3++, pn = $t3[$i3])\n\t      ClipperLib.Clipper.AddPolyNodeToPaths(pn, nt, paths);\n\t  };\n\t  ClipperLib.Clipper.OpenPathsFromPolyTree = function (polytree)\n\t  {\n\t    var result = new ClipperLib.Paths();\n\t    //result.set_Capacity(polytree.ChildCount());\n\t    for (var i = 0, ilen = polytree.ChildCount(); i < ilen; i++)\n\t      if (polytree.Childs()[i].IsOpen)\n\t        result.push(polytree.Childs()[i].m_polygon);\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.ClosedPathsFromPolyTree = function (polytree)\n\t  {\n\t    var result = new ClipperLib.Paths();\n\t    //result.set_Capacity(polytree.Total());\n\t    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntClosed, result);\n\t    return result;\n\t  };\n\t  Inherit(ClipperLib.Clipper, ClipperLib.ClipperBase);\n\t  ClipperLib.Clipper.NodeType = {\n\t    ntAny: 0,\n\t    ntOpen: 1,\n\t    ntClosed: 2\n\t  };\n\t  ClipperLib.ClipperOffset = function (miterLimit, arcTolerance)\n\t  {\n\t    if (typeof (miterLimit) == \"undefined\") miterLimit = 2;\n\t    if (typeof (arcTolerance) == \"undefined\") arcTolerance = ClipperLib.ClipperOffset.def_arc_tolerance;\n\t    this.m_destPolys = new ClipperLib.Paths();\n\t    this.m_srcPoly = new ClipperLib.Path();\n\t    this.m_destPoly = new ClipperLib.Path();\n\t    this.m_normals = new Array();\n\t    this.m_delta = 0;\n\t    this.m_sinA = 0;\n\t    this.m_sin = 0;\n\t    this.m_cos = 0;\n\t    this.m_miterLim = 0;\n\t    this.m_StepsPerRad = 0;\n\t    this.m_lowest = new ClipperLib.IntPoint();\n\t    this.m_polyNodes = new ClipperLib.PolyNode();\n\t    this.MiterLimit = miterLimit;\n\t    this.ArcTolerance = arcTolerance;\n\t    this.m_lowest.X = -1;\n\t  };\n\t  ClipperLib.ClipperOffset.two_pi = 6.28318530717959;\n\t  ClipperLib.ClipperOffset.def_arc_tolerance = 0.25;\n\t  ClipperLib.ClipperOffset.prototype.Clear = function ()\n\t  {\n\t    ClipperLib.Clear(this.m_polyNodes.Childs());\n\t    this.m_lowest.X = -1;\n\t  };\n\t  ClipperLib.ClipperOffset.Round = ClipperLib.Clipper.Round;\n\t  ClipperLib.ClipperOffset.prototype.AddPath = function (path, joinType, endType)\n\t  {\n\t    var highI = path.length - 1;\n\t    if (highI < 0)\n\t      return;\n\t    var newNode = new ClipperLib.PolyNode();\n\t    newNode.m_jointype = joinType;\n\t    newNode.m_endtype = endType;\n\t    //strip duplicate points from path and also get index to the lowest point ...\n\t    if (endType == ClipperLib.EndType.etClosedLine || endType == ClipperLib.EndType.etClosedPolygon)\n\t      while (highI > 0 && ClipperLib.IntPoint.op_Equality(path[0], path[highI]))\n\t        highI--;\n\t    //newNode.m_polygon.set_Capacity(highI + 1);\n\t    newNode.m_polygon.push(path[0]);\n\t    var j = 0,\n\t      k = 0;\n\t    for (var i = 1; i <= highI; i++)\n\t      if (ClipperLib.IntPoint.op_Inequality(newNode.m_polygon[j], path[i]))\n\t      {\n\t        j++;\n\t        newNode.m_polygon.push(path[i]);\n\t        if (path[i].Y > newNode.m_polygon[k].Y || (path[i].Y == newNode.m_polygon[k].Y && path[i].X < newNode.m_polygon[k].X))\n\t          k = j;\n\t      }\n\t    if (endType == ClipperLib.EndType.etClosedPolygon && j < 2) return;\n\t\n\t    this.m_polyNodes.AddChild(newNode);\n\t    //if this path's lowest pt is lower than all the others then update m_lowest\n\t    if (endType != ClipperLib.EndType.etClosedPolygon)\n\t      return;\n\t    if (this.m_lowest.X < 0)\n\t      this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);\n\t    else\n\t    {\n\t      var ip = this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon[this.m_lowest.Y];\n\t      if (newNode.m_polygon[k].Y > ip.Y || (newNode.m_polygon[k].Y == ip.Y && newNode.m_polygon[k].X < ip.X))\n\t        this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);\n\t    }\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.AddPaths = function (paths, joinType, endType)\n\t  {\n\t    for (var i = 0, ilen = paths.length; i < ilen; i++)\n\t      this.AddPath(paths[i], joinType, endType);\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.FixOrientations = function ()\n\t  {\n\t    //fixup orientations of all closed paths if the orientation of the\n\t    //closed path with the lowermost vertex is wrong ...\n\t    if (this.m_lowest.X >= 0 && !ClipperLib.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon))\n\t    {\n\t      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t      {\n\t        var node = this.m_polyNodes.Childs()[i];\n\t        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon || (node.m_endtype == ClipperLib.EndType.etClosedLine && ClipperLib.Clipper.Orientation(node.m_polygon)))\n\t          node.m_polygon.reverse();\n\t      }\n\t    }\n\t    else\n\t    {\n\t      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t      {\n\t        var node = this.m_polyNodes.Childs()[i];\n\t        if (node.m_endtype == ClipperLib.EndType.etClosedLine && !ClipperLib.Clipper.Orientation(node.m_polygon))\n\t          node.m_polygon.reverse();\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.ClipperOffset.GetUnitNormal = function (pt1, pt2)\n\t  {\n\t    var dx = (pt2.X - pt1.X);\n\t    var dy = (pt2.Y - pt1.Y);\n\t    if ((dx == 0) && (dy == 0))\n\t      return new ClipperLib.DoublePoint(0, 0);\n\t    var f = 1 / Math.sqrt(dx * dx + dy * dy);\n\t    dx *= f;\n\t    dy *= f;\n\t    return new ClipperLib.DoublePoint(dy, -dx);\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.DoOffset = function (delta)\n\t  {\n\t    this.m_destPolys = new Array();\n\t    this.m_delta = delta;\n\t    //if Zero offset, just copy any CLOSED polygons to m_p and return ...\n\t    if (ClipperLib.ClipperBase.near_zero(delta))\n\t    {\n\t      //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount);\n\t      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t      {\n\t        var node = this.m_polyNodes.Childs()[i];\n\t        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n\t          this.m_destPolys.push(node.m_polygon);\n\t      }\n\t      return;\n\t    }\n\t    //see offset_triginometry3.svg in the documentation folder ...\n\t    if (this.MiterLimit > 2)\n\t      this.m_miterLim = 2 / (this.MiterLimit * this.MiterLimit);\n\t    else\n\t      this.m_miterLim = 0.5;\n\t    var y;\n\t    if (this.ArcTolerance <= 0)\n\t      y = ClipperLib.ClipperOffset.def_arc_tolerance;\n\t    else if (this.ArcTolerance > Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance)\n\t      y = Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance;\n\t    else\n\t      y = this.ArcTolerance;\n\t    //see offset_triginometry2.svg in the documentation folder ...\n\t    var steps = 3.14159265358979 / Math.acos(1 - y / Math.abs(delta));\n\t    this.m_sin = Math.sin(ClipperLib.ClipperOffset.two_pi / steps);\n\t    this.m_cos = Math.cos(ClipperLib.ClipperOffset.two_pi / steps);\n\t    this.m_StepsPerRad = steps / ClipperLib.ClipperOffset.two_pi;\n\t    if (delta < 0)\n\t      this.m_sin = -this.m_sin;\n\t    //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount * 2);\n\t    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t    {\n\t      var node = this.m_polyNodes.Childs()[i];\n\t      this.m_srcPoly = node.m_polygon;\n\t      var len = this.m_srcPoly.length;\n\t      if (len == 0 || (delta <= 0 && (len < 3 || node.m_endtype != ClipperLib.EndType.etClosedPolygon)))\n\t        continue;\n\t      this.m_destPoly = new Array();\n\t      if (len == 1)\n\t      {\n\t        if (node.m_jointype == ClipperLib.JoinType.jtRound)\n\t        {\n\t          var X = 1,\n\t            Y = 0;\n\t          for (var j = 1; j <= steps; j++)\n\t          {\n\t            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n\t            var X2 = X;\n\t            X = X * this.m_cos - this.m_sin * Y;\n\t            Y = X2 * this.m_sin + Y * this.m_cos;\n\t          }\n\t        }\n\t        else\n\t        {\n\t          var X = -1,\n\t            Y = -1;\n\t          for (var j = 0; j < 4; ++j)\n\t          {\n\t            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n\t            if (X < 0)\n\t              X = 1;\n\t            else if (Y < 0)\n\t              Y = 1;\n\t            else\n\t              X = -1;\n\t          }\n\t        }\n\t        this.m_destPolys.push(this.m_destPoly);\n\t        continue;\n\t      }\n\t      //build m_normals ...\n\t      this.m_normals.length = 0;\n\t      //this.m_normals.set_Capacity(len);\n\t      for (var j = 0; j < len - 1; j++)\n\t        this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[j], this.m_srcPoly[j + 1]));\n\t      if (node.m_endtype == ClipperLib.EndType.etClosedLine || node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n\t        this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[len - 1], this.m_srcPoly[0]));\n\t      else\n\t        this.m_normals.push(new ClipperLib.DoublePoint(this.m_normals[len - 2]));\n\t      if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n\t      {\n\t        var k = len - 1;\n\t        for (var j = 0; j < len; j++)\n\t          k = this.OffsetPoint(j, k, node.m_jointype);\n\t        this.m_destPolys.push(this.m_destPoly);\n\t      }\n\t      else if (node.m_endtype == ClipperLib.EndType.etClosedLine)\n\t      {\n\t        var k = len - 1;\n\t        for (var j = 0; j < len; j++)\n\t          k = this.OffsetPoint(j, k, node.m_jointype);\n\t        this.m_destPolys.push(this.m_destPoly);\n\t        this.m_destPoly = new Array();\n\t        //re-build m_normals ...\n\t        var n = this.m_normals[len - 1];\n\t        for (var j = len - 1; j > 0; j--)\n\t          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n\t        this.m_normals[0] = new ClipperLib.DoublePoint(-n.X, -n.Y);\n\t        k = 0;\n\t        for (var j = len - 1; j >= 0; j--)\n\t          k = this.OffsetPoint(j, k, node.m_jointype);\n\t        this.m_destPolys.push(this.m_destPoly);\n\t      }\n\t      else\n\t      {\n\t        var k = 0;\n\t        for (var j = 1; j < len - 1; ++j)\n\t          k = this.OffsetPoint(j, k, node.m_jointype);\n\t        var pt1;\n\t        if (node.m_endtype == ClipperLib.EndType.etOpenButt)\n\t        {\n\t          var j = len - 1;\n\t          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * delta));\n\t          this.m_destPoly.push(pt1);\n\t          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X - this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y - this.m_normals[j].Y * delta));\n\t          this.m_destPoly.push(pt1);\n\t        }\n\t        else\n\t        {\n\t          var j = len - 1;\n\t          k = len - 2;\n\t          this.m_sinA = 0;\n\t          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j].X, -this.m_normals[j].Y);\n\t          if (node.m_endtype == ClipperLib.EndType.etOpenSquare)\n\t            this.DoSquare(j, k);\n\t          else\n\t            this.DoRound(j, k);\n\t        }\n\t        //re-build m_normals ...\n\t        for (var j = len - 1; j > 0; j--)\n\t          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n\t        this.m_normals[0] = new ClipperLib.DoublePoint(-this.m_normals[1].X, -this.m_normals[1].Y);\n\t        k = len - 1;\n\t        for (var j = k - 1; j > 0; --j)\n\t          k = this.OffsetPoint(j, k, node.m_jointype);\n\t        if (node.m_endtype == ClipperLib.EndType.etOpenButt)\n\t        {\n\t          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X - this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y - this.m_normals[0].Y * delta));\n\t          this.m_destPoly.push(pt1);\n\t          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + this.m_normals[0].Y * delta));\n\t          this.m_destPoly.push(pt1);\n\t        }\n\t        else\n\t        {\n\t          k = 1;\n\t          this.m_sinA = 0;\n\t          if (node.m_endtype == ClipperLib.EndType.etOpenSquare)\n\t            this.DoSquare(0, 1);\n\t          else\n\t            this.DoRound(0, 1);\n\t        }\n\t        this.m_destPolys.push(this.m_destPoly);\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.Execute = function ()\n\t  {\n\t    var a = arguments,\n\t      ispolytree = a[0] instanceof ClipperLib.PolyTree;\n\t    if (!ispolytree) // function (solution, delta)\n\t    {\n\t      var solution = a[0],\n\t        delta = a[1];\n\t      ClipperLib.Clear(solution);\n\t      this.FixOrientations();\n\t      this.DoOffset(delta);\n\t      //now clean up 'corners' ...\n\t      var clpr = new ClipperLib.Clipper(0);\n\t      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n\t      if (delta > 0)\n\t      {\n\t        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n\t      }\n\t      else\n\t      {\n\t        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n\t        var outer = new ClipperLib.Path();\n\t        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n\t        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n\t        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n\t        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n\t        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n\t        clpr.ReverseSolution = true;\n\t        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n\t        if (solution.length > 0)\n\t          solution.splice(0, 1);\n\t      }\n\t      //console.log(JSON.stringify(solution));\n\t    }\n\t    else // function (polytree, delta)\n\t    {\n\t      var solution = a[0],\n\t        delta = a[1];\n\t      solution.Clear();\n\t      this.FixOrientations();\n\t      this.DoOffset(delta);\n\t      //now clean up 'corners' ...\n\t      var clpr = new ClipperLib.Clipper(0);\n\t      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n\t      if (delta > 0)\n\t      {\n\t        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n\t      }\n\t      else\n\t      {\n\t        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n\t        var outer = new ClipperLib.Path();\n\t        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n\t        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n\t        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n\t        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n\t        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n\t        clpr.ReverseSolution = true;\n\t        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n\t        //remove the outer PolyNode rectangle ...\n\t        if (solution.ChildCount() == 1 && solution.Childs()[0].ChildCount() > 0)\n\t        {\n\t          var outerNode = solution.Childs()[0];\n\t          //solution.Childs.set_Capacity(outerNode.ChildCount);\n\t          solution.Childs()[0] = outerNode.Childs()[0];\n\t          solution.Childs()[0].m_Parent = solution;\n\t          for (var i = 1; i < outerNode.ChildCount(); i++)\n\t            solution.AddChild(outerNode.Childs()[i]);\n\t        }\n\t        else\n\t          solution.Clear();\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.OffsetPoint = function (j, k, jointype)\n\t  {\n\t\t\t//cross product ...\n\t\t\tthis.m_sinA = (this.m_normals[k].X * this.m_normals[j].Y - this.m_normals[j].X * this.m_normals[k].Y);\n\t\n\t\t\tif (Math.abs(this.m_sinA * this.m_delta) < 1.0)\n\t\t\t{\n\t\t\t\t//dot product ...\n\t\t\t\tvar cosA = (this.m_normals[k].X * this.m_normals[j].X + this.m_normals[j].Y * this.m_normals[k].Y);\n\t\t\t\tif (cosA > 0) // angle ==> 0 degrees\n\t\t\t\t{\n\t\t\t\t\tthis.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),\n\t\t\t\t\t\tClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n\t\t\t\t\treturn k;\n\t\t\t\t}\n\t\t\t\t//else angle ==> 180 degrees\n\t\t\t}\n\t    else if (this.m_sinA > 1)\n\t      this.m_sinA = 1.0;\n\t    else if (this.m_sinA < -1)\n\t      this.m_sinA = -1.0;\n\t    if (this.m_sinA * this.m_delta < 0)\n\t    {\n\t      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),\n\t        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n\t      this.m_destPoly.push(new ClipperLib.IntPoint(this.m_srcPoly[j]));\n\t      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n\t        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n\t    }\n\t    else\n\t      switch (jointype)\n\t      {\n\t      case ClipperLib.JoinType.jtMiter:\n\t        {\n\t          var r = 1 + (this.m_normals[j].X * this.m_normals[k].X + this.m_normals[j].Y * this.m_normals[k].Y);\n\t          if (r >= this.m_miterLim)\n\t            this.DoMiter(j, k, r);\n\t          else\n\t            this.DoSquare(j, k);\n\t          break;\n\t        }\n\t      case ClipperLib.JoinType.jtSquare:\n\t        this.DoSquare(j, k);\n\t        break;\n\t      case ClipperLib.JoinType.jtRound:\n\t        this.DoRound(j, k);\n\t        break;\n\t      }\n\t    k = j;\n\t    return k;\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.DoSquare = function (j, k)\n\t  {\n\t    var dx = Math.tan(Math.atan2(this.m_sinA,\n\t      this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y) / 4);\n\t    this.m_destPoly.push(new ClipperLib.IntPoint(\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[k].X - this.m_normals[k].Y * dx)),\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[k].Y + this.m_normals[k].X * dx))));\n\t    this.m_destPoly.push(new ClipperLib.IntPoint(\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[j].X + this.m_normals[j].Y * dx)),\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[j].Y - this.m_normals[j].X * dx))));\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.DoMiter = function (j, k, r)\n\t  {\n\t    var q = this.m_delta / r;\n\t    this.m_destPoly.push(new ClipperLib.IntPoint(\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + (this.m_normals[k].X + this.m_normals[j].X) * q),\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + (this.m_normals[k].Y + this.m_normals[j].Y) * q)));\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.DoRound = function (j, k)\n\t  {\n\t    var a = Math.atan2(this.m_sinA,\n\t      this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y);\n\t\n\t    \tvar steps = Math.max(ClipperLib.Cast_Int32(ClipperLib.ClipperOffset.Round(this.m_StepsPerRad * Math.abs(a))), 1);\n\t\n\t    var X = this.m_normals[k].X,\n\t      Y = this.m_normals[k].Y,\n\t      X2;\n\t    for (var i = 0; i < steps; ++i)\n\t    {\n\t      this.m_destPoly.push(new ClipperLib.IntPoint(\n\t        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + X * this.m_delta),\n\t        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + Y * this.m_delta)));\n\t      X2 = X;\n\t      X = X * this.m_cos - this.m_sin * Y;\n\t      Y = X2 * this.m_sin + Y * this.m_cos;\n\t    }\n\t    this.m_destPoly.push(new ClipperLib.IntPoint(\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n\t  };\n\t  ClipperLib.Error = function (message)\n\t  {\n\t    try\n\t    {\n\t      throw new Error(message);\n\t    }\n\t    catch (err)\n\t    {\n\t      alert(err.message);\n\t    }\n\t  };\n\t  // ---------------------------------\n\t  // JS extension by Timo 2013\n\t  ClipperLib.JS = {};\n\t  ClipperLib.JS.AreaOfPolygon = function (poly, scale)\n\t  {\n\t    if (!scale) scale = 1;\n\t    return ClipperLib.Clipper.Area(poly) / (scale * scale);\n\t  };\n\t  ClipperLib.JS.AreaOfPolygons = function (poly, scale)\n\t  {\n\t    if (!scale) scale = 1;\n\t    var area = 0;\n\t    for (var i = 0; i < poly.length; i++)\n\t    {\n\t      area += ClipperLib.Clipper.Area(poly[i]);\n\t    }\n\t    return area / (scale * scale);\n\t  };\n\t  ClipperLib.JS.BoundsOfPath = function (path, scale)\n\t  {\n\t    return ClipperLib.JS.BoundsOfPaths([path], scale);\n\t  };\n\t  ClipperLib.JS.BoundsOfPaths = function (paths, scale)\n\t  {\n\t    if (!scale) scale = 1;\n\t    var bounds = ClipperLib.Clipper.GetBounds(paths);\n\t    bounds.left /= scale;\n\t    bounds.bottom /= scale;\n\t    bounds.right /= scale;\n\t    bounds.top /= scale;\n\t    return bounds;\n\t  };\n\t  // Clean() joins vertices that are too near each other\n\t  // and causes distortion to offsetted polygons without cleaning\n\t  ClipperLib.JS.Clean = function (polygon, delta)\n\t  {\n\t    if (!(polygon instanceof Array)) return [];\n\t    var isPolygons = polygon[0] instanceof Array;\n\t    var polygon = ClipperLib.JS.Clone(polygon);\n\t    if (typeof delta != \"number\" || delta === null)\n\t    {\n\t      ClipperLib.Error(\"Delta is not a number in Clean().\");\n\t      return polygon;\n\t    }\n\t    if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || delta < 0) return polygon;\n\t    if (!isPolygons) polygon = [polygon];\n\t    var k_length = polygon.length;\n\t    var len, poly, result, d, p, j, i;\n\t    var results = [];\n\t    for (var k = 0; k < k_length; k++)\n\t    {\n\t      poly = polygon[k];\n\t      len = poly.length;\n\t      if (len === 0) continue;\n\t      else if (len < 3)\n\t      {\n\t        result = poly;\n\t        results.push(result);\n\t        continue;\n\t      }\n\t      result = poly;\n\t      d = delta * delta;\n\t      //d = Math.floor(c_delta * c_delta);\n\t      p = poly[0];\n\t      j = 1;\n\t      for (i = 1; i < len; i++)\n\t      {\n\t        if ((poly[i].X - p.X) * (poly[i].X - p.X) +\n\t          (poly[i].Y - p.Y) * (poly[i].Y - p.Y) <= d)\n\t          continue;\n\t        result[j] = poly[i];\n\t        p = poly[i];\n\t        j++;\n\t      }\n\t      p = poly[j - 1];\n\t      if ((poly[0].X - p.X) * (poly[0].X - p.X) +\n\t        (poly[0].Y - p.Y) * (poly[0].Y - p.Y) <= d)\n\t        j--;\n\t      if (j < len)\n\t        result.splice(j, len - j);\n\t      if (result.length) results.push(result);\n\t    }\n\t    if (!isPolygons && results.length) results = results[0];\n\t    else if (!isPolygons && results.length === 0) results = [];\n\t    else if (isPolygons && results.length === 0) results = [\n\t      []\n\t    ];\n\t    return results;\n\t  }\n\t  // Make deep copy of Polygons or Polygon\n\t  // so that also IntPoint objects are cloned and not only referenced\n\t  // This should be the fastest way\n\t  ClipperLib.JS.Clone = function (polygon)\n\t  {\n\t    if (!(polygon instanceof Array)) return [];\n\t    if (polygon.length === 0) return [];\n\t    else if (polygon.length == 1 && polygon[0].length === 0) return [[]];\n\t    var isPolygons = polygon[0] instanceof Array;\n\t    if (!isPolygons) polygon = [polygon];\n\t    var len = polygon.length,\n\t      plen, i, j, result;\n\t    var results = new Array(len);\n\t    for (i = 0; i < len; i++)\n\t    {\n\t      plen = polygon[i].length;\n\t      result = new Array(plen);\n\t      for (j = 0; j < plen; j++)\n\t      {\n\t        result[j] = {\n\t          X: polygon[i][j].X,\n\t          Y: polygon[i][j].Y\n\t        };\n\t      }\n\t      results[i] = result;\n\t    }\n\t    if (!isPolygons) results = results[0];\n\t    return results;\n\t  };\n\t  // Removes points that doesn't affect much to the visual appearance.\n\t  // If middle point is at or under certain distance (tolerance) of the line segment between\n\t  // start and end point, the middle point is removed.\n\t  ClipperLib.JS.Lighten = function (polygon, tolerance)\n\t  {\n\t    if (!(polygon instanceof Array)) return [];\n\t    if (typeof tolerance != \"number\" || tolerance === null)\n\t    {\n\t      ClipperLib.Error(\"Tolerance is not a number in Lighten().\")\n\t      return ClipperLib.JS.Clone(polygon);\n\t    }\n\t    if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || tolerance < 0)\n\t    {\n\t      return ClipperLib.JS.Clone(polygon);\n\t    }\n\t    if (!(polygon[0] instanceof Array)) polygon = [polygon];\n\t    var i, j, poly, k, poly2, plen, A, B, P, d, rem, addlast;\n\t    var bxax, byay, l, ax, ay;\n\t    var len = polygon.length;\n\t    var toleranceSq = tolerance * tolerance;\n\t    var results = [];\n\t    for (i = 0; i < len; i++)\n\t    {\n\t      poly = polygon[i];\n\t      plen = poly.length;\n\t      if (plen == 0) continue;\n\t      for (k = 0; k < 1000000; k++) // could be forever loop, but wiser to restrict max repeat count\n\t      {\n\t        poly2 = [];\n\t        plen = poly.length;\n\t        // the first have to added to the end, if first and last are not the same\n\t        // this way we ensure that also the actual last point can be removed if needed\n\t        if (poly[plen - 1].X != poly[0].X || poly[plen - 1].Y != poly[0].Y)\n\t        {\n\t          addlast = 1;\n\t          poly.push(\n\t          {\n\t            X: poly[0].X,\n\t            Y: poly[0].Y\n\t          });\n\t          plen = poly.length;\n\t        }\n\t        else addlast = 0;\n\t        rem = []; // Indexes of removed points\n\t        for (j = 0; j < plen - 2; j++)\n\t        {\n\t          A = poly[j]; // Start point of line segment\n\t          P = poly[j + 1]; // Middle point. This is the one to be removed.\n\t          B = poly[j + 2]; // End point of line segment\n\t          ax = A.X;\n\t          ay = A.Y;\n\t          bxax = B.X - ax;\n\t          byay = B.Y - ay;\n\t          if (bxax !== 0 || byay !== 0) // To avoid Nan, when A==P && P==B. And to avoid peaks (A==B && A!=P), which have lenght, but not area.\n\t          {\n\t            l = ((P.X - ax) * bxax + (P.Y - ay) * byay) / (bxax * bxax + byay * byay);\n\t            if (l > 1)\n\t            {\n\t              ax = B.X;\n\t              ay = B.Y;\n\t            }\n\t            else if (l > 0)\n\t            {\n\t              ax += bxax * l;\n\t              ay += byay * l;\n\t            }\n\t          }\n\t          bxax = P.X - ax;\n\t          byay = P.Y - ay;\n\t          d = bxax * bxax + byay * byay;\n\t          if (d <= toleranceSq)\n\t          {\n\t            rem[j + 1] = 1;\n\t            j++; // when removed, transfer the pointer to the next one\n\t          }\n\t        }\n\t        // add all unremoved points to poly2\n\t        poly2.push(\n\t        {\n\t          X: poly[0].X,\n\t          Y: poly[0].Y\n\t        });\n\t        for (j = 1; j < plen - 1; j++)\n\t          if (!rem[j]) poly2.push(\n\t          {\n\t            X: poly[j].X,\n\t            Y: poly[j].Y\n\t          });\n\t        poly2.push(\n\t        {\n\t          X: poly[plen - 1].X,\n\t          Y: poly[plen - 1].Y\n\t        });\n\t        // if the first point was added to the end, remove it\n\t        if (addlast) poly.pop();\n\t        // break, if there was not anymore removed points\n\t        if (!rem.length) break;\n\t        // else continue looping using poly2, to check if there are points to remove\n\t        else poly = poly2;\n\t      }\n\t      plen = poly2.length;\n\t      // remove duplicate from end, if needed\n\t      if (poly2[plen - 1].X == poly2[0].X && poly2[plen - 1].Y == poly2[0].Y)\n\t      {\n\t        poly2.pop();\n\t      }\n\t      if (poly2.length > 2) // to avoid two-point-polygons\n\t        results.push(poly2);\n\t    }\n\t    if (!(polygon[0] instanceof Array)) results = results[0];\n\t    if (typeof (results) == \"undefined\") results = [\n\t      []\n\t    ];\n\t    return results;\n\t  }\n\t  ClipperLib.JS.PerimeterOfPath = function (path, closed, scale)\n\t  {\n\t    if (typeof (path) == \"undefined\") return 0;\n\t    var sqrt = Math.sqrt;\n\t    var perimeter = 0.0;\n\t    var p1, p2, p1x = 0.0,\n\t      p1y = 0.0,\n\t      p2x = 0.0,\n\t      p2y = 0.0;\n\t    var j = path.length;\n\t    if (j < 2) return 0;\n\t    if (closed)\n\t    {\n\t      path[j] = path[0];\n\t      j++;\n\t    }\n\t    while (--j)\n\t    {\n\t      p1 = path[j];\n\t      p1x = p1.X;\n\t      p1y = p1.Y;\n\t      p2 = path[j - 1];\n\t      p2x = p2.X;\n\t      p2y = p2.Y;\n\t      perimeter += sqrt((p1x - p2x) * (p1x - p2x) + (p1y - p2y) * (p1y - p2y));\n\t    }\n\t    if (closed) path.pop();\n\t    return perimeter / scale;\n\t  };\n\t  ClipperLib.JS.PerimeterOfPaths = function (paths, closed, scale)\n\t  {\n\t    if (!scale) scale = 1;\n\t    var perimeter = 0;\n\t    for (var i = 0; i < paths.length; i++)\n\t    {\n\t      perimeter += ClipperLib.JS.PerimeterOfPath(paths[i], closed, scale);\n\t    }\n\t    return perimeter;\n\t  };\n\t  ClipperLib.JS.ScaleDownPath = function (path, scale)\n\t  {\n\t    var i, p;\n\t    if (!scale) scale = 1;\n\t    i = path.length;\n\t    while (i--)\n\t    {\n\t      p = path[i];\n\t      p.X = p.X / scale;\n\t      p.Y = p.Y / scale;\n\t    }\n\t  };\n\t  ClipperLib.JS.ScaleDownPaths = function (paths, scale)\n\t  {\n\t    var i, j, p;\n\t    if (!scale) scale = 1;\n\t    i = paths.length;\n\t    while (i--)\n\t    {\n\t      j = paths[i].length;\n\t      while (j--)\n\t      {\n\t        p = paths[i][j];\n\t        p.X = p.X / scale;\n\t        p.Y = p.Y / scale;\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.JS.ScaleUpPath = function (path, scale)\n\t  {\n\t    var i, p, round = Math.round;\n\t    if (!scale) scale = 1;\n\t    i = path.length;\n\t    while (i--)\n\t    {\n\t      p = path[i];\n\t      p.X = round(p.X * scale);\n\t      p.Y = round(p.Y * scale);\n\t    }\n\t  };\n\t  ClipperLib.JS.ScaleUpPaths = function (paths, scale)\n\t  {\n\t    var i, j, p, round = Math.round;\n\t    if (!scale) scale = 1;\n\t    i = paths.length;\n\t    while (i--)\n\t    {\n\t      j = paths[i].length;\n\t      while (j--)\n\t      {\n\t        p = paths[i][j];\n\t        p.X = round(p.X * scale);\n\t        p.Y = round(p.Y * scale);\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.ExPolygons = function ()\n\t  {\n\t    return [];\n\t  }\n\t  ClipperLib.ExPolygon = function ()\n\t  {\n\t    this.outer = null;\n\t    this.holes = null;\n\t  };\n\t  ClipperLib.JS.AddOuterPolyNodeToExPolygons = function (polynode, expolygons)\n\t  {\n\t    var ep = new ClipperLib.ExPolygon();\n\t    ep.outer = polynode.Contour();\n\t    var childs = polynode.Childs();\n\t    var ilen = childs.length;\n\t    ep.holes = new Array(ilen);\n\t    var node, n, i, j, childs2, jlen;\n\t    for (i = 0; i < ilen; i++)\n\t    {\n\t      node = childs[i];\n\t      ep.holes[i] = node.Contour();\n\t      //Add outer polygons contained by (nested within) holes ...\n\t      for (j = 0, childs2 = node.Childs(), jlen = childs2.length; j < jlen; j++)\n\t      {\n\t        n = childs2[j];\n\t        ClipperLib.JS.AddOuterPolyNodeToExPolygons(n, expolygons);\n\t      }\n\t    }\n\t    expolygons.push(ep);\n\t  };\n\t  ClipperLib.JS.ExPolygonsToPaths = function (expolygons)\n\t  {\n\t    var a, i, alen, ilen;\n\t    var paths = new ClipperLib.Paths();\n\t    for (a = 0, alen = expolygons.length; a < alen; a++)\n\t    {\n\t      paths.push(expolygons[a].outer);\n\t      for (i = 0, ilen = expolygons[a].holes.length; i < ilen; i++)\n\t      {\n\t        paths.push(expolygons[a].holes[i]);\n\t      }\n\t    }\n\t    return paths;\n\t  }\n\t  ClipperLib.JS.PolyTreeToExPolygons = function (polytree)\n\t  {\n\t    var expolygons = new ClipperLib.ExPolygons();\n\t    var node, i, childs, ilen;\n\t    for (i = 0, childs = polytree.Childs(), ilen = childs.length; i < ilen; i++)\n\t    {\n\t      node = childs[i];\n\t      ClipperLib.JS.AddOuterPolyNodeToExPolygons(node, expolygons);\n\t    }\n\t    return expolygons;\n\t  };\n\t})();\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// lw.svg-parser.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 987a4f71c96348849025","class Point {\n    // Class constructor...\n    constructor(x, y) {\n        // Init properties\n        this.x = parseFloat(x)\n        this.y = parseFloat(y)\n\n        if (isNaN(this.x) || isNaN(this.y)) {\n            console.error('x:', x, 'y:', y)\n            throw new Error('Float value!!!')\n        }\n    }\n\n    isEqual(point) {\n        return this.x === point.x && this.y === point.y\n    }\n}\n\nclass Path {\n    // Class constructor...\n    constructor() {\n        // Init properties\n        this.points = []\n        this.length = 0\n    }\n\n    getPoints() {\n        return this.points\n    }\n\n    getFlattenPoints() {\n        let points = []\n        this.points.forEach(point => points.push(point.x, point.y))\n        return points\n    }\n\n    getClipperPoints(scale = 1) {\n        let points = []\n        this.points.forEach(point => points.push({ X: point.x * scale, Y: point.y * scale }))\n        return points\n    }\n\n    fromClipperPoints(points, scale = 1) {\n        this.points = []\n        points.forEach(point => this.addPoint(point.X * scale, point.Y * scale))\n        return this\n    }\n\n    getPoint(i) {\n        return this.points[i < 0 ? this.length + i : i] || null\n    }\n\n    addPoint(x, y) {\n        this.points.push(new Point(x, y))\n        this.length = this.points.length\n    }\n\n    addPoints(points) {\n        // For each couple of points\n        for (let i = 0, il = points.length; i < il; i += 2) {\n            this.addPoint(points[i], points[i + 1])\n        }\n    }\n\n    isClosed() {\n        let firstPoint = this.getPoint(0)\n        return firstPoint && firstPoint.isEqual(this.getPoint(-1))\n    }\n\n    close() {\n        if (! this.isClosed() && this.length > 2) {\n            let firstPoint = this.getPoint(0)\n            this.addPoint(firstPoint.x, firstPoint.y)\n            return true\n        }\n\n        return false\n    }\n\n    transform(matrix) {\n        this.points = this.points.map(point => {\n            return new Point(\n                matrix[0] * point.x + matrix[2] * point.y + matrix[4],\n                matrix[1] * point.x + matrix[3] * point.y + matrix[5]\n            )\n        })\n    }\n}\n\n// Exports\nexport { Path, Point }\nexport default Path\n\n\n\n// WEBPACK FOOTER //\n// ./path.js","// Imports\nimport { Tag } from './tag'\nimport { TagParser } from './tagparser'\n\n// SVG parser class\nclass Parser {\n    // Class constructor...\n    constructor(settings) {\n        // Defaults settings\n        settings = settings || {}\n\n        // Init properties\n        this.element  = null // XML document Element object\n        this.editor   = null // Editor info { name, version, fingerprint }\n        this.document = null // Document info { width, height, viewBox }\n        this.defs     = null // Defined <defs> (DOM) nodes list by id\n        this.tags     = null // Tag objects hierarchy\n\n        // Trace settings (Arc, Bezier)\n        this.traceSettings = Object.assign({\n            linear       : true, // Linear trace mode\n            step         : 0.01, // Step resolution if linear mode = false\n            resolution   : 100,  // Number of segments we use to approximate arc length\n            segmentLength: 1,    // Segment length\n        }, settings.traceSettings || {})\n\n        // Supported tags by this lib\n        this.supportedTags = [\n            'svg', 'g', 'defs', 'use',\n            'line', 'polyline', 'polygon',\n            'rect', 'circle', 'ellipse', 'path',\n            'title', 'desc'\n        ]\n\n        // Tags list to includes/excludes\n        this.parseTags = settings.includes || this.supportedTags\n        this.skipTags  = settings.excludes || ['#text', '#comment']  // silent (no warning)\n\n        // User onTag callback ?\n        settings.onTag && this.onTag(settings.onTag, settings.onTagContext)\n    }\n\n    // Load raw XML string, XMLDocument, Element or File object\n    load(input) {\n        // Load raw XML string\n        if (typeof input === 'string') {\n            return this.loadFromString(input)\n        }\n\n        // Load File object\n        if (input instanceof File) {\n            return this.loadFromFile(input)\n        }\n\n        // Load XMLDocument object\n        if (input instanceof XMLDocument) {\n            return this.loadFromXMLDocument(input)\n        }\n\n        // Load Element object\n        if (input instanceof Element) {\n            return this.loadFromElement(input)\n        }\n\n        // Return rejected promise with an Error object\n        return Promise.reject(new Error('Unsupported input format.'))\n    }\n\n    // Load from Element object\n    loadFromElement(input) {\n        return new Promise((resolve, reject) => {\n            // Bad input type\n            if (! (input instanceof Element)) {\n                reject(new Error('Input param must be a Element object.'))\n            }\n\n            // Parser error\n            if (input.nodeName === 'parsererror') { // FF\n                reject(new Error(input.textContent))\n            }\n\n            if (input.nodeName === 'html' && input.getElementsByTagName('parsererror')) { // Chrome\n                reject(new Error(input.getElementsByTagName('parsererror')[0].textContent))\n            }\n\n            // Set document element\n            this.element = input\n\n            // Resolve promise\n            resolve(input)\n        })\n    }\n\n    // Load from XMLDocument object\n    loadFromXMLDocument(input) {\n        return new Promise((resolve, reject) => {\n            // Bad input type\n            if (! (input instanceof XMLDocument)) {\n                reject(new Error('Input param must be a XMLDocument object.'))\n            }\n\n            // Load from Element...\n            this.loadFromElement(input.documentElement).then(resolve).catch(reject)\n        })\n    }\n\n    // Load raw XML string\n    loadFromString(input) {\n        return new Promise((resolve, reject) => {\n            // Bad input type\n            if (typeof input !== 'string') {\n                reject(new Error('Input param must be a string.'))\n            }\n\n            // Parse svg editor\n            this._parseEditor(input)\n\n            // Parse string as DOM object\n            let parser = new DOMParser()\n            let XMLDoc = parser.parseFromString(input, 'text/xml')\n\n            // Load from XMLDocument...\n            this.loadFromXMLDocument(XMLDoc).then(resolve).catch(reject)\n        })\n    }\n\n    // Try to get the svg editor from input string\n    _parseEditor(input) {\n        // Reset editor\n        this.editor = {\n            name       : 'unknown',\n            version    : null,\n            fingerprint: null\n        }\n\n        // Fingerprint matches\n        let fingerprint\n\n        // Inkscape\n        fingerprint = input.match(/<!-- Created with Inkscape .*-->/i)\n\n        if (fingerprint) {\n            this.editor.name        = 'inkscape'\n            this.editor.fingerprint = fingerprint[0]\n\n            return this.editor\n        }\n\n        // Illustrator\n        fingerprint = input.match(/<!-- Generator: Adobe Illustrator ([0-9\\.]+), .*-->/i)\n\n        if (fingerprint) {\n            this.editor.name        = 'illustrator'\n            this.editor.version     = fingerprint[1]\n            this.editor.fingerprint = fingerprint[0]\n\n            return this.editor\n        }\n\n        // Return default\n        return this.editor\n    }\n\n    // Load from File object\n    loadFromFile(input) {\n        return new Promise((resolve, reject) => {\n            // Bad input type\n            if (! (input instanceof File)) {\n                reject(new Error('Input param must be a File object.'))\n            }\n\n            // Create file reader\n            let reader = new FileReader()\n\n            // Register reader events handlers\n            reader.onload = event => {\n                this.loadFromString(event.target.result).then(resolve).catch(reject)\n            }\n\n            reader.onerror = event => {\n                reject(new Error('Error reading file : ' + input.name))\n            }\n\n            // Finally read input file as text\n            reader.readAsText(input)\n        })\n    }\n\n    // Parse the (loaded) element\n    parse(input) {\n        // Reset properties\n        this.document = null\n        this.defs     = {}\n        this.tags     = null\n\n        // Load input if provided\n        if (input) {\n            return new Promise((resolve, reject) => {\n                this.load(input).then(() => {\n                    resolve(this.parse())\n                }).catch(reject)\n            })\n        }\n\n        // Start parsing element\n        return new Promise((resolve, reject) => {\n            // If no element is loaded\n            if (! this.element) {\n                reject(new Error('No element is loaded, call the load method before.'))\n            }\n\n            // Parse the main Element (recursive)\n            this.tags = this._parseElement(this.element)\n\n            if (! this.tags) {\n                reject(new Error('No supported tags found.'))\n            }\n\n            // Apply matrix (recursive)\n            this.tags.applyMatrix()\n\n            // Resolve the promise\n            resolve(this.tags)\n        })\n    }\n\n    // On tag callback\n    _onTag(tag) {\n        console.info('onTag:', tag)\n    }\n\n    // Register on tag callback\n    onTag(callback, context) {\n        this._onTag = tag => callback.call(context || this, tag)\n    }\n\n    // Parse the provided Element and return an Tag collection (recursive)\n    _parseElement(element, parent) {\n        // Create base tag object\n        let tag = new Tag(element, parent)\n\n        // Exluded tag ?\n        if (this.skipTags.indexOf(tag.name) !== -1) {\n            return null // silent\n        }\n\n        // Supported tag ?\n        if (this.parseTags.indexOf(tag.name) === -1) {\n            return this._skipTag(tag, 'unsupported')\n        }\n\n        // Parse the tag\n        let tagParser = new TagParser(tag, this)\n\n        if (! tagParser.parse()) {\n            return false\n        }\n\n        // Call the on tag callback\n        this._onTag(tag)\n\n        // Parse child nodes\n        let childTag\n\n        element.childNodes.forEach(childNode => {\n            // Parse child element\n            if (childTag = this._parseElement(childNode, tag)) {\n                tag.addChild(childTag)\n            }\n        })\n\n        // Empty group\n        if (['svg', 'g'].indexOf(tag.name) !== -1 && ! tag.children.length) {\n            return this._skipTag(tag, 'empty')\n        }\n\n        // Return tag object\n        return tag\n    }\n\n    // Log skip tag warning message\n    _skipTag(tag, message) {\n        console.warn('Skip tag :', message + ':', tag)\n        return false\n    }\n\n    // Log skip tag attribute warning message\n    _skipTagAttr(tag, attr, message) {\n        console.warn('Skip tag attribute :', message + ':', attr, tag)\n        return false\n    }\n\n}\n\n// Exports\nexport { Parser }\nexport default Parser\n\n\n\n// WEBPACK FOOTER //\n// ./parser.js","import { Path, Point } from './path'\nimport clipper from 'clipper-lib'\n\nconst DEG_TO_RAD = Math.PI / 180\n\n// SVG tag class\nclass Tag {\n    // Class constructor...\n    constructor(element, parent) {\n        // Init properties\n        this.element  = element\n        this.name     = element.nodeName.toLowerCase()\n        this.parent   = parent || null\n        this.layer    = null\n        this.attrs    = {}\n        this.children = []\n        this.paths    = []\n        this.matrix   = null\n        this.path     = new Path()\n        this.point    = new Point(0, 0)\n        this.shapes   = []\n\n        // Add first path\n        this.paths.push(this.path)\n\n        // Set the matrix\n        this.setMatrix(this.parent && this.parent.matrix)\n\n        // Clone parent attributes\n        if (this.parent && (this.parent.name === 'g' || this.parent.name === 'svg')) {\n            // Inherit layer name\n            this.layer = this.parent.layer\n\n            // Inherit parent attributes\n            let excludes = ['transform', 'width', 'height']\n\n            Object.keys(this.parent.attrs).forEach(key => {\n                if (excludes.indexOf(key) === -1) {\n                    this.setAttr(key, this.parent.attrs[key])\n                }\n            })\n        }\n    }\n\n    setAttr(name, value) {\n        this.attrs[name] = value\n    }\n\n    getAttr(name, defaultValue) {\n        return this.attrs[name] !== undefined ? this.attrs[name]\n            : (defaultValue !== undefined ? defaultValue : null)\n    }\n\n    getLayerName() {\n        if (this.name === 'g') {\n            return this.getAttr('inkscape:label', this.getAttr('id', null))\n        }\n    }\n\n    setLayerName(name) {\n        if (this.name === 'g') {\n            this.layer = name || this.getLayerName()\n        }\n    }\n\n    addChild(childTag) {\n        this.children.push(childTag)\n    }\n\n    clearPath() {\n        this.path = new Path()\n    }\n\n    newPath() {\n        if (this.path.length > 0) {\n            this.clearPath()\n            this.paths.push(this.path)\n        }\n    }\n\n    closePath() {\n        return this.path.close()\n    }\n\n    addPoint(x, y, relative) {\n        // Relative from the last point\n        if (relative) {\n            x += this.point.x\n            y += this.point.y\n        }\n\n        // Add current point\n        this.path.addPoint(x, y)\n\n        // Update current point\n        this.point = this.path.getPoint(-1)\n    }\n\n    addPoints(points, relative) {\n        // For each couple of points\n        for (let i = 0, il = points.length; i < il; i += 2) {\n            this.addPoint(points[i], points[i + 1], relative)\n        }\n    }\n\n    setMatrix(matrix) {\n        this.matrix = matrix || [1, 0, 0, 1, 0, 0]\n    }\n\n    addMatrix(matrix) {\n        this.matrix = [\n            this.matrix[0] * matrix[0] + this.matrix[2] * matrix[1],\n            this.matrix[1] * matrix[0] + this.matrix[3] * matrix[1],\n            this.matrix[0] * matrix[2] + this.matrix[2] * matrix[3],\n            this.matrix[1] * matrix[2] + this.matrix[3] * matrix[3],\n            this.matrix[0] * matrix[4] + this.matrix[2] * matrix[5] + this.matrix[4],\n            this.matrix[1] * matrix[4] + this.matrix[3] * matrix[5] + this.matrix[5]\n        ]\n    }\n\n    translate(x, y) {\n        y = y === undefined ? 0 : y\n        this.addMatrix([1, 0, 0, 1, x, y])\n    }\n\n    rotate(angle, x, y) {\n        angle = angle * DEG_TO_RAD\n\n        if (arguments.length == 2) {\n            this.addMatrix([1, 0, 0, 1, x, y])\n        }\n\n        this.addMatrix([Math.cos(angle), Math.sin(angle), -Math.sin(angle), Math.cos(angle), 0, 0])\n\n        if (arguments.length == 2) {\n            this.addMatrix([1, 0, 0, 1, -x, -y])\n        }\n    }\n\n    scale(x, y) {\n        y = y === undefined ? x : y\n        this.addMatrix([x, 0, 0, y, 0, 0])\n    }\n\n    skewX(angle) {\n        this.addMatrix([1, 0, Math.tan(angle * DEG_TO_RAD), 1, 0, 0])\n    }\n\n    skewY(angle) {\n        this.addMatrix([1, Math.tan(angle * DEG_TO_RAD), 0, 1, 0, 0])\n    }\n\n    applyMatrix(matrix) {\n        matrix && this.addMatrix(matrix)\n\n        this.paths.forEach(path => {\n            path.transform(this.matrix)\n        })\n\n        this.shapes.forEach(shape => {\n            shape.outer.transform(this.matrix)\n            shape.holes.forEach(hole => {\n                hole.transform(this.matrix)\n            })\n        })\n\n        this.setMatrix(null)\n\n        this.children.forEach(tag => {\n            tag.applyMatrix(matrix)\n        })\n    }\n\n    getPaths() {\n        return this.paths\n    }\n\n    getShapes() {\n        // No shapes...\n        if (this.getAttr('fill', 'none') === 'none' || ! this.paths[0].length) {\n            return this.shapes\n        }\n\n        // Get fill rule\n        let fillRule = this.getAttr('fill-rule', 'nonzero')\n            console.log(fillRule);\n            fillRule = fillRule === 'nonzero' ? clipper.PolyFillType.pftNonZero : clipper.PolyFillType.pftEvenOdd\n\n        // Create clipper path\n        let clipperPaths = []\n        let clipperScale = 1000000.0\n\n        this.paths.forEach(path => {\n            clipperPaths.push(path.getClipperPoints(clipperScale))\n        })\n\n        // Simplify paths (self-intersecting)\n        clipperPaths = clipper.Clipper.SimplifyPolygons(clipperPaths, fillRule)\n\n        // Clipper paths to PolyTree\n        let cClipper = new clipper.Clipper()\n        let polyTree = new clipper.PolyTree()\n\n        cClipper.AddPaths(clipperPaths, clipper.PolyType.ptSubject, true)\n        cClipper.Execute(clipper.ClipType.ctUnion, polyTree, fillRule, fillRule)\n\n        // PolyTree to ExPolygons\n        let exPolygons = clipper.JS.PolyTreeToExPolygons(polyTree)\n\n        let toPath = path => new Path().fromClipperPoints(path, 1 / clipperScale)\n\n        this.shapes = exPolygons.map(exPolygon => {\n            return {\n                outer: toPath(exPolygon.outer),\n                holes: exPolygon.holes.map(toPath)\n            }\n        })\n\n        // console.log('clipperPaths:', clipperPaths)\n        // console.log('polyTree:', polyTree)\n        // console.log('shapes:', this.shapes)\n\n        return this.shapes\n    }\n}\n\n// Exports\nexport { Tag }\nexport default Tag\n\n\n\n// WEBPACK FOOTER //\n// ./tag.js","import { Arc, CubicBezier, QuadricBezier } from './trace'\nimport { Point, Path } from './path'\n\n// SVG tag parser\nclass TagParser {\n    // Class constructor...\n    constructor(tag, parser) {\n        // Init properties\n        this.tag            = tag\n        this.parser         = parser\n        this.currentCommand = null\n        this.lastCommand    = null\n        this.pathData       = null\n        this.traceSettings  = parser.traceSettings\n    }\n\n    parse() {\n        // Get internal parser from node name\n        let handler = this['_' + this.tag.name]\n\n        // Implemented tag handler?\n        if (! handler || typeof handler !== 'function') {\n            return this.parser._skipTag(this.tag, 'not yet implemented')\n        }\n\n        // Parse tag attributes\n        this._parseTagAttrs()\n\n        // Parse tag\n        return handler.call(this)\n    }\n\n    // Parse the tag attributes\n    _parseTagAttrs() {\n        // Get tag attributes\n        let attrs = this.tag.element.attributes\n\n        if (! attrs) {\n            return null\n        }\n\n        // For each attribute\n        let attr, value, style\n\n        Object.keys(attrs).some(key => {\n            // Current attribute\n            attr = attrs[key]\n\n            // Normalize attribute value\n            value = this._normalizeTagAttr(attr)\n\n            if (value === false) {\n                return false // continue\n            }\n\n            // Special case\n            if (attr.nodeName === 'style') {\n                style = value\n            }\n            else {\n                // Set new attribute name/value\n                this.tag.setAttr(attr.nodeName, value)\n            }\n        })\n\n        // If style attribute (override tag attributes)\n        // TODO get/parse global style and override this one...\n        style && style.split(';').some(attr => {\n            // Current style\n            attr = attr.split(':')\n            attr = { nodeName: attr[0], nodeValue: attr[1] }\n\n            // Normalize attribute value\n            value = this._normalizeTagAttr(attr)\n\n            if (value === false) {\n                return false // continue\n            }\n\n            // Set new attribute name/value\n            this.tag.setAttr(attr.nodeName, value)\n        })\n\n        // Set inherited color\n        let colorsAttrs = ['fill', 'stroke', 'color']\n\n        colorsAttrs.forEach(attrName => {\n            if (this.tag.getAttr(attrName) === 'inherit') {\n                this.tag.setAttr(attrName, this.tag.parent.getAttr(attrName, 'none'))\n            }\n        })\n\n        // Parse viewBox attribute\n        this._parseViewBoxAttr()\n\n        // Parse transform attribute\n        this._parseTransformAttr()\n    }\n\n    // Normalize tag attribute\n    _normalizeTagAttr(attr) {\n        // Normalize whitespaces\n        let value = attr.nodeValue\n            .replace(/(\\r?\\n|\\r)+/gm, ' ') // Remove all new line chars\n            .replace(/\\s+/gm, ' ')         // Reduce multiple whitespaces\n            .trim()                        // Remove trailing whitespaces\n\n        if (! value.length) {\n            return this.parser._skipTagAttr(this.tag, attr, 'empty')\n        }\n\n        // Filters\n        switch (attr.nodeName) {\n            // Normalize size unit -> to px\n            case 'x':\n            case 'y':\n            case 'x1':\n            case 'y1':\n            case 'x2':\n            case 'y2':\n            case 'r':\n            case 'rx':\n            case 'ry':\n            case 'cx':\n            case 'cy':\n            case 'width':\n            case 'height':\n            case 'fontSize':\n            case 'strokeWidth':\n                value = this._normalizeTagAttrUnit(attr)\n            break\n\n            // Normalize points attribute\n            case 'points':\n            case 'viewBox':\n                value = this._normalizeTagAttrPoints(attr)\n            break\n\n            // Range limit to [0 - 1]\n            case 'opacity':\n            case 'fillOpacity':\n            case 'strokeOpacity':\n                value = this._normalizeTagAttrRange(attr, 0, 1)\n            break\n\n            case 'preserveAspectRatio':\n                value = this._normalizeTagAttrPreserveAspectRatio(attr)\n            break\n        }\n\n        // Return normalized value\n        return value\n    }\n\n    // Normalize attribute unit to px\n    _normalizeTagAttrUnit(attr) {\n        let stringValue = attr.nodeValue.toLowerCase()\n        let floatValue  = parseFloat(stringValue)\n\n        if (isNaN(floatValue)) {\n            return this.parser._skipTagAttr(this.tag, attr, 'only numeric value allowed')\n        }\n\n        if (stringValue.indexOf('mm') !== -1) {\n            return floatValue * 3.5433070869\n        }\n\n        if (stringValue.indexOf('cm') !== -1) {\n            return floatValue * 35.433070869\n        }\n\n        if (stringValue.indexOf('in') !== -1) {\n            return floatValue * 90.0\n        }\n\n        if (stringValue.indexOf('pt') !== -1) {\n            return floatValue * 1.25\n        }\n\n        if (stringValue.indexOf('pc') !== -1) {\n            return floatValue * 15.0\n        }\n\n        return floatValue\n    }\n\n    // Normalize points attribute\n    _normalizeTagAttrPoints(attr) {\n        let points = this._parseNumbers(attr.nodeValue)\n\n        if (points === false) {\n            return this.parser._skipTagAttr(this.tag, attr, 'only numeric values are allowed')\n        }\n\n        if (! points.length) {\n            return this.parser._skipTagAttr(this.tag, attr, 'empty points list')\n        }\n\n        if (points.length % 0) {\n            return this.parser._skipTagAttr(this.tag, attr, 'the number of points must be even')\n        }\n\n        return points\n    }\n\n    // Normalize range attribute like \"opacity\"\n    _normalizeTagAttrRange(attr, min, max) {\n        let stringValue = attr.nodeValue.trim()\n        let floatValue  = parseFloat(stringValue)\n\n        if (isNaN(floatValue)) {\n            return this.parser._skipTagAttr(this.tag, attr, 'only numeric values are allowed')\n        }\n\n        if (floatValue < min || floatValue > max) {\n            return this.parser._skipTagAttr(this.tag, attr, 'out of range [' + min + ', ' + max + ']')\n        }\n\n        return floatValue\n    }\n\n    // Parse points string as numbers array\n    _parseNumbers(points) {\n        // http://stackoverflow.com/questions/638565/parsing-scientific-notation-sensibly\n        if (typeof points === 'string') {\n            points = points.split(/([+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)?/g)\n            .filter(point => {\n                return point && ['', ','].indexOf(point.trim()) === -1\n            })\n        }\n\n        // Normalize to float values\n        points = points.map(parseFloat)\n\n        // Test if all numbers is valid\n        if (points.some(isNaN)) {\n            return false\n        }\n\n        return points\n    }\n\n    // Normalize the preserveAspectRatio attribute\n    _normalizeTagAttrPreserveAspectRatio(attr) {\n        let params = {\n            defer: false,\n            align: 'none',\n            meet : true,\n            slice: false\n        }\n\n        let rawParams = attr.nodeValue\n\n        if (rawParams.indexOf('defer') === 0) {\n            rawParams    = rawParams.substr(6)\n            params.defer = true\n        }\n\n        rawParams    = rawParams.split(' ')\n        params.align = rawParams[0]\n        params.meet  = rawParams[1] || 'meet'\n        params.meet  = params.meet === 'meet'\n        params.slice = ! params.meet\n\n        return params\n    }\n\n    // Parse viewBox attribute and set transformations\n    _parseViewBoxAttr() {\n        // Get viewBox attribute\n        let viewBox = this.tag.getAttr('viewBox', null)\n\n        // No viewBox...\n        if (viewBox === null) {\n            return null\n        }\n\n        // Update size attributes\n        let width  = this.tag.getAttr('width', viewBox[2])\n        let height = this.tag.getAttr('height', viewBox[3])\n\n        this.tag.setAttr('width' , width)\n        this.tag.setAttr('height', height)\n\n        // Scale to match viewBox\n        // TODO clip path if preserveAspectRatio.slice\n        let scaleX     = width  / viewBox[2]\n        let scaleY     = height / viewBox[3]\n        let translateX = viewBox[0]\n        let translateY = viewBox[1]\n\n        let preserveAspectRatio = this.tag.getAttr('preserveAspectRatio', 'meet xMidYMid')\n\n        if (preserveAspectRatio) {\n            let newWidth, newHeight\n\n            if (preserveAspectRatio.meet) {\n                if (scaleX > scaleY) {\n                    scaleX   = scaleY\n                    newWidth = viewBox[2] * scaleX\n                }\n                else if (scaleX < scaleY) {\n                    scaleY    = scaleX\n                    newHeight = viewBox[3] * scaleY\n                }\n            }\n            else if (preserveAspectRatio.slice) {\n                if (scaleX < scaleY) {\n                    scaleX   = scaleY\n                    newWidth = viewBox[2] * scaleX\n                }\n                else if (scaleX > scaleY) {\n                    scaleY    = scaleX\n                    newHeight = viewBox[3] * scaleY\n                }\n            }\n\n            if (newWidth !== undefined) {\n                if (preserveAspectRatio.align === 'xMidYMid') {\n                    this.tag.translate((width - newWidth) / 2, 0)\n                }\n                else if (preserveAspectRatio.align === 'xMaxYMax') {\n                    this.tag.translate(width - newWidth, 0)\n                }\n            }\n            else if (newHeight !== undefined) {\n                if (preserveAspectRatio.align === 'xMidYMid') {\n                    this.tag.translate(0, (height - newHeight) / 2)\n                }\n                else if (preserveAspectRatio.align === 'xMaxYMax') {\n                    this.tag.translate(0, height - newHeight)\n                }\n            }\n        }\n\n        this.tag.scale(scaleX, scaleY)\n        this.tag.translate(-translateX, -translateY)\n    }\n\n    // Parse transform attribute and set transformations\n    _parseTransformAttr() {\n        // Get transform attribute\n        let transformAttr = this.tag.getAttr('transform', null)\n\n        // No transformation...\n        if (transformAttr === null || ! transformAttr.length) {\n            return null\n        }\n\n        // Parse attribute (split group on closing parenthesis)\n        let transformations = transformAttr.split(')')\n\n        // Remove last entry due to last \")\" found\n        transformations.pop()\n\n        // For each transformation\n        let transform, type, params\n\n        transformations.some(raw => {\n            // Split name and value on opening parenthesis\n            transform = raw.split('(')\n\n            // Invalid parts number\n            if (transform.length !== 2) {\n                return this.parser._skipTagAttr(this.tag, transformAttr, 'malformed') // continue\n            }\n\n            type = transform[0].trim()\n\n            // Quik hack 1/2\n            let func = type\n            if (func === 'matrix') {\n                func = 'addMatrix'\n            }\n\n            // Get tag transform method\n            let tagTransform = this.tag[func]\n\n            if (typeof tagTransform !== 'function') {\n                return this.parser._skipTagAttr(this.tag, transformAttr, 'unsupported transform type :' + type)\n            }\n\n            params = transform[1].trim()\n            params = this._parseNumbers(params)\n\n            // Skip empty value\n            if (! params.length) {\n                return this.parser._skipTagAttr(this.tag, transformAttr, 'malformed transform type :' + type)\n            }\n\n            // Quik hack 2/2\n            if (func == 'addMatrix') {\n                params = [params]\n            }\n\n            // Call tag transform method like \"tag.translate(param1, ..., paramN)\"\n            tagTransform.apply(this.tag, params)\n        })\n    }\n\n    _newPath() {\n        this.tag.newPath()\n    }\n\n    _clearPath() {\n        this.tag.clearPath()\n    }\n\n    _closePath() {\n        return this.tag.closePath()\n    }\n\n    _addPoints(points, relative) {\n        if (! points.length) {\n            return this.parser._skipTag(this.tag, 'empty points list')\n        }\n\n        if (points.length % 0) {\n            return this.parser._skipTag(this.tag, 'the number of points must be even')\n        }\n\n        relative = arguments.length < 2 && this.currentCommand.relative\n\n        this.tag.addPoints(points, relative)\n        return true\n    }\n\n    // SVG specs at https://www.w3.org/TR/SVG11/\n\n    _svg() {\n        // Only parse the root SVG tag as main document\n        if (this.parser.document) {\n            // Handled tag\n            return true\n        }\n\n        // Get the document size\n        let width  = this.tag.getAttr('width')\n        let height = this.tag.getAttr('height')\n\n        // Invalid size\n        if (! width || width < 0 || ! height || height < 0) {\n            throw new Error('Invalid document size: ' + width + ' / ' + height)\n        }\n\n        // Set document size\n        this.parser.document = {\n            width : width,\n            height: height\n        }\n\n        // Get document viewBox or set default to document size\n        let viewBox = this.tag.getAttr('viewBox', [0, 0, width, height])\n\n        this.parser.document.viewBox = {\n            x     : viewBox[0],\n            y     : viewBox[1],\n            width : viewBox[2],\n            height: viewBox[3]\n        }\n\n        // Check inkscape version\n        if (this.parser.editor.name === 'inkscape') {\n            this.parser.editor.version = this.tag.getAttr('inkscape:version')\n        }\n\n        // Handled tag\n        return true\n    }\n\n    _title() {\n        // Register the first encountered title tag as document title\n        if (this.parser.document && ! this.parser.document.title) {\n            this.parser.document.title = this.tag.element.textContent\n        }\n\n        // Skipped tag\n        return false\n    }\n\n    _desc() {\n        // Register the first encountered desc tag as document description\n        if (this.parser.document && ! this.parser.document.description) {\n            this.parser.document.description = this.tag.element.textContent\n        }\n\n        // Skipped tag\n        return false\n    }\n\n    _defs() {\n        // Register all child element with an id attribute\n        this.tag.element.childNodes.forEach(childNode => {\n            childNode.id && (this.parser.defs[childNode.id] = childNode)\n        })\n\n        // Skipped tag\n        return false\n    }\n\n    _use() {\n        // Get the target id\n        let target  = this.tag.getAttr('xlink:href').replace(/^#/, '')\n\n        // Try to get the defined element\n        let element = this.parser.defs[target]\n\n        if (! element) {\n            return this.parser._skipTag(this.tag, 'undefined reference [' + target + ']')\n        }\n\n        // Parse the defined element and set new parent from <use> tag parent\n        let useTag = this.parser._parseElement(element, this.tag.parent)\n\n        if (! useTag) {\n            return this.parser._skipTag(this.tag, 'empty reference [' + target + ']')\n        }\n\n        // Set matrix from real parent (<use>)\n        useTag.setMatrix(this.tag.matrix)\n\n        // Replace the use tag with new one\n        this.tag.parent.addChild(useTag)\n\n        // Skipped tag\n        return false\n    }\n\n    _g() {\n        // Set the tag layer name\n        this.tag.setLayerName()\n\n        // Handled tag\n        return true\n    }\n\n    _line() {\n        // Handled tag\n        return this._path([\n            'M', this.tag.getAttr('x1'), this.tag.getAttr('y1'),\n            'L', this.tag.getAttr('x2'), this.tag.getAttr('y2')\n        ])\n    }\n\n    _polyline(close=false) {\n        let points = this.tag.getAttr('points')\n        let path   = ['M', points.shift(), points.shift(), 'L']\n\n        path = path.concat(points)\n        close && path.push('Z')\n\n        // Handled tag\n        return this._path(path)\n    }\n\n    _polygon() {\n        // Handled like polyline but closed\n        return this._polyline(true)\n    }\n\n    _rect() {\n        // Get rectangle attributes\n        let w  = this.tag.getAttr('width')\n        let h  = this.tag.getAttr('height')\n        let x  = this.tag.getAttr('x', 0)\n        let y  = this.tag.getAttr('y', 0)\n        let rx = this.tag.getAttr('rx', null)\n        let ry = this.tag.getAttr('ry', null)\n\n        // Simple rect\n        if (!rx && !ry) {\n            // Handled tag\n            return this._path(['M', x, y, 'h', w, 'v', h, 'h', -w, 'z'])\n        }\n\n        // If a properly specified value is provided for rx, but not for ry,\n        // then set both rx and ry to the value of rx and vis-vera...\n        if (rx === null) rx = ry\n        if (ry === null) ry = rx\n\n        // A negative value is an error\n        if (rx === null || rx === null || rx < 0 || ry < 0) {\n            // Skip tag\n            return this.parser._skipTag(this.tag, 'negative value for \"rx/ry\" not allowed')\n        }\n\n        // If rx is greater than half of width, then set rx to half of width.\n        // If ry is greater than half of height, then set ry to half of height.\n        if (rx > w / 2) rx = w / 2\n        if (ry > h / 2) ry = h / 2\n\n        let dx = rx * 2\n        let dy = ry * 2\n\n        // Handled tag\n        return this._path([\n            'M', x + rx, y,\n            'h', w - dx,\n            'c', rx, 0, rx, ry, rx, ry,\n            'v', h - dy,\n            'c', 0, ry, -rx, ry, -rx, ry,\n            'h', -w + dx,\n            'c', -rx, 0, -rx, -ry, -rx, -ry,\n            'v', -h + dy,\n            'c', 0, 0, 0, -ry, rx, -ry,\n            'z'\n        ])\n    }\n\n    _circle() {\n        let r = this.tag.getAttr('r', 0)\n\n        if (r <= 0) {\n            // Skipped tag\n            return false\n        }\n\n        let cx = this.tag.getAttr('cx', 0)\n        let cy = this.tag.getAttr('cy', 0)\n\n        // Handled tag\n        return this._path([\n            'M', cx-r, cy,\n            'A', r, r, 0, 0, 0, cx, cy+r,\n            'A', r, r, 0, 0, 0, cx+r, cy,\n            'A', r, r, 0, 0, 0, cx, cy-r,\n            'A', r, r, 0, 0, 0, cx-r, cy,\n            'Z'\n        ])\n    }\n\n    _ellipse() {\n        let rx = this.tag.getAttr('rx', 0)\n        let ry = this.tag.getAttr('ry', 0)\n\n        if (rx <= 0 || ry <= 0) {\n            // Skipped tag\n            return false\n        }\n\n        let cx = this.tag.getAttr('cx', 0)\n        let cy = this.tag.getAttr('cy', 0)\n\n        // Handled tag\n        return this._path([\n            'M', cx-rx, cy,\n            'A', rx, ry, 0, 0, 0, cx, cy+ry,\n            'A', rx, ry, 0, 0, 0, cx+rx, cy,\n            'A', rx, ry, 0, 0, 0, cx, cy-ry,\n            'A', rx, ry, 0, 0, 0, cx-rx, cy,\n            'Z'\n        ])\n    }\n\n    _paths(type, num, points) {\n        if (points.length > num) {\n            let handler, result = true\n\n            while(result && points.length) {\n                handler = this['_path' + type]\n                result  = handler.call(this, points.splice(0, num))\n            }\n\n            return result\n        }\n\n        return null\n    }\n\n    _path(path) {\n        // Provided path\n        if (path && typeof path !== 'string') {\n            path = path.join(' ')\n        }\n\n        // Get the paths data attribute value\n        let dAttr = path || this.tag.getAttr('d', null)\n\n        if (! dAttr) {\n            // Skipped tag\n            return false\n        }\n\n        // Split on each commands\n        let commands = dAttr.match(/([M|Z|L|H|V|C|S|Q|T|A]+([^M|Z|L|H|V|C|S|Q|T|A]+)?)/gi)\n\n        if (! commands) {\n            return this.parser._skipTag(this.tag, 'malformed \"d\" attribute')\n        }\n\n        // For each command...\n        this.currentCommand = {\n            raw     : null,\n            type    : null,\n            params  : null,\n            relative: null\n        }\n        this.lastCommand = this.currentCommand\n        this.pathData    = {}\n\n        let handler    = null\n        let parseError = false\n\n        commands.some(raw => {\n            // Remove trailing whitespaces\n            raw = raw.trim()\n\n            // Extract command char and params\n            this.currentCommand.raw      = raw\n            this.currentCommand.type     = raw[0].toUpperCase()\n            this.currentCommand.params   = raw.substr(1).trim()\n            this.currentCommand.relative = this.currentCommand.type !== raw[0]\n\n            // Get path handler from command char\n            handler = this['_path' + this.currentCommand.type]\n\n            if (! handler || typeof handler !== 'function') {\n                this.parser._skipTag(this.tag, 'unsupported path command [' + raw[0] + ']')\n                return parseError = true // break\n            }\n\n            // Extract all numbers from arguments string\n            this.currentCommand.params = this._parseNumbers(this.currentCommand.params)\n\n            if (this.currentCommand.params === false) {\n                this.parser._skipTag(this.tag, 'only numeric values are allowed in [' + this.currentCommand.raw + ']')\n                return parseError = true // break\n            }\n\n            // Execute command parser\n            if (! handler.call(this, this.currentCommand.params)) {\n                return parseError = true // break\n            }\n\n            // Update last command\n            this.lastCommand = {}\n\n            Object.keys(this.currentCommand).forEach(key => {\n                this.lastCommand[key] = this.currentCommand[key]\n            })\n        })\n\n        // Skip tag\n        if (parseError) {\n            this._clearPath()\n            return false\n        }\n\n        // Handled tag\n        return true\n    }\n\n    _pathM(points) {\n        // New path\n        this._newPath()\n\n        // Set the current point (start of new path)\n        // If is followed by multiple pairs of coordinates,\n        // the subsequent pairs are treated as implicit lineto commands.\n        return this._addPoints(points)\n    }\n\n    _pathZ() {\n        this._closePath()\n        return true\n    }\n\n    _pathL(points) {\n        return this._addPoints(points)\n    }\n\n    _pathH(points) {\n        return points.every(x => {\n            return this._addPoints([x, this.currentCommand.relative ? 0 : this.tag.point.y])\n        })\n    }\n\n    _pathV(points) {\n        return points.every(y => {\n            return this._addPoints([this.currentCommand.relative ? 0 : this.tag.point.x, y])\n        })\n    }\n\n    _pathC(points) {\n        // Multiple paths\n        let result = this._paths('C', 6, points)\n\n        if (result !== null) {\n            return result\n        }\n\n        // Single path\n        let p1 = this.tag.point\n        let rl = this.currentCommand.relative\n\n        let x1 = points[0] + (rl ? p1.x : 0)\n        let y1 = points[1] + (rl ? p1.y : 0)\n        let x2 = points[2] + (rl ? p1.x : 0)\n        let y2 = points[3] + (rl ? p1.y : 0)\n        let x  = points[4] + (rl ? p1.x : 0)\n        let y  = points[5] + (rl ? p1.y : 0)\n\n        this.pathData.x2 = x2\n        this.pathData.y2 = y2\n\n        let p2 = new Point(x1, y1)\n        let p3 = new Point(x2, y2)\n        let p4 = new Point(x, y)\n\n        //console.log('C', p1, p2, p3, p4)\n\n        // p1  : starting point\n        // p2  : control point\n        // p3  : control point\n        // p4  : end point\n        let tracer = new CubicBezier(this.traceSettings)\n        let coords = tracer.trace({ p1, p2, p3, p4 }) // => [x,y, x,y, ...]\n        // let tracer = trace(CubicBezier, this.traceSettings)\n        // let coords = tracer({ p1, p2, p3, p4 })\n\n        // Trace the line\n        return this._addPoints(coords, false)\n    }\n\n    _pathS(points) {\n        // Multiple paths\n        let result = this._paths('S', 4, points)\n\n        if (result !== null) {\n            return result\n        }\n\n        // Single path\n        let p1 = this.tag.point\n        let rl = this.currentCommand.relative\n\n        let x1 = p1.x\n        let y1 = p1.y\n\n        if (this.lastCommand.type === 'S' || this.lastCommand.type === 'C') {\n            x1 -= this.pathData.x2 - x1\n            y1 -= this.pathData.y2 - y1\n        }\n\n        let x2 = points[0] + (rl ? p1.x : 0)\n        let y2 = points[1] + (rl ? p1.y : 0)\n        let x  = points[2] + (rl ? p1.x : 0)\n        let y  = points[3] + (rl ? p1.y : 0)\n\n        this.pathData.x2 = x2\n        this.pathData.y2 = y2\n\n        let p2 = new Point(x1, y1)\n        let p3 = new Point(x2, y2)\n        let p4 = new Point(x, y)\n\n        //console.log('S', p1, p2, p3, p4)\n\n        // p1  : starting point\n        // p2  : control point\n        // p3  : control point\n        // p4  : end point\n        let tracer = new CubicBezier(this.traceSettings)\n        let coords = tracer.trace({ p1, p2, p3, p4 }) // => [x,y, x,y, ...]\n        // let tracer = trace(CubicBezier, this.traceSettings)\n        // let coords = tracer({ p1, p2, p3, p4 })\n\n        // Trace the line\n        return this._addPoints(coords, false)\n    }\n\n    _pathQ(points) {\n        // Multiple paths\n        let result = this._paths('Q', 4, points)\n\n        if (result !== null) {\n            return result\n        }\n\n        // Single path\n        let p1 = this.tag.point\n        let rl = this.currentCommand.relative\n\n        let x1 = points[0] + (rl ? p1.x : 0)\n        let y1 = points[1] + (rl ? p1.y : 0)\n        let x  = points[2] + (rl ? p1.x : 0)\n        let y  = points[3] + (rl ? p1.y : 0)\n\n        this.pathData.x1 = x1\n        this.pathData.y1 = y1\n\n        let p2 = new Point(x1, y1)\n        let p3 = new Point(x, y)\n\n        //console.log('Q', p1, p2, p3)\n\n        // p1  : starting point\n        // p2  : control point\n        // p3  : end point\n        let tracer = new QuadricBezier(this.traceSettings)\n        let coords = tracer.trace({ p1, p2, p3 }) // => [x,y, x,y, ...]\n\n        // Trace the line\n        return this._addPoints(coords, false)\n    }\n\n    _pathT(points) {\n        // Multiple paths\n        let result = this._paths('T', 2, points)\n\n        if (result !== null) {\n            return result\n        }\n\n        // Single path\n        let p1 = this.tag.point\n        let rl = this.currentCommand.relative\n\n        let x1 = p1.x\n        let y1 = p1.y\n\n        if (this.lastCommand.type === 'Q' || this.lastCommand.type === 'T') {\n            x1 -= this.pathData.x1 - x1\n            y1 -= this.pathData.y1 - y1\n        }\n\n        let x = points[0] + (rl ? p1.x : 0)\n        let y = points[1] + (rl ? p1.y : 0)\n\n        this.pathData.x1 = x1\n        this.pathData.y1 = y1\n\n        let p2 = new Point(x1, y1)\n        let p3 = new Point(x, y)\n\n        //console.log('T', p1, p2, p3)\n\n        // p1  : starting point\n        // p2  : control point\n        // p3  : end point\n        let tracer = new QuadricBezier(this.traceSettings)\n        let coords = tracer.trace({ p1, p2, p3 }) // => [x,y, x,y, ...]\n\n        // Trace the line\n        return this._addPoints(coords, false)\n    }\n\n    _pathA(points) {\n        // Multiple paths\n        let result = this._paths('A', 7, points)\n\n        if (result !== null) {\n            return result\n        }\n\n        // Single path\n        let rl    = this.currentCommand.relative\n        let p1    = this.tag.point\n        let rx    = points[0]\n        let ry    = points[1]\n        let angle = points[2]\n        let large = !!points[3]\n        let sweep = !!points[4]\n        let x     = points[5] + (rl ? p1.x : 0)\n        let y     = points[6] + (rl ? p1.y : 0)\n        let p2    = new Point(x, y)\n\n        //console.log('A', p1, rx, ry, angle, large, sweep, p2)\n\n        let tracer = new Arc(this.traceSettings)\n        let coords = tracer.trace({ p1, rx, ry, angle, large, sweep, p2 }) // => [x,y, x,y, ...]\n\n        // Trace the line\n        return this._addPoints(coords, false)\n    }\n}\n\n// Exports\nexport { TagParser }\nexport default TagParser\n\n\n\n// WEBPACK FOOTER //\n// ./tagparser.js","// Base code from : https://github.com/MadLittleMods/svg-curve-lib/blob/master/src/js/svg-curve-lib.js\nimport { Point } from './path'\n\nconst MATH_PI_2  = Math.PI * 2\nconst DEG_TO_RAD = Math.PI / 180\n\nfunction mod(x, m) {\n    return (x % m + m) % m\n}\n\nfunction clamp(val, min, max) {\n    return Math.min(Math.max(val, min), max)\n}\n\nfunction distance(p0, p1) {\n    return Math.sqrt(Math.pow(p1.x - p0.x, 2) + Math.pow(p1.y - p0.y, 2))\n}\n\nfunction angle(v0, v1) {\n    let p = v0.x * v1.x + v0.y * v1.y\n    let n = Math.sqrt((Math.pow(v0.x, 2) + Math.pow(v0.y, 2)) * (Math.pow(v1.x, 2) + Math.pow(v1.y, 2)))\n    return (v0.x * v1.y - v0.y * v1.x < 0 ? -1 : 1) * Math.acos(p / n)\n}\n\n// Abstract class\nclass TraceBase {\n    constructor(settings) {\n        // Set defaults properties\n        this.path          = []   // Points collection [x,y, x,y, ...]\n        this.linear        = true // Linear trace mode\n        this.step          = 0.01 // Step resolution if linear mode = false\n        this.resolution    = 500  // Number of segments we use to approximate arc length\n        this.segmentLength = 0.1  // Segment length\n\n        // Update properties from user settings\n        Object.assign(this, settings || {})\n\n        // Arc length properties\n        this.arcLength    = null\n        this.arcLengthMap = null\n    }\n\n    _clearPath() {\n        this.path = []\n    }\n\n    getPath() {\n        return this.path\n    }\n\n    getPointAtT(t) {\n        return new Point(0, 0)\n    }\n\n    _addPoint(point) {\n        this.path.push(point.x, point.y)\n    }\n\n    _postTrace() {\n        // Do additional tasks\n    }\n\n    _approximateLength() {\n        let arcLength    = 0\n        let arcLengthMap = []\n        let prevPoint    = this.getPointAtT(0)\n\n        let i, t, nextPoint\n\n        for(i = 0; i < this.resolution; i++) {\n            t          = clamp(i * (1 / this.resolution), 0, 1)\n            nextPoint  = this.getPointAtT(t)\n            arcLength += distance(prevPoint, nextPoint)\n\n            arcLengthMap.push({ t: t, arcLength: arcLength })\n\n            prevPoint = nextPoint\n        }\n\n        // Last stretch to the endpoint\n        nextPoint  = this.getPointAtT(1)\n        arcLength += distance(prevPoint, nextPoint)\n\n        arcLengthMap.push({ t: 1, arcLength: arcLength })\n        Object.assign(this, { arcLength, arcLengthMap })\n    }\n\n    getPointAtU(u) {\n        u = clamp(u, 0, 1)\n\n        let targetDistanceFromStartingPoint = u * this.arcLength\n\n        let resultantT    = 0\n        let prevArcLength = 0\n        let prevT         = 0\n\n        this.arcLengthMap.every(entry => {\n            let t         = entry.t\n            let arcLength = entry.arcLength\n\n            // Once we go a past our target\n            // Lets interpolate from a previous to current\n            if (arcLength >= targetDistanceFromStartingPoint) {\n                let endDiff      = arcLength - targetDistanceFromStartingPoint\n                let startDiff    = targetDistanceFromStartingPoint - prevArcLength\n                let linearFactor = (startDiff / (endDiff + startDiff)) || 0\n\n                resultantT = prevT + (t - prevT) * linearFactor\n\n                // Break\n                return false\n            }\n\n            prevArcLength = arcLength\n            prevT = t\n\n            return true\n        })\n\n        return this.getPointAtT(resultantT)\n    }\n\n    trace(settings) {\n        // Update properties from user settings\n        Object.assign(this, settings || {})\n\n        // Default getPoint settings\n        let getPoint = 'getPointAtT'\n        let step     = this.step\n\n        // Linear mode ?\n        if (this.linear) {\n            this._approximateLength()\n\n            let segments = Math.round(this.arcLength / this.segmentLength)\n\n            getPoint = 'getPointAtU'\n            step     = 1 / segments\n        }\n\n        // Clear points list\n        this._clearPath()\n\n        // Trace the path\n        for (let t = 0; t <= 1; t += step) {\n            this._addPoint(this[getPoint](t))\n        }\n\n        // Do additional tasks\n        this._postTrace()\n\n        // Return the path\n        return this.getPath()\n    }\n}\n\n// Rewrite from https://github.com/MadLittleMods/svg-curve-lib/blob/master/src/js/svg-curve-lib.js#L84\nclass Arc extends TraceBase {\n    init(settings) {\n        // Update properties from user settings\n        Object.assign(this, settings || {})\n\n        // Get angle in radians\n        this.radians = mod(this.angle, 360) * DEG_TO_RAD\n\n        // If the endpoints are identical, then this is equivalent\n        // to omitting the elliptical arc segment entirely.\n        if(this.p1.x === this.p2.x && this.p1.y === this.p2.y) {\n            return this.path\n        }\n\n        this.rx = Math.abs(this.rx)\n        this.ry = Math.abs(this.ry)\n\n        // If rx = 0 or ry = 0 then this arc is treated as\n        // a straight line segment joining the endpoints.\n        if (this.rx === 0 || this.ry === 0) {\n            this.__addPoint(this.p1)\n            this.__addPoint(this.p2)\n            return this.path\n        }\n\n        // Following \"Conversion from endpoint to center parameterization\"\n        // http://www.w3.org/TR/SVG/implnote.html#ArcConversionEndpointToCenter\n\n        // Step #1: Compute transformedPoint\n        let dx = (this.p1.x - this.p2.x) / 2\n        let dy = (this.p1.y - this.p2.y) / 2\n\n        let transformedPoint = {\n            x:  Math.cos(this.radians) * dx + Math.sin(this.radians) * dy,\n            y: -Math.sin(this.radians) * dx + Math.cos(this.radians) * dy\n        }\n\n        // Ensure radii are large enough\n        let radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(this.rx, 2) + Math.pow(transformedPoint.y, 2) / Math.pow(this.ry, 2)\n\n        if (radiiCheck > 1) {\n            this.rx = Math.sqrt(radiiCheck) * this.rx\n            this.ry = Math.sqrt(radiiCheck) * this.ry\n        }\n\n        // Step #2: Compute transformedCenter\n        let cSquareNumerator = Math.pow(this.rx, 2) * Math.pow(this.ry, 2) - Math.pow(this.rx, 2) * Math.pow(transformedPoint.y, 2) - Math.pow(this.ry, 2) * Math.pow(transformedPoint.x, 2)\n        let cSquareRootDenom = Math.pow(this.rx, 2) * Math.pow(transformedPoint.y, 2) + Math.pow(this.ry, 2) * Math.pow(transformedPoint.x, 2)\n        let cRadicand        = cSquareNumerator / cSquareRootDenom\n\n        // Make sure this never drops below zero because of precision\n        cRadicand = cRadicand < 0 ? 0 : cRadicand\n        let cCoef = (this.large !== this.sweep ? 1 : -1) * Math.sqrt(cRadicand)\n        let transformedCenter = {\n            x: cCoef * ( (this.rx * transformedPoint.y) / this.ry),\n            y: cCoef * (-(this.ry * transformedPoint.x) / this.rx)\n        }\n\n        // Step #3: Compute center\n        this.center = {\n            x: Math.cos(this.radians) * transformedCenter.x - Math.sin(this.radians) * transformedCenter.y + ((this.p1.x + this.p2.x) / 2),\n            y: Math.sin(this.radians) * transformedCenter.x + Math.cos(this.radians) * transformedCenter.y + ((this.p1.y + this.p2.y) / 2)\n        }\n\n        // Step #4: Compute start/sweep angles\n        // Start angle of the elliptical arc prior to the stretch and rotate operations.\n        // Difference between the start and end angles\n        let startVector = {\n            x: (transformedPoint.x - transformedCenter.x) / this.rx,\n            y: (transformedPoint.y - transformedCenter.y) / this.ry\n        }\n\n        let endVector = {\n            x: (-transformedPoint.x - transformedCenter.x) / this.rx,\n            y: (-transformedPoint.y - transformedCenter.y) / this.ry\n        }\n\n        this.startAngle = angle({ x: 1, y: 0 }, startVector)\n        this.sweepAngle = angle(startVector, endVector)\n\n        if (! this.sweep && this.sweepAngle > 0) {\n            this.sweepAngle -= MATH_PI_2\n        }\n\n        else if (this.sweep && this.sweepAngle < 0) {\n            this.sweepAngle += MATH_PI_2\n        }\n\n        // We use % instead of `mod(..)` because we want it to be -360deg to 360deg(but actually in radians)\n        this.sweepAngle %= MATH_PI_2\n    }\n\n    trace(settings) {\n        this.init(settings)\n        return super.trace()\n    }\n\n    getPointAtT(t) {\n        let angle = this.startAngle + (this.sweepAngle * t)\n\n        let x = this.rx * Math.cos(angle)\n        let y = this.ry * Math.sin(angle)\n\n        return new Point(\n            Math.cos(this.radians) * x - Math.sin(this.radians) * y + this.center.x,\n            Math.sin(this.radians) * x + Math.cos(this.radians) * y + this.center.y\n        )\n    }\n\n    _postTrace() {\n        // Add last point in the path\n        this._addPoint(this.p2)\n    }\n}\n\nclass CubicBezier extends TraceBase {\n    _B1(t) { return t*t*t }\n    _B2(t) { return 3*t*t*(1-t) }\n    _B3(t) { return 3*t*(1-t)*(1-t) }\n    _B4(t) { return (1-t)*(1-t)*(1-t) }\n\n    _C1(p1, p2, p3, p4, t) {\n        return p1*this._B1(t) + p2*this._B2(t) + p3*this._B3(t) + p4*this._B4(t)\n    }\n\n    getPointAtT(t) {\n        return new Point(\n            this._C1(this.p1.x, this.p2.x, this.p3.x, this.p4.x, t),\n            this._C1(this.p1.y, this.p2.y, this.p3.y, this.p4.y, t)\n        )\n    }\n\n    _addPoint(point) {\n        this.path.unshift(point.x, point.y)\n    }\n}\n\nclass QuadricBezier extends TraceBase {\n    _B1(t) { return t*t }\n    _B2(t) { return 2*t*(1-t) }\n    _B3(t) { return (1-t)*(1-t) }\n\n    _C1(p1, p2, p3, t) {\n        return p1*this._B1(t) + p2*this._B2(t) + p3*this._B3(t)\n    }\n\n    getPointAtT(t) {\n        return new Point(\n            this._C1(this.p1.x, this.p2.x, this.p3.x, t),\n            this._C1(this.p1.y, this.p2.y, this.p3.y, t)\n        )\n    }\n\n    _addPoint(point) {\n        this.path.unshift(point.x, point.y)\n    }\n}\n\n// Exports\nexport { Arc, CubicBezier, QuadricBezier }\n\n\n\n// WEBPACK FOOTER //\n// ./trace.js","// rev 482\n/********************************************************************************\n *                                                                              *\n * Author    :  Angus Johnson                                                   *\n * Version   :  6.2.1                                                          *\n * Date      :  31 October 2014                                                 *\n * Website   :  http://www.angusj.com                                           *\n * Copyright :  Angus Johnson 2010-2014                                         *\n *                                                                              *\n * License:                                                                     *\n * Use, modification & distribution is subject to Boost Software License Ver 1. *\n * http://www.boost.org/LICENSE_1_0.txt                                         *\n *                                                                              *\n * Attributions:                                                                *\n * The code in this library is an extension of Bala Vatti's clipping algorithm: *\n * \"A generic solution to polygon clipping\"                                     *\n * Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *\n * http://portal.acm.org/citation.cfm?id=129906                                 *\n *                                                                              *\n * Computer graphics and geometric modeling: implementation and algorithms      *\n * By Max K. Agoston                                                            *\n * Springer; 1 edition (January 4, 2005)                                        *\n * http://books.google.com/books?q=vatti+clipping+agoston                       *\n *                                                                              *\n * See also:                                                                    *\n * \"Polygon Offsetting by Computing Winding Numbers\"                            *\n * Paper no. DETC2005-85513 pp. 565-575                                         *\n * ASME 2005 International Design Engineering Technical Conferences             *\n * and Computers and Information in Engineering Conference (IDETC/CIE2005)      *\n * September 24-28, 2005 , Long Beach, California, USA                          *\n * http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *\n *                                                                              *\n *******************************************************************************/\n/*******************************************************************************\n *                                                                              *\n * Author    :  Timo                                                            *\n * Version   :  6.2.1.0                                                         *\n * Date      :  17 June 2016                                                 *\n *                                                                              *\n * This is a translation of the C# Clipper library to Javascript.               *\n * Int128 struct of C# is implemented using JSBN of Tom Wu.                     *\n * Because Javascript lacks support for 64-bit integers, the space              *\n * is a little more restricted than in C# version.                              *\n *                                                                              *\n * C# version has support for coordinate space:                                 *\n * +-4611686018427387903 ( sqrt(2^127 -1)/2 )                                   *\n * while Javascript version has support for space:                              *\n * +-4503599627370495 ( sqrt(2^106 -1)/2 )                                      *\n *                                                                              *\n * Tom Wu's JSBN proved to be the fastest big integer library:                  *\n * http://jsperf.com/big-integer-library-test                                   *\n *                                                                              *\n * This class can be made simpler when (if ever) 64-bit integer support comes.  *\n *                                                                              *\n *******************************************************************************/\n/*******************************************************************************\n *                                                                              *\n * Basic JavaScript BN library - subset useful for RSA encryption.              *\n * http://www-cs-students.stanford.edu/~tjw/jsbn/                               *\n * Copyright (c) 2005  Tom Wu                                                   *\n * All Rights Reserved.                                                         *\n * See \"LICENSE\" for details:                                                   *\n * http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE                        *\n *                                                                              *\n *******************************************************************************/\n(function ()\n{\n  \"use strict\";\n  //use_int32: When enabled 32bit ints are used instead of 64bit ints. This\n  //improve performance but coordinate values are limited to the range +/- 46340\n  var use_int32 = false;\n  //use_xyz: adds a Z member to IntPoint. Adds a minor cost to performance.\n  var use_xyz = false;\n  //UseLines: Enables open path clipping. Adds a very minor cost to performance.\n  var use_lines = true;\n\n  var ClipperLib = {};\n  var isNode = false;\n  if (typeof module !== 'undefined' && module.exports)\n  {\n    module.exports = ClipperLib;\n    isNode = true;\n  }\n  else\n  {\n    if (typeof define === 'function' && define.amd) {\n      define(ClipperLib);\n    }\n    if (typeof (document) !== \"undefined\") window.ClipperLib = ClipperLib;\n    else self['ClipperLib'] = ClipperLib;\n  }\n  var navigator_appName;\n  if (!isNode)\n  {\n    var nav = navigator.userAgent.toString().toLowerCase();\n    navigator_appName = navigator.appName;\n  }\n  else\n  {\n    var nav = \"chrome\"; // Node.js uses Chrome's V8 engine\n    navigator_appName = \"Netscape\"; // Firefox, Chrome and Safari returns \"Netscape\", so Node.js should also\n  }\n  // Browser test to speedup performance critical functions\n  var browser = {};\n  if (nav.indexOf(\"chrome\") != -1 && nav.indexOf(\"chromium\") == -1) browser.chrome = 1;\n  else browser.chrome = 0;\n  if (nav.indexOf(\"chromium\") != -1) browser.chromium = 1;\n  else browser.chromium = 0;\n  if (nav.indexOf(\"safari\") != -1 && nav.indexOf(\"chrome\") == -1 && nav.indexOf(\"chromium\") == -1) browser.safari = 1;\n  else browser.safari = 0;\n  if (nav.indexOf(\"firefox\") != -1) browser.firefox = 1;\n  else browser.firefox = 0;\n  if (nav.indexOf(\"firefox/17\") != -1) browser.firefox17 = 1;\n  else browser.firefox17 = 0;\n  if (nav.indexOf(\"firefox/15\") != -1) browser.firefox15 = 1;\n  else browser.firefox15 = 0;\n  if (nav.indexOf(\"firefox/3\") != -1) browser.firefox3 = 1;\n  else browser.firefox3 = 0;\n  if (nav.indexOf(\"opera\") != -1) browser.opera = 1;\n  else browser.opera = 0;\n  if (nav.indexOf(\"msie 10\") != -1) browser.msie10 = 1;\n  else browser.msie10 = 0;\n  if (nav.indexOf(\"msie 9\") != -1) browser.msie9 = 1;\n  else browser.msie9 = 0;\n  if (nav.indexOf(\"msie 8\") != -1) browser.msie8 = 1;\n  else browser.msie8 = 0;\n  if (nav.indexOf(\"msie 7\") != -1) browser.msie7 = 1;\n  else browser.msie7 = 0;\n  if (nav.indexOf(\"msie \") != -1) browser.msie = 1;\n  else browser.msie = 0;\n  ClipperLib.biginteger_used = null;\n\n  // Copyright (c) 2005  Tom Wu\n  // All Rights Reserved.\n  // See \"LICENSE\" for details.\n  // Basic JavaScript BN library - subset useful for RSA encryption.\n  // Bits per digit\n  var dbits;\n  // JavaScript engine analysis\n  var canary = 0xdeadbeefcafe;\n  var j_lm = ((canary & 0xffffff) == 0xefcafe);\n  // (public) Constructor\n  function BigInteger(a, b, c)\n  {\n    // This test variable can be removed,\n    // but at least for performance tests it is useful piece of knowledge\n    // This is the only ClipperLib related variable in BigInteger library\n    ClipperLib.biginteger_used = 1;\n    if (a != null)\n      if (\"number\" == typeof a && \"undefined\" == typeof (b)) this.fromInt(a); // faster conversion\n      else if (\"number\" == typeof a) this.fromNumber(a, b, c);\n    else if (b == null && \"string\" != typeof a) this.fromString(a, 256);\n    else this.fromString(a, b);\n  }\n  // return new, unset BigInteger\n  function nbi()\n  {\n    return new BigInteger(null,undefined,undefined);\n  }\n  // am: Compute w_j += (x*this_i), propagate carries,\n  // c is initial carry, returns final carry.\n  // c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n  // We need to select the fastest one that works in this environment.\n  // am1: use a single mult and divide to get the high bits,\n  // max digit bits should be 26 because\n  // max internal value = 2*dvalue^2-2*dvalue (< 2^53)\n  function am1(i, x, w, j, c, n)\n  {\n    while (--n >= 0)\n    {\n      var v = x * this[i++] + w[j] + c;\n      c = Math.floor(v / 0x4000000);\n      w[j++] = v & 0x3ffffff;\n    }\n    return c;\n  }\n  // am2 avoids a big mult-and-extract completely.\n  // Max digit bits should be <= 30 because we do bitwise ops\n  // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\n  function am2(i, x, w, j, c, n)\n  {\n    var xl = x & 0x7fff,\n      xh = x >> 15;\n    while (--n >= 0)\n    {\n      var l = this[i] & 0x7fff;\n      var h = this[i++] >> 15;\n      var m = xh * l + h * xl;\n      l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);\n      c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);\n      w[j++] = l & 0x3fffffff;\n    }\n    return c;\n  }\n  // Alternately, set max digit bits to 28 since some\n  // browsers slow down when dealing with 32-bit numbers.\n  function am3(i, x, w, j, c, n)\n  {\n    var xl = x & 0x3fff,\n      xh = x >> 14;\n    while (--n >= 0)\n    {\n      var l = this[i] & 0x3fff;\n      var h = this[i++] >> 14;\n      var m = xh * l + h * xl;\n      l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;\n      c = (l >> 28) + (m >> 14) + xh * h;\n      w[j++] = l & 0xfffffff;\n    }\n    return c;\n  }\n  if (j_lm && (navigator_appName == \"Microsoft Internet Explorer\"))\n  {\n    BigInteger.prototype.am = am2;\n    dbits = 30;\n  }\n  else if (j_lm && (navigator_appName != \"Netscape\"))\n  {\n    BigInteger.prototype.am = am1;\n    dbits = 26;\n  }\n  else\n  { // Mozilla/Netscape seems to prefer am3\n    BigInteger.prototype.am = am3;\n    dbits = 28;\n  }\n  BigInteger.prototype.DB = dbits;\n  BigInteger.prototype.DM = ((1 << dbits) - 1);\n  BigInteger.prototype.DV = (1 << dbits);\n  var BI_FP = 52;\n  BigInteger.prototype.FV = Math.pow(2, BI_FP);\n  BigInteger.prototype.F1 = BI_FP - dbits;\n  BigInteger.prototype.F2 = 2 * dbits - BI_FP;\n  // Digit conversions\n  var BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n  var BI_RC = new Array();\n  var rr, vv;\n  rr = \"0\".charCodeAt(0);\n  for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\n  rr = \"a\".charCodeAt(0);\n  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n  rr = \"A\".charCodeAt(0);\n  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\n  function int2char(n)\n  {\n    return BI_RM.charAt(n);\n  }\n\n  function intAt(s, i)\n  {\n    var c = BI_RC[s.charCodeAt(i)];\n    return (c == null) ? -1 : c;\n  }\n  // (protected) copy this to r\n  function bnpCopyTo(r)\n  {\n    for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];\n    r.t = this.t;\n    r.s = this.s;\n  }\n  // (protected) set from integer value x, -DV <= x < DV\n  function bnpFromInt(x)\n  {\n    this.t = 1;\n    this.s = (x < 0) ? -1 : 0;\n    if (x > 0) this[0] = x;\n    else if (x < -1) this[0] = x + this.DV;\n    else this.t = 0;\n  }\n  // return bigint initialized to value\n  function nbv(i)\n  {\n    var r = nbi();\n    r.fromInt(i);\n    return r;\n  }\n  // (protected) set from string and radix\n  function bnpFromString(s, b)\n  {\n    var k;\n    if (b == 16) k = 4;\n    else if (b == 8) k = 3;\n    else if (b == 256) k = 8; // byte array\n    else if (b == 2) k = 1;\n    else if (b == 32) k = 5;\n    else if (b == 4) k = 2;\n    else\n    {\n      this.fromRadix(s, b);\n      return;\n    }\n    this.t = 0;\n    this.s = 0;\n    var i = s.length,\n      mi = false,\n      sh = 0;\n    while (--i >= 0)\n    {\n      var x = (k == 8) ? s[i] & 0xff : intAt(s, i);\n      if (x < 0)\n      {\n        if (s.charAt(i) == \"-\") mi = true;\n        continue;\n      }\n      mi = false;\n      if (sh == 0)\n        this[this.t++] = x;\n      else if (sh + k > this.DB)\n      {\n        this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;\n        this[this.t++] = (x >> (this.DB - sh));\n      }\n      else\n        this[this.t - 1] |= x << sh;\n      sh += k;\n      if (sh >= this.DB) sh -= this.DB;\n    }\n    if (k == 8 && (s[0] & 0x80) != 0)\n    {\n      this.s = -1;\n      if (sh > 0) this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;\n    }\n    this.clamp();\n    if (mi) BigInteger.ZERO.subTo(this, this);\n  }\n  // (protected) clamp off excess high words\n  function bnpClamp()\n  {\n    var c = this.s & this.DM;\n    while (this.t > 0 && this[this.t - 1] == c)--this.t;\n  }\n  // (public) return string representation in given radix\n  function bnToString(b)\n  {\n    if (this.s < 0) return \"-\" + this.negate().toString(b);\n    var k;\n    if (b == 16) k = 4;\n    else if (b == 8) k = 3;\n    else if (b == 2) k = 1;\n    else if (b == 32) k = 5;\n    else if (b == 4) k = 2;\n    else return this.toRadix(b);\n    var km = (1 << k) - 1,\n      d, m = false,\n      r = \"\",\n      i = this.t;\n    var p = this.DB - (i * this.DB) % k;\n    if (i-- > 0)\n    {\n      if (p < this.DB && (d = this[i] >> p) > 0)\n      {\n        m = true;\n        r = int2char(d);\n      }\n      while (i >= 0)\n      {\n        if (p < k)\n        {\n          d = (this[i] & ((1 << p) - 1)) << (k - p);\n          d |= this[--i] >> (p += this.DB - k);\n        }\n        else\n        {\n          d = (this[i] >> (p -= k)) & km;\n          if (p <= 0)\n          {\n            p += this.DB;\n            --i;\n          }\n        }\n        if (d > 0) m = true;\n        if (m) r += int2char(d);\n      }\n    }\n    return m ? r : \"0\";\n  }\n  // (public) -this\n  function bnNegate()\n  {\n    var r = nbi();\n    BigInteger.ZERO.subTo(this, r);\n    return r;\n  }\n  // (public) |this|\n  function bnAbs()\n  {\n    return (this.s < 0) ? this.negate() : this;\n  }\n  // (public) return + if this > a, - if this < a, 0 if equal\n  function bnCompareTo(a)\n  {\n    var r = this.s - a.s;\n    if (r != 0) return r;\n    var i = this.t;\n    r = i - a.t;\n    if (r != 0) return (this.s < 0) ? -r : r;\n    while (--i >= 0)\n      if ((r = this[i] - a[i]) != 0) return r;\n    return 0;\n  }\n  // returns bit length of the integer x\n  function nbits(x)\n  {\n    var r = 1,\n      t;\n    if ((t = x >>> 16) != 0)\n    {\n      x = t;\n      r += 16;\n    }\n    if ((t = x >> 8) != 0)\n    {\n      x = t;\n      r += 8;\n    }\n    if ((t = x >> 4) != 0)\n    {\n      x = t;\n      r += 4;\n    }\n    if ((t = x >> 2) != 0)\n    {\n      x = t;\n      r += 2;\n    }\n    if ((t = x >> 1) != 0)\n    {\n      x = t;\n      r += 1;\n    }\n    return r;\n  }\n  // (public) return the number of bits in \"this\"\n  function bnBitLength()\n  {\n    if (this.t <= 0) return 0;\n    return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));\n  }\n  // (protected) r = this << n*DB\n  function bnpDLShiftTo(n, r)\n  {\n    var i;\n    for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];\n    for (i = n - 1; i >= 0; --i) r[i] = 0;\n    r.t = this.t + n;\n    r.s = this.s;\n  }\n  // (protected) r = this >> n*DB\n  function bnpDRShiftTo(n, r)\n  {\n    for (var i = n; i < this.t; ++i) r[i - n] = this[i];\n    r.t = Math.max(this.t - n, 0);\n    r.s = this.s;\n  }\n  // (protected) r = this << n\n  function bnpLShiftTo(n, r)\n  {\n    var bs = n % this.DB;\n    var cbs = this.DB - bs;\n    var bm = (1 << cbs) - 1;\n    var ds = Math.floor(n / this.DB),\n      c = (this.s << bs) & this.DM,\n      i;\n    for (i = this.t - 1; i >= 0; --i)\n    {\n      r[i + ds + 1] = (this[i] >> cbs) | c;\n      c = (this[i] & bm) << bs;\n    }\n    for (i = ds - 1; i >= 0; --i) r[i] = 0;\n    r[ds] = c;\n    r.t = this.t + ds + 1;\n    r.s = this.s;\n    r.clamp();\n  }\n  // (protected) r = this >> n\n  function bnpRShiftTo(n, r)\n  {\n    r.s = this.s;\n    var ds = Math.floor(n / this.DB);\n    if (ds >= this.t)\n    {\n      r.t = 0;\n      return;\n    }\n    var bs = n % this.DB;\n    var cbs = this.DB - bs;\n    var bm = (1 << bs) - 1;\n    r[0] = this[ds] >> bs;\n    for (var i = ds + 1; i < this.t; ++i)\n    {\n      r[i - ds - 1] |= (this[i] & bm) << cbs;\n      r[i - ds] = this[i] >> bs;\n    }\n    if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;\n    r.t = this.t - ds;\n    r.clamp();\n  }\n  // (protected) r = this - a\n  function bnpSubTo(a, r)\n  {\n    var i = 0,\n      c = 0,\n      m = Math.min(a.t, this.t);\n    while (i < m)\n    {\n      c += this[i] - a[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n    if (a.t < this.t)\n    {\n      c -= a.s;\n      while (i < this.t)\n      {\n        c += this[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n      c += this.s;\n    }\n    else\n    {\n      c += this.s;\n      while (i < a.t)\n      {\n        c -= a[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n      c -= a.s;\n    }\n    r.s = (c < 0) ? -1 : 0;\n    if (c < -1) r[i++] = this.DV + c;\n    else if (c > 0) r[i++] = c;\n    r.t = i;\n    r.clamp();\n  }\n  // (protected) r = this * a, r != this,a (HAC 14.12)\n  // \"this\" should be the larger one if appropriate.\n  function bnpMultiplyTo(a, r)\n  {\n    var x = this.abs(),\n      y = a.abs();\n    var i = x.t;\n    r.t = i + y.t;\n    while (--i >= 0) r[i] = 0;\n    for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);\n    r.s = 0;\n    r.clamp();\n    if (this.s != a.s) BigInteger.ZERO.subTo(r, r);\n  }\n  // (protected) r = this^2, r != this (HAC 14.16)\n  function bnpSquareTo(r)\n  {\n    var x = this.abs();\n    var i = r.t = 2 * x.t;\n    while (--i >= 0) r[i] = 0;\n    for (i = 0; i < x.t - 1; ++i)\n    {\n      var c = x.am(i, x[i], r, 2 * i, 0, 1);\n      if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV)\n      {\n        r[i + x.t] -= x.DV;\n        r[i + x.t + 1] = 1;\n      }\n    }\n    if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);\n    r.s = 0;\n    r.clamp();\n  }\n  // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n  // r != q, this != m.  q or r may be null.\n  function bnpDivRemTo(m, q, r)\n  {\n    var pm = m.abs();\n    if (pm.t <= 0) return;\n    var pt = this.abs();\n    if (pt.t < pm.t)\n    {\n      if (q != null) q.fromInt(0);\n      if (r != null) this.copyTo(r);\n      return;\n    }\n    if (r == null) r = nbi();\n    var y = nbi(),\n      ts = this.s,\n      ms = m.s;\n    var nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus\n    if (nsh > 0)\n    {\n      pm.lShiftTo(nsh, y);\n      pt.lShiftTo(nsh, r);\n    }\n    else\n    {\n      pm.copyTo(y);\n      pt.copyTo(r);\n    }\n    var ys = y.t;\n    var y0 = y[ys - 1];\n    if (y0 == 0) return;\n    var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);\n    var d1 = this.FV / yt,\n      d2 = (1 << this.F1) / yt,\n      e = 1 << this.F2;\n    var i = r.t,\n      j = i - ys,\n      t = (q == null) ? nbi() : q;\n    y.dlShiftTo(j, t);\n    if (r.compareTo(t) >= 0)\n    {\n      r[r.t++] = 1;\n      r.subTo(t, r);\n    }\n    BigInteger.ONE.dlShiftTo(ys, t);\n    t.subTo(y, y); // \"negative\" y so we can replace sub with am later\n    while (y.t < ys) y[y.t++] = 0;\n    while (--j >= 0)\n    {\n      // Estimate quotient digit\n      var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);\n      if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd)\n      { // Try it out\n        y.dlShiftTo(j, t);\n        r.subTo(t, r);\n        while (r[i] < --qd) r.subTo(t, r);\n      }\n    }\n    if (q != null)\n    {\n      r.drShiftTo(ys, q);\n      if (ts != ms) BigInteger.ZERO.subTo(q, q);\n    }\n    r.t = ys;\n    r.clamp();\n    if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder\n    if (ts < 0) BigInteger.ZERO.subTo(r, r);\n  }\n  // (public) this mod a\n  function bnMod(a)\n  {\n    var r = nbi();\n    this.abs().divRemTo(a, null, r);\n    if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);\n    return r;\n  }\n  // Modular reduction using \"classic\" algorithm\n  function Classic(m)\n  {\n    this.m = m;\n  }\n\n  function cConvert(x)\n  {\n    if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n    else return x;\n  }\n\n  function cRevert(x)\n  {\n    return x;\n  }\n\n  function cReduce(x)\n  {\n    x.divRemTo(this.m, null, x);\n  }\n\n  function cMulTo(x, y, r)\n  {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n  }\n\n  function cSqrTo(x, r)\n  {\n    x.squareTo(r);\n    this.reduce(r);\n  }\n  Classic.prototype.convert = cConvert;\n  Classic.prototype.revert = cRevert;\n  Classic.prototype.reduce = cReduce;\n  Classic.prototype.mulTo = cMulTo;\n  Classic.prototype.sqrTo = cSqrTo;\n  // (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n  // justification:\n  //         xy == 1 (mod m)\n  //         xy =  1+km\n  //   xy(2-xy) = (1+km)(1-km)\n  // x[y(2-xy)] = 1-k^2m^2\n  // x[y(2-xy)] == 1 (mod m^2)\n  // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n  // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n  // JS multiply \"overflows\" differently from C/C++, so care is needed here.\n  function bnpInvDigit()\n  {\n    if (this.t < 1) return 0;\n    var x = this[0];\n    if ((x & 1) == 0) return 0;\n    var y = x & 3; // y == 1/x mod 2^2\n    y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4\n    y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8\n    y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16\n    // last step - calculate inverse mod DV directly;\n    // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n    y = (y * (2 - x * y % this.DV)) % this.DV; // y == 1/x mod 2^dbits\n    // we really want the negative inverse, and -DV < y < DV\n    return (y > 0) ? this.DV - y : -y;\n  }\n  // Montgomery reduction\n  function Montgomery(m)\n  {\n    this.m = m;\n    this.mp = m.invDigit();\n    this.mpl = this.mp & 0x7fff;\n    this.mph = this.mp >> 15;\n    this.um = (1 << (m.DB - 15)) - 1;\n    this.mt2 = 2 * m.t;\n  }\n  // xR mod m\n  function montConvert(x)\n  {\n    var r = nbi();\n    x.abs().dlShiftTo(this.m.t, r);\n    r.divRemTo(this.m, null, r);\n    if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);\n    return r;\n  }\n  // x/R mod m\n  function montRevert(x)\n  {\n    var r = nbi();\n    x.copyTo(r);\n    this.reduce(r);\n    return r;\n  }\n  // x = x/R mod m (HAC 14.32)\n  function montReduce(x)\n  {\n    while (x.t <= this.mt2) // pad x so am has enough room later\n      x[x.t++] = 0;\n    for (var i = 0; i < this.m.t; ++i)\n    {\n      // faster way of calculating u0 = x[i]*mp mod DV\n      var j = x[i] & 0x7fff;\n      var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;\n      // use am to combine the multiply-shift-add into one call\n      j = i + this.m.t;\n      x[j] += this.m.am(0, u0, x, i, 0, this.m.t);\n      // propagate carry\n      while (x[j] >= x.DV)\n      {\n        x[j] -= x.DV;\n        x[++j]++;\n      }\n    }\n    x.clamp();\n    x.drShiftTo(this.m.t, x);\n    if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n  }\n  // r = \"x^2/R mod m\"; x != r\n  function montSqrTo(x, r)\n  {\n    x.squareTo(r);\n    this.reduce(r);\n  }\n  // r = \"xy/R mod m\"; x,y != r\n  function montMulTo(x, y, r)\n  {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n  }\n  Montgomery.prototype.convert = montConvert;\n  Montgomery.prototype.revert = montRevert;\n  Montgomery.prototype.reduce = montReduce;\n  Montgomery.prototype.mulTo = montMulTo;\n  Montgomery.prototype.sqrTo = montSqrTo;\n  // (protected) true iff this is even\n  function bnpIsEven()\n  {\n    return ((this.t > 0) ? (this[0] & 1) : this.s) == 0;\n  }\n  // (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\n  function bnpExp(e, z)\n  {\n    if (e > 0xffffffff || e < 1) return BigInteger.ONE;\n    var r = nbi(),\n      r2 = nbi(),\n      g = z.convert(this),\n      i = nbits(e) - 1;\n    g.copyTo(r);\n    while (--i >= 0)\n    {\n      z.sqrTo(r, r2);\n      if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);\n      else\n      {\n        var t = r;\n        r = r2;\n        r2 = t;\n      }\n    }\n    return z.revert(r);\n  }\n  // (public) this^e % m, 0 <= e < 2^32\n  function bnModPowInt(e, m)\n  {\n    var z;\n    if (e < 256 || m.isEven()) z = new Classic(m);\n    else z = new Montgomery(m);\n    return this.exp(e, z);\n  }\n  // protected\n  BigInteger.prototype.copyTo = bnpCopyTo;\n  BigInteger.prototype.fromInt = bnpFromInt;\n  BigInteger.prototype.fromString = bnpFromString;\n  BigInteger.prototype.clamp = bnpClamp;\n  BigInteger.prototype.dlShiftTo = bnpDLShiftTo;\n  BigInteger.prototype.drShiftTo = bnpDRShiftTo;\n  BigInteger.prototype.lShiftTo = bnpLShiftTo;\n  BigInteger.prototype.rShiftTo = bnpRShiftTo;\n  BigInteger.prototype.subTo = bnpSubTo;\n  BigInteger.prototype.multiplyTo = bnpMultiplyTo;\n  BigInteger.prototype.squareTo = bnpSquareTo;\n  BigInteger.prototype.divRemTo = bnpDivRemTo;\n  BigInteger.prototype.invDigit = bnpInvDigit;\n  BigInteger.prototype.isEven = bnpIsEven;\n  BigInteger.prototype.exp = bnpExp;\n  // public\n  BigInteger.prototype.toString = bnToString;\n  BigInteger.prototype.negate = bnNegate;\n  BigInteger.prototype.abs = bnAbs;\n  BigInteger.prototype.compareTo = bnCompareTo;\n  BigInteger.prototype.bitLength = bnBitLength;\n  BigInteger.prototype.mod = bnMod;\n  BigInteger.prototype.modPowInt = bnModPowInt;\n  // \"constants\"\n  BigInteger.ZERO = nbv(0);\n  BigInteger.ONE = nbv(1);\n  // Copyright (c) 2005-2009  Tom Wu\n  // All Rights Reserved.\n  // See \"LICENSE\" for details.\n  // Extended JavaScript BN functions, required for RSA private ops.\n  // Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\n  // Version 1.2: square() API, isProbablePrime fix\n  // (public)\n  function bnClone()\n  {\n    var r = nbi();\n    this.copyTo(r);\n    return r;\n  }\n  // (public) return value as integer\n  function bnIntValue()\n  {\n    if (this.s < 0)\n    {\n      if (this.t == 1) return this[0] - this.DV;\n      else if (this.t == 0) return -1;\n    }\n    else if (this.t == 1) return this[0];\n    else if (this.t == 0) return 0;\n    // assumes 16 < DB < 32\n    return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];\n  }\n  // (public) return value as byte\n  function bnByteValue()\n  {\n    return (this.t == 0) ? this.s : (this[0] << 24) >> 24;\n  }\n  // (public) return value as short (assumes DB>=16)\n  function bnShortValue()\n  {\n    return (this.t == 0) ? this.s : (this[0] << 16) >> 16;\n  }\n  // (protected) return x s.t. r^x < DV\n  function bnpChunkSize(r)\n  {\n    return Math.floor(Math.LN2 * this.DB / Math.log(r));\n  }\n  // (public) 0 if this == 0, 1 if this > 0\n  function bnSigNum()\n  {\n    if (this.s < 0) return -1;\n    else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n    else return 1;\n  }\n  // (protected) convert to radix string\n  function bnpToRadix(b)\n  {\n    if (b == null) b = 10;\n    if (this.signum() == 0 || b < 2 || b > 36) return \"0\";\n    var cs = this.chunkSize(b);\n    var a = Math.pow(b, cs);\n    var d = nbv(a),\n      y = nbi(),\n      z = nbi(),\n      r = \"\";\n    this.divRemTo(d, y, z);\n    while (y.signum() > 0)\n    {\n      r = (a + z.intValue()).toString(b).substr(1) + r;\n      y.divRemTo(d, y, z);\n    }\n    return z.intValue().toString(b) + r;\n  }\n  // (protected) convert from radix string\n  function bnpFromRadix(s, b)\n  {\n    this.fromInt(0);\n    if (b == null) b = 10;\n    var cs = this.chunkSize(b);\n    var d = Math.pow(b, cs),\n      mi = false,\n      j = 0,\n      w = 0;\n    for (var i = 0; i < s.length; ++i)\n    {\n      var x = intAt(s, i);\n      if (x < 0)\n      {\n        if (s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\n        continue;\n      }\n      w = b * w + x;\n      if (++j >= cs)\n      {\n        this.dMultiply(d);\n        this.dAddOffset(w, 0);\n        j = 0;\n        w = 0;\n      }\n    }\n    if (j > 0)\n    {\n      this.dMultiply(Math.pow(b, j));\n      this.dAddOffset(w, 0);\n    }\n    if (mi) BigInteger.ZERO.subTo(this, this);\n  }\n  // (protected) alternate constructor\n  function bnpFromNumber(a, b, c)\n  {\n    if (\"number\" == typeof b)\n    {\n      // new BigInteger(int,int,RNG)\n      if (a < 2) this.fromInt(1);\n      else\n      {\n        this.fromNumber(a, c);\n        if (!this.testBit(a - 1)) // force MSB set\n          this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);\n        if (this.isEven()) this.dAddOffset(1, 0); // force odd\n        while (!this.isProbablePrime(b))\n        {\n          this.dAddOffset(2, 0);\n          if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);\n        }\n      }\n    }\n    else\n    {\n      // new BigInteger(int,RNG)\n      var x = new Array(),\n        t = a & 7;\n      x.length = (a >> 3) + 1;\n      b.nextBytes(x);\n      if (t > 0) x[0] &= ((1 << t) - 1);\n      else x[0] = 0;\n      this.fromString(x, 256);\n    }\n  }\n  // (public) convert to bigendian byte array\n  function bnToByteArray()\n  {\n    var i = this.t,\n      r = new Array();\n    r[0] = this.s;\n    var p = this.DB - (i * this.DB) % 8,\n      d, k = 0;\n    if (i-- > 0)\n    {\n      if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)\n        r[k++] = d | (this.s << (this.DB - p));\n      while (i >= 0)\n      {\n        if (p < 8)\n        {\n          d = (this[i] & ((1 << p) - 1)) << (8 - p);\n          d |= this[--i] >> (p += this.DB - 8);\n        }\n        else\n        {\n          d = (this[i] >> (p -= 8)) & 0xff;\n          if (p <= 0)\n          {\n            p += this.DB;\n            --i;\n          }\n        }\n        if ((d & 0x80) != 0) d |= -256;\n        if (k == 0 && (this.s & 0x80) != (d & 0x80))++k;\n        if (k > 0 || d != this.s) r[k++] = d;\n      }\n    }\n    return r;\n  }\n\n  function bnEquals(a)\n  {\n    return (this.compareTo(a) == 0);\n  }\n\n  function bnMin(a)\n  {\n    return (this.compareTo(a) < 0) ? this : a;\n  }\n\n  function bnMax(a)\n  {\n    return (this.compareTo(a) > 0) ? this : a;\n  }\n  // (protected) r = this op a (bitwise)\n  function bnpBitwiseTo(a, op, r)\n  {\n    var i, f, m = Math.min(a.t, this.t);\n    for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);\n    if (a.t < this.t)\n    {\n      f = a.s & this.DM;\n      for (i = m; i < this.t; ++i) r[i] = op(this[i], f);\n      r.t = this.t;\n    }\n    else\n    {\n      f = this.s & this.DM;\n      for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);\n      r.t = a.t;\n    }\n    r.s = op(this.s, a.s);\n    r.clamp();\n  }\n  // (public) this & a\n  function op_and(x, y)\n  {\n    return x & y;\n  }\n\n  function bnAnd(a)\n  {\n    var r = nbi();\n    this.bitwiseTo(a, op_and, r);\n    return r;\n  }\n  // (public) this | a\n  function op_or(x, y)\n  {\n    return x | y;\n  }\n\n  function bnOr(a)\n  {\n    var r = nbi();\n    this.bitwiseTo(a, op_or, r);\n    return r;\n  }\n  // (public) this ^ a\n  function op_xor(x, y)\n  {\n    return x ^ y;\n  }\n\n  function bnXor(a)\n  {\n    var r = nbi();\n    this.bitwiseTo(a, op_xor, r);\n    return r;\n  }\n  // (public) this & ~a\n  function op_andnot(x, y)\n  {\n    return x & ~y;\n  }\n\n  function bnAndNot(a)\n  {\n    var r = nbi();\n    this.bitwiseTo(a, op_andnot, r);\n    return r;\n  }\n  // (public) ~this\n  function bnNot()\n  {\n    var r = nbi();\n    for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];\n    r.t = this.t;\n    r.s = ~this.s;\n    return r;\n  }\n  // (public) this << n\n  function bnShiftLeft(n)\n  {\n    var r = nbi();\n    if (n < 0) this.rShiftTo(-n, r);\n    else this.lShiftTo(n, r);\n    return r;\n  }\n  // (public) this >> n\n  function bnShiftRight(n)\n  {\n    var r = nbi();\n    if (n < 0) this.lShiftTo(-n, r);\n    else this.rShiftTo(n, r);\n    return r;\n  }\n  // return index of lowest 1-bit in x, x < 2^31\n  function lbit(x)\n  {\n    if (x == 0) return -1;\n    var r = 0;\n    if ((x & 0xffff) == 0)\n    {\n      x >>= 16;\n      r += 16;\n    }\n    if ((x & 0xff) == 0)\n    {\n      x >>= 8;\n      r += 8;\n    }\n    if ((x & 0xf) == 0)\n    {\n      x >>= 4;\n      r += 4;\n    }\n    if ((x & 3) == 0)\n    {\n      x >>= 2;\n      r += 2;\n    }\n    if ((x & 1) == 0)++r;\n    return r;\n  }\n  // (public) returns index of lowest 1-bit (or -1 if none)\n  function bnGetLowestSetBit()\n  {\n    for (var i = 0; i < this.t; ++i)\n      if (this[i] != 0) return i * this.DB + lbit(this[i]);\n    if (this.s < 0) return this.t * this.DB;\n    return -1;\n  }\n  // return number of 1 bits in x\n  function cbit(x)\n  {\n    var r = 0;\n    while (x != 0)\n    {\n      x &= x - 1;\n      ++r;\n    }\n    return r;\n  }\n  // (public) return number of set bits\n  function bnBitCount()\n  {\n    var r = 0,\n      x = this.s & this.DM;\n    for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);\n    return r;\n  }\n  // (public) true iff nth bit is set\n  function bnTestBit(n)\n  {\n    var j = Math.floor(n / this.DB);\n    if (j >= this.t) return (this.s != 0);\n    return ((this[j] & (1 << (n % this.DB))) != 0);\n  }\n  // (protected) this op (1<<n)\n  function bnpChangeBit(n, op)\n  {\n    var r = BigInteger.ONE.shiftLeft(n);\n    this.bitwiseTo(r, op, r);\n    return r;\n  }\n  // (public) this | (1<<n)\n  function bnSetBit(n)\n  {\n    return this.changeBit(n, op_or);\n  }\n  // (public) this & ~(1<<n)\n  function bnClearBit(n)\n  {\n    return this.changeBit(n, op_andnot);\n  }\n  // (public) this ^ (1<<n)\n  function bnFlipBit(n)\n  {\n    return this.changeBit(n, op_xor);\n  }\n  // (protected) r = this + a\n  function bnpAddTo(a, r)\n  {\n    var i = 0,\n      c = 0,\n      m = Math.min(a.t, this.t);\n    while (i < m)\n    {\n      c += this[i] + a[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n    if (a.t < this.t)\n    {\n      c += a.s;\n      while (i < this.t)\n      {\n        c += this[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n      c += this.s;\n    }\n    else\n    {\n      c += this.s;\n      while (i < a.t)\n      {\n        c += a[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n      c += a.s;\n    }\n    r.s = (c < 0) ? -1 : 0;\n    if (c > 0) r[i++] = c;\n    else if (c < -1) r[i++] = this.DV + c;\n    r.t = i;\n    r.clamp();\n  }\n  // (public) this + a\n  function bnAdd(a)\n  {\n    var r = nbi();\n    this.addTo(a, r);\n    return r;\n  }\n  // (public) this - a\n  function bnSubtract(a)\n  {\n    var r = nbi();\n    this.subTo(a, r);\n    return r;\n  }\n  // (public) this * a\n  function bnMultiply(a)\n  {\n    var r = nbi();\n    this.multiplyTo(a, r);\n    return r;\n  }\n  // (public) this^2\n  function bnSquare()\n  {\n    var r = nbi();\n    this.squareTo(r);\n    return r;\n  }\n  // (public) this / a\n  function bnDivide(a)\n  {\n    var r = nbi();\n    this.divRemTo(a, r, null);\n    return r;\n  }\n  // (public) this % a\n  function bnRemainder(a)\n  {\n    var r = nbi();\n    this.divRemTo(a, null, r);\n    return r;\n  }\n  // (public) [this/a,this%a]\n  function bnDivideAndRemainder(a)\n  {\n    var q = nbi(),\n      r = nbi();\n    this.divRemTo(a, q, r);\n    return new Array(q, r);\n  }\n  // (protected) this *= n, this >= 0, 1 < n < DV\n  function bnpDMultiply(n)\n  {\n    this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);\n    ++this.t;\n    this.clamp();\n  }\n  // (protected) this += n << w words, this >= 0\n  function bnpDAddOffset(n, w)\n  {\n    if (n == 0) return;\n    while (this.t <= w) this[this.t++] = 0;\n    this[w] += n;\n    while (this[w] >= this.DV)\n    {\n      this[w] -= this.DV;\n      if (++w >= this.t) this[this.t++] = 0;\n      ++this[w];\n    }\n  }\n  // A \"null\" reducer\n  function NullExp()\n  {}\n\n  function nNop(x)\n  {\n    return x;\n  }\n\n  function nMulTo(x, y, r)\n  {\n    x.multiplyTo(y, r);\n  }\n\n  function nSqrTo(x, r)\n  {\n    x.squareTo(r);\n  }\n  NullExp.prototype.convert = nNop;\n  NullExp.prototype.revert = nNop;\n  NullExp.prototype.mulTo = nMulTo;\n  NullExp.prototype.sqrTo = nSqrTo;\n  // (public) this^e\n  function bnPow(e)\n  {\n    return this.exp(e, new NullExp());\n  }\n  // (protected) r = lower n words of \"this * a\", a.t <= n\n  // \"this\" should be the larger one if appropriate.\n  function bnpMultiplyLowerTo(a, n, r)\n  {\n    var i = Math.min(this.t + a.t, n);\n    r.s = 0; // assumes a,this >= 0\n    r.t = i;\n    while (i > 0) r[--i] = 0;\n    var j;\n    for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);\n    for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);\n    r.clamp();\n  }\n  // (protected) r = \"this * a\" without lower n words, n > 0\n  // \"this\" should be the larger one if appropriate.\n  function bnpMultiplyUpperTo(a, n, r)\n  {\n    --n;\n    var i = r.t = this.t + a.t - n;\n    r.s = 0; // assumes a,this >= 0\n    while (--i >= 0) r[i] = 0;\n    for (i = Math.max(n - this.t, 0); i < a.t; ++i)\n      r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);\n    r.clamp();\n    r.drShiftTo(1, r);\n  }\n  // Barrett modular reduction\n  function Barrett(m)\n  {\n    // setup Barrett\n    this.r2 = nbi();\n    this.q3 = nbi();\n    BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);\n    this.mu = this.r2.divide(m);\n    this.m = m;\n  }\n\n  function barrettConvert(x)\n  {\n    if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);\n    else if (x.compareTo(this.m) < 0) return x;\n    else\n    {\n      var r = nbi();\n      x.copyTo(r);\n      this.reduce(r);\n      return r;\n    }\n  }\n\n  function barrettRevert(x)\n  {\n    return x;\n  }\n  // x = x mod m (HAC 14.42)\n  function barrettReduce(x)\n  {\n    x.drShiftTo(this.m.t - 1, this.r2);\n    if (x.t > this.m.t + 1)\n    {\n      x.t = this.m.t + 1;\n      x.clamp();\n    }\n    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);\n    this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);\n    while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);\n    x.subTo(this.r2, x);\n    while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n  }\n  // r = x^2 mod m; x != r\n  function barrettSqrTo(x, r)\n  {\n    x.squareTo(r);\n    this.reduce(r);\n  }\n  // r = x*y mod m; x,y != r\n  function barrettMulTo(x, y, r)\n  {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n  }\n  Barrett.prototype.convert = barrettConvert;\n  Barrett.prototype.revert = barrettRevert;\n  Barrett.prototype.reduce = barrettReduce;\n  Barrett.prototype.mulTo = barrettMulTo;\n  Barrett.prototype.sqrTo = barrettSqrTo;\n  // (public) this^e % m (HAC 14.85)\n  function bnModPow(e, m)\n  {\n    var i = e.bitLength(),\n      k, r = nbv(1),\n      z;\n    if (i <= 0) return r;\n    else if (i < 18) k = 1;\n    else if (i < 48) k = 3;\n    else if (i < 144) k = 4;\n    else if (i < 768) k = 5;\n    else k = 6;\n    if (i < 8)\n      z = new Classic(m);\n    else if (m.isEven())\n      z = new Barrett(m);\n    else\n      z = new Montgomery(m);\n    // precomputation\n    var g = new Array(),\n      n = 3,\n      k1 = k - 1,\n      km = (1 << k) - 1;\n    g[1] = z.convert(this);\n    if (k > 1)\n    {\n      var g2 = nbi();\n      z.sqrTo(g[1], g2);\n      while (n <= km)\n      {\n        g[n] = nbi();\n        z.mulTo(g2, g[n - 2], g[n]);\n        n += 2;\n      }\n    }\n    var j = e.t - 1,\n      w, is1 = true,\n      r2 = nbi(),\n      t;\n    i = nbits(e[j]) - 1;\n    while (j >= 0)\n    {\n      if (i >= k1) w = (e[j] >> (i - k1)) & km;\n      else\n      {\n        w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);\n        if (j > 0) w |= e[j - 1] >> (this.DB + i - k1);\n      }\n      n = k;\n      while ((w & 1) == 0)\n      {\n        w >>= 1;\n        --n;\n      }\n      if ((i -= n) < 0)\n      {\n        i += this.DB;\n        --j;\n      }\n      if (is1)\n      { // ret == 1, don't bother squaring or multiplying it\n        g[w].copyTo(r);\n        is1 = false;\n      }\n      else\n      {\n        while (n > 1)\n        {\n          z.sqrTo(r, r2);\n          z.sqrTo(r2, r);\n          n -= 2;\n        }\n        if (n > 0) z.sqrTo(r, r2);\n        else\n        {\n          t = r;\n          r = r2;\n          r2 = t;\n        }\n        z.mulTo(r2, g[w], r);\n      }\n      while (j >= 0 && (e[j] & (1 << i)) == 0)\n      {\n        z.sqrTo(r, r2);\n        t = r;\n        r = r2;\n        r2 = t;\n        if (--i < 0)\n        {\n          i = this.DB - 1;\n          --j;\n        }\n      }\n    }\n    return z.revert(r);\n  }\n  // (public) gcd(this,a) (HAC 14.54)\n  function bnGCD(a)\n  {\n    var x = (this.s < 0) ? this.negate() : this.clone();\n    var y = (a.s < 0) ? a.negate() : a.clone();\n    if (x.compareTo(y) < 0)\n    {\n      var t = x;\n      x = y;\n      y = t;\n    }\n    var i = x.getLowestSetBit(),\n      g = y.getLowestSetBit();\n    if (g < 0) return x;\n    if (i < g) g = i;\n    if (g > 0)\n    {\n      x.rShiftTo(g, x);\n      y.rShiftTo(g, y);\n    }\n    while (x.signum() > 0)\n    {\n      if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);\n      if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);\n      if (x.compareTo(y) >= 0)\n      {\n        x.subTo(y, x);\n        x.rShiftTo(1, x);\n      }\n      else\n      {\n        y.subTo(x, y);\n        y.rShiftTo(1, y);\n      }\n    }\n    if (g > 0) y.lShiftTo(g, y);\n    return y;\n  }\n  // (protected) this % n, n < 2^26\n  function bnpModInt(n)\n  {\n    if (n <= 0) return 0;\n    var d = this.DV % n,\n      r = (this.s < 0) ? n - 1 : 0;\n    if (this.t > 0)\n      if (d == 0) r = this[0] % n;\n      else\n        for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;\n    return r;\n  }\n  // (public) 1/this % m (HAC 14.61)\n  function bnModInverse(m)\n  {\n    var ac = m.isEven();\n    if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n    var u = m.clone(),\n      v = this.clone();\n    var a = nbv(1),\n      b = nbv(0),\n      c = nbv(0),\n      d = nbv(1);\n    while (u.signum() != 0)\n    {\n      while (u.isEven())\n      {\n        u.rShiftTo(1, u);\n        if (ac)\n        {\n          if (!a.isEven() || !b.isEven())\n          {\n            a.addTo(this, a);\n            b.subTo(m, b);\n          }\n          a.rShiftTo(1, a);\n        }\n        else if (!b.isEven()) b.subTo(m, b);\n        b.rShiftTo(1, b);\n      }\n      while (v.isEven())\n      {\n        v.rShiftTo(1, v);\n        if (ac)\n        {\n          if (!c.isEven() || !d.isEven())\n          {\n            c.addTo(this, c);\n            d.subTo(m, d);\n          }\n          c.rShiftTo(1, c);\n        }\n        else if (!d.isEven()) d.subTo(m, d);\n        d.rShiftTo(1, d);\n      }\n      if (u.compareTo(v) >= 0)\n      {\n        u.subTo(v, u);\n        if (ac) a.subTo(c, a);\n        b.subTo(d, b);\n      }\n      else\n      {\n        v.subTo(u, v);\n        if (ac) c.subTo(a, c);\n        d.subTo(b, d);\n      }\n    }\n    if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n    if (d.compareTo(m) >= 0) return d.subtract(m);\n    if (d.signum() < 0) d.addTo(m, d);\n    else return d;\n    if (d.signum() < 0) return d.add(m);\n    else return d;\n  }\n  var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\n  var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];\n  // (public) test primality with certainty >= 1-.5^t\n  function bnIsProbablePrime(t)\n  {\n    var i, x = this.abs();\n    if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1])\n    {\n      for (i = 0; i < lowprimes.length; ++i)\n        if (x[0] == lowprimes[i]) return true;\n      return false;\n    }\n    if (x.isEven()) return false;\n    i = 1;\n    while (i < lowprimes.length)\n    {\n      var m = lowprimes[i],\n        j = i + 1;\n      while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n      m = x.modInt(m);\n      while (i < j)\n        if (m % lowprimes[i++] == 0) return false;\n    }\n    return x.millerRabin(t);\n  }\n  // (protected) true if probably prime (HAC 4.24, Miller-Rabin)\n  function bnpMillerRabin(t)\n  {\n    var n1 = this.subtract(BigInteger.ONE);\n    var k = n1.getLowestSetBit();\n    if (k <= 0) return false;\n    var r = n1.shiftRight(k);\n    t = (t + 1) >> 1;\n    if (t > lowprimes.length) t = lowprimes.length;\n    var a = nbi();\n    for (var i = 0; i < t; ++i)\n    {\n      //Pick bases at random, instead of starting at 2\n      a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);\n      var y = a.modPow(r, this);\n      if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0)\n      {\n        var j = 1;\n        while (j++ < k && y.compareTo(n1) != 0)\n        {\n          y = y.modPowInt(2, this);\n          if (y.compareTo(BigInteger.ONE) == 0) return false;\n        }\n        if (y.compareTo(n1) != 0) return false;\n      }\n    }\n    return true;\n  }\n  // protected\n  BigInteger.prototype.chunkSize = bnpChunkSize;\n  BigInteger.prototype.toRadix = bnpToRadix;\n  BigInteger.prototype.fromRadix = bnpFromRadix;\n  BigInteger.prototype.fromNumber = bnpFromNumber;\n  BigInteger.prototype.bitwiseTo = bnpBitwiseTo;\n  BigInteger.prototype.changeBit = bnpChangeBit;\n  BigInteger.prototype.addTo = bnpAddTo;\n  BigInteger.prototype.dMultiply = bnpDMultiply;\n  BigInteger.prototype.dAddOffset = bnpDAddOffset;\n  BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\n  BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\n  BigInteger.prototype.modInt = bnpModInt;\n  BigInteger.prototype.millerRabin = bnpMillerRabin;\n  // public\n  BigInteger.prototype.clone = bnClone;\n  BigInteger.prototype.intValue = bnIntValue;\n  BigInteger.prototype.byteValue = bnByteValue;\n  BigInteger.prototype.shortValue = bnShortValue;\n  BigInteger.prototype.signum = bnSigNum;\n  BigInteger.prototype.toByteArray = bnToByteArray;\n  BigInteger.prototype.equals = bnEquals;\n  BigInteger.prototype.min = bnMin;\n  BigInteger.prototype.max = bnMax;\n  BigInteger.prototype.and = bnAnd;\n  BigInteger.prototype.or = bnOr;\n  BigInteger.prototype.xor = bnXor;\n  BigInteger.prototype.andNot = bnAndNot;\n  BigInteger.prototype.not = bnNot;\n  BigInteger.prototype.shiftLeft = bnShiftLeft;\n  BigInteger.prototype.shiftRight = bnShiftRight;\n  BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\n  BigInteger.prototype.bitCount = bnBitCount;\n  BigInteger.prototype.testBit = bnTestBit;\n  BigInteger.prototype.setBit = bnSetBit;\n  BigInteger.prototype.clearBit = bnClearBit;\n  BigInteger.prototype.flipBit = bnFlipBit;\n  BigInteger.prototype.add = bnAdd;\n  BigInteger.prototype.subtract = bnSubtract;\n  BigInteger.prototype.multiply = bnMultiply;\n  BigInteger.prototype.divide = bnDivide;\n  BigInteger.prototype.remainder = bnRemainder;\n  BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\n  BigInteger.prototype.modPow = bnModPow;\n  BigInteger.prototype.modInverse = bnModInverse;\n  BigInteger.prototype.pow = bnPow;\n  BigInteger.prototype.gcd = bnGCD;\n  BigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n  // JSBN-specific extension\n  BigInteger.prototype.square = bnSquare;\n  var Int128 = BigInteger;\n  // BigInteger interfaces not implemented in jsbn:\n  // BigInteger(int signum, byte[] magnitude)\n  // double doubleValue()\n  // float floatValue()\n  // int hashCode()\n  // long longValue()\n  // static BigInteger valueOf(long val)\n  // Helper functions to make BigInteger functions callable with two parameters\n  // as in original C# Clipper\n  Int128.prototype.IsNegative = function ()\n  {\n    if (this.compareTo(Int128.ZERO) == -1) return true;\n    else return false;\n  };\n  Int128.op_Equality = function (val1, val2)\n  {\n    if (val1.compareTo(val2) == 0) return true;\n    else return false;\n  };\n  Int128.op_Inequality = function (val1, val2)\n  {\n    if (val1.compareTo(val2) != 0) return true;\n    else return false;\n  };\n  Int128.op_GreaterThan = function (val1, val2)\n  {\n    if (val1.compareTo(val2) > 0) return true;\n    else return false;\n  };\n  Int128.op_LessThan = function (val1, val2)\n  {\n    if (val1.compareTo(val2) < 0) return true;\n    else return false;\n  };\n  Int128.op_Addition = function (lhs, rhs)\n  {\n    return new Int128(lhs).add(new Int128(rhs));\n  };\n  Int128.op_Subtraction = function (lhs, rhs)\n  {\n    return new Int128(lhs).subtract(new Int128(rhs));\n  };\n  Int128.Int128Mul = function (lhs, rhs)\n  {\n    return new Int128(lhs).multiply(new Int128(rhs));\n  };\n  Int128.op_Division = function (lhs, rhs)\n  {\n    return lhs.divide(rhs);\n  };\n  Int128.prototype.ToDouble = function ()\n  {\n    return parseFloat(this.toString()); // This could be something faster\n  };\n  // end of Int128 section\n  /*\n  // Uncomment the following two lines if you want to use Int128 outside ClipperLib\n  if (typeof(document) !== \"undefined\") window.Int128 = Int128;\n  else self.Int128 = Int128;\n  */\n\n\n  // ---------------------------------------------\n  // Here starts the actual Clipper library:\n  // Helper function to support Inheritance in Javascript\n\tvar Inherit = function (ce, ce2)\n\t{\n\t\tvar p;\n\t\tif (typeof (Object.getOwnPropertyNames) == 'undefined')\n\t\t{\n\t\t\tfor (p in ce2.prototype)\n\t\t\t\tif (typeof (ce.prototype[p]) == 'undefined' || ce.prototype[p] == Object.prototype[p]) ce.prototype[p] = ce2.prototype[p];\n\t\t\tfor (p in ce2)\n\t\t\t\tif (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];\n\t\t\tce.$baseCtor = ce2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar props = Object.getOwnPropertyNames(ce2.prototype);\n\t\t\tfor (var i = 0; i < props.length; i++)\n\t\t\t\tif (typeof (Object.getOwnPropertyDescriptor(ce.prototype, props[i])) == 'undefined') Object.defineProperty(ce.prototype, props[i], Object.getOwnPropertyDescriptor(ce2.prototype, props[i]));\n\t\t\tfor (p in ce2)\n\t\t\t\tif (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];\n\t\t\tce.$baseCtor = ce2;\n\t\t}\n\t};\n  ClipperLib.Path = function ()\n  {\n    return [];\n  };\n  ClipperLib.Paths = function ()\n  {\n    return []; // Was previously [[]], but caused problems when pushed\n  };\n  // Preserves the calling way of original C# Clipper\n  // Is essential due to compatibility, because DoublePoint is public class in original C# version\n  ClipperLib.DoublePoint = function ()\n  {\n    var a = arguments;\n    this.X = 0;\n    this.Y = 0;\n    // public DoublePoint(DoublePoint dp)\n    // public DoublePoint(IntPoint ip)\n    if (a.length == 1)\n    {\n      this.X = a[0].X;\n      this.Y = a[0].Y;\n    }\n    else if (a.length == 2)\n    {\n      this.X = a[0];\n      this.Y = a[1];\n    }\n  }; // This is internal faster function when called without arguments\n  ClipperLib.DoublePoint0 = function ()\n  {\n    this.X = 0;\n    this.Y = 0;\n  };\n  // This is internal faster function when called with 1 argument (dp or ip)\n  ClipperLib.DoublePoint1 = function (dp)\n  {\n    this.X = dp.X;\n    this.Y = dp.Y;\n  };\n  // This is internal faster function when called with 2 arguments (x and y)\n  ClipperLib.DoublePoint2 = function (x, y)\n  {\n    this.X = x;\n    this.Y = y;\n  };\n  // PolyTree & PolyNode start\n  // -------------------------------\n  ClipperLib.PolyNode = function ()\n  {\n    this.m_Parent = null;\n    this.m_polygon = new ClipperLib.Path();\n    this.m_Index = 0;\n    this.m_jointype = 0;\n    this.m_endtype = 0;\n    this.m_Childs = [];\n    this.IsOpen = false;\n  };\n  ClipperLib.PolyNode.prototype.IsHoleNode = function ()\n  {\n    var result = true;\n    var node = this.m_Parent;\n    while (node !== null)\n    {\n      result = !result;\n      node = node.m_Parent;\n    }\n    return result;\n  };\n  ClipperLib.PolyNode.prototype.ChildCount = function ()\n  {\n    return this.m_Childs.length;\n  };\n  ClipperLib.PolyNode.prototype.Contour = function ()\n  {\n    return this.m_polygon;\n  };\n  ClipperLib.PolyNode.prototype.AddChild = function (Child)\n  {\n    var cnt = this.m_Childs.length;\n    this.m_Childs.push(Child);\n    Child.m_Parent = this;\n    Child.m_Index = cnt;\n  };\n  ClipperLib.PolyNode.prototype.GetNext = function ()\n  {\n    if (this.m_Childs.length > 0)\n      return this.m_Childs[0];\n    else\n      return this.GetNextSiblingUp();\n  };\n  ClipperLib.PolyNode.prototype.GetNextSiblingUp = function ()\n  {\n    if (this.m_Parent === null)\n      return null;\n    else if (this.m_Index == this.m_Parent.m_Childs.length - 1)\n      return this.m_Parent.GetNextSiblingUp();\n    else\n      return this.m_Parent.m_Childs[this.m_Index + 1];\n  };\n  ClipperLib.PolyNode.prototype.Childs = function ()\n  {\n    return this.m_Childs;\n  };\n  ClipperLib.PolyNode.prototype.Parent = function ()\n  {\n    return this.m_Parent;\n  };\n  ClipperLib.PolyNode.prototype.IsHole = function ()\n  {\n    return this.IsHoleNode();\n  };\n  // PolyTree : PolyNode\n  ClipperLib.PolyTree = function ()\n  {\n    this.m_AllPolys = [];\n    ClipperLib.PolyNode.call(this);\n  };\n  ClipperLib.PolyTree.prototype.Clear = function ()\n  {\n    for (var i = 0, ilen = this.m_AllPolys.length; i < ilen; i++)\n      this.m_AllPolys[i] = null;\n    this.m_AllPolys.length = 0;\n    this.m_Childs.length = 0;\n  };\n  ClipperLib.PolyTree.prototype.GetFirst = function ()\n  {\n    if (this.m_Childs.length > 0)\n      return this.m_Childs[0];\n    else\n      return null;\n  };\n  ClipperLib.PolyTree.prototype.Total = function ()\n  {\n\t\tvar result = this.m_AllPolys.length;\n\t\t//with negative offsets, ignore the hidden outer polygon ...\n\t\tif (result > 0 && this.m_Childs[0] != this.m_AllPolys[0]) result--;\n\t\treturn result;\n  };\n  Inherit(ClipperLib.PolyTree, ClipperLib.PolyNode);\n  // -------------------------------\n  // PolyTree & PolyNode end\n  ClipperLib.Math_Abs_Int64 = ClipperLib.Math_Abs_Int32 = ClipperLib.Math_Abs_Double = function (a)\n  {\n    return Math.abs(a);\n  };\n  ClipperLib.Math_Max_Int32_Int32 = function (a, b)\n  {\n    return Math.max(a, b);\n  };\n  /*\n  -----------------------------------\n  cast_32 speedtest: http://jsperf.com/truncate-float-to-integer/2\n  -----------------------------------\n  */\n  if (browser.msie || browser.opera || browser.safari) ClipperLib.Cast_Int32 = function (a)\n  {\n    return a | 0;\n  };\n  else ClipperLib.Cast_Int32 = function (a)\n  { // eg. browser.chrome || browser.chromium || browser.firefox\n    return~~ a;\n  };\n  /*\n  --------------------------\n  cast_64 speedtests: http://jsperf.com/truncate-float-to-integer\n  Chrome: bitwise_not_floor\n  Firefox17: toInteger (typeof test)\n  IE9: bitwise_or_floor\n  IE7 and IE8: to_parseint\n  Chromium: to_floor_or_ceil\n  Firefox3: to_floor_or_ceil\n  Firefox15: to_floor_or_ceil\n  Opera: to_floor_or_ceil\n  Safari: to_floor_or_ceil\n  --------------------------\n  */\n  if (browser.chrome) ClipperLib.Cast_Int64 = function (a)\n  {\n    if (a < -2147483648 || a > 2147483647)\n      return a < 0 ? Math.ceil(a) : Math.floor(a);\n    else return~~ a;\n  };\n  else if (browser.firefox && typeof (Number.toInteger) == \"function\") ClipperLib.Cast_Int64 = function (a)\n  {\n    return Number.toInteger(a);\n  };\n  else if (browser.msie7 || browser.msie8) ClipperLib.Cast_Int64 = function (a)\n  {\n    return parseInt(a, 10);\n  };\n  else if (browser.msie) ClipperLib.Cast_Int64 = function (a)\n  {\n    if (a < -2147483648 || a > 2147483647)\n      return a < 0 ? Math.ceil(a) : Math.floor(a);\n    return a | 0;\n  };\n  // eg. browser.chromium || browser.firefox || browser.opera || browser.safari\n  else ClipperLib.Cast_Int64 = function (a)\n  {\n    return a < 0 ? Math.ceil(a) : Math.floor(a);\n  };\n  ClipperLib.Clear = function (a)\n  {\n    a.length = 0;\n  };\n  //ClipperLib.MaxSteps = 64; // How many steps at maximum in arc in BuildArc() function\n  ClipperLib.PI = 3.141592653589793;\n  ClipperLib.PI2 = 2 * 3.141592653589793;\n  ClipperLib.IntPoint = function ()\n  {\n    var a = arguments,\n      alen = a.length;\n    this.X = 0;\n    this.Y = 0;\n    if (use_xyz)\n    {\n      this.Z = 0;\n      if (alen == 3) // public IntPoint(cInt x, cInt y, cInt z = 0)\n      {\n        this.X = a[0];\n        this.Y = a[1];\n        this.Z = a[2];\n      }\n      else if (alen == 2) // public IntPoint(cInt x, cInt y)\n      {\n        this.X = a[0];\n        this.Y = a[1];\n        this.Z = 0;\n      }\n      else if (alen == 1)\n      {\n        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n        {\n          var dp = a[0];\n          this.X = ClipperLib.Clipper.Round(dp.X);\n          this.Y = ClipperLib.Clipper.Round(dp.Y);\n          this.Z = 0;\n        }\n        else // public IntPoint(IntPoint pt)\n        {\n          var pt = a[0];\n          if (typeof (pt.Z) == \"undefined\") pt.Z = 0;\n          this.X = pt.X;\n          this.Y = pt.Y;\n          this.Z = pt.Z;\n        }\n      }\n      else // public IntPoint()\n      {\n        this.X = 0;\n        this.Y = 0;\n        this.Z = 0;\n      }\n    }\n    else // if (!use_xyz)\n    {\n      if (alen == 2) // public IntPoint(cInt X, cInt Y)\n      {\n        this.X = a[0];\n        this.Y = a[1];\n      }\n      else if (alen == 1)\n      {\n        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n        {\n          var dp = a[0];\n          this.X = ClipperLib.Clipper.Round(dp.X);\n          this.Y = ClipperLib.Clipper.Round(dp.Y);\n        }\n        else // public IntPoint(IntPoint pt)\n        {\n          var pt = a[0];\n          this.X = pt.X;\n          this.Y = pt.Y;\n        }\n      }\n      else // public IntPoint(IntPoint pt)\n      {\n        this.X = 0;\n        this.Y = 0;\n      }\n    }\n  };\n  ClipperLib.IntPoint.op_Equality = function (a, b)\n  {\n    //return a == b;\n    return a.X == b.X && a.Y == b.Y;\n  };\n  ClipperLib.IntPoint.op_Inequality = function (a, b)\n  {\n    //return a != b;\n    return a.X != b.X || a.Y != b.Y;\n  };\n  /*\n  ClipperLib.IntPoint.prototype.Equals = function (obj)\n  {\n    if (obj === null)\n        return false;\n    if (obj instanceof ClipperLib.IntPoint)\n    {\n        var a = Cast(obj, ClipperLib.IntPoint);\n        return (this.X == a.X) && (this.Y == a.Y);\n    }\n    else\n        return false;\n  };\n*/\n  if (use_xyz)\n  {\n    ClipperLib.IntPoint0 = function ()\n    {\n      this.X = 0;\n      this.Y = 0;\n      this.Z = 0;\n    };\n    ClipperLib.IntPoint1 = function (pt)\n    {\n      this.X = pt.X;\n      this.Y = pt.Y;\n      this.Z = pt.Z;\n    };\n    ClipperLib.IntPoint1dp = function (dp)\n    {\n      this.X = ClipperLib.Clipper.Round(dp.X);\n      this.Y = ClipperLib.Clipper.Round(dp.Y);\n      this.Z = 0;\n    };\n    ClipperLib.IntPoint2 = function (x, y)\n    {\n      this.X = x;\n      this.Y = y;\n      this.Z = 0;\n    };\n    ClipperLib.IntPoint3 = function (x, y, z)\n    {\n      this.X = x;\n      this.Y = y;\n      this.Z = z;\n    };\n  }\n  else // if (!use_xyz)\n  {\n    ClipperLib.IntPoint0 = function ()\n    {\n      this.X = 0;\n      this.Y = 0;\n    };\n    ClipperLib.IntPoint1 = function (pt)\n    {\n      this.X = pt.X;\n      this.Y = pt.Y;\n    };\n    ClipperLib.IntPoint1dp = function (dp)\n    {\n      this.X = ClipperLib.Clipper.Round(dp.X);\n      this.Y = ClipperLib.Clipper.Round(dp.Y);\n    };\n    ClipperLib.IntPoint2 = function (x, y)\n    {\n      this.X = x;\n      this.Y = y;\n    };\n  }\n  ClipperLib.IntRect = function ()\n  {\n    var a = arguments,\n      alen = a.length;\n    if (alen == 4) // function (l, t, r, b)\n    {\n      this.left = a[0];\n      this.top = a[1];\n      this.right = a[2];\n      this.bottom = a[3];\n    }\n    else if (alen == 1) // function (ir)\n    {\n      this.left = ir.left;\n      this.top = ir.top;\n      this.right = ir.right;\n      this.bottom = ir.bottom;\n    }\n    else // function ()\n    {\n      this.left = 0;\n      this.top = 0;\n      this.right = 0;\n      this.bottom = 0;\n    }\n  };\n  ClipperLib.IntRect0 = function ()\n  {\n    this.left = 0;\n    this.top = 0;\n    this.right = 0;\n    this.bottom = 0;\n  };\n  ClipperLib.IntRect1 = function (ir)\n  {\n    this.left = ir.left;\n    this.top = ir.top;\n    this.right = ir.right;\n    this.bottom = ir.bottom;\n  };\n  ClipperLib.IntRect4 = function (l, t, r, b)\n  {\n    this.left = l;\n    this.top = t;\n    this.right = r;\n    this.bottom = b;\n  };\n  ClipperLib.ClipType = {\n    ctIntersection: 0,\n    ctUnion: 1,\n    ctDifference: 2,\n    ctXor: 3\n  };\n  ClipperLib.PolyType = {\n    ptSubject: 0,\n    ptClip: 1\n  };\n  ClipperLib.PolyFillType = {\n    pftEvenOdd: 0,\n    pftNonZero: 1,\n    pftPositive: 2,\n    pftNegative: 3\n  };\n  ClipperLib.JoinType = {\n    jtSquare: 0,\n    jtRound: 1,\n    jtMiter: 2\n  };\n  ClipperLib.EndType = {\n    etOpenSquare: 0,\n    etOpenRound: 1,\n    etOpenButt: 2,\n    etClosedLine: 3,\n    etClosedPolygon: 4\n  };\n  ClipperLib.EdgeSide = {\n    esLeft: 0,\n    esRight: 1\n  };\n  ClipperLib.Direction = {\n    dRightToLeft: 0,\n    dLeftToRight: 1\n  };\n  ClipperLib.TEdge = function ()\n  {\n    this.Bot = new ClipperLib.IntPoint();\n    this.Curr = new ClipperLib.IntPoint();\n    this.Top = new ClipperLib.IntPoint();\n    this.Delta = new ClipperLib.IntPoint();\n    this.Dx = 0;\n    this.PolyTyp = ClipperLib.PolyType.ptSubject;\n    this.Side = ClipperLib.EdgeSide.esLeft;\n    this.WindDelta = 0;\n    this.WindCnt = 0;\n    this.WindCnt2 = 0;\n    this.OutIdx = 0;\n    this.Next = null;\n    this.Prev = null;\n    this.NextInLML = null;\n    this.NextInAEL = null;\n    this.PrevInAEL = null;\n    this.NextInSEL = null;\n    this.PrevInSEL = null;\n  };\n  ClipperLib.IntersectNode = function ()\n  {\n    this.Edge1 = null;\n    this.Edge2 = null;\n    this.Pt = new ClipperLib.IntPoint();\n  };\n  ClipperLib.MyIntersectNodeSort = function () {};\n  ClipperLib.MyIntersectNodeSort.Compare = function (node1, node2)\n  {\n    var i = node2.Pt.Y - node1.Pt.Y;\n    if (i > 0) return 1;\n    else if (i < 0) return -1;\n    else return 0;\n  };\n\n  ClipperLib.LocalMinima = function ()\n  {\n    this.Y = 0;\n    this.LeftBound = null;\n    this.RightBound = null;\n    this.Next = null;\n  };\n  ClipperLib.Scanbeam = function ()\n  {\n    this.Y = 0;\n    this.Next = null;\n  };\n  ClipperLib.OutRec = function ()\n  {\n    this.Idx = 0;\n    this.IsHole = false;\n    this.IsOpen = false;\n    this.FirstLeft = null;\n    this.Pts = null;\n    this.BottomPt = null;\n    this.PolyNode = null;\n  };\n  ClipperLib.OutPt = function ()\n  {\n    this.Idx = 0;\n    this.Pt = new ClipperLib.IntPoint();\n    this.Next = null;\n    this.Prev = null;\n  };\n  ClipperLib.Join = function ()\n  {\n    this.OutPt1 = null;\n    this.OutPt2 = null;\n    this.OffPt = new ClipperLib.IntPoint();\n  };\n  ClipperLib.ClipperBase = function ()\n  {\n    this.m_MinimaList = null;\n    this.m_CurrentLM = null;\n    this.m_edges = new Array();\n    this.m_UseFullRange = false;\n    this.m_HasOpenPaths = false;\n    this.PreserveCollinear = false;\n    this.m_MinimaList = null;\n    this.m_CurrentLM = null;\n    this.m_UseFullRange = false;\n    this.m_HasOpenPaths = false;\n  };\n  // Ranges are in original C# too high for Javascript (in current state 2013 september):\n  // protected const double horizontal = -3.4E+38;\n  // internal const cInt loRange = 0x3FFFFFFF; // = 1073741823 = sqrt(2^63 -1)/2\n  // internal const cInt hiRange = 0x3FFFFFFFFFFFFFFFL; // = 4611686018427387903 = sqrt(2^127 -1)/2\n  // So had to adjust them to more suitable for Javascript.\n  // If JS some day supports truly 64-bit integers, then these ranges can be as in C#\n  // and biginteger library can be more simpler (as then 128bit can be represented as two 64bit numbers)\n  ClipperLib.ClipperBase.horizontal = -9007199254740992; //-2^53\n  ClipperLib.ClipperBase.Skip = -2;\n  ClipperLib.ClipperBase.Unassigned = -1;\n  ClipperLib.ClipperBase.tolerance = 1E-20;\n  if (use_int32)\n  {\n    ClipperLib.ClipperBase.loRange = 0x7FFF;\n    ClipperLib.ClipperBase.hiRange = 0x7FFF;\n  }\n  else\n  {\n    ClipperLib.ClipperBase.loRange = 47453132; // sqrt(2^53 -1)/2\n    ClipperLib.ClipperBase.hiRange = 4503599627370495; // sqrt(2^106 -1)/2\n  }\n\n  ClipperLib.ClipperBase.near_zero = function (val)\n  {\n    return (val > -ClipperLib.ClipperBase.tolerance) && (val < ClipperLib.ClipperBase.tolerance);\n  };\n  ClipperLib.ClipperBase.IsHorizontal = function (e)\n  {\n    return e.Delta.Y === 0;\n  };\n  ClipperLib.ClipperBase.prototype.PointIsVertex = function (pt, pp)\n  {\n    var pp2 = pp;\n    do {\n      if (ClipperLib.IntPoint.op_Equality(pp2.Pt, pt))\n        return true;\n      pp2 = pp2.Next;\n    }\n    while (pp2 != pp)\n    return false;\n  };\n  ClipperLib.ClipperBase.prototype.PointOnLineSegment = function (pt, linePt1, linePt2, UseFullRange)\n  {\n    if (UseFullRange)\n      return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) ||\n        ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) ||\n        (((pt.X > linePt1.X) == (pt.X < linePt2.X)) &&\n        ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) &&\n        (Int128.op_Equality(Int128.Int128Mul((pt.X - linePt1.X), (linePt2.Y - linePt1.Y)),\n          Int128.Int128Mul((linePt2.X - linePt1.X), (pt.Y - linePt1.Y)))));\n    else\n      return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) || ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) || (((pt.X > linePt1.X) == (pt.X < linePt2.X)) && ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) && ((pt.X - linePt1.X) * (linePt2.Y - linePt1.Y) == (linePt2.X - linePt1.X) * (pt.Y - linePt1.Y)));\n  };\n  ClipperLib.ClipperBase.prototype.PointOnPolygon = function (pt, pp, UseFullRange)\n  {\n    var pp2 = pp;\n    while (true)\n    {\n      if (this.PointOnLineSegment(pt, pp2.Pt, pp2.Next.Pt, UseFullRange))\n        return true;\n      pp2 = pp2.Next;\n      if (pp2 == pp)\n        break;\n    }\n    return false;\n  };\n  ClipperLib.ClipperBase.prototype.SlopesEqual = ClipperLib.ClipperBase.SlopesEqual = function ()\n  {\n    var a = arguments,\n      alen = a.length;\n    var e1, e2, pt1, pt2, pt3, pt4, UseFullRange;\n    if (alen == 3) // function (e1, e2, UseFullRange)\n    {\n      e1 = a[0];\n      e2 = a[1];\n      UseFullRange = a[2];\n      if (UseFullRange)\n        return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n      else\n        return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n    }\n    else if (alen == 4) // function (pt1, pt2, pt3, UseFullRange)\n    {\n      pt1 = a[0];\n      pt2 = a[1];\n      pt3 = a[2];\n      UseFullRange = a[3];\n      if (UseFullRange)\n        return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n      else\n        return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n    }\n    else // function (pt1, pt2, pt3, pt4, UseFullRange)\n    {\n      pt1 = a[0];\n      pt2 = a[1];\n      pt3 = a[2];\n      pt4 = a[3];\n      UseFullRange = a[4];\n      if (UseFullRange)\n        return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n      else\n        return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n    }\n  };\n  ClipperLib.ClipperBase.SlopesEqual3 = function (e1, e2, UseFullRange)\n  {\n    if (UseFullRange)\n      return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n    else\n      return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n  };\n  ClipperLib.ClipperBase.SlopesEqual4 = function (pt1, pt2, pt3, UseFullRange)\n  {\n    if (UseFullRange)\n      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n    else\n      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n  };\n  ClipperLib.ClipperBase.SlopesEqual5 = function (pt1, pt2, pt3, pt4, UseFullRange)\n  {\n    if (UseFullRange)\n      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n    else\n      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n  };\n  ClipperLib.ClipperBase.prototype.Clear = function ()\n  {\n    this.DisposeLocalMinimaList();\n    for (var i = 0, ilen = this.m_edges.length; i < ilen; ++i)\n    {\n      for (var j = 0, jlen = this.m_edges[i].length; j < jlen; ++j)\n        this.m_edges[i][j] = null;\n      ClipperLib.Clear(this.m_edges[i]);\n    }\n    ClipperLib.Clear(this.m_edges);\n    this.m_UseFullRange = false;\n    this.m_HasOpenPaths = false;\n  };\n  ClipperLib.ClipperBase.prototype.DisposeLocalMinimaList = function ()\n  {\n    while (this.m_MinimaList !== null)\n    {\n      var tmpLm = this.m_MinimaList.Next;\n      this.m_MinimaList = null;\n      this.m_MinimaList = tmpLm;\n    }\n    this.m_CurrentLM = null;\n  };\n  ClipperLib.ClipperBase.prototype.RangeTest = function (Pt, useFullRange)\n  {\n    if (useFullRange.Value)\n    {\n      if (Pt.X > ClipperLib.ClipperBase.hiRange || Pt.Y > ClipperLib.ClipperBase.hiRange || -Pt.X > ClipperLib.ClipperBase.hiRange || -Pt.Y > ClipperLib.ClipperBase.hiRange)\n        ClipperLib.Error(\"Coordinate outside allowed range in RangeTest().\");\n    }\n    else if (Pt.X > ClipperLib.ClipperBase.loRange || Pt.Y > ClipperLib.ClipperBase.loRange || -Pt.X > ClipperLib.ClipperBase.loRange || -Pt.Y > ClipperLib.ClipperBase.loRange)\n    {\n      useFullRange.Value = true;\n      this.RangeTest(Pt, useFullRange);\n    }\n  };\n  ClipperLib.ClipperBase.prototype.InitEdge = function (e, eNext, ePrev, pt)\n  {\n    e.Next = eNext;\n    e.Prev = ePrev;\n    //e.Curr = pt;\n    e.Curr.X = pt.X;\n    e.Curr.Y = pt.Y;\n    e.OutIdx = -1;\n  };\n  ClipperLib.ClipperBase.prototype.InitEdge2 = function (e, polyType)\n  {\n    if (e.Curr.Y >= e.Next.Curr.Y)\n    {\n      //e.Bot = e.Curr;\n      e.Bot.X = e.Curr.X;\n      e.Bot.Y = e.Curr.Y;\n      //e.Top = e.Next.Curr;\n      e.Top.X = e.Next.Curr.X;\n      e.Top.Y = e.Next.Curr.Y;\n    }\n    else\n    {\n      //e.Top = e.Curr;\n      e.Top.X = e.Curr.X;\n      e.Top.Y = e.Curr.Y;\n      //e.Bot = e.Next.Curr;\n      e.Bot.X = e.Next.Curr.X;\n      e.Bot.Y = e.Next.Curr.Y;\n    }\n    this.SetDx(e);\n    e.PolyTyp = polyType;\n  };\n  ClipperLib.ClipperBase.prototype.FindNextLocMin = function (E)\n  {\n    var E2;\n    for (;;)\n    {\n      while (ClipperLib.IntPoint.op_Inequality(E.Bot, E.Prev.Bot) || ClipperLib.IntPoint.op_Equality(E.Curr, E.Top))\n        E = E.Next;\n      if (E.Dx != ClipperLib.ClipperBase.horizontal && E.Prev.Dx != ClipperLib.ClipperBase.horizontal)\n        break;\n      while (E.Prev.Dx == ClipperLib.ClipperBase.horizontal)\n        E = E.Prev;\n      E2 = E;\n      while (E.Dx == ClipperLib.ClipperBase.horizontal)\n        E = E.Next;\n      if (E.Top.Y == E.Prev.Bot.Y)\n        continue;\n      //ie just an intermediate horz.\n      if (E2.Prev.Bot.X < E.Bot.X)\n        E = E2;\n      break;\n    }\n    return E;\n  };\n  ClipperLib.ClipperBase.prototype.ProcessBound = function (E, LeftBoundIsForward)\n  {\n    var EStart;\n    var Result = E;\n    var Horz;\n\n      if (Result.OutIdx == ClipperLib.ClipperBase.Skip)\n      {\n        //check if there are edges beyond the skip edge in the bound and if so\n        //create another LocMin and calling ProcessBound once more ...\n        E = Result;\n        if (LeftBoundIsForward)\n        {\n          while (E.Top.Y == E.Next.Bot.Y) E = E.Next;\n          while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Prev;\n        }\n        else\n        {\n          while (E.Top.Y == E.Prev.Bot.Y) E = E.Prev;\n          while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Next;\n        }\n        if (E == Result)\n        {\n          if (LeftBoundIsForward) Result = E.Next;\n          else Result = E.Prev;\n        }\n        else\n        {\n          //there are more edges in the bound beyond result starting with E\n          if (LeftBoundIsForward)\n            E = Result.Next;\n          else\n            E = Result.Prev;\n          var locMin = new ClipperLib.LocalMinima();\n          locMin.Next = null;\n          locMin.Y = E.Bot.Y;\n          locMin.LeftBound = null;\n          locMin.RightBound = E;\n          E.WindDelta = 0;\n          Result = this.ProcessBound(E, LeftBoundIsForward);\n          this.InsertLocalMinima(locMin);\n        }\n        return Result;\n      }\n\n      if (E.Dx == ClipperLib.ClipperBase.horizontal)\n      {\n        //We need to be careful with open paths because this may not be a\n        //true local minima (ie E may be following a skip edge).\n        //Also, consecutive horz. edges may start heading left before going right.\n        if (LeftBoundIsForward) EStart = E.Prev;\n        else EStart = E.Next;\n        if (EStart.OutIdx != ClipperLib.ClipperBase.Skip)\n        {\n          if (EStart.Dx == ClipperLib.ClipperBase.horizontal) //ie an adjoining horizontal skip edge\n          {\n            if (EStart.Bot.X != E.Bot.X && EStart.Top.X != E.Bot.X)\n              this.ReverseHorizontal(E);\n          }\n          else if (EStart.Bot.X != E.Bot.X)\n            this.ReverseHorizontal(E);\n        }\n      }\n\n      EStart = E;\n      if (LeftBoundIsForward)\n      {\n        while (Result.Top.Y == Result.Next.Bot.Y && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n          Result = Result.Next;\n        if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n        {\n          //nb: at the top of a bound, horizontals are added to the bound\n          //only when the preceding edge attaches to the horizontal's left vertex\n          //unless a Skip edge is encountered when that becomes the top divide\n          Horz = Result;\n          while (Horz.Prev.Dx == ClipperLib.ClipperBase.horizontal)\n            Horz = Horz.Prev;\n          if (Horz.Prev.Top.X == Result.Next.Top.X)\n          {\n            if (!LeftBoundIsForward)\n              Result = Horz.Prev;\n          }\n          else if (Horz.Prev.Top.X > Result.Next.Top.X)\n            Result = Horz.Prev;\n        }\n        while (E != Result)\n        {\n          E.NextInLML = E.Next;\n          if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)\n            this.ReverseHorizontal(E);\n          E = E.Next;\n        }\n        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)\n          this.ReverseHorizontal(E);\n        Result = Result.Next;\n        //move to the edge just beyond current bound\n      }\n      else\n      {\n        while (Result.Top.Y == Result.Prev.Bot.Y && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)\n          Result = Result.Prev;\n        if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)\n        {\n          Horz = Result;\n          while (Horz.Next.Dx == ClipperLib.ClipperBase.horizontal)\n            Horz = Horz.Next;\n          if (Horz.Next.Top.X == Result.Prev.Top.X)\n          {\n            if (!LeftBoundIsForward)\n              Result = Horz.Next;\n          }\n          else if (Horz.Next.Top.X > Result.Prev.Top.X)\n            Result = Horz.Next;\n        }\n        while (E != Result)\n        {\n          E.NextInLML = E.Prev;\n          if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)\n            this.ReverseHorizontal(E);\n          E = E.Prev;\n        }\n        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)\n          this.ReverseHorizontal(E);\n        Result = Result.Prev;\n        //move to the edge just beyond current bound\n      }\n\n    return Result;\n  };\n\n  ClipperLib.ClipperBase.prototype.AddPath = function (pg, polyType, Closed)\n  {\n    if (use_lines)\n    {\n      if (!Closed && polyType == ClipperLib.PolyType.ptClip)\n        ClipperLib.Error(\"AddPath: Open paths must be subject.\");\n    }\n    else\n    {\n      if (!Closed)\n        ClipperLib.Error(\"AddPath: Open paths have been disabled.\");\n    }\n    var highI = pg.length - 1;\n    if (Closed)\n      while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[0])))\n    --highI;\n    while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[highI - 1])))\n    --highI;\n    if ((Closed && highI < 2) || (!Closed && highI < 1))\n      return false;\n    //create a new edge array ...\n    var edges = new Array();\n    for (var i = 0; i <= highI; i++)\n      edges.push(new ClipperLib.TEdge());\n    var IsFlat = true;\n    //1. Basic (first) edge initialization ...\n\n    //edges[1].Curr = pg[1];\n    edges[1].Curr.X = pg[1].X;\n    edges[1].Curr.Y = pg[1].Y;\n\n    var $1 = {Value: this.m_UseFullRange};\n    this.RangeTest(pg[0], $1);\n    this.m_UseFullRange = $1.Value;\n\n    $1.Value = this.m_UseFullRange;\n    this.RangeTest(pg[highI], $1);\n    this.m_UseFullRange = $1.Value;\n\n    this.InitEdge(edges[0], edges[1], edges[highI], pg[0]);\n    this.InitEdge(edges[highI], edges[0], edges[highI - 1], pg[highI]);\n    for (var i = highI - 1; i >= 1; --i)\n    {\n      $1.Value = this.m_UseFullRange;\n      this.RangeTest(pg[i], $1);\n      this.m_UseFullRange = $1.Value;\n\n      this.InitEdge(edges[i], edges[i + 1], edges[i - 1], pg[i]);\n    }\n\n    var eStart = edges[0];\n    //2. Remove duplicate vertices, and (when closed) collinear edges ...\n    var E = eStart,\n      eLoopStop = eStart;\n    for (;;)\n    {\n    //console.log(E.Next, eStart);\n    \t//nb: allows matching start and end points when not Closed ...\n      if (E.Curr == E.Next.Curr && (Closed || E.Next != eStart))\n      {\n        if (E == E.Next)\n          break;\n        if (E == eStart)\n          eStart = E.Next;\n        E = this.RemoveEdge(E);\n        eLoopStop = E;\n        continue;\n      }\n      if (E.Prev == E.Next)\n        break;\n      else if (Closed && ClipperLib.ClipperBase.SlopesEqual(E.Prev.Curr, E.Curr, E.Next.Curr, this.m_UseFullRange) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(E.Prev.Curr, E.Curr, E.Next.Curr)))\n      {\n        //Collinear edges are allowed for open paths but in closed paths\n        //the default is to merge adjacent collinear edges into a single edge.\n        //However, if the PreserveCollinear property is enabled, only overlapping\n        //collinear edges (ie spikes) will be removed from closed paths.\n        if (E == eStart)\n          eStart = E.Next;\n        E = this.RemoveEdge(E);\n        E = E.Prev;\n        eLoopStop = E;\n        continue;\n      }\n      E = E.Next;\n      if ((E == eLoopStop) || (!Closed && E.Next == eStart)) break;\n    }\n    if ((!Closed && (E == E.Next)) || (Closed && (E.Prev == E.Next)))\n      return false;\n    if (!Closed)\n    {\n      this.m_HasOpenPaths = true;\n      eStart.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n    }\n    //3. Do second stage of edge initialization ...\n    E = eStart;\n    do {\n      this.InitEdge2(E, polyType);\n      E = E.Next;\n      if (IsFlat && E.Curr.Y != eStart.Curr.Y)\n        IsFlat = false;\n    }\n    while (E != eStart)\n    //4. Finally, add edge bounds to LocalMinima list ...\n    //Totally flat paths must be handled differently when adding them\n    //to LocalMinima list to avoid endless loops etc ...\n    if (IsFlat)\n    {\n      if (Closed)\n        return false;\n      E.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n      if (E.Prev.Bot.X < E.Prev.Top.X)\n        this.ReverseHorizontal(E.Prev);\n      var locMin = new ClipperLib.LocalMinima();\n      locMin.Next = null;\n      locMin.Y = E.Bot.Y;\n      locMin.LeftBound = null;\n      locMin.RightBound = E;\n      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n      locMin.RightBound.WindDelta = 0;\n      while (E.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n      {\n        E.NextInLML = E.Next;\n        if (E.Bot.X != E.Prev.Top.X)\n          this.ReverseHorizontal(E);\n        E = E.Next;\n      }\n      this.InsertLocalMinima(locMin);\n      this.m_edges.push(edges);\n      return true;\n    }\n    this.m_edges.push(edges);\n    var leftBoundIsForward;\n    var EMin = null;\n\n\t\t//workaround to avoid an endless loop in the while loop below when\n    //open paths have matching start and end points ...\n    if(ClipperLib.IntPoint.op_Equality(E.Prev.Bot, E.Prev.Top))\n    \tE = E.Next;\n\n    for (;;)\n    {\n      E = this.FindNextLocMin(E);\n      if (E == EMin)\n        break;\n      else if (EMin == null)\n        EMin = E;\n      //E and E.Prev now share a local minima (left aligned if horizontal).\n      //Compare their slopes to find which starts which bound ...\n      var locMin = new ClipperLib.LocalMinima();\n      locMin.Next = null;\n      locMin.Y = E.Bot.Y;\n      if (E.Dx < E.Prev.Dx)\n      {\n        locMin.LeftBound = E.Prev;\n        locMin.RightBound = E;\n        leftBoundIsForward = false;\n        //Q.nextInLML = Q.prev\n      }\n      else\n      {\n        locMin.LeftBound = E;\n        locMin.RightBound = E.Prev;\n        leftBoundIsForward = true;\n        //Q.nextInLML = Q.next\n      }\n      locMin.LeftBound.Side = ClipperLib.EdgeSide.esLeft;\n      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n      if (!Closed)\n        locMin.LeftBound.WindDelta = 0;\n      else if (locMin.LeftBound.Next == locMin.RightBound)\n        locMin.LeftBound.WindDelta = -1;\n      else\n        locMin.LeftBound.WindDelta = 1;\n      locMin.RightBound.WindDelta = -locMin.LeftBound.WindDelta;\n      E = this.ProcessBound(locMin.LeftBound, leftBoundIsForward);\n      if (E.OutIdx == ClipperLib.ClipperBase.Skip)\n      \tE = this.ProcessBound(E, leftBoundIsForward);\n      var E2 = this.ProcessBound(locMin.RightBound, !leftBoundIsForward);\n      if (E2.OutIdx == ClipperLib.ClipperBase.Skip) E2 = this.ProcessBound(E2, !leftBoundIsForward);\n      if (locMin.LeftBound.OutIdx == ClipperLib.ClipperBase.Skip)\n        locMin.LeftBound = null;\n      else if (locMin.RightBound.OutIdx == ClipperLib.ClipperBase.Skip)\n        locMin.RightBound = null;\n      this.InsertLocalMinima(locMin);\n      if (!leftBoundIsForward)\n        E = E2;\n    }\n    return true;\n  };\n  ClipperLib.ClipperBase.prototype.AddPaths = function (ppg, polyType, closed)\n  {\n    //  console.log(\"-------------------------------------------\");\n    //  console.log(JSON.stringify(ppg));\n    var result = false;\n    for (var i = 0, ilen = ppg.length; i < ilen; ++i)\n      if (this.AddPath(ppg[i], polyType, closed))\n        result = true;\n    return result;\n  };\n  //------------------------------------------------------------------------------\n  ClipperLib.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3 = function (pt1, pt2, pt3)\n  {\n    if ((ClipperLib.IntPoint.op_Equality(pt1, pt3)) || (ClipperLib.IntPoint.op_Equality(pt1, pt2)) ||       (ClipperLib.IntPoint.op_Equality(pt3, pt2)))\n\n   //if ((pt1 == pt3) || (pt1 == pt2) || (pt3 == pt2))\n   return false;\n\n    else if (pt1.X != pt3.X)\n      return (pt2.X > pt1.X) == (pt2.X < pt3.X);\n    else\n      return (pt2.Y > pt1.Y) == (pt2.Y < pt3.Y);\n  };\n  ClipperLib.ClipperBase.prototype.RemoveEdge = function (e)\n  {\n    //removes e from double_linked_list (but without removing from memory)\n    e.Prev.Next = e.Next;\n    e.Next.Prev = e.Prev;\n    var result = e.Next;\n    e.Prev = null; //flag as removed (see ClipperBase.Clear)\n    return result;\n  };\n  ClipperLib.ClipperBase.prototype.SetDx = function (e)\n  {\n    e.Delta.X = (e.Top.X - e.Bot.X);\n    e.Delta.Y = (e.Top.Y - e.Bot.Y);\n    if (e.Delta.Y === 0) e.Dx = ClipperLib.ClipperBase.horizontal;\n    else e.Dx = (e.Delta.X) / (e.Delta.Y);\n  };\n  ClipperLib.ClipperBase.prototype.InsertLocalMinima = function (newLm)\n  {\n    if (this.m_MinimaList === null)\n    {\n      this.m_MinimaList = newLm;\n    }\n    else if (newLm.Y >= this.m_MinimaList.Y)\n    {\n      newLm.Next = this.m_MinimaList;\n      this.m_MinimaList = newLm;\n    }\n    else\n    {\n      var tmpLm = this.m_MinimaList;\n      while (tmpLm.Next !== null && (newLm.Y < tmpLm.Next.Y))\n        tmpLm = tmpLm.Next;\n      newLm.Next = tmpLm.Next;\n      tmpLm.Next = newLm;\n    }\n  };\n  ClipperLib.ClipperBase.prototype.PopLocalMinima = function ()\n  {\n    if (this.m_CurrentLM === null)\n      return;\n    this.m_CurrentLM = this.m_CurrentLM.Next;\n  };\n  ClipperLib.ClipperBase.prototype.ReverseHorizontal = function (e)\n  {\n    //swap horizontal edges' top and bottom x's so they follow the natural\n    //progression of the bounds - ie so their xbots will align with the\n    //adjoining lower edge. [Helpful in the ProcessHorizontal() method.]\n    var tmp = e.Top.X;\n    e.Top.X = e.Bot.X;\n    e.Bot.X = tmp;\n    if (use_xyz)\n    {\n      tmp = e.Top.Z;\n      e.Top.Z = e.Bot.Z;\n      e.Bot.Z = tmp;\n    }\n  };\n  ClipperLib.ClipperBase.prototype.Reset = function ()\n  {\n    this.m_CurrentLM = this.m_MinimaList;\n    if (this.m_CurrentLM == null)\n      return;\n    //ie nothing to process\n    //reset all edges ...\n    var lm = this.m_MinimaList;\n    while (lm != null)\n    {\n      var e = lm.LeftBound;\n      if (e != null)\n      {\n        //e.Curr = e.Bot;\n        e.Curr.X = e.Bot.X;\n        e.Curr.Y = e.Bot.Y;\n        e.Side = ClipperLib.EdgeSide.esLeft;\n        e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n      }\n      e = lm.RightBound;\n      if (e != null)\n      {\n        //e.Curr = e.Bot;\n        e.Curr.X = e.Bot.X;\n        e.Curr.Y = e.Bot.Y;\n        e.Side = ClipperLib.EdgeSide.esRight;\n        e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n      }\n      lm = lm.Next;\n    }\n  };\n  ClipperLib.Clipper = function (InitOptions) // public Clipper(int InitOptions = 0)\n  {\n    if (typeof (InitOptions) == \"undefined\") InitOptions = 0;\n    this.m_PolyOuts = null;\n    this.m_ClipType = ClipperLib.ClipType.ctIntersection;\n    this.m_Scanbeam = null;\n    this.m_ActiveEdges = null;\n    this.m_SortedEdges = null;\n    this.m_IntersectList = null;\n    this.m_IntersectNodeComparer = null;\n    this.m_ExecuteLocked = false;\n    this.m_ClipFillType = ClipperLib.PolyFillType.pftEvenOdd;\n    this.m_SubjFillType = ClipperLib.PolyFillType.pftEvenOdd;\n    this.m_Joins = null;\n    this.m_GhostJoins = null;\n    this.m_UsingPolyTree = false;\n    this.ReverseSolution = false;\n    this.StrictlySimple = false;\n    ClipperLib.ClipperBase.call(this);\n    this.m_Scanbeam = null;\n    this.m_ActiveEdges = null;\n    this.m_SortedEdges = null;\n    this.m_IntersectList = new Array();\n    this.m_IntersectNodeComparer = ClipperLib.MyIntersectNodeSort.Compare;\n    this.m_ExecuteLocked = false;\n    this.m_UsingPolyTree = false;\n    this.m_PolyOuts = new Array();\n    this.m_Joins = new Array();\n    this.m_GhostJoins = new Array();\n    this.ReverseSolution = (1 & InitOptions) !== 0;\n    this.StrictlySimple = (2 & InitOptions) !== 0;\n    this.PreserveCollinear = (4 & InitOptions) !== 0;\n    if (use_xyz)\n    {\n      this.ZFillFunction = null; // function (IntPoint vert1, IntPoint vert2, ref IntPoint intersectPt);\n    }\n  };\n  ClipperLib.Clipper.ioReverseSolution = 1;\n  ClipperLib.Clipper.ioStrictlySimple = 2;\n  ClipperLib.Clipper.ioPreserveCollinear = 4;\n\n  ClipperLib.Clipper.prototype.Clear = function ()\n  {\n    if (this.m_edges.length === 0)\n      return;\n    //avoids problems with ClipperBase destructor\n    this.DisposeAllPolyPts();\n    ClipperLib.ClipperBase.prototype.Clear.call(this);\n  };\n\n  ClipperLib.Clipper.prototype.DisposeScanbeamList = function ()\n  {\n    while (this.m_Scanbeam !== null)\n    {\n      var sb2 = this.m_Scanbeam.Next;\n      this.m_Scanbeam = null;\n      this.m_Scanbeam = sb2;\n    }\n  };\n  ClipperLib.Clipper.prototype.Reset = function ()\n  {\n    ClipperLib.ClipperBase.prototype.Reset.call(this);\n    this.m_Scanbeam = null;\n    this.m_ActiveEdges = null;\n    this.m_SortedEdges = null;\n\n    var lm = this.m_MinimaList;\n    while (lm !== null)\n    {\n      this.InsertScanbeam(lm.Y);\n      lm = lm.Next;\n    }\n  };\n  ClipperLib.Clipper.prototype.InsertScanbeam = function (Y)\n  {\n    if (this.m_Scanbeam === null)\n    {\n      this.m_Scanbeam = new ClipperLib.Scanbeam();\n      this.m_Scanbeam.Next = null;\n      this.m_Scanbeam.Y = Y;\n    }\n    else if (Y > this.m_Scanbeam.Y)\n    {\n      var newSb = new ClipperLib.Scanbeam();\n      newSb.Y = Y;\n      newSb.Next = this.m_Scanbeam;\n      this.m_Scanbeam = newSb;\n    }\n    else\n    {\n      var sb2 = this.m_Scanbeam;\n      while (sb2.Next !== null && (Y <= sb2.Next.Y))\n        sb2 = sb2.Next;\n      if (Y == sb2.Y)\n        return;\n      //ie ignores duplicates\n      var newSb = new ClipperLib.Scanbeam();\n      newSb.Y = Y;\n      newSb.Next = sb2.Next;\n      sb2.Next = newSb;\n    }\n  };\n  // ************************************\n  ClipperLib.Clipper.prototype.Execute = function ()\n  {\n    var a = arguments,\n      alen = a.length,\n      ispolytree = a[1] instanceof ClipperLib.PolyTree;\n    if (alen == 4 && !ispolytree) // function (clipType, solution, subjFillType, clipFillType)\n    {\n      var clipType = a[0],\n        solution = a[1],\n        subjFillType = a[2],\n        clipFillType = a[3];\n      if (this.m_ExecuteLocked)\n        return false;\n      if (this.m_HasOpenPaths)\n        ClipperLib.Error(\"Error: PolyTree struct is need for open path clipping.\");\n      this.m_ExecuteLocked = true;\n      ClipperLib.Clear(solution);\n      this.m_SubjFillType = subjFillType;\n      this.m_ClipFillType = clipFillType;\n      this.m_ClipType = clipType;\n      this.m_UsingPolyTree = false;\n      try\n      {\n        var succeeded = this.ExecuteInternal();\n        //build the return polygons ...\n        if (succeeded) this.BuildResult(solution);\n      }\n      finally\n      {\n        this.DisposeAllPolyPts();\n        this.m_ExecuteLocked = false;\n      }\n      return succeeded;\n    }\n    else if (alen == 4 && ispolytree) // function (clipType, polytree, subjFillType, clipFillType)\n    {\n      var clipType = a[0],\n        polytree = a[1],\n        subjFillType = a[2],\n        clipFillType = a[3];\n      if (this.m_ExecuteLocked)\n        return false;\n      this.m_ExecuteLocked = true;\n      this.m_SubjFillType = subjFillType;\n      this.m_ClipFillType = clipFillType;\n      this.m_ClipType = clipType;\n      this.m_UsingPolyTree = true;\n      try\n      {\n        var succeeded = this.ExecuteInternal();\n        //build the return polygons ...\n        if (succeeded) this.BuildResult2(polytree);\n      }\n      finally\n      {\n        this.DisposeAllPolyPts();\n        this.m_ExecuteLocked = false;\n      }\n      return succeeded;\n    }\n    else if (alen == 2 && !ispolytree) // function (clipType, solution)\n    {\n      var clipType = a[0],\n        solution = a[1];\n      return this.Execute(clipType, solution, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n    }\n    else if (alen == 2 && ispolytree) // function (clipType, polytree)\n    {\n      var clipType = a[0],\n        polytree = a[1];\n      return this.Execute(clipType, polytree, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n    }\n  };\n  ClipperLib.Clipper.prototype.FixHoleLinkage = function (outRec)\n  {\n    //skip if an outermost polygon or\n    //already already points to the correct FirstLeft ...\n    if (outRec.FirstLeft === null || (outRec.IsHole != outRec.FirstLeft.IsHole && outRec.FirstLeft.Pts !== null))\n      return;\n    var orfl = outRec.FirstLeft;\n    while (orfl !== null && ((orfl.IsHole == outRec.IsHole) || orfl.Pts === null))\n      orfl = orfl.FirstLeft;\n    outRec.FirstLeft = orfl;\n  };\n  ClipperLib.Clipper.prototype.ExecuteInternal = function ()\n  {\n    try\n    {\n      this.Reset();\n      if (this.m_CurrentLM === null)\n        return false;\n      var botY = this.PopScanbeam();\n      do {\n        this.InsertLocalMinimaIntoAEL(botY);\n        ClipperLib.Clear(this.m_GhostJoins);\n        this.ProcessHorizontals(false);\n        if (this.m_Scanbeam === null)\n          break;\n        var topY = this.PopScanbeam();\n        if (!this.ProcessIntersections(topY)) return false;\n\n        this.ProcessEdgesAtTopOfScanbeam(topY);\n        botY = topY;\n      }\n      while (this.m_Scanbeam !== null || this.m_CurrentLM !== null)\n      //fix orientations ...\n      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n      {\n        var outRec = this.m_PolyOuts[i];\n        if (outRec.Pts === null || outRec.IsOpen)\n          continue;\n        if ((outRec.IsHole ^ this.ReverseSolution) == (this.Area(outRec) > 0))\n          this.ReversePolyPtLinks(outRec.Pts);\n      }\n      this.JoinCommonEdges();\n      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n      {\n        var outRec = this.m_PolyOuts[i];\n        if (outRec.Pts !== null && !outRec.IsOpen)\n          this.FixupOutPolygon(outRec);\n      }\n      if (this.StrictlySimple)\n        this.DoSimplePolygons();\n      return true;\n    }\n    finally\n    {\n      ClipperLib.Clear(this.m_Joins);\n      ClipperLib.Clear(this.m_GhostJoins);\n    }\n  };\n  ClipperLib.Clipper.prototype.PopScanbeam = function ()\n  {\n    var Y = this.m_Scanbeam.Y;\n    this.m_Scanbeam = this.m_Scanbeam.Next;\n    return Y;\n  };\n\n  ClipperLib.Clipper.prototype.DisposeAllPolyPts = function ()\n  {\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; ++i)\n      this.DisposeOutRec(i);\n    ClipperLib.Clear(this.m_PolyOuts);\n  };\n  ClipperLib.Clipper.prototype.DisposeOutRec = function (index)\n  {\n    var outRec = this.m_PolyOuts[index];\n    outRec.Pts = null;\n    outRec = null;\n    this.m_PolyOuts[index] = null;\n  };\n\n  ClipperLib.Clipper.prototype.AddJoin = function (Op1, Op2, OffPt)\n  {\n    var j = new ClipperLib.Join();\n    j.OutPt1 = Op1;\n    j.OutPt2 = Op2;\n    //j.OffPt = OffPt;\n    j.OffPt.X = OffPt.X;\n    j.OffPt.Y = OffPt.Y;\n    this.m_Joins.push(j);\n  };\n  ClipperLib.Clipper.prototype.AddGhostJoin = function (Op, OffPt)\n  {\n    var j = new ClipperLib.Join();\n    j.OutPt1 = Op;\n    //j.OffPt = OffPt;\n    j.OffPt.X = OffPt.X;\n    j.OffPt.Y = OffPt.Y;\n    this.m_GhostJoins.push(j);\n  };\n  if (use_xyz)\n  {\n    ClipperLib.Clipper.prototype.SetZ = function (pt, e1, e2)\n    {\n      if (this.ZFillFunction !== null)\n      {\n        if (pt.Z != 0 || this.ZFillFunction === null) return;\n        else if (ClipperLib.IntPoint.op_Equality(pt, e1.Bot)) pt.Z = e1.Bot.Z;\n        else if (ClipperLib.IntPoint.op_Equality(pt, e1.Top)) pt.Z = e1.Top.Z;\n        else if (ClipperLib.IntPoint.op_Equality(pt, e2.Bot)) pt.Z = e2.Bot.Z;\n        else if (ClipperLib.IntPoint.op_Equality(pt, e2.Top)) pt.Z = e2.Top.Z;\n        else ZFillFunction(e1.Bot, e1.Top, e2.Bot, e2.Top, pt);\n      }\n    };\n\n    //------------------------------------------------------------------------------\n  }\n\n  ClipperLib.Clipper.prototype.InsertLocalMinimaIntoAEL = function (botY)\n  {\n    while (this.m_CurrentLM !== null && (this.m_CurrentLM.Y == botY))\n    {\n      var lb = this.m_CurrentLM.LeftBound;\n      var rb = this.m_CurrentLM.RightBound;\n      this.PopLocalMinima();\n      var Op1 = null;\n      if (lb === null)\n      {\n        this.InsertEdgeIntoAEL(rb, null);\n        this.SetWindingCount(rb);\n        if (this.IsContributing(rb))\n          Op1 = this.AddOutPt(rb, rb.Bot);\n      }\n      else if (rb == null)\n      {\n        this.InsertEdgeIntoAEL(lb, null);\n        this.SetWindingCount(lb);\n        if (this.IsContributing(lb))\n          Op1 = this.AddOutPt(lb, lb.Bot);\n        this.InsertScanbeam(lb.Top.Y);\n      }\n      else\n      {\n        this.InsertEdgeIntoAEL(lb, null);\n        this.InsertEdgeIntoAEL(rb, lb);\n        this.SetWindingCount(lb);\n        rb.WindCnt = lb.WindCnt;\n        rb.WindCnt2 = lb.WindCnt2;\n        if (this.IsContributing(lb))\n          Op1 = this.AddLocalMinPoly(lb, rb, lb.Bot);\n        this.InsertScanbeam(lb.Top.Y);\n      }\n      if (rb != null)\n      {\n        if (ClipperLib.ClipperBase.IsHorizontal(rb))\n          this.AddEdgeToSEL(rb);\n        else\n          this.InsertScanbeam(rb.Top.Y);\n      }\n      if (lb == null || rb == null) continue;\n      //if output polygons share an Edge with a horizontal rb, they'll need joining later ...\n      if (Op1 !== null && ClipperLib.ClipperBase.IsHorizontal(rb) && this.m_GhostJoins.length > 0 && rb.WindDelta !== 0)\n      {\n        for (var i = 0, ilen = this.m_GhostJoins.length; i < ilen; i++)\n        {\n          //if the horizontal Rb and a 'ghost' horizontal overlap, then convert\n          //the 'ghost' join to a real join ready for later ...\n          var j = this.m_GhostJoins[i];\n\n\t\t\t\t\tif (this.HorzSegmentsOverlap(j.OutPt1.Pt.X, j.OffPt.X, rb.Bot.X, rb.Top.X))\n            this.AddJoin(j.OutPt1, Op1, j.OffPt);\n        }\n      }\n      if (lb.OutIdx >= 0 && lb.PrevInAEL !== null &&\n        lb.PrevInAEL.Curr.X == lb.Bot.X &&\n        lb.PrevInAEL.OutIdx >= 0 &&\n        ClipperLib.ClipperBase.SlopesEqual(lb.PrevInAEL, lb, this.m_UseFullRange) &&\n        lb.WindDelta !== 0 && lb.PrevInAEL.WindDelta !== 0)\n      {\n        var Op2 = this.AddOutPt(lb.PrevInAEL, lb.Bot);\n        this.AddJoin(Op1, Op2, lb.Top);\n      }\n      if (lb.NextInAEL != rb)\n      {\n        if (rb.OutIdx >= 0 && rb.PrevInAEL.OutIdx >= 0 &&\n          ClipperLib.ClipperBase.SlopesEqual(rb.PrevInAEL, rb, this.m_UseFullRange) &&\n          rb.WindDelta !== 0 && rb.PrevInAEL.WindDelta !== 0)\n        {\n          var Op2 = this.AddOutPt(rb.PrevInAEL, rb.Bot);\n          this.AddJoin(Op1, Op2, rb.Top);\n        }\n        var e = lb.NextInAEL;\n        if (e !== null)\n          while (e != rb)\n          {\n            //nb: For calculating winding counts etc, IntersectEdges() assumes\n            //that param1 will be to the right of param2 ABOVE the intersection ...\n            this.IntersectEdges(rb, e, lb.Curr, false);\n            //order important here\n            e = e.NextInAEL;\n          }\n      }\n    }\n  };\n  ClipperLib.Clipper.prototype.InsertEdgeIntoAEL = function (edge, startEdge)\n  {\n    if (this.m_ActiveEdges === null)\n    {\n      edge.PrevInAEL = null;\n      edge.NextInAEL = null;\n      this.m_ActiveEdges = edge;\n    }\n    else if (startEdge === null && this.E2InsertsBeforeE1(this.m_ActiveEdges, edge))\n    {\n      edge.PrevInAEL = null;\n      edge.NextInAEL = this.m_ActiveEdges;\n      this.m_ActiveEdges.PrevInAEL = edge;\n      this.m_ActiveEdges = edge;\n    }\n    else\n    {\n      if (startEdge === null)\n        startEdge = this.m_ActiveEdges;\n      while (startEdge.NextInAEL !== null && !this.E2InsertsBeforeE1(startEdge.NextInAEL, edge))\n        startEdge = startEdge.NextInAEL;\n      edge.NextInAEL = startEdge.NextInAEL;\n      if (startEdge.NextInAEL !== null)\n        startEdge.NextInAEL.PrevInAEL = edge;\n      edge.PrevInAEL = startEdge;\n      startEdge.NextInAEL = edge;\n    }\n  };\n  ClipperLib.Clipper.prototype.E2InsertsBeforeE1 = function (e1, e2)\n  {\n    if (e2.Curr.X == e1.Curr.X)\n    {\n      if (e2.Top.Y > e1.Top.Y)\n        return e2.Top.X < ClipperLib.Clipper.TopX(e1, e2.Top.Y);\n      else\n        return e1.Top.X > ClipperLib.Clipper.TopX(e2, e1.Top.Y);\n    }\n    else\n      return e2.Curr.X < e1.Curr.X;\n  };\n  ClipperLib.Clipper.prototype.IsEvenOddFillType = function (edge)\n  {\n    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n      return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n    else\n      return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n  };\n  ClipperLib.Clipper.prototype.IsEvenOddAltFillType = function (edge)\n  {\n    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n      return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n    else\n      return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n  };\n  ClipperLib.Clipper.prototype.IsContributing = function (edge)\n  {\n    var pft, pft2;\n    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n    {\n      pft = this.m_SubjFillType;\n      pft2 = this.m_ClipFillType;\n    }\n    else\n    {\n      pft = this.m_ClipFillType;\n      pft2 = this.m_SubjFillType;\n    }\n    switch (pft)\n    {\n    case ClipperLib.PolyFillType.pftEvenOdd:\n      if (edge.WindDelta === 0 && edge.WindCnt != 1)\n        return false;\n      break;\n    case ClipperLib.PolyFillType.pftNonZero:\n      if (Math.abs(edge.WindCnt) != 1)\n        return false;\n      break;\n    case ClipperLib.PolyFillType.pftPositive:\n      if (edge.WindCnt != 1)\n        return false;\n      break;\n    default:\n      if (edge.WindCnt != -1)\n        return false;\n      break;\n    }\n    switch (this.m_ClipType)\n    {\n    case ClipperLib.ClipType.ctIntersection:\n      switch (pft2)\n      {\n      case ClipperLib.PolyFillType.pftEvenOdd:\n      case ClipperLib.PolyFillType.pftNonZero:\n        return (edge.WindCnt2 !== 0);\n      case ClipperLib.PolyFillType.pftPositive:\n        return (edge.WindCnt2 > 0);\n      default:\n        return (edge.WindCnt2 < 0);\n      }\n    case ClipperLib.ClipType.ctUnion:\n      switch (pft2)\n      {\n      case ClipperLib.PolyFillType.pftEvenOdd:\n      case ClipperLib.PolyFillType.pftNonZero:\n        return (edge.WindCnt2 === 0);\n      case ClipperLib.PolyFillType.pftPositive:\n        return (edge.WindCnt2 <= 0);\n      default:\n        return (edge.WindCnt2 >= 0);\n      }\n    case ClipperLib.ClipType.ctDifference:\n      if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n        switch (pft2)\n        {\n        case ClipperLib.PolyFillType.pftEvenOdd:\n        case ClipperLib.PolyFillType.pftNonZero:\n          return (edge.WindCnt2 === 0);\n        case ClipperLib.PolyFillType.pftPositive:\n          return (edge.WindCnt2 <= 0);\n        default:\n          return (edge.WindCnt2 >= 0);\n        }\n      else\n        switch (pft2)\n        {\n        case ClipperLib.PolyFillType.pftEvenOdd:\n        case ClipperLib.PolyFillType.pftNonZero:\n          return (edge.WindCnt2 !== 0);\n        case ClipperLib.PolyFillType.pftPositive:\n          return (edge.WindCnt2 > 0);\n        default:\n          return (edge.WindCnt2 < 0);\n        }\n    case ClipperLib.ClipType.ctXor:\n      if (edge.WindDelta === 0)\n        switch (pft2)\n        {\n        case ClipperLib.PolyFillType.pftEvenOdd:\n        case ClipperLib.PolyFillType.pftNonZero:\n          return (edge.WindCnt2 === 0);\n        case ClipperLib.PolyFillType.pftPositive:\n          return (edge.WindCnt2 <= 0);\n        default:\n          return (edge.WindCnt2 >= 0);\n        }\n      else\n        return true;\n    }\n    return true;\n  };\n  ClipperLib.Clipper.prototype.SetWindingCount = function (edge)\n  {\n    var e = edge.PrevInAEL;\n    //find the edge of the same polytype that immediately preceeds 'edge' in AEL\n    while (e !== null && ((e.PolyTyp != edge.PolyTyp) || (e.WindDelta === 0)))\n      e = e.PrevInAEL;\n    if (e === null)\n    {\n      edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n      edge.WindCnt2 = 0;\n      e = this.m_ActiveEdges;\n      //ie get ready to calc WindCnt2\n    }\n    else if (edge.WindDelta === 0 && this.m_ClipType != ClipperLib.ClipType.ctUnion)\n    {\n      edge.WindCnt = 1;\n      edge.WindCnt2 = e.WindCnt2;\n      e = e.NextInAEL;\n      //ie get ready to calc WindCnt2\n    }\n    else if (this.IsEvenOddFillType(edge))\n    {\n      //EvenOdd filling ...\n      if (edge.WindDelta === 0)\n      {\n        //are we inside a subj polygon ...\n        var Inside = true;\n        var e2 = e.PrevInAEL;\n        while (e2 !== null)\n        {\n          if (e2.PolyTyp == e.PolyTyp && e2.WindDelta !== 0)\n            Inside = !Inside;\n          e2 = e2.PrevInAEL;\n        }\n        edge.WindCnt = (Inside ? 0 : 1);\n      }\n      else\n      {\n        edge.WindCnt = edge.WindDelta;\n      }\n      edge.WindCnt2 = e.WindCnt2;\n      e = e.NextInAEL;\n      //ie get ready to calc WindCnt2\n    }\n    else\n    {\n      //nonZero, Positive or Negative filling ...\n      if (e.WindCnt * e.WindDelta < 0)\n      {\n        //prev edge is 'decreasing' WindCount (WC) toward zero\n        //so we're outside the previous polygon ...\n        if (Math.abs(e.WindCnt) > 1)\n        {\n          //outside prev poly but still inside another.\n          //when reversing direction of prev poly use the same WC\n          if (e.WindDelta * edge.WindDelta < 0)\n            edge.WindCnt = e.WindCnt;\n          else\n            edge.WindCnt = e.WindCnt + edge.WindDelta;\n        }\n        else\n          edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n      }\n      else\n      {\n        //prev edge is 'increasing' WindCount (WC) away from zero\n        //so we're inside the previous polygon ...\n        if (edge.WindDelta === 0)\n          edge.WindCnt = (e.WindCnt < 0 ? e.WindCnt - 1 : e.WindCnt + 1);\n        else if (e.WindDelta * edge.WindDelta < 0)\n          edge.WindCnt = e.WindCnt;\n        else\n          edge.WindCnt = e.WindCnt + edge.WindDelta;\n      }\n      edge.WindCnt2 = e.WindCnt2;\n      e = e.NextInAEL;\n      //ie get ready to calc WindCnt2\n    }\n    //update WindCnt2 ...\n    if (this.IsEvenOddAltFillType(edge))\n    {\n      //EvenOdd filling ...\n      while (e != edge)\n      {\n        if (e.WindDelta !== 0)\n          edge.WindCnt2 = (edge.WindCnt2 === 0 ? 1 : 0);\n        e = e.NextInAEL;\n      }\n    }\n    else\n    {\n      //nonZero, Positive or Negative filling ...\n      while (e != edge)\n      {\n        edge.WindCnt2 += e.WindDelta;\n        e = e.NextInAEL;\n      }\n    }\n  };\n  ClipperLib.Clipper.prototype.AddEdgeToSEL = function (edge)\n  {\n    //SEL pointers in PEdge are reused to build a list of horizontal edges.\n    //However, we don't need to worry about order with horizontal edge processing.\n    if (this.m_SortedEdges === null)\n    {\n      this.m_SortedEdges = edge;\n      edge.PrevInSEL = null;\n      edge.NextInSEL = null;\n    }\n    else\n    {\n      edge.NextInSEL = this.m_SortedEdges;\n      edge.PrevInSEL = null;\n      this.m_SortedEdges.PrevInSEL = edge;\n      this.m_SortedEdges = edge;\n    }\n  };\n  ClipperLib.Clipper.prototype.CopyAELToSEL = function ()\n  {\n    var e = this.m_ActiveEdges;\n    this.m_SortedEdges = e;\n    while (e !== null)\n    {\n      e.PrevInSEL = e.PrevInAEL;\n      e.NextInSEL = e.NextInAEL;\n      e = e.NextInAEL;\n    }\n  };\n  ClipperLib.Clipper.prototype.SwapPositionsInAEL = function (edge1, edge2)\n  {\n    //check that one or other edge hasn't already been removed from AEL ...\n    if (edge1.NextInAEL == edge1.PrevInAEL || edge2.NextInAEL == edge2.PrevInAEL)\n      return;\n    if (edge1.NextInAEL == edge2)\n    {\n      var next = edge2.NextInAEL;\n      if (next !== null)\n        next.PrevInAEL = edge1;\n      var prev = edge1.PrevInAEL;\n      if (prev !== null)\n        prev.NextInAEL = edge2;\n      edge2.PrevInAEL = prev;\n      edge2.NextInAEL = edge1;\n      edge1.PrevInAEL = edge2;\n      edge1.NextInAEL = next;\n    }\n    else if (edge2.NextInAEL == edge1)\n    {\n      var next = edge1.NextInAEL;\n      if (next !== null)\n        next.PrevInAEL = edge2;\n      var prev = edge2.PrevInAEL;\n      if (prev !== null)\n        prev.NextInAEL = edge1;\n      edge1.PrevInAEL = prev;\n      edge1.NextInAEL = edge2;\n      edge2.PrevInAEL = edge1;\n      edge2.NextInAEL = next;\n    }\n    else\n    {\n      var next = edge1.NextInAEL;\n      var prev = edge1.PrevInAEL;\n      edge1.NextInAEL = edge2.NextInAEL;\n      if (edge1.NextInAEL !== null)\n        edge1.NextInAEL.PrevInAEL = edge1;\n      edge1.PrevInAEL = edge2.PrevInAEL;\n      if (edge1.PrevInAEL !== null)\n        edge1.PrevInAEL.NextInAEL = edge1;\n      edge2.NextInAEL = next;\n      if (edge2.NextInAEL !== null)\n        edge2.NextInAEL.PrevInAEL = edge2;\n      edge2.PrevInAEL = prev;\n      if (edge2.PrevInAEL !== null)\n        edge2.PrevInAEL.NextInAEL = edge2;\n    }\n    if (edge1.PrevInAEL === null)\n      this.m_ActiveEdges = edge1;\n    else if (edge2.PrevInAEL === null)\n      this.m_ActiveEdges = edge2;\n  };\n  ClipperLib.Clipper.prototype.SwapPositionsInSEL = function (edge1, edge2)\n  {\n    if (edge1.NextInSEL === null && edge1.PrevInSEL === null)\n      return;\n    if (edge2.NextInSEL === null && edge2.PrevInSEL === null)\n      return;\n    if (edge1.NextInSEL == edge2)\n    {\n      var next = edge2.NextInSEL;\n      if (next !== null)\n        next.PrevInSEL = edge1;\n      var prev = edge1.PrevInSEL;\n      if (prev !== null)\n        prev.NextInSEL = edge2;\n      edge2.PrevInSEL = prev;\n      edge2.NextInSEL = edge1;\n      edge1.PrevInSEL = edge2;\n      edge1.NextInSEL = next;\n    }\n    else if (edge2.NextInSEL == edge1)\n    {\n      var next = edge1.NextInSEL;\n      if (next !== null)\n        next.PrevInSEL = edge2;\n      var prev = edge2.PrevInSEL;\n      if (prev !== null)\n        prev.NextInSEL = edge1;\n      edge1.PrevInSEL = prev;\n      edge1.NextInSEL = edge2;\n      edge2.PrevInSEL = edge1;\n      edge2.NextInSEL = next;\n    }\n    else\n    {\n      var next = edge1.NextInSEL;\n      var prev = edge1.PrevInSEL;\n      edge1.NextInSEL = edge2.NextInSEL;\n      if (edge1.NextInSEL !== null)\n        edge1.NextInSEL.PrevInSEL = edge1;\n      edge1.PrevInSEL = edge2.PrevInSEL;\n      if (edge1.PrevInSEL !== null)\n        edge1.PrevInSEL.NextInSEL = edge1;\n      edge2.NextInSEL = next;\n      if (edge2.NextInSEL !== null)\n        edge2.NextInSEL.PrevInSEL = edge2;\n      edge2.PrevInSEL = prev;\n      if (edge2.PrevInSEL !== null)\n        edge2.PrevInSEL.NextInSEL = edge2;\n    }\n    if (edge1.PrevInSEL === null)\n      this.m_SortedEdges = edge1;\n    else if (edge2.PrevInSEL === null)\n      this.m_SortedEdges = edge2;\n  };\n  ClipperLib.Clipper.prototype.AddLocalMaxPoly = function (e1, e2, pt)\n  {\n    this.AddOutPt(e1, pt);\n    if (e2.WindDelta == 0) this.AddOutPt(e2, pt);\n    if (e1.OutIdx == e2.OutIdx)\n    {\n      e1.OutIdx = -1;\n      e2.OutIdx = -1;\n    }\n    else if (e1.OutIdx < e2.OutIdx)\n      this.AppendPolygon(e1, e2);\n    else\n      this.AppendPolygon(e2, e1);\n  };\n  ClipperLib.Clipper.prototype.AddLocalMinPoly = function (e1, e2, pt)\n  {\n    var result;\n    var e, prevE;\n    if (ClipperLib.ClipperBase.IsHorizontal(e2) || (e1.Dx > e2.Dx))\n    {\n      result = this.AddOutPt(e1, pt);\n      e2.OutIdx = e1.OutIdx;\n      e1.Side = ClipperLib.EdgeSide.esLeft;\n      e2.Side = ClipperLib.EdgeSide.esRight;\n      e = e1;\n      if (e.PrevInAEL == e2)\n        prevE = e2.PrevInAEL;\n      else\n        prevE = e.PrevInAEL;\n    }\n    else\n    {\n      result = this.AddOutPt(e2, pt);\n      e1.OutIdx = e2.OutIdx;\n      e1.Side = ClipperLib.EdgeSide.esRight;\n      e2.Side = ClipperLib.EdgeSide.esLeft;\n      e = e2;\n      if (e.PrevInAEL == e1)\n        prevE = e1.PrevInAEL;\n      else\n        prevE = e.PrevInAEL;\n    }\n    if (prevE !== null && prevE.OutIdx >= 0 && (ClipperLib.Clipper.TopX(prevE, pt.Y) == ClipperLib.Clipper.TopX(e, pt.Y)) && ClipperLib.ClipperBase.SlopesEqual(e, prevE, this.m_UseFullRange) && (e.WindDelta !== 0) && (prevE.WindDelta !== 0))\n    {\n      var outPt = this.AddOutPt(prevE, pt);\n      this.AddJoin(result, outPt, e.Top);\n    }\n    return result;\n  };\n  ClipperLib.Clipper.prototype.CreateOutRec = function ()\n  {\n    var result = new ClipperLib.OutRec();\n    result.Idx = -1;\n    result.IsHole = false;\n    result.IsOpen = false;\n    result.FirstLeft = null;\n    result.Pts = null;\n    result.BottomPt = null;\n    result.PolyNode = null;\n    this.m_PolyOuts.push(result);\n    result.Idx = this.m_PolyOuts.length - 1;\n    return result;\n  };\n  ClipperLib.Clipper.prototype.AddOutPt = function (e, pt)\n  {\n    var ToFront = (e.Side == ClipperLib.EdgeSide.esLeft);\n    if (e.OutIdx < 0)\n    {\n      var outRec = this.CreateOutRec();\n      outRec.IsOpen = (e.WindDelta === 0);\n      var newOp = new ClipperLib.OutPt();\n      outRec.Pts = newOp;\n      newOp.Idx = outRec.Idx;\n      //newOp.Pt = pt;\n      newOp.Pt.X = pt.X;\n      newOp.Pt.Y = pt.Y;\n      newOp.Next = newOp;\n      newOp.Prev = newOp;\n      if (!outRec.IsOpen)\n        this.SetHoleState(e, outRec);\n      e.OutIdx = outRec.Idx;\n      //nb: do this after SetZ !\n      return newOp;\n    }\n    else\n    {\n      var outRec = this.m_PolyOuts[e.OutIdx];\n      //OutRec.Pts is the 'Left-most' point & OutRec.Pts.Prev is the 'Right-most'\n      var op = outRec.Pts;\n      if (ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Pt))\n        return op;\n      else if (!ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Prev.Pt))\n        return op.Prev;\n      var newOp = new ClipperLib.OutPt();\n      newOp.Idx = outRec.Idx;\n      //newOp.Pt = pt;\n      newOp.Pt.X = pt.X;\n      newOp.Pt.Y = pt.Y;\n      newOp.Next = op;\n      newOp.Prev = op.Prev;\n      newOp.Prev.Next = newOp;\n      op.Prev = newOp;\n      if (ToFront)\n        outRec.Pts = newOp;\n      return newOp;\n    }\n  };\n  ClipperLib.Clipper.prototype.SwapPoints = function (pt1, pt2)\n  {\n    var tmp = new ClipperLib.IntPoint(pt1.Value);\n    //pt1.Value = pt2.Value;\n    pt1.Value.X = pt2.Value.X;\n    pt1.Value.Y = pt2.Value.Y;\n    //pt2.Value = tmp;\n    pt2.Value.X = tmp.X;\n    pt2.Value.Y = tmp.Y;\n  };\n  ClipperLib.Clipper.prototype.HorzSegmentsOverlap = function (seg1a, seg1b, seg2a, seg2b)\n\t{\n\t\tvar tmp;\n\t\tif (seg1a > seg1b)\n\t\t{\n\t\t\ttmp = seg1a;\n\t\t\tseg1a = seg1b;\n\t\t\tseg1b = tmp;\n\t\t}\n\t\tif (seg2a > seg2b)\n\t\t{\n\t\t\ttmp = seg2a;\n\t\t\tseg2a = seg2b;\n\t\t\tseg2b = tmp;\n\t\t}\n\t\treturn (seg1a < seg2b) && (seg2a < seg1b);\n\t}\n\n  ClipperLib.Clipper.prototype.SetHoleState = function (e, outRec)\n  {\n    var isHole = false;\n    var e2 = e.PrevInAEL;\n    while (e2 !== null)\n    {\n      if (e2.OutIdx >= 0 && e2.WindDelta != 0)\n      {\n        isHole = !isHole;\n        if (outRec.FirstLeft === null)\n          outRec.FirstLeft = this.m_PolyOuts[e2.OutIdx];\n      }\n      e2 = e2.PrevInAEL;\n    }\n    if (isHole)\n      outRec.IsHole = true;\n  };\n  ClipperLib.Clipper.prototype.GetDx = function (pt1, pt2)\n  {\n    if (pt1.Y == pt2.Y)\n      return ClipperLib.ClipperBase.horizontal;\n    else\n      return (pt2.X - pt1.X) / (pt2.Y - pt1.Y);\n  };\n  ClipperLib.Clipper.prototype.FirstIsBottomPt = function (btmPt1, btmPt2)\n  {\n    var p = btmPt1.Prev;\n    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))\n      p = p.Prev;\n    var dx1p = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n    p = btmPt1.Next;\n    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))\n      p = p.Next;\n    var dx1n = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n    p = btmPt2.Prev;\n    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))\n      p = p.Prev;\n    var dx2p = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n    p = btmPt2.Next;\n    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))\n      p = p.Next;\n    var dx2n = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n    return (dx1p >= dx2p && dx1p >= dx2n) || (dx1n >= dx2p && dx1n >= dx2n);\n  };\n  ClipperLib.Clipper.prototype.GetBottomPt = function (pp)\n  {\n    var dups = null;\n    var p = pp.Next;\n    while (p != pp)\n    {\n      if (p.Pt.Y > pp.Pt.Y)\n      {\n        pp = p;\n        dups = null;\n      }\n      else if (p.Pt.Y == pp.Pt.Y && p.Pt.X <= pp.Pt.X)\n      {\n        if (p.Pt.X < pp.Pt.X)\n        {\n          dups = null;\n          pp = p;\n        }\n        else\n        {\n          if (p.Next != pp && p.Prev != pp)\n            dups = p;\n        }\n      }\n      p = p.Next;\n    }\n    if (dups !== null)\n    {\n      //there appears to be at least 2 vertices at bottomPt so ...\n      while (dups != p)\n      {\n        if (!this.FirstIsBottomPt(p, dups))\n          pp = dups;\n        dups = dups.Next;\n        while (ClipperLib.IntPoint.op_Inequality(dups.Pt, pp.Pt))\n          dups = dups.Next;\n      }\n    }\n    return pp;\n  };\n  ClipperLib.Clipper.prototype.GetLowermostRec = function (outRec1, outRec2)\n  {\n    //work out which polygon fragment has the correct hole state ...\n    if (outRec1.BottomPt === null)\n      outRec1.BottomPt = this.GetBottomPt(outRec1.Pts);\n    if (outRec2.BottomPt === null)\n      outRec2.BottomPt = this.GetBottomPt(outRec2.Pts);\n    var bPt1 = outRec1.BottomPt;\n    var bPt2 = outRec2.BottomPt;\n    if (bPt1.Pt.Y > bPt2.Pt.Y)\n      return outRec1;\n    else if (bPt1.Pt.Y < bPt2.Pt.Y)\n      return outRec2;\n    else if (bPt1.Pt.X < bPt2.Pt.X)\n      return outRec1;\n    else if (bPt1.Pt.X > bPt2.Pt.X)\n      return outRec2;\n    else if (bPt1.Next == bPt1)\n      return outRec2;\n    else if (bPt2.Next == bPt2)\n      return outRec1;\n    else if (this.FirstIsBottomPt(bPt1, bPt2))\n      return outRec1;\n    else\n      return outRec2;\n  };\n  ClipperLib.Clipper.prototype.Param1RightOfParam2 = function (outRec1, outRec2)\n  {\n    do {\n      outRec1 = outRec1.FirstLeft;\n      if (outRec1 == outRec2)\n        return true;\n    }\n    while (outRec1 !== null)\n    return false;\n  };\n  ClipperLib.Clipper.prototype.GetOutRec = function (idx)\n  {\n    var outrec = this.m_PolyOuts[idx];\n    while (outrec != this.m_PolyOuts[outrec.Idx])\n      outrec = this.m_PolyOuts[outrec.Idx];\n    return outrec;\n  };\n  ClipperLib.Clipper.prototype.AppendPolygon = function (e1, e2)\n  {\n    //get the start and ends of both output polygons ...\n    var outRec1 = this.m_PolyOuts[e1.OutIdx];\n    var outRec2 = this.m_PolyOuts[e2.OutIdx];\n    var holeStateRec;\n    if (this.Param1RightOfParam2(outRec1, outRec2))\n      holeStateRec = outRec2;\n    else if (this.Param1RightOfParam2(outRec2, outRec1))\n      holeStateRec = outRec1;\n    else\n      holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n    var p1_lft = outRec1.Pts;\n    var p1_rt = p1_lft.Prev;\n    var p2_lft = outRec2.Pts;\n    var p2_rt = p2_lft.Prev;\n    var side;\n    //join e2 poly onto e1 poly and delete pointers to e2 ...\n    if (e1.Side == ClipperLib.EdgeSide.esLeft)\n    {\n      if (e2.Side == ClipperLib.EdgeSide.esLeft)\n      {\n        //z y x a b c\n        this.ReversePolyPtLinks(p2_lft);\n        p2_lft.Next = p1_lft;\n        p1_lft.Prev = p2_lft;\n        p1_rt.Next = p2_rt;\n        p2_rt.Prev = p1_rt;\n        outRec1.Pts = p2_rt;\n      }\n      else\n      {\n        //x y z a b c\n        p2_rt.Next = p1_lft;\n        p1_lft.Prev = p2_rt;\n        p2_lft.Prev = p1_rt;\n        p1_rt.Next = p2_lft;\n        outRec1.Pts = p2_lft;\n      }\n      side = ClipperLib.EdgeSide.esLeft;\n    }\n    else\n    {\n      if (e2.Side == ClipperLib.EdgeSide.esRight)\n      {\n        //a b c z y x\n        this.ReversePolyPtLinks(p2_lft);\n        p1_rt.Next = p2_rt;\n        p2_rt.Prev = p1_rt;\n        p2_lft.Next = p1_lft;\n        p1_lft.Prev = p2_lft;\n      }\n      else\n      {\n        //a b c x y z\n        p1_rt.Next = p2_lft;\n        p2_lft.Prev = p1_rt;\n        p1_lft.Prev = p2_rt;\n        p2_rt.Next = p1_lft;\n      }\n      side = ClipperLib.EdgeSide.esRight;\n    }\n    outRec1.BottomPt = null;\n    if (holeStateRec == outRec2)\n    {\n      if (outRec2.FirstLeft != outRec1)\n        outRec1.FirstLeft = outRec2.FirstLeft;\n      outRec1.IsHole = outRec2.IsHole;\n    }\n    outRec2.Pts = null;\n    outRec2.BottomPt = null;\n    outRec2.FirstLeft = outRec1;\n    var OKIdx = e1.OutIdx;\n    var ObsoleteIdx = e2.OutIdx;\n    e1.OutIdx = -1;\n    //nb: safe because we only get here via AddLocalMaxPoly\n    e2.OutIdx = -1;\n    var e = this.m_ActiveEdges;\n    while (e !== null)\n    {\n      if (e.OutIdx == ObsoleteIdx)\n      {\n        e.OutIdx = OKIdx;\n        e.Side = side;\n        break;\n      }\n      e = e.NextInAEL;\n    }\n    outRec2.Idx = outRec1.Idx;\n  };\n  ClipperLib.Clipper.prototype.ReversePolyPtLinks = function (pp)\n  {\n    if (pp === null)\n      return;\n    var pp1;\n    var pp2;\n    pp1 = pp;\n    do {\n      pp2 = pp1.Next;\n      pp1.Next = pp1.Prev;\n      pp1.Prev = pp2;\n      pp1 = pp2;\n    }\n    while (pp1 != pp)\n  };\n  ClipperLib.Clipper.SwapSides = function (edge1, edge2)\n  {\n    var side = edge1.Side;\n    edge1.Side = edge2.Side;\n    edge2.Side = side;\n  };\n  ClipperLib.Clipper.SwapPolyIndexes = function (edge1, edge2)\n  {\n    var outIdx = edge1.OutIdx;\n    edge1.OutIdx = edge2.OutIdx;\n    edge2.OutIdx = outIdx;\n  };\n  ClipperLib.Clipper.prototype.IntersectEdges = function (e1, e2, pt)\n  {\n    //e1 will be to the left of e2 BELOW the intersection. Therefore e1 is before\n    //e2 in AEL except when e1 is being inserted at the intersection point ...\n    var e1Contributing = (e1.OutIdx >= 0);\n    var e2Contributing = (e2.OutIdx >= 0);\n\n    if (use_xyz)\n    \tthis.SetZ(pt, e1, e2);\n\n    if (use_lines)\n    {\n      //if either edge is on an OPEN path ...\n      if (e1.WindDelta === 0 || e2.WindDelta === 0)\n      {\n        //ignore subject-subject open path intersections UNLESS they\n        //are both open paths, AND they are both 'contributing maximas' ...\n\t\t\t\tif (e1.WindDelta == 0 && e2.WindDelta == 0) return;\n        //if intersecting a subj line with a subj poly ...\n        else if (e1.PolyTyp == e2.PolyTyp &&\n          e1.WindDelta != e2.WindDelta && this.m_ClipType == ClipperLib.ClipType.ctUnion)\n        {\n          if (e1.WindDelta === 0)\n          {\n            if (e2Contributing)\n            {\n              this.AddOutPt(e1, pt);\n              if (e1Contributing)\n                e1.OutIdx = -1;\n            }\n          }\n          else\n          {\n            if (e1Contributing)\n            {\n              this.AddOutPt(e2, pt);\n              if (e2Contributing)\n                e2.OutIdx = -1;\n            }\n          }\n        }\n        else if (e1.PolyTyp != e2.PolyTyp)\n        {\n          if ((e1.WindDelta === 0) && Math.abs(e2.WindCnt) == 1 &&\n            (this.m_ClipType != ClipperLib.ClipType.ctUnion || e2.WindCnt2 === 0))\n          {\n            this.AddOutPt(e1, pt);\n            if (e1Contributing)\n              e1.OutIdx = -1;\n          }\n          else if ((e2.WindDelta === 0) && (Math.abs(e1.WindCnt) == 1) &&\n            (this.m_ClipType != ClipperLib.ClipType.ctUnion || e1.WindCnt2 === 0))\n          {\n            this.AddOutPt(e2, pt);\n            if (e2Contributing)\n              e2.OutIdx = -1;\n          }\n        }\n        return;\n      }\n    }\n    //update winding counts...\n    //assumes that e1 will be to the Right of e2 ABOVE the intersection\n    if (e1.PolyTyp == e2.PolyTyp)\n    {\n      if (this.IsEvenOddFillType(e1))\n      {\n        var oldE1WindCnt = e1.WindCnt;\n        e1.WindCnt = e2.WindCnt;\n        e2.WindCnt = oldE1WindCnt;\n      }\n      else\n      {\n        if (e1.WindCnt + e2.WindDelta === 0)\n          e1.WindCnt = -e1.WindCnt;\n        else\n          e1.WindCnt += e2.WindDelta;\n        if (e2.WindCnt - e1.WindDelta === 0)\n          e2.WindCnt = -e2.WindCnt;\n        else\n          e2.WindCnt -= e1.WindDelta;\n      }\n    }\n    else\n    {\n      if (!this.IsEvenOddFillType(e2))\n        e1.WindCnt2 += e2.WindDelta;\n      else\n        e1.WindCnt2 = (e1.WindCnt2 === 0) ? 1 : 0;\n      if (!this.IsEvenOddFillType(e1))\n        e2.WindCnt2 -= e1.WindDelta;\n      else\n        e2.WindCnt2 = (e2.WindCnt2 === 0) ? 1 : 0;\n    }\n    var e1FillType, e2FillType, e1FillType2, e2FillType2;\n    if (e1.PolyTyp == ClipperLib.PolyType.ptSubject)\n    {\n      e1FillType = this.m_SubjFillType;\n      e1FillType2 = this.m_ClipFillType;\n    }\n    else\n    {\n      e1FillType = this.m_ClipFillType;\n      e1FillType2 = this.m_SubjFillType;\n    }\n    if (e2.PolyTyp == ClipperLib.PolyType.ptSubject)\n    {\n      e2FillType = this.m_SubjFillType;\n      e2FillType2 = this.m_ClipFillType;\n    }\n    else\n    {\n      e2FillType = this.m_ClipFillType;\n      e2FillType2 = this.m_SubjFillType;\n    }\n    var e1Wc, e2Wc;\n    switch (e1FillType)\n    {\n    case ClipperLib.PolyFillType.pftPositive:\n      e1Wc = e1.WindCnt;\n      break;\n    case ClipperLib.PolyFillType.pftNegative:\n      e1Wc = -e1.WindCnt;\n      break;\n    default:\n      e1Wc = Math.abs(e1.WindCnt);\n      break;\n    }\n    switch (e2FillType)\n    {\n    case ClipperLib.PolyFillType.pftPositive:\n      e2Wc = e2.WindCnt;\n      break;\n    case ClipperLib.PolyFillType.pftNegative:\n      e2Wc = -e2.WindCnt;\n      break;\n    default:\n      e2Wc = Math.abs(e2.WindCnt);\n      break;\n    }\n    if (e1Contributing && e2Contributing)\n    {\n\t\t\tif ((e1Wc != 0 && e1Wc != 1) || (e2Wc != 0 && e2Wc != 1) ||\n\t\t\t(e1.PolyTyp != e2.PolyTyp && this.m_ClipType != ClipperLib.ClipType.ctXor))\n\t\t\t{\n\t\t\t\tthis.AddLocalMaxPoly(e1, e2, pt);\n\t\t\t}\n      else\n      {\n        this.AddOutPt(e1, pt);\n        this.AddOutPt(e2, pt);\n        ClipperLib.Clipper.SwapSides(e1, e2);\n        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n      }\n    }\n    else if (e1Contributing)\n    {\n      if (e2Wc === 0 || e2Wc == 1)\n      {\n        this.AddOutPt(e1, pt);\n        ClipperLib.Clipper.SwapSides(e1, e2);\n        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n      }\n    }\n    else if (e2Contributing)\n    {\n      if (e1Wc === 0 || e1Wc == 1)\n      {\n        this.AddOutPt(e2, pt);\n        ClipperLib.Clipper.SwapSides(e1, e2);\n        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n      }\n    }\n\t\telse if ( (e1Wc == 0 || e1Wc == 1) && (e2Wc == 0 || e2Wc == 1))\n    {\n      //neither edge is currently contributing ...\n      var e1Wc2, e2Wc2;\n      switch (e1FillType2)\n      {\n      case ClipperLib.PolyFillType.pftPositive:\n        e1Wc2 = e1.WindCnt2;\n        break;\n      case ClipperLib.PolyFillType.pftNegative:\n        e1Wc2 = -e1.WindCnt2;\n        break;\n      default:\n        e1Wc2 = Math.abs(e1.WindCnt2);\n        break;\n      }\n      switch (e2FillType2)\n      {\n      case ClipperLib.PolyFillType.pftPositive:\n        e2Wc2 = e2.WindCnt2;\n        break;\n      case ClipperLib.PolyFillType.pftNegative:\n        e2Wc2 = -e2.WindCnt2;\n        break;\n      default:\n        e2Wc2 = Math.abs(e2.WindCnt2);\n        break;\n      }\n      if (e1.PolyTyp != e2.PolyTyp)\n      {\n        this.AddLocalMinPoly(e1, e2, pt);\n      }\n      else if (e1Wc == 1 && e2Wc == 1)\n        switch (this.m_ClipType)\n        {\n        case ClipperLib.ClipType.ctIntersection:\n          if (e1Wc2 > 0 && e2Wc2 > 0)\n            this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        case ClipperLib.ClipType.ctUnion:\n          if (e1Wc2 <= 0 && e2Wc2 <= 0)\n            this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        case ClipperLib.ClipType.ctDifference:\n          if (((e1.PolyTyp == ClipperLib.PolyType.ptClip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||\n            ((e1.PolyTyp == ClipperLib.PolyType.ptSubject) && (e1Wc2 <= 0) && (e2Wc2 <= 0)))\n            this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        case ClipperLib.ClipType.ctXor:\n          this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        }\n      else\n        ClipperLib.Clipper.SwapSides(e1, e2);\n    }\n  };\n  ClipperLib.Clipper.prototype.DeleteFromAEL = function (e)\n  {\n    var AelPrev = e.PrevInAEL;\n    var AelNext = e.NextInAEL;\n    if (AelPrev === null && AelNext === null && (e != this.m_ActiveEdges))\n      return;\n    //already deleted\n    if (AelPrev !== null)\n      AelPrev.NextInAEL = AelNext;\n    else\n      this.m_ActiveEdges = AelNext;\n    if (AelNext !== null)\n      AelNext.PrevInAEL = AelPrev;\n    e.NextInAEL = null;\n    e.PrevInAEL = null;\n  };\n  ClipperLib.Clipper.prototype.DeleteFromSEL = function (e)\n  {\n    var SelPrev = e.PrevInSEL;\n    var SelNext = e.NextInSEL;\n    if (SelPrev === null && SelNext === null && (e != this.m_SortedEdges))\n      return;\n    //already deleted\n    if (SelPrev !== null)\n      SelPrev.NextInSEL = SelNext;\n    else\n      this.m_SortedEdges = SelNext;\n    if (SelNext !== null)\n      SelNext.PrevInSEL = SelPrev;\n    e.NextInSEL = null;\n    e.PrevInSEL = null;\n  };\n  ClipperLib.Clipper.prototype.UpdateEdgeIntoAEL = function (e)\n  {\n    if (e.NextInLML === null)\n      ClipperLib.Error(\"UpdateEdgeIntoAEL: invalid call\");\n    var AelPrev = e.PrevInAEL;\n    var AelNext = e.NextInAEL;\n    e.NextInLML.OutIdx = e.OutIdx;\n    if (AelPrev !== null)\n      AelPrev.NextInAEL = e.NextInLML;\n    else\n      this.m_ActiveEdges = e.NextInLML;\n    if (AelNext !== null)\n      AelNext.PrevInAEL = e.NextInLML;\n    e.NextInLML.Side = e.Side;\n    e.NextInLML.WindDelta = e.WindDelta;\n    e.NextInLML.WindCnt = e.WindCnt;\n    e.NextInLML.WindCnt2 = e.WindCnt2;\n    e = e.NextInLML;\n    //    e.Curr = e.Bot;\n    e.Curr.X = e.Bot.X;\n    e.Curr.Y = e.Bot.Y;\n    e.PrevInAEL = AelPrev;\n    e.NextInAEL = AelNext;\n    if (!ClipperLib.ClipperBase.IsHorizontal(e))\n      this.InsertScanbeam(e.Top.Y);\n    return e;\n  };\n  ClipperLib.Clipper.prototype.ProcessHorizontals = function (isTopOfScanbeam)\n  {\n    var horzEdge = this.m_SortedEdges;\n    while (horzEdge !== null)\n    {\n      this.DeleteFromSEL(horzEdge);\n      this.ProcessHorizontal(horzEdge, isTopOfScanbeam);\n      horzEdge = this.m_SortedEdges;\n    }\n  };\n  ClipperLib.Clipper.prototype.GetHorzDirection = function (HorzEdge, $var)\n  {\n    if (HorzEdge.Bot.X < HorzEdge.Top.X)\n    {\n        $var.Left = HorzEdge.Bot.X;\n        $var.Right = HorzEdge.Top.X;\n        $var.Dir = ClipperLib.Direction.dLeftToRight;\n    }\n    else\n    {\n        $var.Left = HorzEdge.Top.X;\n        $var.Right = HorzEdge.Bot.X;\n        $var.Dir = ClipperLib.Direction.dRightToLeft;\n    }\n  };\n  ClipperLib.Clipper.prototype.ProcessHorizontal = function (horzEdge, isTopOfScanbeam)\n  {\n    var $var = {Dir: null, Left: null, Right: null};\n    this.GetHorzDirection(horzEdge, $var);\n    var dir = $var.Dir;\n    var horzLeft = $var.Left;\n    var horzRight = $var.Right;\n\n    var eLastHorz = horzEdge,\n      eMaxPair = null;\n    while (eLastHorz.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(eLastHorz.NextInLML))\n      eLastHorz = eLastHorz.NextInLML;\n    if (eLastHorz.NextInLML === null)\n      eMaxPair = this.GetMaximaPair(eLastHorz);\n    for (;;)\n    {\n      var IsLastHorz = (horzEdge == eLastHorz);\n      var e = this.GetNextInAEL(horzEdge, dir);\n      while (e !== null)\n      {\n        //Break if we've got to the end of an intermediate horizontal edge ...\n        //nb: Smaller Dx's are to the right of larger Dx's ABOVE the horizontal.\n        if (e.Curr.X == horzEdge.Top.X && horzEdge.NextInLML !== null && e.Dx < horzEdge.NextInLML.Dx)\n          break;\n        var eNext = this.GetNextInAEL(e, dir);\n        //saves eNext for later\n        if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X <= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X >= horzLeft))\n        {\n          //so far we're still in range of the horizontal Edge  but make sure\n          //we're at the last of consec. horizontals when matching with eMaxPair\n          if (e == eMaxPair && IsLastHorz)\n          {\n\t\t\t\t\t\tif (horzEdge.OutIdx >= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\t\t\t\t\t\t\tvar eNextHorz = this.m_SortedEdges;\n\t\t\t\t\t\t\twhile (eNextHorz !== null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (eNextHorz.OutIdx >= 0 &&\n\t\t\t\t\t\t\t\t\tthis.HorzSegmentsOverlap(horzEdge.Bot.X,\n\t\t\t\t\t\t\t\t\thorzEdge.Top.X, eNextHorz.Bot.X, eNextHorz.Top.X))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tvar op2 = this.AddOutPt(eNextHorz, eNextHorz.Bot);\n\t\t\t\t\t\t\t\t\tthis.AddJoin(op2, op1, eNextHorz.Top);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\teNextHorz = eNextHorz.NextInSEL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.AddGhostJoin(op1, horzEdge.Bot);\n\t\t\t\t\t\t\tthis.AddLocalMaxPoly(horzEdge, eMaxPair, horzEdge.Top);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.DeleteFromAEL(horzEdge);\n\t\t\t\t\t\tthis.DeleteFromAEL(eMaxPair);\n            return;\n          }\n          else if (dir == ClipperLib.Direction.dLeftToRight)\n          {\n            var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n            this.IntersectEdges(horzEdge, e, Pt);\n          }\n          else\n          {\n            var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n            this.IntersectEdges(e, horzEdge, Pt);\n          }\n          this.SwapPositionsInAEL(horzEdge, e);\n        }\n        else if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X >= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X <= horzLeft))\n          break;\n        e = eNext;\n      }\n      //end while\n      if (horzEdge.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(horzEdge.NextInLML))\n      {\n        horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n        if (horzEdge.OutIdx >= 0)\n          this.AddOutPt(horzEdge, horzEdge.Bot);\n\n          var $var = {Dir: dir, Left: horzLeft, Right: horzRight};\n          this.GetHorzDirection(horzEdge, $var);\n          dir = $var.Dir;\n          horzLeft = $var.Left;\n          horzRight = $var.Right;\n      }\n      else\n        break;\n    }\n    //end for (;;)\n    if (horzEdge.NextInLML !== null)\n    {\n      if (horzEdge.OutIdx >= 0)\n      {\n        var op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\t\t\t\tif (isTopOfScanbeam) this.AddGhostJoin(op1, horzEdge.Bot);\n        horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n        if (horzEdge.WindDelta === 0)\n          return;\n        //nb: HorzEdge is no longer horizontal here\n        var ePrev = horzEdge.PrevInAEL;\n        var eNext = horzEdge.NextInAEL;\n        if (ePrev !== null && ePrev.Curr.X == horzEdge.Bot.X &&\n          ePrev.Curr.Y == horzEdge.Bot.Y && ePrev.WindDelta !== 0 &&\n          (ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&\n            ClipperLib.ClipperBase.SlopesEqual(horzEdge, ePrev, this.m_UseFullRange)))\n        {\n          var op2 = this.AddOutPt(ePrev, horzEdge.Bot);\n          this.AddJoin(op1, op2, horzEdge.Top);\n        }\n        else if (eNext !== null && eNext.Curr.X == horzEdge.Bot.X &&\n          eNext.Curr.Y == horzEdge.Bot.Y && eNext.WindDelta !== 0 &&\n          eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&\n          ClipperLib.ClipperBase.SlopesEqual(horzEdge, eNext, this.m_UseFullRange))\n        {\n          var op2 = this.AddOutPt(eNext, horzEdge.Bot);\n          this.AddJoin(op1, op2, horzEdge.Top);\n        }\n      }\n      else horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n    }\n  \telse\n    {\n      if (horzEdge.OutIdx >= 0)\n        this.AddOutPt(horzEdge, horzEdge.Top);\n      this.DeleteFromAEL(horzEdge);\n    }\n  };\n  ClipperLib.Clipper.prototype.GetNextInAEL = function (e, Direction)\n  {\n    return Direction == ClipperLib.Direction.dLeftToRight ? e.NextInAEL : e.PrevInAEL;\n  };\n  ClipperLib.Clipper.prototype.IsMinima = function (e)\n  {\n    return e !== null && (e.Prev.NextInLML != e) && (e.Next.NextInLML != e);\n  };\n  ClipperLib.Clipper.prototype.IsMaxima = function (e, Y)\n  {\n    return (e !== null && e.Top.Y == Y && e.NextInLML === null);\n  };\n  ClipperLib.Clipper.prototype.IsIntermediate = function (e, Y)\n  {\n    return (e.Top.Y == Y && e.NextInLML !== null);\n  };\n  ClipperLib.Clipper.prototype.GetMaximaPair = function (e)\n  {\n    var result = null;\n    if ((ClipperLib.IntPoint.op_Equality(e.Next.Top, e.Top)) && e.Next.NextInLML === null)\n      result = e.Next;\n    else if ((ClipperLib.IntPoint.op_Equality(e.Prev.Top, e.Top)) && e.Prev.NextInLML === null)\n      result = e.Prev;\n    if (result !== null && (result.OutIdx == -2 || (result.NextInAEL == result.PrevInAEL && !ClipperLib.ClipperBase.IsHorizontal(result))))\n      return null;\n    return result;\n  };\n\n  ClipperLib.Clipper.prototype.ProcessIntersections = function (topY)\n  {\n    if (this.m_ActiveEdges == null)\n      return true;\n    try\n    {\n      this.BuildIntersectList(topY);\n      if (this.m_IntersectList.length == 0)\n        return true;\n      if (this.m_IntersectList.length == 1 || this.FixupIntersectionOrder())\n        this.ProcessIntersectList();\n      else\n        return false;\n    }\n    catch ($$e2)\n    {\n      this.m_SortedEdges = null;\n      this.m_IntersectList.length = 0;\n      ClipperLib.Error(\"ProcessIntersections error\");\n    }\n    this.m_SortedEdges = null;\n    return true;\n  };\n  ClipperLib.Clipper.prototype.BuildIntersectList = function (topY)\n  {\n    if (this.m_ActiveEdges === null)\n      return;\n    //prepare for sorting ...\n    var e = this.m_ActiveEdges;\n    //console.log(JSON.stringify(JSON.decycle( e )));\n    this.m_SortedEdges = e;\n    while (e !== null)\n    {\n      e.PrevInSEL = e.PrevInAEL;\n      e.NextInSEL = e.NextInAEL;\n      e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n      e = e.NextInAEL;\n    }\n    //bubblesort ...\n    var isModified = true;\n    while (isModified && this.m_SortedEdges !== null)\n    {\n      isModified = false;\n      e = this.m_SortedEdges;\n      while (e.NextInSEL !== null)\n      {\n        var eNext = e.NextInSEL;\n        var pt = new ClipperLib.IntPoint();\n        //console.log(\"e.Curr.X: \" + e.Curr.X + \" eNext.Curr.X\" + eNext.Curr.X);\n        if (e.Curr.X > eNext.Curr.X)\n        {\n\t\t\t\t\tthis.IntersectPoint(e, eNext, pt);\n          var newNode = new ClipperLib.IntersectNode();\n          newNode.Edge1 = e;\n          newNode.Edge2 = eNext;\n          //newNode.Pt = pt;\n          newNode.Pt.X = pt.X;\n          newNode.Pt.Y = pt.Y;\n          this.m_IntersectList.push(newNode);\n          this.SwapPositionsInSEL(e, eNext);\n          isModified = true;\n        }\n        else\n          e = eNext;\n      }\n      if (e.PrevInSEL !== null)\n        e.PrevInSEL.NextInSEL = null;\n      else\n        break;\n    }\n    this.m_SortedEdges = null;\n  };\n  ClipperLib.Clipper.prototype.EdgesAdjacent = function (inode)\n  {\n    return (inode.Edge1.NextInSEL == inode.Edge2) || (inode.Edge1.PrevInSEL == inode.Edge2);\n  };\n  ClipperLib.Clipper.IntersectNodeSort = function (node1, node2)\n  {\n    //the following typecast is safe because the differences in Pt.Y will\n    //be limited to the height of the scanbeam.\n    return (node2.Pt.Y - node1.Pt.Y);\n  };\n  ClipperLib.Clipper.prototype.FixupIntersectionOrder = function ()\n  {\n    //pre-condition: intersections are sorted bottom-most first.\n    //Now it's crucial that intersections are made only between adjacent edges,\n    //so to ensure this the order of intersections may need adjusting ...\n    this.m_IntersectList.sort(this.m_IntersectNodeComparer);\n    this.CopyAELToSEL();\n    var cnt = this.m_IntersectList.length;\n    for (var i = 0; i < cnt; i++)\n    {\n      if (!this.EdgesAdjacent(this.m_IntersectList[i]))\n      {\n        var j = i + 1;\n        while (j < cnt && !this.EdgesAdjacent(this.m_IntersectList[j]))\n          j++;\n        if (j == cnt)\n          return false;\n        var tmp = this.m_IntersectList[i];\n        this.m_IntersectList[i] = this.m_IntersectList[j];\n        this.m_IntersectList[j] = tmp;\n      }\n      this.SwapPositionsInSEL(this.m_IntersectList[i].Edge1, this.m_IntersectList[i].Edge2);\n    }\n    return true;\n  };\n  ClipperLib.Clipper.prototype.ProcessIntersectList = function ()\n  {\n    for (var i = 0, ilen = this.m_IntersectList.length; i < ilen; i++)\n    {\n      var iNode = this.m_IntersectList[i];\n      this.IntersectEdges(iNode.Edge1, iNode.Edge2, iNode.Pt);\n      this.SwapPositionsInAEL(iNode.Edge1, iNode.Edge2);\n    }\n    this.m_IntersectList.length = 0;\n  };\n  /*\n  --------------------------------\n  Round speedtest: http://jsperf.com/fastest-round\n  --------------------------------\n  */\n  var R1 = function (a)\n  {\n    return a < 0 ? Math.ceil(a - 0.5) : Math.round(a)\n  };\n  var R2 = function (a)\n  {\n    return a < 0 ? Math.ceil(a - 0.5) : Math.floor(a + 0.5)\n  };\n  var R3 = function (a)\n  {\n    return a < 0 ? -Math.round(Math.abs(a)) : Math.round(a)\n  };\n  var R4 = function (a)\n  {\n    if (a < 0)\n    {\n      a -= 0.5;\n      return a < -2147483648 ? Math.ceil(a) : a | 0;\n    }\n    else\n    {\n      a += 0.5;\n      return a > 2147483647 ? Math.floor(a) : a | 0;\n    }\n  };\n  if (browser.msie) ClipperLib.Clipper.Round = R1;\n  else if (browser.chromium) ClipperLib.Clipper.Round = R3;\n  else if (browser.safari) ClipperLib.Clipper.Round = R4;\n  else ClipperLib.Clipper.Round = R2; // eg. browser.chrome || browser.firefox || browser.opera\n  ClipperLib.Clipper.TopX = function (edge, currentY)\n  {\n    //if (edge.Bot == edge.Curr) alert (\"edge.Bot = edge.Curr\");\n    //if (edge.Bot == edge.Top) alert (\"edge.Bot = edge.Top\");\n    if (currentY == edge.Top.Y)\n      return edge.Top.X;\n    return edge.Bot.X + ClipperLib.Clipper.Round(edge.Dx * (currentY - edge.Bot.Y));\n  };\n  ClipperLib.Clipper.prototype.IntersectPoint = function (edge1, edge2, ip)\n  {\n    ip.X = 0;\n    ip.Y = 0;\n    var b1, b2;\n    //nb: with very large coordinate values, it's possible for SlopesEqual() to\n    //return false but for the edge.Dx value be equal due to double precision rounding.\n    if (edge1.Dx == edge2.Dx)\n\t\t{\n\t\t\tip.Y = edge1.Curr.Y;\n\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t\treturn;\n    }\n    if (edge1.Delta.X === 0)\n    {\n      ip.X = edge1.Bot.X;\n      if (ClipperLib.ClipperBase.IsHorizontal(edge2))\n      {\n        ip.Y = edge2.Bot.Y;\n      }\n      else\n      {\n        b2 = edge2.Bot.Y - (edge2.Bot.X / edge2.Dx);\n        ip.Y = ClipperLib.Clipper.Round(ip.X / edge2.Dx + b2);\n      }\n    }\n    else if (edge2.Delta.X === 0)\n    {\n      ip.X = edge2.Bot.X;\n      if (ClipperLib.ClipperBase.IsHorizontal(edge1))\n      {\n        ip.Y = edge1.Bot.Y;\n      }\n      else\n      {\n        b1 = edge1.Bot.Y - (edge1.Bot.X / edge1.Dx);\n        ip.Y = ClipperLib.Clipper.Round(ip.X / edge1.Dx + b1);\n      }\n    }\n    else\n    {\n      b1 = edge1.Bot.X - edge1.Bot.Y * edge1.Dx;\n      b2 = edge2.Bot.X - edge2.Bot.Y * edge2.Dx;\n      var q = (b2 - b1) / (edge1.Dx - edge2.Dx);\n      ip.Y = ClipperLib.Clipper.Round(q);\n      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n        ip.X = ClipperLib.Clipper.Round(edge1.Dx * q + b1);\n      else\n        ip.X = ClipperLib.Clipper.Round(edge2.Dx * q + b2);\n    }\n    if (ip.Y < edge1.Top.Y || ip.Y < edge2.Top.Y)\n    {\n      if (edge1.Top.Y > edge2.Top.Y)\n      {\n        ip.Y = edge1.Top.Y;\n        ip.X = ClipperLib.Clipper.TopX(edge2, edge1.Top.Y);\n        return ip.X < edge1.Top.X;\n      }\n      else\n        ip.Y = edge2.Top.Y;\n      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n        ip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n      else\n        ip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n    }\n\t\t//finally, don't allow 'ip' to be BELOW curr.Y (ie bottom of scanbeam) ...\n\t\tif (ip.Y > edge1.Curr.Y)\n\t\t{\n\t\t\tip.Y = edge1.Curr.Y;\n\t\t\t//better to use the more vertical edge to derive X ...\n\t\t\tif (Math.abs(edge1.Dx) > Math.abs(edge2.Dx))\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n\t\t\telse\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t}\n  };\n\n  ClipperLib.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function (topY)\n  {\n    var e = this.m_ActiveEdges;\n    while (e !== null)\n    {\n      //1. process maxima, treating them as if they're 'bent' horizontal edges,\n      //   but exclude maxima with horizontal edges. nb: e can't be a horizontal.\n      var IsMaximaEdge = this.IsMaxima(e, topY);\n      if (IsMaximaEdge)\n      {\n        var eMaxPair = this.GetMaximaPair(e);\n        IsMaximaEdge = (eMaxPair === null || !ClipperLib.ClipperBase.IsHorizontal(eMaxPair));\n      }\n      if (IsMaximaEdge)\n      {\n        var ePrev = e.PrevInAEL;\n        this.DoMaxima(e);\n        if (ePrev === null)\n          e = this.m_ActiveEdges;\n        else\n          e = ePrev.NextInAEL;\n      }\n      else\n      {\n        //2. promote horizontal edges, otherwise update Curr.X and Curr.Y ...\n        if (this.IsIntermediate(e, topY) && ClipperLib.ClipperBase.IsHorizontal(e.NextInLML))\n        {\n          e = this.UpdateEdgeIntoAEL(e);\n          if (e.OutIdx >= 0)\n            this.AddOutPt(e, e.Bot);\n          this.AddEdgeToSEL(e);\n        }\n        else\n        {\n          e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n          e.Curr.Y = topY;\n        }\n        if (this.StrictlySimple)\n        {\n          var ePrev = e.PrevInAEL;\n          if ((e.OutIdx >= 0) && (e.WindDelta !== 0) && ePrev !== null &&\n            (ePrev.OutIdx >= 0) && (ePrev.Curr.X == e.Curr.X) &&\n            (ePrev.WindDelta !== 0))\n          {\n           \tvar ip = new ClipperLib.IntPoint(e.Curr);\n\n\t\t\t\t\t\tif(use_xyz)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.SetZ(ip, ePrev, e);\n\t\t\t\t\t\t}\n\n            var op = this.AddOutPt(ePrev, ip);\n            var op2 = this.AddOutPt(e, ip);\n            this.AddJoin(op, op2, ip);\n            //StrictlySimple (type-3) join\n          }\n        }\n        e = e.NextInAEL;\n      }\n    }\n    //3. Process horizontals at the Top of the scanbeam ...\n    this.ProcessHorizontals(true);\n    //4. Promote intermediate vertices ...\n    e = this.m_ActiveEdges;\n    while (e !== null)\n    {\n      if (this.IsIntermediate(e, topY))\n      {\n        var op = null;\n        if (e.OutIdx >= 0)\n          op = this.AddOutPt(e, e.Top);\n        e = this.UpdateEdgeIntoAEL(e);\n        //if output polygons share an edge, they'll need joining later ...\n        var ePrev = e.PrevInAEL;\n        var eNext = e.NextInAEL;\n        if (ePrev !== null && ePrev.Curr.X == e.Bot.X &&\n          ePrev.Curr.Y == e.Bot.Y && op !== null &&\n          ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&\n          ClipperLib.ClipperBase.SlopesEqual(e, ePrev, this.m_UseFullRange) &&\n          (e.WindDelta !== 0) && (ePrev.WindDelta !== 0))\n        {\n          var op2 = this.AddOutPt(ePrev, e.Bot);\n          this.AddJoin(op, op2, e.Top);\n        }\n        else if (eNext !== null && eNext.Curr.X == e.Bot.X &&\n          eNext.Curr.Y == e.Bot.Y && op !== null &&\n          eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&\n          ClipperLib.ClipperBase.SlopesEqual(e, eNext, this.m_UseFullRange) &&\n          (e.WindDelta !== 0) && (eNext.WindDelta !== 0))\n        {\n          var op2 = this.AddOutPt(eNext, e.Bot);\n          this.AddJoin(op, op2, e.Top);\n        }\n      }\n      e = e.NextInAEL;\n    }\n  };\n  ClipperLib.Clipper.prototype.DoMaxima = function (e)\n  {\n    var eMaxPair = this.GetMaximaPair(e);\n    if (eMaxPair === null)\n    {\n      if (e.OutIdx >= 0)\n        this.AddOutPt(e, e.Top);\n      this.DeleteFromAEL(e);\n      return;\n    }\n    var eNext = e.NextInAEL;\n    var use_lines = true;\n    while (eNext !== null && eNext != eMaxPair)\n    {\n      this.IntersectEdges(e, eNext, e.Top);\n      this.SwapPositionsInAEL(e, eNext);\n      eNext = e.NextInAEL;\n    }\n    if (e.OutIdx == -1 && eMaxPair.OutIdx == -1)\n    {\n      this.DeleteFromAEL(e);\n      this.DeleteFromAEL(eMaxPair);\n    }\n    else if (e.OutIdx >= 0 && eMaxPair.OutIdx >= 0)\n    {\n    \tif (e.OutIdx >= 0) this.AddLocalMaxPoly(e, eMaxPair, e.Top);\n      this.DeleteFromAEL(e);\n      this.DeleteFromAEL(eMaxPair);\n    }\n    else if (use_lines && e.WindDelta === 0)\n    {\n      if (e.OutIdx >= 0)\n      {\n        this.AddOutPt(e, e.Top);\n        e.OutIdx = -1;\n      }\n      this.DeleteFromAEL(e);\n      if (eMaxPair.OutIdx >= 0)\n      {\n        this.AddOutPt(eMaxPair, e.Top);\n        eMaxPair.OutIdx = -1;\n      }\n      this.DeleteFromAEL(eMaxPair);\n    }\n    else\n      ClipperLib.Error(\"DoMaxima error\");\n  };\n  ClipperLib.Clipper.ReversePaths = function (polys)\n  {\n    for (var i = 0, len = polys.length; i < len; i++)\n      polys[i].reverse();\n  };\n  ClipperLib.Clipper.Orientation = function (poly)\n  {\n    return ClipperLib.Clipper.Area(poly) >= 0;\n  };\n  ClipperLib.Clipper.prototype.PointCount = function (pts)\n  {\n    if (pts === null)\n      return 0;\n    var result = 0;\n    var p = pts;\n    do {\n      result++;\n      p = p.Next;\n    }\n    while (p != pts)\n    return result;\n  };\n  ClipperLib.Clipper.prototype.BuildResult = function (polyg)\n  {\n    ClipperLib.Clear(polyg);\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n      var outRec = this.m_PolyOuts[i];\n      if (outRec.Pts === null)\n        continue;\n      var p = outRec.Pts.Prev;\n      var cnt = this.PointCount(p);\n      if (cnt < 2)\n        continue;\n      var pg = new Array(cnt);\n      for (var j = 0; j < cnt; j++)\n      {\n        pg[j] = p.Pt;\n        p = p.Prev;\n      }\n      polyg.push(pg);\n    }\n  };\n  ClipperLib.Clipper.prototype.BuildResult2 = function (polytree)\n  {\n    polytree.Clear();\n    //add each output polygon/contour to polytree ...\n    //polytree.m_AllPolys.set_Capacity(this.m_PolyOuts.length);\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n      var outRec = this.m_PolyOuts[i];\n      var cnt = this.PointCount(outRec.Pts);\n      if ((outRec.IsOpen && cnt < 2) || (!outRec.IsOpen && cnt < 3))\n        continue;\n      this.FixHoleLinkage(outRec);\n      var pn = new ClipperLib.PolyNode();\n      polytree.m_AllPolys.push(pn);\n      outRec.PolyNode = pn;\n      pn.m_polygon.length = cnt;\n      var op = outRec.Pts.Prev;\n      for (var j = 0; j < cnt; j++)\n      {\n        pn.m_polygon[j] = op.Pt;\n        op = op.Prev;\n      }\n    }\n    //fixup PolyNode links etc ...\n    //polytree.m_Childs.set_Capacity(this.m_PolyOuts.length);\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n      var outRec = this.m_PolyOuts[i];\n      if (outRec.PolyNode === null)\n        continue;\n      else if (outRec.IsOpen)\n      {\n        outRec.PolyNode.IsOpen = true;\n        polytree.AddChild(outRec.PolyNode);\n      }\n      else if (outRec.FirstLeft !== null && outRec.FirstLeft.PolyNode != null)\n        outRec.FirstLeft.PolyNode.AddChild(outRec.PolyNode);\n      else\n        polytree.AddChild(outRec.PolyNode);\n    }\n  };\n  ClipperLib.Clipper.prototype.FixupOutPolygon = function (outRec)\n  {\n    //FixupOutPolygon() - removes duplicate points and simplifies consecutive\n    //parallel edges by removing the middle vertex.\n    var lastOK = null;\n    outRec.BottomPt = null;\n    var pp = outRec.Pts;\n    for (;;)\n    {\n      if (pp.Prev == pp || pp.Prev == pp.Next)\n      {\n        outRec.Pts = null;\n        return;\n      }\n      //test for duplicate points and collinear edges ...\n      if ((ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Next.Pt)) || (ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Prev.Pt)) ||\n        (ClipperLib.ClipperBase.SlopesEqual(pp.Prev.Pt, pp.Pt, pp.Next.Pt, this.m_UseFullRange) &&\n          (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(pp.Prev.Pt, pp.Pt, pp.Next.Pt))))\n      {\n        lastOK = null;\n        pp.Prev.Next = pp.Next;\n        pp.Next.Prev = pp.Prev;\n        pp = pp.Prev;\n      }\n      else if (pp == lastOK)\n        break;\n      else\n      {\n        if (lastOK === null)\n          lastOK = pp;\n        pp = pp.Next;\n      }\n    }\n    outRec.Pts = pp;\n  };\n  ClipperLib.Clipper.prototype.DupOutPt = function (outPt, InsertAfter)\n  {\n    var result = new ClipperLib.OutPt();\n    //result.Pt = outPt.Pt;\n    result.Pt.X = outPt.Pt.X;\n    result.Pt.Y = outPt.Pt.Y;\n    result.Idx = outPt.Idx;\n    if (InsertAfter)\n    {\n      result.Next = outPt.Next;\n      result.Prev = outPt;\n      outPt.Next.Prev = result;\n      outPt.Next = result;\n    }\n    else\n    {\n      result.Prev = outPt.Prev;\n      result.Next = outPt;\n      outPt.Prev.Next = result;\n      outPt.Prev = result;\n    }\n    return result;\n  };\n  ClipperLib.Clipper.prototype.GetOverlap = function (a1, a2, b1, b2, $val)\n  {\n    if (a1 < a2)\n    {\n      if (b1 < b2)\n      {\n        $val.Left = Math.max(a1, b1);\n        $val.Right = Math.min(a2, b2);\n      }\n      else\n      {\n        $val.Left = Math.max(a1, b2);\n        $val.Right = Math.min(a2, b1);\n      }\n    }\n    else\n    {\n      if (b1 < b2)\n      {\n        $val.Left = Math.max(a2, b1);\n        $val.Right = Math.min(a1, b2);\n      }\n      else\n      {\n        $val.Left = Math.max(a2, b2);\n        $val.Right = Math.min(a1, b1);\n      }\n    }\n    return $val.Left < $val.Right;\n  };\n  ClipperLib.Clipper.prototype.JoinHorz = function (op1, op1b, op2, op2b, Pt, DiscardLeft)\n  {\n    var Dir1 = (op1.Pt.X > op1b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n    var Dir2 = (op2.Pt.X > op2b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n    if (Dir1 == Dir2)\n      return false;\n    //When DiscardLeft, we want Op1b to be on the Left of Op1, otherwise we\n    //want Op1b to be on the Right. (And likewise with Op2 and Op2b.)\n    //So, to facilitate this while inserting Op1b and Op2b ...\n    //when DiscardLeft, make sure we're AT or RIGHT of Pt before adding Op1b,\n    //otherwise make sure we're AT or LEFT of Pt. (Likewise with Op2b.)\n    if (Dir1 == ClipperLib.Direction.dLeftToRight)\n    {\n      while (op1.Next.Pt.X <= Pt.X &&\n        op1.Next.Pt.X >= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)\n        op1 = op1.Next;\n      if (DiscardLeft && (op1.Pt.X != Pt.X))\n        op1 = op1.Next;\n      op1b = this.DupOutPt(op1, !DiscardLeft);\n      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n      {\n        op1 = op1b;\n        //op1.Pt = Pt;\n        op1.Pt.X = Pt.X;\n        op1.Pt.Y = Pt.Y;\n        op1b = this.DupOutPt(op1, !DiscardLeft);\n      }\n    }\n    else\n    {\n      while (op1.Next.Pt.X >= Pt.X &&\n        op1.Next.Pt.X <= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)\n        op1 = op1.Next;\n      if (!DiscardLeft && (op1.Pt.X != Pt.X))\n        op1 = op1.Next;\n      op1b = this.DupOutPt(op1, DiscardLeft);\n      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n      {\n        op1 = op1b;\n        //op1.Pt = Pt;\n        op1.Pt.X = Pt.X;\n        op1.Pt.Y = Pt.Y;\n        op1b = this.DupOutPt(op1, DiscardLeft);\n      }\n    }\n    if (Dir2 == ClipperLib.Direction.dLeftToRight)\n    {\n      while (op2.Next.Pt.X <= Pt.X &&\n        op2.Next.Pt.X >= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)\n        op2 = op2.Next;\n      if (DiscardLeft && (op2.Pt.X != Pt.X))\n        op2 = op2.Next;\n      op2b = this.DupOutPt(op2, !DiscardLeft);\n      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n      {\n        op2 = op2b;\n        //op2.Pt = Pt;\n        op2.Pt.X = Pt.X;\n        op2.Pt.Y = Pt.Y;\n        op2b = this.DupOutPt(op2, !DiscardLeft);\n      }\n    }\n    else\n    {\n      while (op2.Next.Pt.X >= Pt.X &&\n        op2.Next.Pt.X <= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)\n        op2 = op2.Next;\n      if (!DiscardLeft && (op2.Pt.X != Pt.X))\n        op2 = op2.Next;\n      op2b = this.DupOutPt(op2, DiscardLeft);\n      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n      {\n        op2 = op2b;\n        //op2.Pt = Pt;\n        op2.Pt.X = Pt.X;\n        op2.Pt.Y = Pt.Y;\n        op2b = this.DupOutPt(op2, DiscardLeft);\n      }\n    }\n    if ((Dir1 == ClipperLib.Direction.dLeftToRight) == DiscardLeft)\n    {\n      op1.Prev = op2;\n      op2.Next = op1;\n      op1b.Next = op2b;\n      op2b.Prev = op1b;\n    }\n    else\n    {\n      op1.Next = op2;\n      op2.Prev = op1;\n      op1b.Prev = op2b;\n      op2b.Next = op1b;\n    }\n    return true;\n  };\n  ClipperLib.Clipper.prototype.JoinPoints = function (j, outRec1, outRec2)\n  {\n    var op1 = j.OutPt1,\n      op1b = new ClipperLib.OutPt();\n    var op2 = j.OutPt2,\n      op2b = new ClipperLib.OutPt();\n    //There are 3 kinds of joins for output polygons ...\n    //1. Horizontal joins where Join.OutPt1 & Join.OutPt2 are a vertices anywhere\n    //along (horizontal) collinear edges (& Join.OffPt is on the same horizontal).\n    //2. Non-horizontal joins where Join.OutPt1 & Join.OutPt2 are at the same\n    //location at the Bottom of the overlapping segment (& Join.OffPt is above).\n    //3. StrictlySimple joins where edges touch but are not collinear and where\n    //Join.OutPt1, Join.OutPt2 & Join.OffPt all share the same point.\n    var isHorizontal = (j.OutPt1.Pt.Y == j.OffPt.Y);\n    if (isHorizontal && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt1.Pt)) && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt2.Pt)))\n    {\n      //Strictly Simple join ...\n\t\t\tif (outRec1 != outRec2) return false;\n\n      op1b = j.OutPt1.Next;\n      while (op1b != op1 && (ClipperLib.IntPoint.op_Equality(op1b.Pt, j.OffPt)))\n        op1b = op1b.Next;\n      var reverse1 = (op1b.Pt.Y > j.OffPt.Y);\n      op2b = j.OutPt2.Next;\n      while (op2b != op2 && (ClipperLib.IntPoint.op_Equality(op2b.Pt, j.OffPt)))\n        op2b = op2b.Next;\n      var reverse2 = (op2b.Pt.Y > j.OffPt.Y);\n      if (reverse1 == reverse2)\n        return false;\n      if (reverse1)\n      {\n        op1b = this.DupOutPt(op1, false);\n        op2b = this.DupOutPt(op2, true);\n        op1.Prev = op2;\n        op2.Next = op1;\n        op1b.Next = op2b;\n        op2b.Prev = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      }\n      else\n      {\n        op1b = this.DupOutPt(op1, true);\n        op2b = this.DupOutPt(op2, false);\n        op1.Next = op2;\n        op2.Prev = op1;\n        op1b.Prev = op2b;\n        op2b.Next = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      }\n    }\n    else if (isHorizontal)\n    {\n      //treat horizontal joins differently to non-horizontal joins since with\n      //them we're not yet sure where the overlapping is. OutPt1.Pt & OutPt2.Pt\n      //may be anywhere along the horizontal edge.\n      op1b = op1;\n      while (op1.Prev.Pt.Y == op1.Pt.Y && op1.Prev != op1b && op1.Prev != op2)\n        op1 = op1.Prev;\n      while (op1b.Next.Pt.Y == op1b.Pt.Y && op1b.Next != op1 && op1b.Next != op2)\n        op1b = op1b.Next;\n      if (op1b.Next == op1 || op1b.Next == op2)\n        return false;\n      //a flat 'polygon'\n      op2b = op2;\n      while (op2.Prev.Pt.Y == op2.Pt.Y && op2.Prev != op2b && op2.Prev != op1b)\n        op2 = op2.Prev;\n      while (op2b.Next.Pt.Y == op2b.Pt.Y && op2b.Next != op2 && op2b.Next != op1)\n        op2b = op2b.Next;\n      if (op2b.Next == op2 || op2b.Next == op1)\n        return false;\n      //a flat 'polygon'\n      //Op1 -. Op1b & Op2 -. Op2b are the extremites of the horizontal edges\n\n      var $val = {Left: null, Right: null};\n      if (!this.GetOverlap(op1.Pt.X, op1b.Pt.X, op2.Pt.X, op2b.Pt.X, $val))\n        return false;\n      var Left = $val.Left;\n      var Right = $val.Right;\n\n      //DiscardLeftSide: when overlapping edges are joined, a spike will created\n      //which needs to be cleaned up. However, we don't want Op1 or Op2 caught up\n      //on the discard Side as either may still be needed for other joins ...\n      var Pt = new ClipperLib.IntPoint();\n      var DiscardLeftSide;\n      if (op1.Pt.X >= Left && op1.Pt.X <= Right)\n      {\n        //Pt = op1.Pt;\n        Pt.X = op1.Pt.X;\n        Pt.Y = op1.Pt.Y;\n        DiscardLeftSide = (op1.Pt.X > op1b.Pt.X);\n      }\n      else if (op2.Pt.X >= Left && op2.Pt.X <= Right)\n      {\n        //Pt = op2.Pt;\n        Pt.X = op2.Pt.X;\n        Pt.Y = op2.Pt.Y;\n        DiscardLeftSide = (op2.Pt.X > op2b.Pt.X);\n      }\n      else if (op1b.Pt.X >= Left && op1b.Pt.X <= Right)\n      {\n        //Pt = op1b.Pt;\n        Pt.X = op1b.Pt.X;\n        Pt.Y = op1b.Pt.Y;\n        DiscardLeftSide = op1b.Pt.X > op1.Pt.X;\n      }\n      else\n      {\n        //Pt = op2b.Pt;\n        Pt.X = op2b.Pt.X;\n        Pt.Y = op2b.Pt.Y;\n        DiscardLeftSide = (op2b.Pt.X > op2.Pt.X);\n      }\n      j.OutPt1 = op1;\n      j.OutPt2 = op2;\n      return this.JoinHorz(op1, op1b, op2, op2b, Pt, DiscardLeftSide);\n    }\n    else\n    {\n      //nb: For non-horizontal joins ...\n      //    1. Jr.OutPt1.Pt.Y == Jr.OutPt2.Pt.Y\n      //    2. Jr.OutPt1.Pt > Jr.OffPt.Y\n      //make sure the polygons are correctly oriented ...\n      op1b = op1.Next;\n      while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))\n        op1b = op1b.Next;\n      var Reverse1 = ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange));\n      if (Reverse1)\n      {\n        op1b = op1.Prev;\n        while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))\n          op1b = op1b.Prev;\n        if ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange))\n          return false;\n      }\n      op2b = op2.Next;\n      while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))\n        op2b = op2b.Next;\n      var Reverse2 = ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange));\n      if (Reverse2)\n      {\n        op2b = op2.Prev;\n        while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))\n          op2b = op2b.Prev;\n        if ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange))\n          return false;\n      }\n      if ((op1b == op1) || (op2b == op2) || (op1b == op2b) ||\n        ((outRec1 == outRec2) && (Reverse1 == Reverse2)))\n        return false;\n      if (Reverse1)\n      {\n        op1b = this.DupOutPt(op1, false);\n        op2b = this.DupOutPt(op2, true);\n        op1.Prev = op2;\n        op2.Next = op1;\n        op1b.Next = op2b;\n        op2b.Prev = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      }\n      else\n      {\n        op1b = this.DupOutPt(op1, true);\n        op2b = this.DupOutPt(op2, false);\n        op1.Next = op2;\n        op2.Prev = op1;\n        op1b.Prev = op2b;\n        op2b.Next = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      }\n    }\n  };\n  ClipperLib.Clipper.GetBounds = function (paths)\n  {\n    var i = 0,\n      cnt = paths.length;\n    while (i < cnt && paths[i].length == 0) i++;\n    if (i == cnt) return new ClipperLib.IntRect(0, 0, 0, 0);\n    var result = new ClipperLib.IntRect();\n    result.left = paths[i][0].X;\n    result.right = result.left;\n    result.top = paths[i][0].Y;\n    result.bottom = result.top;\n    for (; i < cnt; i++)\n      for (var j = 0, jlen = paths[i].length; j < jlen; j++)\n      {\n        if (paths[i][j].X < result.left) result.left = paths[i][j].X;\n        else if (paths[i][j].X > result.right) result.right = paths[i][j].X;\n        if (paths[i][j].Y < result.top) result.top = paths[i][j].Y;\n        else if (paths[i][j].Y > result.bottom) result.bottom = paths[i][j].Y;\n      }\n    return result;\n  }\n  ClipperLib.Clipper.prototype.GetBounds2 = function (ops)\n  {\n    var opStart = ops;\n    var result = new ClipperLib.IntRect();\n    result.left = ops.Pt.X;\n    result.right = ops.Pt.X;\n    result.top = ops.Pt.Y;\n    result.bottom = ops.Pt.Y;\n    ops = ops.Next;\n    while (ops != opStart)\n    {\n      if (ops.Pt.X < result.left)\n        result.left = ops.Pt.X;\n      if (ops.Pt.X > result.right)\n        result.right = ops.Pt.X;\n      if (ops.Pt.Y < result.top)\n        result.top = ops.Pt.Y;\n      if (ops.Pt.Y > result.bottom)\n        result.bottom = ops.Pt.Y;\n      ops = ops.Next;\n    }\n    return result;\n  };\n\n  ClipperLib.Clipper.PointInPolygon = function (pt, path)\n  {\n    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t\t//See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n    var result = 0,\n      cnt = path.length;\n    if (cnt < 3)\n      return 0;\n    var ip = path[0];\n    for (var i = 1; i <= cnt; ++i)\n    {\n      var ipNext = (i == cnt ? path[0] : path[i]);\n      if (ipNext.Y == pt.Y)\n      {\n        if ((ipNext.X == pt.X) || (ip.Y == pt.Y && ((ipNext.X > pt.X) == (ip.X < pt.X))))\n          return -1;\n      }\n      if ((ip.Y < pt.Y) != (ipNext.Y < pt.Y))\n      {\n        if (ip.X >= pt.X)\n        {\n          if (ipNext.X > pt.X)\n            result = 1 - result;\n          else\n          {\n            var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n            if (d == 0)\n              return -1;\n            else if ((d > 0) == (ipNext.Y > ip.Y))\n              result = 1 - result;\n          }\n        }\n        else\n        {\n          if (ipNext.X > pt.X)\n          {\n            var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n            if (d == 0)\n              return -1;\n            else if ((d > 0) == (ipNext.Y > ip.Y))\n              result = 1 - result;\n          }\n        }\n      }\n      ip = ipNext;\n    }\n    return result;\n  };\n\n  ClipperLib.Clipper.prototype.PointInPolygon = function (pt, op)\n  {\n    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t\t//See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n    var result = 0;\n    var startOp = op;\n\t\tvar ptx = pt.X, pty = pt.Y;\n    var poly0x = op.Pt.X, poly0y = op.Pt.Y;\n    do\n    {\n\t\t\top = op.Next;\n\t\t\tvar poly1x = op.Pt.X, poly1y = op.Pt.Y;\n      if (poly1y == pty)\n      {\n        if ((poly1x == ptx) || (poly0y == pty && ((poly1x > ptx) == (poly0x < ptx))))\n          return -1;\n      }\n      if ((poly0y < pty) != (poly1y < pty))\n      {\n        if (poly0x >= ptx)\n        {\n          if (poly1x > ptx)\n            result = 1 - result;\n          else\n          {\n            var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n            if (d == 0)\n              return -1;\n            if ((d > 0) == (poly1y > poly0y))\n              result = 1 - result;\n          }\n        }\n        else\n        {\n          if (poly1x > ptx)\n          {\n            var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n            if (d == 0)\n              return -1;\n            if ((d > 0) == (poly1y > poly0y))\n              result = 1 - result;\n          }\n        }\n      }\n      poly0x = poly1x;\n      poly0y = poly1y;\n    } while (startOp != op);\n\n    return result;\n  };\n\n  ClipperLib.Clipper.prototype.Poly2ContainsPoly1 = function (outPt1, outPt2)\n  {\n    var op = outPt1;\n    do\n    {\n\t\t\t//nb: PointInPolygon returns 0 if false, +1 if true, -1 if pt on polygon\n      var res = this.PointInPolygon(op.Pt, outPt2);\n      if (res >= 0)\n        return res > 0;\n      op = op.Next;\n    }\n    while (op != outPt1)\n    return true;\n  };\n  ClipperLib.Clipper.prototype.FixupFirstLefts1 = function (OldOutRec, NewOutRec)\n  {\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n\t\t\tvar outRec = this.m_PolyOuts[i];\n\t\t\tif (outRec.Pts == null || outRec.FirstLeft == null)\n\t\t\t\tcontinue;\n\t\t\tvar firstLeft = this.ParseFirstLeft(outRec.FirstLeft);\n\t\t\tif (firstLeft == OldOutRec)\n\t\t\t{\n        if (this.Poly2ContainsPoly1(outRec.Pts, NewOutRec.Pts))\n          outRec.FirstLeft = NewOutRec;\n      }\n    }\n  };\n  ClipperLib.Clipper.prototype.FixupFirstLefts2 = function (OldOutRec, NewOutRec)\n  {\n    for (var $i2 = 0, $t2 = this.m_PolyOuts, $l2 = $t2.length, outRec = $t2[$i2]; $i2 < $l2; $i2++, outRec = $t2[$i2])\n      if (outRec.FirstLeft == OldOutRec)\n        outRec.FirstLeft = NewOutRec;\n  };\n  ClipperLib.Clipper.ParseFirstLeft = function (FirstLeft)\n  {\n    while (FirstLeft != null && FirstLeft.Pts == null)\n      FirstLeft = FirstLeft.FirstLeft;\n    return FirstLeft;\n  };\n  ClipperLib.Clipper.prototype.JoinCommonEdges = function ()\n  {\n    for (var i = 0, ilen = this.m_Joins.length; i < ilen; i++)\n    {\n      var join = this.m_Joins[i];\n      var outRec1 = this.GetOutRec(join.OutPt1.Idx);\n      var outRec2 = this.GetOutRec(join.OutPt2.Idx);\n      if (outRec1.Pts == null || outRec2.Pts == null)\n        continue;\n      //get the polygon fragment with the correct hole state (FirstLeft)\n      //before calling JoinPoints() ...\n      var holeStateRec;\n      if (outRec1 == outRec2)\n        holeStateRec = outRec1;\n      else if (this.Param1RightOfParam2(outRec1, outRec2))\n        holeStateRec = outRec2;\n      else if (this.Param1RightOfParam2(outRec2, outRec1))\n        holeStateRec = outRec1;\n      else\n        holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\n      if (!this.JoinPoints(join, outRec1, outRec2)) continue;\n\n      if (outRec1 == outRec2)\n      {\n        //instead of joining two polygons, we've just created a new one by\n        //splitting one polygon into two.\n        outRec1.Pts = join.OutPt1;\n        outRec1.BottomPt = null;\n        outRec2 = this.CreateOutRec();\n        outRec2.Pts = join.OutPt2;\n        //update all OutRec2.Pts Idx's ...\n        this.UpdateOutPtIdxs(outRec2);\n        //We now need to check every OutRec.FirstLeft pointer. If it points\n        //to OutRec1 it may need to point to OutRec2 instead ...\n        if (this.m_UsingPolyTree)\n          for (var j = 0, jlen = this.m_PolyOuts.length; j < jlen - 1; j++)\n          {\n            var oRec = this.m_PolyOuts[j];\n            if (oRec.Pts == null || ClipperLib.Clipper.ParseFirstLeft(oRec.FirstLeft) != outRec1 || oRec.IsHole == outRec1.IsHole)\n              continue;\n            if (this.Poly2ContainsPoly1(oRec.Pts, join.OutPt2))\n              oRec.FirstLeft = outRec2;\n          }\n        if (this.Poly2ContainsPoly1(outRec2.Pts, outRec1.Pts))\n        {\n          //outRec2 is contained by outRec1 ...\n          outRec2.IsHole = !outRec1.IsHole;\n          outRec2.FirstLeft = outRec1;\n          //fixup FirstLeft pointers that may need reassigning to OutRec1\n          if (this.m_UsingPolyTree)\n            this.FixupFirstLefts2(outRec2, outRec1);\n          if ((outRec2.IsHole ^ this.ReverseSolution) == (this.Area(outRec2) > 0))\n            this.ReversePolyPtLinks(outRec2.Pts);\n        }\n        else if (this.Poly2ContainsPoly1(outRec1.Pts, outRec2.Pts))\n        {\n          //outRec1 is contained by outRec2 ...\n          outRec2.IsHole = outRec1.IsHole;\n          outRec1.IsHole = !outRec2.IsHole;\n          outRec2.FirstLeft = outRec1.FirstLeft;\n          outRec1.FirstLeft = outRec2;\n          //fixup FirstLeft pointers that may need reassigning to OutRec1\n          if (this.m_UsingPolyTree)\n            this.FixupFirstLefts2(outRec1, outRec2);\n          if ((outRec1.IsHole ^ this.ReverseSolution) == (this.Area(outRec1) > 0))\n            this.ReversePolyPtLinks(outRec1.Pts);\n        }\n        else\n        {\n          //the 2 polygons are completely separate ...\n          outRec2.IsHole = outRec1.IsHole;\n          outRec2.FirstLeft = outRec1.FirstLeft;\n          //fixup FirstLeft pointers that may need reassigning to OutRec2\n          if (this.m_UsingPolyTree)\n            this.FixupFirstLefts1(outRec1, outRec2);\n        }\n      }\n      else\n      {\n        //joined 2 polygons together ...\n        outRec2.Pts = null;\n        outRec2.BottomPt = null;\n        outRec2.Idx = outRec1.Idx;\n        outRec1.IsHole = holeStateRec.IsHole;\n        if (holeStateRec == outRec2)\n          outRec1.FirstLeft = outRec2.FirstLeft;\n        outRec2.FirstLeft = outRec1;\n        //fixup FirstLeft pointers that may need reassigning to OutRec1\n        if (this.m_UsingPolyTree)\n          this.FixupFirstLefts2(outRec2, outRec1);\n      }\n    }\n  };\n  ClipperLib.Clipper.prototype.UpdateOutPtIdxs = function (outrec)\n  {\n    var op = outrec.Pts;\n    do {\n      op.Idx = outrec.Idx;\n      op = op.Prev;\n    }\n    while (op != outrec.Pts)\n  };\n  ClipperLib.Clipper.prototype.DoSimplePolygons = function ()\n  {\n    var i = 0;\n    while (i < this.m_PolyOuts.length)\n    {\n      var outrec = this.m_PolyOuts[i++];\n      var op = outrec.Pts;\n\t\t\tif (op == null || outrec.IsOpen)\n\t\t\t\tcontinue;\n      do //for each Pt in Polygon until duplicate found do ...\n      {\n        var op2 = op.Next;\n        while (op2 != outrec.Pts)\n        {\n          if ((ClipperLib.IntPoint.op_Equality(op.Pt, op2.Pt)) && op2.Next != op && op2.Prev != op)\n          {\n            //split the polygon into two ...\n            var op3 = op.Prev;\n            var op4 = op2.Prev;\n            op.Prev = op4;\n            op4.Next = op;\n            op2.Prev = op3;\n            op3.Next = op2;\n            outrec.Pts = op;\n            var outrec2 = this.CreateOutRec();\n            outrec2.Pts = op2;\n            this.UpdateOutPtIdxs(outrec2);\n            if (this.Poly2ContainsPoly1(outrec2.Pts, outrec.Pts))\n            {\n              //OutRec2 is contained by OutRec1 ...\n              outrec2.IsHole = !outrec.IsHole;\n              outrec2.FirstLeft = outrec;\n\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec2, outrec);\n\n            }\n            else if (this.Poly2ContainsPoly1(outrec.Pts, outrec2.Pts))\n            {\n              //OutRec1 is contained by OutRec2 ...\n              outrec2.IsHole = outrec.IsHole;\n              outrec.IsHole = !outrec2.IsHole;\n              outrec2.FirstLeft = outrec.FirstLeft;\n              outrec.FirstLeft = outrec2;\n              if (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec, outrec2);\n            }\n            else\n            {\n              //the 2 polygons are separate ...\n              outrec2.IsHole = outrec.IsHole;\n              outrec2.FirstLeft = outrec.FirstLeft;\n\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts1(outrec, outrec2);\n            }\n            op2 = op;\n            //ie get ready for the next iteration\n          }\n          op2 = op2.Next;\n        }\n        op = op.Next;\n      }\n      while (op != outrec.Pts)\n    }\n  };\n  ClipperLib.Clipper.Area = function (poly)\n  {\n    var cnt = poly.length;\n    if (cnt < 3)\n      return 0;\n    var a = 0;\n    for (var i = 0, j = cnt - 1; i < cnt; ++i)\n    {\n      a += (poly[j].X + poly[i].X) * (poly[j].Y - poly[i].Y);\n      j = i;\n    }\n    return -a * 0.5;\n  };\n  ClipperLib.Clipper.prototype.Area = function (outRec)\n  {\n    var op = outRec.Pts;\n    if (op == null)\n      return 0;\n    var a = 0;\n    do {\n      a = a + (op.Prev.Pt.X + op.Pt.X) * (op.Prev.Pt.Y - op.Pt.Y);\n      op = op.Next;\n    }\n    while (op != outRec.Pts)\n    return a * 0.5;\n  };\n  ClipperLib.Clipper.SimplifyPolygon = function (poly, fillType)\n  {\n    var result = new Array();\n    var c = new ClipperLib.Clipper(0);\n    c.StrictlySimple = true;\n    c.AddPath(poly, ClipperLib.PolyType.ptSubject, true);\n    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n    return result;\n  };\n  ClipperLib.Clipper.SimplifyPolygons = function (polys, fillType)\n  {\n    if (typeof (fillType) == \"undefined\") fillType = ClipperLib.PolyFillType.pftEvenOdd;\n    var result = new Array();\n    var c = new ClipperLib.Clipper(0);\n    c.StrictlySimple = true;\n    c.AddPaths(polys, ClipperLib.PolyType.ptSubject, true);\n    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n    return result;\n  };\n  ClipperLib.Clipper.DistanceSqrd = function (pt1, pt2)\n  {\n    var dx = (pt1.X - pt2.X);\n    var dy = (pt1.Y - pt2.Y);\n    return (dx * dx + dy * dy);\n  };\n  ClipperLib.Clipper.DistanceFromLineSqrd = function (pt, ln1, ln2)\n  {\n    //The equation of a line in general form (Ax + By + C = 0)\n    //given 2 points (x,y) & (x,y) is ...\n    //(y - y)x + (x - x)y + (y - y)x - (x - x)y = 0\n    //A = (y - y); B = (x - x); C = (y - y)x - (x - x)y\n    //perpendicular distance of point (x,y) = (Ax + By + C)/Sqrt(A + B)\n    //see http://en.wikipedia.org/wiki/Perpendicular_distance\n    var A = ln1.Y - ln2.Y;\n    var B = ln2.X - ln1.X;\n    var C = A * ln1.X + B * ln1.Y;\n    C = A * pt.X + B * pt.Y - C;\n    return (C * C) / (A * A + B * B);\n  };\n\n\tClipperLib.Clipper.SlopesNearCollinear = function(pt1, pt2, pt3, distSqrd)\n\t{\n\t\t//this function is more accurate when the point that's GEOMETRICALLY\n\t\t//between the other 2 points is the one that's tested for distance.\n\t\t//nb: with 'spikes', either pt1 or pt3 is geometrically between the other pts\n\t\tif (Math.abs(pt1.X - pt2.X) > Math.abs(pt1.Y - pt2.Y))\n\t\t{\n\t\tif ((pt1.X > pt2.X) == (pt1.X < pt3.X))\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n\t\telse if ((pt2.X > pt1.X) == (pt2.X < pt3.X))\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t\t\t\telse\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n\t\t}\n\t\telse\n\t\t{\n\t\tif ((pt1.Y > pt2.Y) == (pt1.Y < pt3.Y))\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n\t\telse if ((pt2.Y > pt1.Y) == (pt2.Y < pt3.Y))\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t\t\t\telse\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n\t\t}\n\t}\n\n  ClipperLib.Clipper.PointsAreClose = function (pt1, pt2, distSqrd)\n  {\n    var dx = pt1.X - pt2.X;\n    var dy = pt1.Y - pt2.Y;\n    return ((dx * dx) + (dy * dy) <= distSqrd);\n  };\n  //------------------------------------------------------------------------------\n  ClipperLib.Clipper.ExcludeOp = function (op)\n  {\n    var result = op.Prev;\n    result.Next = op.Next;\n    op.Next.Prev = result;\n    result.Idx = 0;\n    return result;\n  };\n  ClipperLib.Clipper.CleanPolygon = function (path, distance)\n  {\n    if (typeof (distance) == \"undefined\") distance = 1.415;\n    //distance = proximity in units/pixels below which vertices will be stripped.\n    //Default ~= sqrt(2) so when adjacent vertices or semi-adjacent vertices have\n    //both x & y coords within 1 unit, then the second vertex will be stripped.\n    var cnt = path.length;\n    if (cnt == 0)\n      return new Array();\n    var outPts = new Array(cnt);\n    for (var i = 0; i < cnt; ++i)\n      outPts[i] = new ClipperLib.OutPt();\n    for (var i = 0; i < cnt; ++i)\n    {\n      outPts[i].Pt = path[i];\n      outPts[i].Next = outPts[(i + 1) % cnt];\n      outPts[i].Next.Prev = outPts[i];\n      outPts[i].Idx = 0;\n    }\n    var distSqrd = distance * distance;\n    var op = outPts[0];\n    while (op.Idx == 0 && op.Next != op.Prev)\n    {\n      if (ClipperLib.Clipper.PointsAreClose(op.Pt, op.Prev.Pt, distSqrd))\n      {\n        op = ClipperLib.Clipper.ExcludeOp(op);\n        cnt--;\n      }\n      else if (ClipperLib.Clipper.PointsAreClose(op.Prev.Pt, op.Next.Pt, distSqrd))\n      {\n        ClipperLib.Clipper.ExcludeOp(op.Next);\n        op = ClipperLib.Clipper.ExcludeOp(op);\n        cnt -= 2;\n      }\n      else if (ClipperLib.Clipper.SlopesNearCollinear(op.Prev.Pt, op.Pt, op.Next.Pt, distSqrd))\n      {\n        op = ClipperLib.Clipper.ExcludeOp(op);\n        cnt--;\n      }\n      else\n      {\n        op.Idx = 1;\n        op = op.Next;\n      }\n    }\n    if (cnt < 3)\n      cnt = 0;\n    var result = new Array(cnt);\n    for (var i = 0; i < cnt; ++i)\n    {\n      result[i] = new ClipperLib.IntPoint(op.Pt);\n      op = op.Next;\n    }\n    outPts = null;\n    return result;\n  };\n  ClipperLib.Clipper.CleanPolygons = function (polys, distance)\n  {\n    var result = new Array(polys.length);\n    for (var i = 0, ilen = polys.length; i < ilen; i++)\n      result[i] = ClipperLib.Clipper.CleanPolygon(polys[i], distance);\n    return result;\n  };\n  ClipperLib.Clipper.Minkowski = function (pattern, path, IsSum, IsClosed)\n  {\n    var delta = (IsClosed ? 1 : 0);\n    var polyCnt = pattern.length;\n    var pathCnt = path.length;\n    var result = new Array();\n    if (IsSum)\n      for (var i = 0; i < pathCnt; i++)\n      {\n        var p = new Array(polyCnt);\n        for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n          p[j] = new ClipperLib.IntPoint(path[i].X + ip.X, path[i].Y + ip.Y);\n        result.push(p);\n      }\n    else\n      for (var i = 0; i < pathCnt; i++)\n      {\n        var p = new Array(polyCnt);\n        for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n          p[j] = new ClipperLib.IntPoint(path[i].X - ip.X, path[i].Y - ip.Y);\n        result.push(p);\n      }\n    var quads = new Array();\n    for (var i = 0; i < pathCnt - 1 + delta; i++)\n      for (var j = 0; j < polyCnt; j++)\n      {\n        var quad = new Array();\n        quad.push(result[i % pathCnt][j % polyCnt]);\n        quad.push(result[(i + 1) % pathCnt][j % polyCnt]);\n        quad.push(result[(i + 1) % pathCnt][(j + 1) % polyCnt]);\n        quad.push(result[i % pathCnt][(j + 1) % polyCnt]);\n        if (!ClipperLib.Clipper.Orientation(quad))\n          quad.reverse();\n        quads.push(quad);\n      }\n\t\t\treturn quads;\n  };\n\n\tClipperLib.Clipper.MinkowskiSum = function(pattern, path_or_paths, pathIsClosed)\n\t{\n\t\tif(!(path_or_paths[0] instanceof Array))\n\t\t{\n\t\t\tvar path = path_or_paths;\n\t\t\tvar paths = ClipperLib.Clipper.Minkowski(pattern, path, true, pathIsClosed);\n\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\tc.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\treturn paths;\n\t\t}\n\t\telse\n\t\t{\n \t\t\tvar paths = path_or_paths;\n\t\t\tvar solution = new ClipperLib.Paths();\n\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\tfor (var i = 0; i < paths.length; ++i)\n\t\t\t{\n\t\t\t\tvar tmp = ClipperLib.Clipper.Minkowski(pattern, paths[i], true, pathIsClosed);\n\t\t\t\tc.AddPaths(tmp, ClipperLib.PolyType.ptSubject, true);\n\t\t\t\tif (pathIsClosed)\n\t\t\t\t{\n\t\t\t\t\tvar path = ClipperLib.Clipper.TranslatePath(paths[i], pattern[0]);\n\t\t\t\t\tc.AddPath(path, ClipperLib.PolyType.ptClip, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, solution,\n\t\t\t\tClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\treturn solution;\n\t\t}\n\t}\n\t//------------------------------------------------------------------------------\n\n\tClipperLib.Clipper.TranslatePath = function (path, delta)\n\t{\n\t\tvar outPath = new ClipperLib.Path();\n\t\tfor (var i = 0; i < path.length; i++)\n\t\t\toutPath.push(new ClipperLib.IntPoint(path[i].X + delta.X, path[i].Y + delta.Y));\n\t\treturn outPath;\n\t}\n\t//------------------------------------------------------------------------------\n\n\tClipperLib.Clipper.MinkowskiDiff = function (poly1, poly2)\n\t{\n\t\tvar paths = ClipperLib.Clipper.Minkowski(poly1, poly2, false, true);\n\t\tvar c = new ClipperLib.Clipper();\n\t\tc.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n\t\tc.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\treturn paths;\n\t}\n\n  ClipperLib.Clipper.PolyTreeToPaths = function (polytree)\n  {\n    var result = new Array();\n    //result.set_Capacity(polytree.get_Total());\n    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntAny, result);\n    return result;\n  };\n  ClipperLib.Clipper.AddPolyNodeToPaths = function (polynode, nt, paths)\n  {\n    var match = true;\n    switch (nt)\n    {\n    case ClipperLib.Clipper.NodeType.ntOpen:\n      return;\n    case ClipperLib.Clipper.NodeType.ntClosed:\n      match = !polynode.IsOpen;\n      break;\n    default:\n      break;\n    }\n    if (polynode.m_polygon.length > 0 && match)\n      paths.push(polynode.m_polygon);\n    for (var $i3 = 0, $t3 = polynode.Childs(), $l3 = $t3.length, pn = $t3[$i3]; $i3 < $l3; $i3++, pn = $t3[$i3])\n      ClipperLib.Clipper.AddPolyNodeToPaths(pn, nt, paths);\n  };\n  ClipperLib.Clipper.OpenPathsFromPolyTree = function (polytree)\n  {\n    var result = new ClipperLib.Paths();\n    //result.set_Capacity(polytree.ChildCount());\n    for (var i = 0, ilen = polytree.ChildCount(); i < ilen; i++)\n      if (polytree.Childs()[i].IsOpen)\n        result.push(polytree.Childs()[i].m_polygon);\n    return result;\n  };\n  ClipperLib.Clipper.ClosedPathsFromPolyTree = function (polytree)\n  {\n    var result = new ClipperLib.Paths();\n    //result.set_Capacity(polytree.Total());\n    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntClosed, result);\n    return result;\n  };\n  Inherit(ClipperLib.Clipper, ClipperLib.ClipperBase);\n  ClipperLib.Clipper.NodeType = {\n    ntAny: 0,\n    ntOpen: 1,\n    ntClosed: 2\n  };\n  ClipperLib.ClipperOffset = function (miterLimit, arcTolerance)\n  {\n    if (typeof (miterLimit) == \"undefined\") miterLimit = 2;\n    if (typeof (arcTolerance) == \"undefined\") arcTolerance = ClipperLib.ClipperOffset.def_arc_tolerance;\n    this.m_destPolys = new ClipperLib.Paths();\n    this.m_srcPoly = new ClipperLib.Path();\n    this.m_destPoly = new ClipperLib.Path();\n    this.m_normals = new Array();\n    this.m_delta = 0;\n    this.m_sinA = 0;\n    this.m_sin = 0;\n    this.m_cos = 0;\n    this.m_miterLim = 0;\n    this.m_StepsPerRad = 0;\n    this.m_lowest = new ClipperLib.IntPoint();\n    this.m_polyNodes = new ClipperLib.PolyNode();\n    this.MiterLimit = miterLimit;\n    this.ArcTolerance = arcTolerance;\n    this.m_lowest.X = -1;\n  };\n  ClipperLib.ClipperOffset.two_pi = 6.28318530717959;\n  ClipperLib.ClipperOffset.def_arc_tolerance = 0.25;\n  ClipperLib.ClipperOffset.prototype.Clear = function ()\n  {\n    ClipperLib.Clear(this.m_polyNodes.Childs());\n    this.m_lowest.X = -1;\n  };\n  ClipperLib.ClipperOffset.Round = ClipperLib.Clipper.Round;\n  ClipperLib.ClipperOffset.prototype.AddPath = function (path, joinType, endType)\n  {\n    var highI = path.length - 1;\n    if (highI < 0)\n      return;\n    var newNode = new ClipperLib.PolyNode();\n    newNode.m_jointype = joinType;\n    newNode.m_endtype = endType;\n    //strip duplicate points from path and also get index to the lowest point ...\n    if (endType == ClipperLib.EndType.etClosedLine || endType == ClipperLib.EndType.etClosedPolygon)\n      while (highI > 0 && ClipperLib.IntPoint.op_Equality(path[0], path[highI]))\n        highI--;\n    //newNode.m_polygon.set_Capacity(highI + 1);\n    newNode.m_polygon.push(path[0]);\n    var j = 0,\n      k = 0;\n    for (var i = 1; i <= highI; i++)\n      if (ClipperLib.IntPoint.op_Inequality(newNode.m_polygon[j], path[i]))\n      {\n        j++;\n        newNode.m_polygon.push(path[i]);\n        if (path[i].Y > newNode.m_polygon[k].Y || (path[i].Y == newNode.m_polygon[k].Y && path[i].X < newNode.m_polygon[k].X))\n          k = j;\n      }\n    if (endType == ClipperLib.EndType.etClosedPolygon && j < 2) return;\n\n    this.m_polyNodes.AddChild(newNode);\n    //if this path's lowest pt is lower than all the others then update m_lowest\n    if (endType != ClipperLib.EndType.etClosedPolygon)\n      return;\n    if (this.m_lowest.X < 0)\n      this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);\n    else\n    {\n      var ip = this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon[this.m_lowest.Y];\n      if (newNode.m_polygon[k].Y > ip.Y || (newNode.m_polygon[k].Y == ip.Y && newNode.m_polygon[k].X < ip.X))\n        this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);\n    }\n  };\n  ClipperLib.ClipperOffset.prototype.AddPaths = function (paths, joinType, endType)\n  {\n    for (var i = 0, ilen = paths.length; i < ilen; i++)\n      this.AddPath(paths[i], joinType, endType);\n  };\n  ClipperLib.ClipperOffset.prototype.FixOrientations = function ()\n  {\n    //fixup orientations of all closed paths if the orientation of the\n    //closed path with the lowermost vertex is wrong ...\n    if (this.m_lowest.X >= 0 && !ClipperLib.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon))\n    {\n      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n      {\n        var node = this.m_polyNodes.Childs()[i];\n        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon || (node.m_endtype == ClipperLib.EndType.etClosedLine && ClipperLib.Clipper.Orientation(node.m_polygon)))\n          node.m_polygon.reverse();\n      }\n    }\n    else\n    {\n      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n      {\n        var node = this.m_polyNodes.Childs()[i];\n        if (node.m_endtype == ClipperLib.EndType.etClosedLine && !ClipperLib.Clipper.Orientation(node.m_polygon))\n          node.m_polygon.reverse();\n      }\n    }\n  };\n  ClipperLib.ClipperOffset.GetUnitNormal = function (pt1, pt2)\n  {\n    var dx = (pt2.X - pt1.X);\n    var dy = (pt2.Y - pt1.Y);\n    if ((dx == 0) && (dy == 0))\n      return new ClipperLib.DoublePoint(0, 0);\n    var f = 1 / Math.sqrt(dx * dx + dy * dy);\n    dx *= f;\n    dy *= f;\n    return new ClipperLib.DoublePoint(dy, -dx);\n  };\n  ClipperLib.ClipperOffset.prototype.DoOffset = function (delta)\n  {\n    this.m_destPolys = new Array();\n    this.m_delta = delta;\n    //if Zero offset, just copy any CLOSED polygons to m_p and return ...\n    if (ClipperLib.ClipperBase.near_zero(delta))\n    {\n      //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount);\n      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n      {\n        var node = this.m_polyNodes.Childs()[i];\n        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n          this.m_destPolys.push(node.m_polygon);\n      }\n      return;\n    }\n    //see offset_triginometry3.svg in the documentation folder ...\n    if (this.MiterLimit > 2)\n      this.m_miterLim = 2 / (this.MiterLimit * this.MiterLimit);\n    else\n      this.m_miterLim = 0.5;\n    var y;\n    if (this.ArcTolerance <= 0)\n      y = ClipperLib.ClipperOffset.def_arc_tolerance;\n    else if (this.ArcTolerance > Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance)\n      y = Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance;\n    else\n      y = this.ArcTolerance;\n    //see offset_triginometry2.svg in the documentation folder ...\n    var steps = 3.14159265358979 / Math.acos(1 - y / Math.abs(delta));\n    this.m_sin = Math.sin(ClipperLib.ClipperOffset.two_pi / steps);\n    this.m_cos = Math.cos(ClipperLib.ClipperOffset.two_pi / steps);\n    this.m_StepsPerRad = steps / ClipperLib.ClipperOffset.two_pi;\n    if (delta < 0)\n      this.m_sin = -this.m_sin;\n    //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount * 2);\n    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n    {\n      var node = this.m_polyNodes.Childs()[i];\n      this.m_srcPoly = node.m_polygon;\n      var len = this.m_srcPoly.length;\n      if (len == 0 || (delta <= 0 && (len < 3 || node.m_endtype != ClipperLib.EndType.etClosedPolygon)))\n        continue;\n      this.m_destPoly = new Array();\n      if (len == 1)\n      {\n        if (node.m_jointype == ClipperLib.JoinType.jtRound)\n        {\n          var X = 1,\n            Y = 0;\n          for (var j = 1; j <= steps; j++)\n          {\n            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n            var X2 = X;\n            X = X * this.m_cos - this.m_sin * Y;\n            Y = X2 * this.m_sin + Y * this.m_cos;\n          }\n        }\n        else\n        {\n          var X = -1,\n            Y = -1;\n          for (var j = 0; j < 4; ++j)\n          {\n            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n            if (X < 0)\n              X = 1;\n            else if (Y < 0)\n              Y = 1;\n            else\n              X = -1;\n          }\n        }\n        this.m_destPolys.push(this.m_destPoly);\n        continue;\n      }\n      //build m_normals ...\n      this.m_normals.length = 0;\n      //this.m_normals.set_Capacity(len);\n      for (var j = 0; j < len - 1; j++)\n        this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[j], this.m_srcPoly[j + 1]));\n      if (node.m_endtype == ClipperLib.EndType.etClosedLine || node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n        this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[len - 1], this.m_srcPoly[0]));\n      else\n        this.m_normals.push(new ClipperLib.DoublePoint(this.m_normals[len - 2]));\n      if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n      {\n        var k = len - 1;\n        for (var j = 0; j < len; j++)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        this.m_destPolys.push(this.m_destPoly);\n      }\n      else if (node.m_endtype == ClipperLib.EndType.etClosedLine)\n      {\n        var k = len - 1;\n        for (var j = 0; j < len; j++)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        this.m_destPolys.push(this.m_destPoly);\n        this.m_destPoly = new Array();\n        //re-build m_normals ...\n        var n = this.m_normals[len - 1];\n        for (var j = len - 1; j > 0; j--)\n          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n        this.m_normals[0] = new ClipperLib.DoublePoint(-n.X, -n.Y);\n        k = 0;\n        for (var j = len - 1; j >= 0; j--)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        this.m_destPolys.push(this.m_destPoly);\n      }\n      else\n      {\n        var k = 0;\n        for (var j = 1; j < len - 1; ++j)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        var pt1;\n        if (node.m_endtype == ClipperLib.EndType.etOpenButt)\n        {\n          var j = len - 1;\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * delta));\n          this.m_destPoly.push(pt1);\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X - this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y - this.m_normals[j].Y * delta));\n          this.m_destPoly.push(pt1);\n        }\n        else\n        {\n          var j = len - 1;\n          k = len - 2;\n          this.m_sinA = 0;\n          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j].X, -this.m_normals[j].Y);\n          if (node.m_endtype == ClipperLib.EndType.etOpenSquare)\n            this.DoSquare(j, k);\n          else\n            this.DoRound(j, k);\n        }\n        //re-build m_normals ...\n        for (var j = len - 1; j > 0; j--)\n          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n        this.m_normals[0] = new ClipperLib.DoublePoint(-this.m_normals[1].X, -this.m_normals[1].Y);\n        k = len - 1;\n        for (var j = k - 1; j > 0; --j)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        if (node.m_endtype == ClipperLib.EndType.etOpenButt)\n        {\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X - this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y - this.m_normals[0].Y * delta));\n          this.m_destPoly.push(pt1);\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + this.m_normals[0].Y * delta));\n          this.m_destPoly.push(pt1);\n        }\n        else\n        {\n          k = 1;\n          this.m_sinA = 0;\n          if (node.m_endtype == ClipperLib.EndType.etOpenSquare)\n            this.DoSquare(0, 1);\n          else\n            this.DoRound(0, 1);\n        }\n        this.m_destPolys.push(this.m_destPoly);\n      }\n    }\n  };\n  ClipperLib.ClipperOffset.prototype.Execute = function ()\n  {\n    var a = arguments,\n      ispolytree = a[0] instanceof ClipperLib.PolyTree;\n    if (!ispolytree) // function (solution, delta)\n    {\n      var solution = a[0],\n        delta = a[1];\n      ClipperLib.Clear(solution);\n      this.FixOrientations();\n      this.DoOffset(delta);\n      //now clean up 'corners' ...\n      var clpr = new ClipperLib.Clipper(0);\n      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n      if (delta > 0)\n      {\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n      }\n      else\n      {\n        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n        var outer = new ClipperLib.Path();\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n        clpr.ReverseSolution = true;\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n        if (solution.length > 0)\n          solution.splice(0, 1);\n      }\n      //console.log(JSON.stringify(solution));\n    }\n    else // function (polytree, delta)\n    {\n      var solution = a[0],\n        delta = a[1];\n      solution.Clear();\n      this.FixOrientations();\n      this.DoOffset(delta);\n      //now clean up 'corners' ...\n      var clpr = new ClipperLib.Clipper(0);\n      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n      if (delta > 0)\n      {\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n      }\n      else\n      {\n        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n        var outer = new ClipperLib.Path();\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n        clpr.ReverseSolution = true;\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n        //remove the outer PolyNode rectangle ...\n        if (solution.ChildCount() == 1 && solution.Childs()[0].ChildCount() > 0)\n        {\n          var outerNode = solution.Childs()[0];\n          //solution.Childs.set_Capacity(outerNode.ChildCount);\n          solution.Childs()[0] = outerNode.Childs()[0];\n          solution.Childs()[0].m_Parent = solution;\n          for (var i = 1; i < outerNode.ChildCount(); i++)\n            solution.AddChild(outerNode.Childs()[i]);\n        }\n        else\n          solution.Clear();\n      }\n    }\n  };\n  ClipperLib.ClipperOffset.prototype.OffsetPoint = function (j, k, jointype)\n  {\n\t\t//cross product ...\n\t\tthis.m_sinA = (this.m_normals[k].X * this.m_normals[j].Y - this.m_normals[j].X * this.m_normals[k].Y);\n\n\t\tif (Math.abs(this.m_sinA * this.m_delta) < 1.0)\n\t\t{\n\t\t\t//dot product ...\n\t\t\tvar cosA = (this.m_normals[k].X * this.m_normals[j].X + this.m_normals[j].Y * this.m_normals[k].Y);\n\t\t\tif (cosA > 0) // angle ==> 0 degrees\n\t\t\t{\n\t\t\t\tthis.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),\n\t\t\t\t\tClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n\t\t\t\treturn k;\n\t\t\t}\n\t\t\t//else angle ==> 180 degrees\n\t\t}\n    else if (this.m_sinA > 1)\n      this.m_sinA = 1.0;\n    else if (this.m_sinA < -1)\n      this.m_sinA = -1.0;\n    if (this.m_sinA * this.m_delta < 0)\n    {\n      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),\n        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n      this.m_destPoly.push(new ClipperLib.IntPoint(this.m_srcPoly[j]));\n      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n    }\n    else\n      switch (jointype)\n      {\n      case ClipperLib.JoinType.jtMiter:\n        {\n          var r = 1 + (this.m_normals[j].X * this.m_normals[k].X + this.m_normals[j].Y * this.m_normals[k].Y);\n          if (r >= this.m_miterLim)\n            this.DoMiter(j, k, r);\n          else\n            this.DoSquare(j, k);\n          break;\n        }\n      case ClipperLib.JoinType.jtSquare:\n        this.DoSquare(j, k);\n        break;\n      case ClipperLib.JoinType.jtRound:\n        this.DoRound(j, k);\n        break;\n      }\n    k = j;\n    return k;\n  };\n  ClipperLib.ClipperOffset.prototype.DoSquare = function (j, k)\n  {\n    var dx = Math.tan(Math.atan2(this.m_sinA,\n      this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y) / 4);\n    this.m_destPoly.push(new ClipperLib.IntPoint(\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[k].X - this.m_normals[k].Y * dx)),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[k].Y + this.m_normals[k].X * dx))));\n    this.m_destPoly.push(new ClipperLib.IntPoint(\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[j].X + this.m_normals[j].Y * dx)),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[j].Y - this.m_normals[j].X * dx))));\n  };\n  ClipperLib.ClipperOffset.prototype.DoMiter = function (j, k, r)\n  {\n    var q = this.m_delta / r;\n    this.m_destPoly.push(new ClipperLib.IntPoint(\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + (this.m_normals[k].X + this.m_normals[j].X) * q),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + (this.m_normals[k].Y + this.m_normals[j].Y) * q)));\n  };\n  ClipperLib.ClipperOffset.prototype.DoRound = function (j, k)\n  {\n    var a = Math.atan2(this.m_sinA,\n      this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y);\n\n    \tvar steps = Math.max(ClipperLib.Cast_Int32(ClipperLib.ClipperOffset.Round(this.m_StepsPerRad * Math.abs(a))), 1);\n\n    var X = this.m_normals[k].X,\n      Y = this.m_normals[k].Y,\n      X2;\n    for (var i = 0; i < steps; ++i)\n    {\n      this.m_destPoly.push(new ClipperLib.IntPoint(\n        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + X * this.m_delta),\n        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + Y * this.m_delta)));\n      X2 = X;\n      X = X * this.m_cos - this.m_sin * Y;\n      Y = X2 * this.m_sin + Y * this.m_cos;\n    }\n    this.m_destPoly.push(new ClipperLib.IntPoint(\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n  };\n  ClipperLib.Error = function (message)\n  {\n    try\n    {\n      throw new Error(message);\n    }\n    catch (err)\n    {\n      alert(err.message);\n    }\n  };\n  // ---------------------------------\n  // JS extension by Timo 2013\n  ClipperLib.JS = {};\n  ClipperLib.JS.AreaOfPolygon = function (poly, scale)\n  {\n    if (!scale) scale = 1;\n    return ClipperLib.Clipper.Area(poly) / (scale * scale);\n  };\n  ClipperLib.JS.AreaOfPolygons = function (poly, scale)\n  {\n    if (!scale) scale = 1;\n    var area = 0;\n    for (var i = 0; i < poly.length; i++)\n    {\n      area += ClipperLib.Clipper.Area(poly[i]);\n    }\n    return area / (scale * scale);\n  };\n  ClipperLib.JS.BoundsOfPath = function (path, scale)\n  {\n    return ClipperLib.JS.BoundsOfPaths([path], scale);\n  };\n  ClipperLib.JS.BoundsOfPaths = function (paths, scale)\n  {\n    if (!scale) scale = 1;\n    var bounds = ClipperLib.Clipper.GetBounds(paths);\n    bounds.left /= scale;\n    bounds.bottom /= scale;\n    bounds.right /= scale;\n    bounds.top /= scale;\n    return bounds;\n  };\n  // Clean() joins vertices that are too near each other\n  // and causes distortion to offsetted polygons without cleaning\n  ClipperLib.JS.Clean = function (polygon, delta)\n  {\n    if (!(polygon instanceof Array)) return [];\n    var isPolygons = polygon[0] instanceof Array;\n    var polygon = ClipperLib.JS.Clone(polygon);\n    if (typeof delta != \"number\" || delta === null)\n    {\n      ClipperLib.Error(\"Delta is not a number in Clean().\");\n      return polygon;\n    }\n    if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || delta < 0) return polygon;\n    if (!isPolygons) polygon = [polygon];\n    var k_length = polygon.length;\n    var len, poly, result, d, p, j, i;\n    var results = [];\n    for (var k = 0; k < k_length; k++)\n    {\n      poly = polygon[k];\n      len = poly.length;\n      if (len === 0) continue;\n      else if (len < 3)\n      {\n        result = poly;\n        results.push(result);\n        continue;\n      }\n      result = poly;\n      d = delta * delta;\n      //d = Math.floor(c_delta * c_delta);\n      p = poly[0];\n      j = 1;\n      for (i = 1; i < len; i++)\n      {\n        if ((poly[i].X - p.X) * (poly[i].X - p.X) +\n          (poly[i].Y - p.Y) * (poly[i].Y - p.Y) <= d)\n          continue;\n        result[j] = poly[i];\n        p = poly[i];\n        j++;\n      }\n      p = poly[j - 1];\n      if ((poly[0].X - p.X) * (poly[0].X - p.X) +\n        (poly[0].Y - p.Y) * (poly[0].Y - p.Y) <= d)\n        j--;\n      if (j < len)\n        result.splice(j, len - j);\n      if (result.length) results.push(result);\n    }\n    if (!isPolygons && results.length) results = results[0];\n    else if (!isPolygons && results.length === 0) results = [];\n    else if (isPolygons && results.length === 0) results = [\n      []\n    ];\n    return results;\n  }\n  // Make deep copy of Polygons or Polygon\n  // so that also IntPoint objects are cloned and not only referenced\n  // This should be the fastest way\n  ClipperLib.JS.Clone = function (polygon)\n  {\n    if (!(polygon instanceof Array)) return [];\n    if (polygon.length === 0) return [];\n    else if (polygon.length == 1 && polygon[0].length === 0) return [[]];\n    var isPolygons = polygon[0] instanceof Array;\n    if (!isPolygons) polygon = [polygon];\n    var len = polygon.length,\n      plen, i, j, result;\n    var results = new Array(len);\n    for (i = 0; i < len; i++)\n    {\n      plen = polygon[i].length;\n      result = new Array(plen);\n      for (j = 0; j < plen; j++)\n      {\n        result[j] = {\n          X: polygon[i][j].X,\n          Y: polygon[i][j].Y\n        };\n      }\n      results[i] = result;\n    }\n    if (!isPolygons) results = results[0];\n    return results;\n  };\n  // Removes points that doesn't affect much to the visual appearance.\n  // If middle point is at or under certain distance (tolerance) of the line segment between\n  // start and end point, the middle point is removed.\n  ClipperLib.JS.Lighten = function (polygon, tolerance)\n  {\n    if (!(polygon instanceof Array)) return [];\n    if (typeof tolerance != \"number\" || tolerance === null)\n    {\n      ClipperLib.Error(\"Tolerance is not a number in Lighten().\")\n      return ClipperLib.JS.Clone(polygon);\n    }\n    if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || tolerance < 0)\n    {\n      return ClipperLib.JS.Clone(polygon);\n    }\n    if (!(polygon[0] instanceof Array)) polygon = [polygon];\n    var i, j, poly, k, poly2, plen, A, B, P, d, rem, addlast;\n    var bxax, byay, l, ax, ay;\n    var len = polygon.length;\n    var toleranceSq = tolerance * tolerance;\n    var results = [];\n    for (i = 0; i < len; i++)\n    {\n      poly = polygon[i];\n      plen = poly.length;\n      if (plen == 0) continue;\n      for (k = 0; k < 1000000; k++) // could be forever loop, but wiser to restrict max repeat count\n      {\n        poly2 = [];\n        plen = poly.length;\n        // the first have to added to the end, if first and last are not the same\n        // this way we ensure that also the actual last point can be removed if needed\n        if (poly[plen - 1].X != poly[0].X || poly[plen - 1].Y != poly[0].Y)\n        {\n          addlast = 1;\n          poly.push(\n          {\n            X: poly[0].X,\n            Y: poly[0].Y\n          });\n          plen = poly.length;\n        }\n        else addlast = 0;\n        rem = []; // Indexes of removed points\n        for (j = 0; j < plen - 2; j++)\n        {\n          A = poly[j]; // Start point of line segment\n          P = poly[j + 1]; // Middle point. This is the one to be removed.\n          B = poly[j + 2]; // End point of line segment\n          ax = A.X;\n          ay = A.Y;\n          bxax = B.X - ax;\n          byay = B.Y - ay;\n          if (bxax !== 0 || byay !== 0) // To avoid Nan, when A==P && P==B. And to avoid peaks (A==B && A!=P), which have lenght, but not area.\n          {\n            l = ((P.X - ax) * bxax + (P.Y - ay) * byay) / (bxax * bxax + byay * byay);\n            if (l > 1)\n            {\n              ax = B.X;\n              ay = B.Y;\n            }\n            else if (l > 0)\n            {\n              ax += bxax * l;\n              ay += byay * l;\n            }\n          }\n          bxax = P.X - ax;\n          byay = P.Y - ay;\n          d = bxax * bxax + byay * byay;\n          if (d <= toleranceSq)\n          {\n            rem[j + 1] = 1;\n            j++; // when removed, transfer the pointer to the next one\n          }\n        }\n        // add all unremoved points to poly2\n        poly2.push(\n        {\n          X: poly[0].X,\n          Y: poly[0].Y\n        });\n        for (j = 1; j < plen - 1; j++)\n          if (!rem[j]) poly2.push(\n          {\n            X: poly[j].X,\n            Y: poly[j].Y\n          });\n        poly2.push(\n        {\n          X: poly[plen - 1].X,\n          Y: poly[plen - 1].Y\n        });\n        // if the first point was added to the end, remove it\n        if (addlast) poly.pop();\n        // break, if there was not anymore removed points\n        if (!rem.length) break;\n        // else continue looping using poly2, to check if there are points to remove\n        else poly = poly2;\n      }\n      plen = poly2.length;\n      // remove duplicate from end, if needed\n      if (poly2[plen - 1].X == poly2[0].X && poly2[plen - 1].Y == poly2[0].Y)\n      {\n        poly2.pop();\n      }\n      if (poly2.length > 2) // to avoid two-point-polygons\n        results.push(poly2);\n    }\n    if (!(polygon[0] instanceof Array)) results = results[0];\n    if (typeof (results) == \"undefined\") results = [\n      []\n    ];\n    return results;\n  }\n  ClipperLib.JS.PerimeterOfPath = function (path, closed, scale)\n  {\n    if (typeof (path) == \"undefined\") return 0;\n    var sqrt = Math.sqrt;\n    var perimeter = 0.0;\n    var p1, p2, p1x = 0.0,\n      p1y = 0.0,\n      p2x = 0.0,\n      p2y = 0.0;\n    var j = path.length;\n    if (j < 2) return 0;\n    if (closed)\n    {\n      path[j] = path[0];\n      j++;\n    }\n    while (--j)\n    {\n      p1 = path[j];\n      p1x = p1.X;\n      p1y = p1.Y;\n      p2 = path[j - 1];\n      p2x = p2.X;\n      p2y = p2.Y;\n      perimeter += sqrt((p1x - p2x) * (p1x - p2x) + (p1y - p2y) * (p1y - p2y));\n    }\n    if (closed) path.pop();\n    return perimeter / scale;\n  };\n  ClipperLib.JS.PerimeterOfPaths = function (paths, closed, scale)\n  {\n    if (!scale) scale = 1;\n    var perimeter = 0;\n    for (var i = 0; i < paths.length; i++)\n    {\n      perimeter += ClipperLib.JS.PerimeterOfPath(paths[i], closed, scale);\n    }\n    return perimeter;\n  };\n  ClipperLib.JS.ScaleDownPath = function (path, scale)\n  {\n    var i, p;\n    if (!scale) scale = 1;\n    i = path.length;\n    while (i--)\n    {\n      p = path[i];\n      p.X = p.X / scale;\n      p.Y = p.Y / scale;\n    }\n  };\n  ClipperLib.JS.ScaleDownPaths = function (paths, scale)\n  {\n    var i, j, p;\n    if (!scale) scale = 1;\n    i = paths.length;\n    while (i--)\n    {\n      j = paths[i].length;\n      while (j--)\n      {\n        p = paths[i][j];\n        p.X = p.X / scale;\n        p.Y = p.Y / scale;\n      }\n    }\n  };\n  ClipperLib.JS.ScaleUpPath = function (path, scale)\n  {\n    var i, p, round = Math.round;\n    if (!scale) scale = 1;\n    i = path.length;\n    while (i--)\n    {\n      p = path[i];\n      p.X = round(p.X * scale);\n      p.Y = round(p.Y * scale);\n    }\n  };\n  ClipperLib.JS.ScaleUpPaths = function (paths, scale)\n  {\n    var i, j, p, round = Math.round;\n    if (!scale) scale = 1;\n    i = paths.length;\n    while (i--)\n    {\n      j = paths[i].length;\n      while (j--)\n      {\n        p = paths[i][j];\n        p.X = round(p.X * scale);\n        p.Y = round(p.Y * scale);\n      }\n    }\n  };\n  ClipperLib.ExPolygons = function ()\n  {\n    return [];\n  }\n  ClipperLib.ExPolygon = function ()\n  {\n    this.outer = null;\n    this.holes = null;\n  };\n  ClipperLib.JS.AddOuterPolyNodeToExPolygons = function (polynode, expolygons)\n  {\n    var ep = new ClipperLib.ExPolygon();\n    ep.outer = polynode.Contour();\n    var childs = polynode.Childs();\n    var ilen = childs.length;\n    ep.holes = new Array(ilen);\n    var node, n, i, j, childs2, jlen;\n    for (i = 0; i < ilen; i++)\n    {\n      node = childs[i];\n      ep.holes[i] = node.Contour();\n      //Add outer polygons contained by (nested within) holes ...\n      for (j = 0, childs2 = node.Childs(), jlen = childs2.length; j < jlen; j++)\n      {\n        n = childs2[j];\n        ClipperLib.JS.AddOuterPolyNodeToExPolygons(n, expolygons);\n      }\n    }\n    expolygons.push(ep);\n  };\n  ClipperLib.JS.ExPolygonsToPaths = function (expolygons)\n  {\n    var a, i, alen, ilen;\n    var paths = new ClipperLib.Paths();\n    for (a = 0, alen = expolygons.length; a < alen; a++)\n    {\n      paths.push(expolygons[a].outer);\n      for (i = 0, ilen = expolygons[a].holes.length; i < ilen; i++)\n      {\n        paths.push(expolygons[a].holes[i]);\n      }\n    }\n    return paths;\n  }\n  ClipperLib.JS.PolyTreeToExPolygons = function (polytree)\n  {\n    var expolygons = new ClipperLib.ExPolygons();\n    var node, i, childs, ilen;\n    for (i = 0, childs = polytree.Childs(), ilen = childs.length; i < ilen; i++)\n    {\n      node = childs[i];\n      ClipperLib.JS.AddOuterPolyNodeToExPolygons(node, expolygons);\n    }\n    return expolygons;\n  };\n})();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/clipper-lib/clipper.js\n// module id = 6\n// module chunks = 0"],"sourceRoot":""}