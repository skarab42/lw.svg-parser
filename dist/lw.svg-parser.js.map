{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///lw.svg-parser.js","webpack:///webpack/bootstrap d38418eff6e0b94b10b7","webpack:///../~/lw.svg-path/dist/lw.svg-path.js","webpack:///./parser.js","webpack:///./tag.js","webpack:///./tagparser.js","webpack:///../~/clipper-lib/clipper.js","webpack:///../~/lw.svg-curves/dist/lw.svg-curves.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","t","n","i","e","o","TypeError","Object","defineProperty","value","length","enumerable","configurable","writable","key","prototype","x","parseFloat","y","isNaN","console","error","Error","r","points","forEach","push","arguments","X","parseInt","Y","addPoint","getPoint","isEqual","isClosed","map","Path","Point","default","_classCallCheck","instance","Constructor","Parser","undefined","_createClass","defineProperties","target","props","descriptor","protoProps","staticProps","_tag","_tagparser","settings","element","editor","document","defs","tags","traceSettings","assign","linear","step","resolution","segmentLength","supportedTags","parseTags","includes","skipTags","excludes","onTag","onTagContext","input","loadFromString","File","loadFromFile","XMLDocument","loadFromXMLDocument","Element","loadFromElement","Promise","reject","_this","resolve","nodeName","textContent","getElementsByTagName","_this2","documentElement","then","catch","_this3","_parseEditor","parser","DOMParser","XMLDoc","parseFromString","name","version","fingerprint","match","_this4","reader","FileReader","onload","event","result","onerror","readAsText","_this5","load","parse","_parseElement","applyMatrix","tag","callback","context","_this6","_onTag","parent","_this7","Tag","indexOf","_skipTag","tagParser","TagParser","childTag","childNodes","childNode","addChild","children","message","warn","attr","_interopRequireDefault","obj","__esModule","_lw","_clipperLib","_clipperLib2","DEG_TO_RAD","Math","PI","toLowerCase","layer","attrs","paths","matrix","path","point","shapes","setMatrix","keys","setAttr","defaultValue","getAttr","getLayerName","clearPath","close","relative","il","addMatrix","angle","cos","sin","tan","transform","shape","outer","holes","hole","fillRule","PolyFillType","pftNonZero","pftEvenOdd","cPolyTree","PolyTree","cClipper","Clipper","clipperScale","clipperPaths","getClipperPoints","AddPaths","PolyType","ptSubject","Execute","ClipType","ctUnion","PolyTreeToPaths","polygones","SimplifyPolygons","Clear","StrictlySimple","toPath","fromClipperPoints","exPolygons","JS","PolyTreeToExPolygons","exPolygon","_lw2","currentCommand","lastCommand","pathData","handler","_parseTagAttrs","attributes","style","some","_normalizeTagAttr","replace","split","nodeValue","colorsAttrs","attrName","_parseViewBoxAttr","_parseTransformAttr","trim","_skipTagAttr","_normalizeTagAttrUnit","_normalizeTagAttrPoints","_normalizeTagAttrRange","_normalizeTagAttrPreserveAspectRatio","stringValue","floatValue","_parseNumbers","min","max","filter","params","defer","align","meet","slice","rawParams","substr","viewBox","width","height","scaleX","scaleY","translateX","translateY","preserveAspectRatio","newWidth","newHeight","translate","scale","transformAttr","transformations","pop","type","raw","func","tagTransform","apply","newPath","closePath","addPoints","title","description","useTag","setLayerName","_path","shift","concat","_polyline","w","h","rx","ry","dx","dy","cx","cy","num","splice","join","dAttr","commands","parseError","toUpperCase","_clearPath","_newPath","_addPoints","_closePath","every","_paths","p1","rl","x1","y1","x2","y2","p2","p3","p4","tracer","CubicBezier","coords","trace","QuadricBezier","large","sweep","Arc","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","BigInteger","a","b","ClipperLib","biginteger_used","fromInt","fromNumber","fromString","nbi","am1","j","v","floor","am2","xl","xh","l","am3","int2char","BI_RM","charAt","intAt","s","BI_RC","charCodeAt","bnpCopyTo","bnpFromInt","DV","nbv","bnpFromString","k","fromRadix","mi","sh","DB","clamp","ZERO","subTo","bnpClamp","DM","bnToString","negate","toString","toRadix","d","km","bnNegate","bnAbs","bnCompareTo","nbits","bnBitLength","bnpDLShiftTo","bnpDRShiftTo","bnpLShiftTo","bs","cbs","bm","ds","bnpRShiftTo","bnpSubTo","bnpMultiplyTo","abs","am","bnpSquareTo","bnpDivRemTo","q","pm","pt","copyTo","ts","ms","nsh","lShiftTo","ys","y0","yt","F1","F2","d1","FV","d2","dlShiftTo","compareTo","ONE","qd","drShiftTo","rShiftTo","bnMod","divRemTo","Classic","cConvert","mod","cRevert","cReduce","cMulTo","multiplyTo","reduce","cSqrTo","squareTo","bnpInvDigit","Montgomery","mp","invDigit","mpl","mph","um","mt2","montConvert","montRevert","montReduce","u0","montSqrTo","montMulTo","bnpIsEven","bnpExp","z","r2","g","convert","sqrTo","mulTo","revert","bnModPowInt","isEven","exp","bnClone","bnIntValue","bnByteValue","bnShortValue","bnpChunkSize","LN2","log","bnSigNum","bnpToRadix","signum","cs","chunkSize","pow","intValue","bnpFromRadix","dMultiply","dAddOffset","bnpFromNumber","testBit","bitwiseTo","shiftLeft","op_or","isProbablePrime","bitLength","Array","nextBytes","bnToByteArray","bnEquals","bnMin","bnMax","bnpBitwiseTo","op","f","op_and","bnAnd","bnOr","op_xor","bnXor","op_andnot","bnAndNot","bnNot","bnShiftLeft","bnShiftRight","lbit","bnGetLowestSetBit","cbit","bnBitCount","bnTestBit","bnpChangeBit","bnSetBit","changeBit","bnClearBit","bnFlipBit","bnpAddTo","bnAdd","addTo","bnSubtract","bnMultiply","bnSquare","bnDivide","bnRemainder","bnDivideAndRemainder","bnpDMultiply","bnpDAddOffset","NullExp","nNop","nMulTo","nSqrTo","bnPow","bnpMultiplyLowerTo","bnpMultiplyUpperTo","Barrett","q3","mu","divide","barrettConvert","barrettRevert","barrettReduce","multiplyUpperTo","multiplyLowerTo","barrettSqrTo","barrettMulTo","bnModPow","k1","g2","is1","bnGCD","clone","getLowestSetBit","bnpModInt","bnModInverse","ac","u","subtract","add","bnIsProbablePrime","lowprimes","lplim","modInt","millerRabin","bnpMillerRabin","n1","shiftRight","random","modPow","modPowInt","use_int32","use_xyz","use_lines","isNode","window","self","navigator_appName","nav","navigator","userAgent","appName","browser","chrome","chromium","safari","firefox","firefox17","firefox15","firefox3","opera","msie10","msie9","msie8","msie7","msie","dbits","canary","j_lm","BI_FP","rr","vv","byteValue","shortValue","toByteArray","equals","and","or","xor","andNot","not","bitCount","setBit","clearBit","flipBit","multiply","remainder","divideAndRemainder","modInverse","gcd","square","Int128","IsNegative","op_Equality","val1","val2","op_Inequality","op_GreaterThan","op_LessThan","op_Addition","lhs","rhs","op_Subtraction","Int128Mul","op_Division","ToDouble","Inherit","ce","ce2","$baseCtor","getOwnPropertyNames","getOwnPropertyDescriptor","Paths","DoublePoint","DoublePoint0","DoublePoint1","dp","DoublePoint2","PolyNode","m_Parent","m_polygon","m_Index","m_jointype","m_endtype","m_Childs","IsOpen","IsHoleNode","node","ChildCount","Contour","AddChild","Child","cnt","GetNext","GetNextSiblingUp","Childs","Parent","IsHole","m_AllPolys","ilen","GetFirst","Total","Math_Abs_Int64","Math_Abs_Int32","Math_Abs_Double","Math_Max_Int32_Int32","Cast_Int32","Cast_Int64","ceil","Number","toInteger","PI2","IntPoint","alen","Z","Round","IntPoint0","IntPoint1","IntPoint1dp","IntPoint2","IntPoint3","IntRect","left","top","right","bottom","ir","IntRect0","IntRect1","IntRect4","ctIntersection","ctDifference","ctXor","ptClip","pftPositive","pftNegative","JoinType","jtSquare","jtRound","jtMiter","EndType","etOpenSquare","etOpenRound","etOpenButt","etClosedLine","etClosedPolygon","EdgeSide","esLeft","esRight","Direction","dRightToLeft","dLeftToRight","TEdge","Bot","Curr","Top","Delta","Dx","PolyTyp","Side","WindDelta","WindCnt","WindCnt2","OutIdx","Next","Prev","NextInLML","NextInAEL","PrevInAEL","NextInSEL","PrevInSEL","IntersectNode","Edge1","Edge2","Pt","MyIntersectNodeSort","Compare","node1","node2","LocalMinima","LeftBound","RightBound","Scanbeam","OutRec","Idx","FirstLeft","Pts","BottomPt","OutPt","Join","OutPt1","OutPt2","OffPt","ClipperBase","m_MinimaList","m_CurrentLM","m_edges","m_UseFullRange","m_HasOpenPaths","PreserveCollinear","horizontal","Skip","Unassigned","tolerance","loRange","hiRange","near_zero","val","IsHorizontal","PointIsVertex","pp","pp2","PointOnLineSegment","linePt1","linePt2","UseFullRange","PointOnPolygon","SlopesEqual","e1","e2","pt1","pt2","pt3","pt4","SlopesEqual3","SlopesEqual4","SlopesEqual5","DisposeLocalMinimaList","jlen","tmpLm","RangeTest","useFullRange","Value","InitEdge","eNext","ePrev","InitEdge2","polyType","SetDx","FindNextLocMin","E","E2","ProcessBound","LeftBoundIsForward","EStart","Horz","Result","locMin","InsertLocalMinima","ReverseHorizontal","AddPath","pg","Closed","highI","edges","IsFlat","$1","eStart","eLoopStop","Pt2IsBetweenPt1AndPt3","RemoveEdge","leftBoundIsForward","EMin","ppg","closed","newLm","PopLocalMinima","tmp","Reset","lm","InitOptions","m_PolyOuts","m_ClipType","m_Scanbeam","m_ActiveEdges","m_SortedEdges","m_IntersectList","m_IntersectNodeComparer","m_ExecuteLocked","m_ClipFillType","m_SubjFillType","m_Joins","m_GhostJoins","m_UsingPolyTree","ReverseSolution","ZFillFunction","ioReverseSolution","ioStrictlySimple","ioPreserveCollinear","DisposeAllPolyPts","DisposeScanbeamList","sb2","InsertScanbeam","newSb","ispolytree","clipType","solution","subjFillType","clipFillType","succeeded","ExecuteInternal","BuildResult","polytree","BuildResult2","FixHoleLinkage","outRec","orfl","botY","PopScanbeam","InsertLocalMinimaIntoAEL","ProcessHorizontals","topY","ProcessIntersections","ProcessEdgesAtTopOfScanbeam","Area","ReversePolyPtLinks","JoinCommonEdges","FixupOutPolygon","DoSimplePolygons","DisposeOutRec","index","AddJoin","Op1","Op2","AddGhostJoin","Op","SetZ","lb","rb","InsertEdgeIntoAEL","SetWindingCount","IsContributing","AddOutPt","AddLocalMinPoly","AddEdgeToSEL","HorzSegmentsOverlap","IntersectEdges","edge","startEdge","E2InsertsBeforeE1","TopX","IsEvenOddFillType","IsEvenOddAltFillType","pft","pft2","Inside","CopyAELToSEL","SwapPositionsInAEL","edge1","edge2","next","prev","SwapPositionsInSEL","AddLocalMaxPoly","AppendPolygon","prevE","outPt","CreateOutRec","ToFront","newOp","SetHoleState","SwapPoints","seg1a","seg1b","seg2a","seg2b","isHole","GetDx","FirstIsBottomPt","btmPt1","btmPt2","dx1p","dx1n","dx2p","dx2n","GetBottomPt","dups","GetLowermostRec","outRec1","outRec2","bPt1","bPt2","Param1RightOfParam2","GetOutRec","idx","outrec","holeStateRec","side","p1_lft","p1_rt","p2_lft","p2_rt","OKIdx","ObsoleteIdx","pp1","SwapSides","SwapPolyIndexes","outIdx","e1Contributing","e2Contributing","oldE1WindCnt","e1FillType","e2FillType","e1FillType2","e2FillType2","e1Wc","e2Wc","e1Wc2","e2Wc2","DeleteFromAEL","AelPrev","AelNext","DeleteFromSEL","SelPrev","SelNext","UpdateEdgeIntoAEL","isTopOfScanbeam","horzEdge","ProcessHorizontal","GetHorzDirection","HorzEdge","$var","Left","Right","Dir","dir","horzLeft","horzRight","eLastHorz","eMaxPair","GetMaximaPair","IsLastHorz","GetNextInAEL","op1","eNextHorz","op2","IsMinima","IsMaxima","IsIntermediate","BuildIntersectList","FixupIntersectionOrder","ProcessIntersectList","$$e2","isModified","IntersectPoint","newNode","EdgesAdjacent","inode","IntersectNodeSort","sort","iNode","R1","round","R2","R3","R4","currentY","ip","b1","b2","IsMaximaEdge","DoMaxima","ReversePaths","polys","len","reverse","Orientation","poly","PointCount","pts","polyg","pn","lastOK","DupOutPt","InsertAfter","GetOverlap","a1","a2","$val","JoinHorz","op1b","op2b","DiscardLeft","Dir1","Dir2","JoinPoints","isHorizontal","reverse1","reverse2","DiscardLeftSide","Reverse1","Reverse2","GetBounds","GetBounds2","ops","opStart","PointInPolygon","ipNext","startOp","ptx","pty","poly0x","poly0y","poly1x","poly1y","Poly2ContainsPoly1","outPt1","outPt2","res","FixupFirstLefts1","OldOutRec","NewOutRec","firstLeft","ParseFirstLeft","FixupFirstLefts2","$i2","$t2","$l2","UpdateOutPtIdxs","oRec","op3","op4","outrec2","SimplifyPolygon","fillType","DistanceSqrd","DistanceFromLineSqrd","ln1","ln2","A","B","C","SlopesNearCollinear","distSqrd","PointsAreClose","ExcludeOp","CleanPolygon","distance","outPts","CleanPolygons","Minkowski","pattern","IsSum","IsClosed","delta","polyCnt","pathCnt","quads","quad","MinkowskiSum","path_or_paths","pathIsClosed","TranslatePath","outPath","MinkowskiDiff","poly1","poly2","AddPolyNodeToPaths","NodeType","ntAny","polynode","nt","ntOpen","ntClosed","$i3","$t3","$l3","OpenPathsFromPolyTree","ClosedPathsFromPolyTree","ClipperOffset","miterLimit","arcTolerance","def_arc_tolerance","m_destPolys","m_srcPoly","m_destPoly","m_normals","m_delta","m_sinA","m_sin","m_cos","m_miterLim","m_StepsPerRad","m_lowest","m_polyNodes","MiterLimit","ArcTolerance","two_pi","joinType","endType","FixOrientations","GetUnitNormal","sqrt","DoOffset","steps","acos","OffsetPoint","DoSquare","DoRound","X2","clpr","outerNode","jointype","cosA","DoMiter","atan2","err","alert","AreaOfPolygon","AreaOfPolygons","area","BoundsOfPath","BoundsOfPaths","bounds","Clean","polygon","isPolygons","Clone","k_length","results","plen","Lighten","P","rem","addlast","bxax","byay","ax","ay","toleranceSq","PerimeterOfPath","perimeter","p1x","p1y","p2x","p2y","PerimeterOfPaths","ScaleDownPath","ScaleDownPaths","ScaleUpPath","ScaleUpPaths","ExPolygons","ExPolygon","AddOuterPolyNodeToExPolygons","expolygons","ep","childs","childs2","ExPolygonsToPaths","ReferenceError","create","constructor","setPrototypeOf","__proto__","Function","getPrototypeOf","get","arcLength","arcLengthMap","getPointAtT","_approximateLength","_addPoint","_postTrace","getPath","radians","__addPoint","center","startAngle","sweepAngle","init","_B1","_B2","_B3","_B4","_C1","unshift"],"mappings":"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","file":"lw.svg-parser.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"SVGParser\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SVGParser\"] = factory();\n\telse\n\t\troot[\"SVGParser\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"SVGParser\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SVGParser\"] = factory();\n\telse\n\t\troot[\"SVGParser\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(2);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t!function(t,n){ true?module.exports=n():\"function\"==typeof define&&define.amd?define(\"SVGPath\",[],n):\"object\"==typeof exports?exports.SVGPath=n():t.SVGPath=n()}(this,function(){return function(t){function n(i){if(e[i])return e[i].exports;var o=e[i]={exports:{},id:i,loaded:!1};return t[i].call(o.exports,o,o.exports,n),o.loaded=!0,o.exports}var e={};return n.m=t,n.c=e,n.p=\"\",n(0)}([function(t,n,e){t.exports=e(1)},function(t,n){\"use strict\";function e(t,n){if(!(t instanceof n))throw new TypeError(\"Cannot call a class as a function\")}Object.defineProperty(n,\"__esModule\",{value:!0});var i=function(){function t(t,n){for(var e=0;e<n.length;e++){var i=n[e];i.enumerable=i.enumerable||!1,i.configurable=!0,\"value\"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(n,e,i){return e&&t(n.prototype,e),i&&t(n,i),n}}(),o=function(){function t(n,i){if(e(this,t),this.x=parseFloat(n),this.y=parseFloat(i),isNaN(this.x)||isNaN(this.y))throw console.error(\"new Point(\",n,i,\")\"),new Error(\"Invalid input: x and y params must be float.\")}return i(t,[{key:\"isEqual\",value:function(t){return this.x===t.x&&this.y===t.y}}]),t}(),r=function(){function t(){e(this,t),this.points=[],this.length=0}return i(t,[{key:\"getPoints\",value:function(){return this.points}},{key:\"getFlattenPoints\",value:function(){var t=[];return this.points.forEach(function(n){return t.push(n.x,n.y)}),t}},{key:\"getClipperPoints\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,n=[];return this.points.forEach(function(e){return n.push({X:parseInt(e.x*t),Y:parseInt(e.y*t)})}),n}},{key:\"fromClipperPoints\",value:function(t){var n=this,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return this.points=[],t.forEach(function(t){return n.addPoint(parseFloat(t.X*e),parseFloat(t.Y*e))}),this}},{key:\"getPoint\",value:function(t){return this.points[t<0?this.length+t:t]||null}},{key:\"addPoint\",value:function(t,n){this.points.push(new o(t,n)),this.length=this.points.length}},{key:\"addPoints\",value:function(t){for(var n=0,e=t.length;n<e;n+=2)this.addPoint(t[n],t[n+1])}},{key:\"isClosed\",value:function(){var t=this.getPoint(0);return t&&t.isEqual(this.getPoint(-1))}},{key:\"close\",value:function(){if(!this.isClosed()&&this.length>2){var t=this.getPoint(0);return this.addPoint(t.x,t.y),!0}return!1}},{key:\"transform\",value:function(t){this.points=this.points.map(function(n){return new o(t[0]*n.x+t[2]*n.y+t[4],t[1]*n.x+t[3]*n.y+t[5])})}}]),t}();n.Path=r,n.Point=o,n.default=r}])});\n\t//# sourceMappingURL=lw.svg-path.js.map\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.Parser = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); // Imports\n\t\n\t\n\tvar _tag = __webpack_require__(3);\n\t\n\tvar _tagparser = __webpack_require__(4);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t// SVG parser class\n\tvar Parser = function () {\n\t    // Class constructor...\n\t    function Parser(settings) {\n\t        _classCallCheck(this, Parser);\n\t\n\t        // Defaults settings\n\t        settings = settings || {};\n\t\n\t        // Init properties\n\t        this.element = null; // XML document Element object\n\t        this.editor = null; // Editor info { name, version, fingerprint }\n\t        this.document = null; // Document info { width, height, viewBox }\n\t        this.defs = null; // Defined <defs> (DOM) nodes list by id\n\t        this.tags = null; // Tag objects hierarchy\n\t\n\t        // Trace settings (Arc, Bezier)\n\t        this.traceSettings = Object.assign({\n\t            linear: true, // Linear trace mode\n\t            step: 0.01, // Step resolution if linear mode = false\n\t            resolution: 100, // Number of segments we use to approximate arc length\n\t            segmentLength: 1 }, settings.traceSettings || {});\n\t\n\t        // Supported tags by this lib\n\t        this.supportedTags = ['svg', 'g', 'defs', 'use', 'line', 'polyline', 'polygon', 'rect', 'circle', 'ellipse', 'path', 'title', 'desc'];\n\t\n\t        // Tags list to includes/excludes\n\t        this.parseTags = settings.includes || this.supportedTags;\n\t        this.skipTags = settings.excludes || ['#text', '#comment']; // silent (no warning)\n\t\n\t        // User onTag callback ?\n\t        settings.onTag && this.onTag(settings.onTag, settings.onTagContext);\n\t    }\n\t\n\t    // Load raw XML string, XMLDocument, Element or File object\n\t\n\t\n\t    _createClass(Parser, [{\n\t        key: 'load',\n\t        value: function load(input) {\n\t            // Load raw XML string\n\t            if (typeof input === 'string') {\n\t                return this.loadFromString(input);\n\t            }\n\t\n\t            // Load File object\n\t            if (input instanceof File) {\n\t                return this.loadFromFile(input);\n\t            }\n\t\n\t            // Load XMLDocument object\n\t            if (input instanceof XMLDocument) {\n\t                return this.loadFromXMLDocument(input);\n\t            }\n\t\n\t            // Load Element object\n\t            if (input instanceof Element) {\n\t                return this.loadFromElement(input);\n\t            }\n\t\n\t            // Return rejected promise with an Error object\n\t            return Promise.reject(new Error('Unsupported input format.'));\n\t        }\n\t\n\t        // Load from Element object\n\t\n\t    }, {\n\t        key: 'loadFromElement',\n\t        value: function loadFromElement(input) {\n\t            var _this = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (!(input instanceof Element)) {\n\t                    reject(new Error('Input param must be a Element object.'));\n\t                }\n\t\n\t                // Parser error\n\t                if (input.nodeName === 'parsererror') {\n\t                    // FF\n\t                    reject(new Error(input.textContent));\n\t                }\n\t\n\t                if (input.nodeName === 'html' && input.getElementsByTagName('parsererror')) {\n\t                    // Chrome\n\t                    reject(new Error(input.getElementsByTagName('parsererror')[0].textContent));\n\t                }\n\t\n\t                // Set document element\n\t                _this.element = input;\n\t\n\t                // Resolve promise\n\t                resolve(input);\n\t            });\n\t        }\n\t\n\t        // Load from XMLDocument object\n\t\n\t    }, {\n\t        key: 'loadFromXMLDocument',\n\t        value: function loadFromXMLDocument(input) {\n\t            var _this2 = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (!(input instanceof XMLDocument)) {\n\t                    reject(new Error('Input param must be a XMLDocument object.'));\n\t                }\n\t\n\t                // Load from Element...\n\t                _this2.loadFromElement(input.documentElement).then(resolve).catch(reject);\n\t            });\n\t        }\n\t\n\t        // Load raw XML string\n\t\n\t    }, {\n\t        key: 'loadFromString',\n\t        value: function loadFromString(input) {\n\t            var _this3 = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (typeof input !== 'string') {\n\t                    reject(new Error('Input param must be a string.'));\n\t                }\n\t\n\t                // Parse svg editor\n\t                _this3._parseEditor(input);\n\t\n\t                // Parse string as DOM object\n\t                var parser = new DOMParser();\n\t                var XMLDoc = parser.parseFromString(input, 'text/xml');\n\t\n\t                // Load from XMLDocument...\n\t                _this3.loadFromXMLDocument(XMLDoc).then(resolve).catch(reject);\n\t            });\n\t        }\n\t\n\t        // Try to get the svg editor from input string\n\t\n\t    }, {\n\t        key: '_parseEditor',\n\t        value: function _parseEditor(input) {\n\t            // Reset editor\n\t            this.editor = {\n\t                name: 'unknown',\n\t                version: null,\n\t                fingerprint: null\n\t            };\n\t\n\t            // Fingerprint matches\n\t            var fingerprint = void 0;\n\t\n\t            // Inkscape\n\t            fingerprint = input.match(/<!-- Created with Inkscape .*-->/i);\n\t\n\t            if (fingerprint) {\n\t                this.editor.name = 'inkscape';\n\t                this.editor.fingerprint = fingerprint[0];\n\t\n\t                return this.editor;\n\t            }\n\t\n\t            // Illustrator\n\t            fingerprint = input.match(/<!-- Generator: Adobe Illustrator ([0-9\\.]+), .*-->/i);\n\t\n\t            if (fingerprint) {\n\t                this.editor.name = 'illustrator';\n\t                this.editor.version = fingerprint[1];\n\t                this.editor.fingerprint = fingerprint[0];\n\t\n\t                return this.editor;\n\t            }\n\t\n\t            // Return default\n\t            return this.editor;\n\t        }\n\t\n\t        // Load from File object\n\t\n\t    }, {\n\t        key: 'loadFromFile',\n\t        value: function loadFromFile(input) {\n\t            var _this4 = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (!(input instanceof File)) {\n\t                    reject(new Error('Input param must be a File object.'));\n\t                }\n\t\n\t                // Create file reader\n\t                var reader = new FileReader();\n\t\n\t                // Register reader events handlers\n\t                reader.onload = function (event) {\n\t                    _this4.loadFromString(event.target.result).then(resolve).catch(reject);\n\t                };\n\t\n\t                reader.onerror = function (event) {\n\t                    reject(new Error('Error reading file : ' + input.name));\n\t                };\n\t\n\t                // Finally read input file as text\n\t                reader.readAsText(input);\n\t            });\n\t        }\n\t\n\t        // Parse the (loaded) element\n\t\n\t    }, {\n\t        key: 'parse',\n\t        value: function parse(input) {\n\t            var _this5 = this;\n\t\n\t            // Reset properties\n\t            this.document = null;\n\t            this.defs = {};\n\t            this.tags = null;\n\t\n\t            // Load input if provided\n\t            if (input) {\n\t                return new Promise(function (resolve, reject) {\n\t                    _this5.load(input).then(function () {\n\t                        resolve(_this5.parse());\n\t                    }).catch(reject);\n\t                });\n\t            }\n\t\n\t            // Start parsing element\n\t            return new Promise(function (resolve, reject) {\n\t                // If no element is loaded\n\t                if (!_this5.element) {\n\t                    reject(new Error('No element is loaded, call the load method before.'));\n\t                }\n\t\n\t                // Parse the main Element (recursive)\n\t                _this5.tags = _this5._parseElement(_this5.element);\n\t\n\t                if (!_this5.tags) {\n\t                    reject(new Error('No supported tags found.'));\n\t                }\n\t\n\t                // Apply matrix (recursive)\n\t                _this5.tags.applyMatrix();\n\t\n\t                // Resolve the promise\n\t                resolve(_this5.tags);\n\t            });\n\t        }\n\t\n\t        // On tag callback\n\t\n\t    }, {\n\t        key: '_onTag',\n\t        value: function _onTag(tag) {}\n\t        //console.info('onTag:', tag)\n\t\n\t\n\t        // Register on tag callback\n\t\n\t    }, {\n\t        key: 'onTag',\n\t        value: function onTag(callback, context) {\n\t            var _this6 = this;\n\t\n\t            this._onTag = function (tag) {\n\t                return callback.call(context || _this6, tag);\n\t            };\n\t        }\n\t\n\t        // Parse the provided Element and return an Tag collection (recursive)\n\t\n\t    }, {\n\t        key: '_parseElement',\n\t        value: function _parseElement(element, parent) {\n\t            var _this7 = this;\n\t\n\t            // Create base tag object\n\t            var tag = new _tag.Tag(element, parent);\n\t\n\t            // Exluded tag ?\n\t            if (this.skipTags.indexOf(tag.name) !== -1) {\n\t                return null; // silent\n\t            }\n\t\n\t            // Supported tag ?\n\t            if (this.parseTags.indexOf(tag.name) === -1) {\n\t                return this._skipTag(tag, 'unsupported');\n\t            }\n\t\n\t            // Parse the tag\n\t            var tagParser = new _tagparser.TagParser(tag, this);\n\t\n\t            if (!tagParser.parse()) {\n\t                return false;\n\t            }\n\t\n\t            // Call the on tag callback\n\t            this._onTag(tag);\n\t\n\t            // Parse child nodes\n\t            var childTag = void 0;\n\t\n\t            element.childNodes.forEach(function (childNode) {\n\t                // Parse child element\n\t                if (childTag = _this7._parseElement(childNode, tag)) {\n\t                    tag.addChild(childTag);\n\t                }\n\t            });\n\t\n\t            // Empty group\n\t            if (['svg', 'g'].indexOf(tag.name) !== -1 && !tag.children.length) {\n\t                return this._skipTag(tag, 'empty');\n\t            }\n\t\n\t            // Return tag object\n\t            return tag;\n\t        }\n\t\n\t        // Log skip tag warning message\n\t\n\t    }, {\n\t        key: '_skipTag',\n\t        value: function _skipTag(tag, message) {\n\t            console.warn('Skip tag :', message + ':', tag);\n\t            return false;\n\t        }\n\t\n\t        // Log skip tag attribute warning message\n\t\n\t    }, {\n\t        key: '_skipTagAttr',\n\t        value: function _skipTagAttr(tag, attr, message) {\n\t            console.warn('Skip tag attribute :', message + ':', attr, tag);\n\t            return false;\n\t        }\n\t    }]);\n\t\n\t    return Parser;\n\t}();\n\t\n\t// Exports\n\t\n\t\n\texports.Parser = Parser;\n\texports.default = Parser;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.Tag = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _lw = __webpack_require__(1);\n\t\n\tvar _clipperLib = __webpack_require__(5);\n\t\n\tvar _clipperLib2 = _interopRequireDefault(_clipperLib);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar DEG_TO_RAD = Math.PI / 180;\n\t\n\t// SVG tag class\n\t\n\tvar Tag = function () {\n\t    // Class constructor...\n\t    function Tag(element, parent) {\n\t        var _this = this;\n\t\n\t        _classCallCheck(this, Tag);\n\t\n\t        // Init properties\n\t        this.element = element;\n\t        this.name = element.nodeName.toLowerCase();\n\t        this.parent = parent || null;\n\t        this.layer = null;\n\t        this.attrs = {};\n\t        this.children = [];\n\t        this.paths = [];\n\t        this.matrix = null;\n\t        this.path = new _lw.Path();\n\t        this.point = new _lw.Point(0, 0);\n\t        this.shapes = [];\n\t\n\t        // Add first path\n\t        this.paths.push(this.path);\n\t\n\t        // Set the matrix\n\t        this.setMatrix(this.parent && this.parent.matrix);\n\t\n\t        // Clone parent attributes\n\t        if (this.parent && (this.parent.name === 'g' || this.parent.name === 'svg')) {\n\t            (function () {\n\t                // Inherit layer name\n\t                _this.layer = _this.parent.layer;\n\t\n\t                // Inherit parent attributes\n\t                var excludes = ['transform', 'width', 'height'];\n\t\n\t                Object.keys(_this.parent.attrs).forEach(function (key) {\n\t                    if (excludes.indexOf(key) === -1) {\n\t                        _this.setAttr(key, _this.parent.attrs[key]);\n\t                    }\n\t                });\n\t            })();\n\t        }\n\t    }\n\t\n\t    _createClass(Tag, [{\n\t        key: 'setAttr',\n\t        value: function setAttr(name, value) {\n\t            this.attrs[name] = value;\n\t        }\n\t    }, {\n\t        key: 'getAttr',\n\t        value: function getAttr(name, defaultValue) {\n\t            return this.attrs[name] !== undefined ? this.attrs[name] : defaultValue !== undefined ? defaultValue : null;\n\t        }\n\t    }, {\n\t        key: 'getLayerName',\n\t        value: function getLayerName() {\n\t            if (this.name === 'g') {\n\t                return this.getAttr('inkscape:label', this.getAttr('id', null));\n\t            }\n\t        }\n\t    }, {\n\t        key: 'setLayerName',\n\t        value: function setLayerName(name) {\n\t            if (this.name === 'g') {\n\t                this.layer = name || this.getLayerName();\n\t            }\n\t        }\n\t    }, {\n\t        key: 'addChild',\n\t        value: function addChild(childTag) {\n\t            this.children.push(childTag);\n\t        }\n\t    }, {\n\t        key: 'clearPath',\n\t        value: function clearPath() {\n\t            this.path = new _lw.Path();\n\t        }\n\t    }, {\n\t        key: 'newPath',\n\t        value: function newPath() {\n\t            if (this.path.length > 0) {\n\t                this.clearPath();\n\t                this.paths.push(this.path);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'closePath',\n\t        value: function closePath() {\n\t            return this.path.close();\n\t        }\n\t    }, {\n\t        key: 'addPoint',\n\t        value: function addPoint(x, y, relative) {\n\t            // Relative from the last point\n\t            if (relative) {\n\t                x += this.point.x;\n\t                y += this.point.y;\n\t            }\n\t\n\t            // Add current point\n\t            this.path.addPoint(x, y);\n\t\n\t            // Update current point\n\t            this.point = this.path.getPoint(-1);\n\t        }\n\t    }, {\n\t        key: 'addPoints',\n\t        value: function addPoints(points, relative) {\n\t            // For each couple of points\n\t            for (var i = 0, il = points.length; i < il; i += 2) {\n\t                this.addPoint(points[i], points[i + 1], relative);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'setMatrix',\n\t        value: function setMatrix(matrix) {\n\t            this.matrix = matrix || [1, 0, 0, 1, 0, 0];\n\t        }\n\t    }, {\n\t        key: 'addMatrix',\n\t        value: function addMatrix(matrix) {\n\t            this.matrix = [this.matrix[0] * matrix[0] + this.matrix[2] * matrix[1], this.matrix[1] * matrix[0] + this.matrix[3] * matrix[1], this.matrix[0] * matrix[2] + this.matrix[2] * matrix[3], this.matrix[1] * matrix[2] + this.matrix[3] * matrix[3], this.matrix[0] * matrix[4] + this.matrix[2] * matrix[5] + this.matrix[4], this.matrix[1] * matrix[4] + this.matrix[3] * matrix[5] + this.matrix[5]];\n\t        }\n\t    }, {\n\t        key: 'translate',\n\t        value: function translate(x, y) {\n\t            y = y === undefined ? 0 : y;\n\t            this.addMatrix([1, 0, 0, 1, x, y]);\n\t        }\n\t    }, {\n\t        key: 'rotate',\n\t        value: function rotate(angle, x, y) {\n\t            angle = angle * DEG_TO_RAD;\n\t\n\t            if (arguments.length == 2) {\n\t                this.addMatrix([1, 0, 0, 1, x, y]);\n\t            }\n\t\n\t            this.addMatrix([Math.cos(angle), Math.sin(angle), -Math.sin(angle), Math.cos(angle), 0, 0]);\n\t\n\t            if (arguments.length == 2) {\n\t                this.addMatrix([1, 0, 0, 1, -x, -y]);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'scale',\n\t        value: function scale(x, y) {\n\t            y = y === undefined ? x : y;\n\t            this.addMatrix([x, 0, 0, y, 0, 0]);\n\t        }\n\t    }, {\n\t        key: 'skewX',\n\t        value: function skewX(angle) {\n\t            this.addMatrix([1, 0, Math.tan(angle * DEG_TO_RAD), 1, 0, 0]);\n\t        }\n\t    }, {\n\t        key: 'skewY',\n\t        value: function skewY(angle) {\n\t            this.addMatrix([1, Math.tan(angle * DEG_TO_RAD), 0, 1, 0, 0]);\n\t        }\n\t    }, {\n\t        key: 'applyMatrix',\n\t        value: function applyMatrix(matrix) {\n\t            var _this2 = this;\n\t\n\t            matrix && this.addMatrix(matrix);\n\t\n\t            this.paths.forEach(function (path) {\n\t                path.transform(_this2.matrix);\n\t            });\n\t\n\t            this.shapes.forEach(function (shape) {\n\t                shape.outer.transform(_this2.matrix);\n\t                shape.holes.forEach(function (hole) {\n\t                    hole.transform(_this2.matrix);\n\t                });\n\t            });\n\t\n\t            this.setMatrix(null);\n\t\n\t            this.children.forEach(function (tag) {\n\t                tag.applyMatrix(matrix);\n\t            });\n\t        }\n\t    }, {\n\t        key: 'getPaths',\n\t        value: function getPaths() {\n\t            return this.paths;\n\t        }\n\t    }, {\n\t        key: 'getShapes',\n\t        value: function getShapes() {\n\t            // No shapes...\n\t            if (this.getAttr('fill', 'none') === 'none' || !this.paths[0].length) {\n\t                return this.shapes;\n\t            }\n\t\n\t            // Get fill rule\n\t            var fillRule = this.getAttr('fill-rule', 'nonzero');\n\t            fillRule = fillRule === 'nonzero' ? _clipperLib2.default.PolyFillType.pftNonZero : _clipperLib2.default.PolyFillType.pftEvenOdd;\n\t\n\t            // Create clipper path\n\t            var cPolyTree = new _clipperLib2.default.PolyTree();\n\t            var cClipper = new _clipperLib2.default.Clipper();\n\t            var clipperScale = 10000000;\n\t            var clipperPaths = [];\n\t\n\t            this.paths.forEach(function (path) {\n\t                clipperPaths.push(path.getClipperPoints(clipperScale));\n\t            });\n\t\n\t            cClipper.AddPaths(clipperPaths, _clipperLib2.default.PolyType.ptSubject, true);\n\t            cClipper.Execute(_clipperLib2.default.ClipType.ctUnion, cPolyTree, fillRule, fillRule);\n\t\n\t            var paths = _clipperLib2.default.Clipper.PolyTreeToPaths(cPolyTree);\n\t            var polygones = _clipperLib2.default.Clipper.SimplifyPolygons(paths, fillRule);\n\t\n\t            // Single path (no hole)\n\t            if (this.paths.length > 1) {\n\t                cClipper.Clear();\n\t                cClipper.StrictlySimple = true;\n\t                cPolyTree = new _clipperLib2.default.PolyTree();\n\t                cClipper.AddPaths(polygones, _clipperLib2.default.PolyType.ptSubject, true);\n\t                cClipper.Execute(_clipperLib2.default.ClipType.ctUnion, cPolyTree, fillRule, fillRule);\n\t            }\n\t\n\t            // PolyTree to ExPolygons\n\t            var toPath = function toPath(path) {\n\t                return new _lw.Path().fromClipperPoints(path, 1 / clipperScale);\n\t            };\n\t            var exPolygons = _clipperLib2.default.JS.PolyTreeToExPolygons(cPolyTree);\n\t            this.shapes = exPolygons.map(function (exPolygon) {\n\t                return {\n\t                    outer: toPath(exPolygon.outer),\n\t                    holes: exPolygon.holes.map(toPath)\n\t                };\n\t            });\n\t\n\t            // Return shapes...\n\t            return this.shapes;\n\t        }\n\t    }]);\n\t\n\t    return Tag;\n\t}();\n\t\n\t// Exports\n\t\n\t\n\texports.Tag = Tag;\n\texports.default = Tag;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.TagParser = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _lw = __webpack_require__(6);\n\t\n\tvar _lw2 = __webpack_require__(1);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t// SVG tag parser\n\tvar TagParser = function () {\n\t    // Class constructor...\n\t    function TagParser(tag, parser) {\n\t        _classCallCheck(this, TagParser);\n\t\n\t        // Init properties\n\t        this.tag = tag;\n\t        this.parser = parser;\n\t        this.currentCommand = null;\n\t        this.lastCommand = null;\n\t        this.pathData = null;\n\t        this.traceSettings = parser.traceSettings;\n\t    }\n\t\n\t    _createClass(TagParser, [{\n\t        key: 'parse',\n\t        value: function parse() {\n\t            // Get internal parser from node name\n\t            var handler = this['_' + this.tag.name];\n\t\n\t            // Implemented tag handler?\n\t            if (!handler || typeof handler !== 'function') {\n\t                return this.parser._skipTag(this.tag, 'not yet implemented');\n\t            }\n\t\n\t            // Parse tag attributes\n\t            this._parseTagAttrs();\n\t\n\t            // Parse tag\n\t            return handler.call(this);\n\t        }\n\t\n\t        // Parse the tag attributes\n\t\n\t    }, {\n\t        key: '_parseTagAttrs',\n\t        value: function _parseTagAttrs() {\n\t            var _this = this;\n\t\n\t            // Get tag attributes\n\t            var attrs = this.tag.element.attributes;\n\t\n\t            if (!attrs) {\n\t                return null;\n\t            }\n\t\n\t            // For each attribute\n\t            var attr = void 0,\n\t                value = void 0,\n\t                style = void 0;\n\t\n\t            Object.keys(attrs).some(function (key) {\n\t                // Current attribute\n\t                attr = attrs[key];\n\t\n\t                // Normalize attribute value\n\t                value = _this._normalizeTagAttr(attr);\n\t\n\t                if (value === false) {\n\t                    return false; // continue\n\t                }\n\t\n\t                // Special case\n\t                if (attr.nodeName === 'style') {\n\t                    style = value;\n\t                } else {\n\t                    // Set new attribute name/value\n\t                    _this.tag.setAttr(attr.nodeName, value);\n\t                }\n\t            });\n\t\n\t            // If style attribute (override tag attributes)\n\t            // TODO get/parse global style and override this one...\n\t            style && style.replace(/;$/, '').split(';').some(function (attr) {\n\t                // Current style\n\t                attr = attr.split(':');\n\t                attr = { nodeName: attr[0], nodeValue: attr[1] };\n\t\n\t                // Normalize attribute value\n\t                value = _this._normalizeTagAttr(attr);\n\t\n\t                if (value === false) {\n\t                    return false; // continue\n\t                }\n\t\n\t                // Set new attribute name/value\n\t                _this.tag.setAttr(attr.nodeName, value);\n\t            });\n\t\n\t            // Set inherited color\n\t            var colorsAttrs = ['fill', 'stroke', 'color'];\n\t\n\t            colorsAttrs.forEach(function (attrName) {\n\t                if (_this.tag.getAttr(attrName) === 'inherit') {\n\t                    _this.tag.setAttr(attrName, _this.tag.parent.getAttr(attrName, 'none'));\n\t                }\n\t            });\n\t\n\t            // Parse viewBox attribute\n\t            this._parseViewBoxAttr();\n\t\n\t            // Parse transform attribute\n\t            this._parseTransformAttr();\n\t        }\n\t\n\t        // Normalize tag attribute\n\t\n\t    }, {\n\t        key: '_normalizeTagAttr',\n\t        value: function _normalizeTagAttr(attr) {\n\t            // Normalize whitespaces\n\t            var value = attr.nodeValue.replace(/(\\r?\\n|\\r)+/gm, ' ') // Remove all new line chars\n\t            .replace(/\\s+/gm, ' ') // Reduce multiple whitespaces\n\t            .trim(); // Remove trailing whitespaces\n\t\n\t            if (!value.length) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'empty');\n\t            }\n\t\n\t            // Filters\n\t            switch (attr.nodeName) {\n\t                // Normalize size unit -> to px\n\t                case 'x':\n\t                case 'y':\n\t                case 'x1':\n\t                case 'y1':\n\t                case 'x2':\n\t                case 'y2':\n\t                case 'r':\n\t                case 'rx':\n\t                case 'ry':\n\t                case 'cx':\n\t                case 'cy':\n\t                case 'width':\n\t                case 'height':\n\t                case 'fontSize':\n\t                case 'strokeWidth':\n\t                    value = this._normalizeTagAttrUnit(attr);\n\t                    break;\n\t\n\t                // Normalize points attribute\n\t                case 'points':\n\t                case 'viewBox':\n\t                    value = this._normalizeTagAttrPoints(attr);\n\t                    break;\n\t\n\t                // Range limit to [0 - 1]\n\t                case 'opacity':\n\t                case 'fillOpacity':\n\t                case 'strokeOpacity':\n\t                    value = this._normalizeTagAttrRange(attr, 0, 1);\n\t                    break;\n\t\n\t                case 'preserveAspectRatio':\n\t                    value = this._normalizeTagAttrPreserveAspectRatio(attr);\n\t                    break;\n\t            }\n\t\n\t            // Return normalized value\n\t            return value;\n\t        }\n\t\n\t        // Normalize attribute unit to px\n\t\n\t    }, {\n\t        key: '_normalizeTagAttrUnit',\n\t        value: function _normalizeTagAttrUnit(attr) {\n\t            var stringValue = attr.nodeValue.toLowerCase();\n\t            var floatValue = parseFloat(stringValue);\n\t\n\t            if (isNaN(floatValue)) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'only numeric value allowed');\n\t            }\n\t\n\t            if (stringValue.indexOf('mm') !== -1) {\n\t                return floatValue * 3.5433070869;\n\t            }\n\t\n\t            if (stringValue.indexOf('cm') !== -1) {\n\t                return floatValue * 35.433070869;\n\t            }\n\t\n\t            if (stringValue.indexOf('in') !== -1) {\n\t                return floatValue * 90.0;\n\t            }\n\t\n\t            if (stringValue.indexOf('pt') !== -1) {\n\t                return floatValue * 1.25;\n\t            }\n\t\n\t            if (stringValue.indexOf('pc') !== -1) {\n\t                return floatValue * 15.0;\n\t            }\n\t\n\t            return floatValue;\n\t        }\n\t\n\t        // Normalize points attribute\n\t\n\t    }, {\n\t        key: '_normalizeTagAttrPoints',\n\t        value: function _normalizeTagAttrPoints(attr) {\n\t            var points = this._parseNumbers(attr.nodeValue);\n\t\n\t            if (points === false) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'only numeric values are allowed');\n\t            }\n\t\n\t            if (!points.length) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'empty points list');\n\t            }\n\t\n\t            if (points.length % 0) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'the number of points must be even');\n\t            }\n\t\n\t            return points;\n\t        }\n\t\n\t        // Normalize range attribute like \"opacity\"\n\t\n\t    }, {\n\t        key: '_normalizeTagAttrRange',\n\t        value: function _normalizeTagAttrRange(attr, min, max) {\n\t            var stringValue = attr.nodeValue.trim();\n\t            var floatValue = parseFloat(stringValue);\n\t\n\t            if (isNaN(floatValue)) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'only numeric values are allowed');\n\t            }\n\t\n\t            if (floatValue < min || floatValue > max) {\n\t                return this.parser._skipTagAttr(this.tag, attr, 'out of range [' + min + ', ' + max + ']');\n\t            }\n\t\n\t            return floatValue;\n\t        }\n\t\n\t        // Parse points string as numbers array\n\t\n\t    }, {\n\t        key: '_parseNumbers',\n\t        value: function _parseNumbers(points) {\n\t            // http://stackoverflow.com/questions/638565/parsing-scientific-notation-sensibly\n\t            if (typeof points === 'string') {\n\t                points = points.split(/([+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)?/g).filter(function (point) {\n\t                    return point && ['', ','].indexOf(point.trim()) === -1;\n\t                });\n\t            }\n\t\n\t            // Normalize to float values\n\t            points = points.map(parseFloat);\n\t\n\t            // Test if all numbers is valid\n\t            if (points.some(isNaN)) {\n\t                return false;\n\t            }\n\t\n\t            return points;\n\t        }\n\t\n\t        // Normalize the preserveAspectRatio attribute\n\t\n\t    }, {\n\t        key: '_normalizeTagAttrPreserveAspectRatio',\n\t        value: function _normalizeTagAttrPreserveAspectRatio(attr) {\n\t            var params = {\n\t                defer: false,\n\t                align: 'none',\n\t                meet: true,\n\t                slice: false\n\t            };\n\t\n\t            var rawParams = attr.nodeValue;\n\t\n\t            if (rawParams.indexOf('defer') === 0) {\n\t                rawParams = rawParams.substr(6);\n\t                params.defer = true;\n\t            }\n\t\n\t            rawParams = rawParams.split(' ');\n\t            params.align = rawParams[0];\n\t            params.meet = rawParams[1] || 'meet';\n\t            params.meet = params.meet === 'meet';\n\t            params.slice = !params.meet;\n\t\n\t            return params;\n\t        }\n\t\n\t        // Parse viewBox attribute and set transformations\n\t\n\t    }, {\n\t        key: '_parseViewBoxAttr',\n\t        value: function _parseViewBoxAttr() {\n\t            // Get viewBox attribute\n\t            var viewBox = this.tag.getAttr('viewBox', null);\n\t\n\t            // No viewBox...\n\t            if (viewBox === null) {\n\t                return null;\n\t            }\n\t\n\t            // Update size attributes\n\t            var width = this.tag.getAttr('width', viewBox[2]);\n\t            var height = this.tag.getAttr('height', viewBox[3]);\n\t\n\t            this.tag.setAttr('width', width);\n\t            this.tag.setAttr('height', height);\n\t\n\t            // Scale to match viewBox\n\t            // TODO clip path if preserveAspectRatio.slice\n\t            var scaleX = width / viewBox[2];\n\t            var scaleY = height / viewBox[3];\n\t            var translateX = viewBox[0];\n\t            var translateY = viewBox[1];\n\t\n\t            var preserveAspectRatio = this.tag.getAttr('preserveAspectRatio', 'meet xMidYMid');\n\t\n\t            if (preserveAspectRatio) {\n\t                var newWidth = void 0,\n\t                    newHeight = void 0;\n\t\n\t                if (preserveAspectRatio.meet) {\n\t                    if (scaleX > scaleY) {\n\t                        scaleX = scaleY;\n\t                        newWidth = viewBox[2] * scaleX;\n\t                    } else if (scaleX < scaleY) {\n\t                        scaleY = scaleX;\n\t                        newHeight = viewBox[3] * scaleY;\n\t                    }\n\t                } else if (preserveAspectRatio.slice) {\n\t                    if (scaleX < scaleY) {\n\t                        scaleX = scaleY;\n\t                        newWidth = viewBox[2] * scaleX;\n\t                    } else if (scaleX > scaleY) {\n\t                        scaleY = scaleX;\n\t                        newHeight = viewBox[3] * scaleY;\n\t                    }\n\t                }\n\t\n\t                if (newWidth !== undefined) {\n\t                    if (preserveAspectRatio.align === 'xMidYMid') {\n\t                        this.tag.translate((width - newWidth) / 2, 0);\n\t                    } else if (preserveAspectRatio.align === 'xMaxYMax') {\n\t                        this.tag.translate(width - newWidth, 0);\n\t                    }\n\t                } else if (newHeight !== undefined) {\n\t                    if (preserveAspectRatio.align === 'xMidYMid') {\n\t                        this.tag.translate(0, (height - newHeight) / 2);\n\t                    } else if (preserveAspectRatio.align === 'xMaxYMax') {\n\t                        this.tag.translate(0, height - newHeight);\n\t                    }\n\t                }\n\t            }\n\t\n\t            this.tag.scale(scaleX, scaleY);\n\t            this.tag.translate(-translateX, -translateY);\n\t        }\n\t\n\t        // Parse transform attribute and set transformations\n\t\n\t    }, {\n\t        key: '_parseTransformAttr',\n\t        value: function _parseTransformAttr() {\n\t            var _this2 = this;\n\t\n\t            // Get transform attribute\n\t            var transformAttr = this.tag.getAttr('transform', null);\n\t\n\t            // No transformation...\n\t            if (transformAttr === null || !transformAttr.length) {\n\t                return null;\n\t            }\n\t\n\t            // Parse attribute (split group on closing parenthesis)\n\t            var transformations = transformAttr.split(')');\n\t\n\t            // Remove last entry due to last \")\" found\n\t            transformations.pop();\n\t\n\t            // For each transformation\n\t            var transform = void 0,\n\t                type = void 0,\n\t                params = void 0;\n\t\n\t            transformations.some(function (raw) {\n\t                // Split name and value on opening parenthesis\n\t                transform = raw.split('(');\n\t\n\t                // Invalid parts number\n\t                if (transform.length !== 2) {\n\t                    return _this2.parser._skipTagAttr(_this2.tag, transformAttr, 'malformed'); // continue\n\t                }\n\t\n\t                type = transform[0].trim();\n\t\n\t                // Quik hack 1/2\n\t                var func = type;\n\t                if (func === 'matrix') {\n\t                    func = 'addMatrix';\n\t                }\n\t\n\t                // Get tag transform method\n\t                var tagTransform = _this2.tag[func];\n\t\n\t                if (typeof tagTransform !== 'function') {\n\t                    return _this2.parser._skipTagAttr(_this2.tag, transformAttr, 'unsupported transform type :' + type);\n\t                }\n\t\n\t                params = transform[1].trim();\n\t                params = _this2._parseNumbers(params);\n\t\n\t                // Skip empty value\n\t                if (!params.length) {\n\t                    return _this2.parser._skipTagAttr(_this2.tag, transformAttr, 'malformed transform type :' + type);\n\t                }\n\t\n\t                // Quik hack 2/2\n\t                if (func == 'addMatrix') {\n\t                    params = [params];\n\t                }\n\t\n\t                // Call tag transform method like \"tag.translate(param1, ..., paramN)\"\n\t                tagTransform.apply(_this2.tag, params);\n\t            });\n\t        }\n\t    }, {\n\t        key: '_newPath',\n\t        value: function _newPath() {\n\t            this.tag.newPath();\n\t        }\n\t    }, {\n\t        key: '_clearPath',\n\t        value: function _clearPath() {\n\t            this.tag.clearPath();\n\t        }\n\t    }, {\n\t        key: '_closePath',\n\t        value: function _closePath() {\n\t            return this.tag.closePath();\n\t        }\n\t    }, {\n\t        key: '_addPoints',\n\t        value: function _addPoints(points, relative) {\n\t            if (!points.length) {\n\t                return this.parser._skipTag(this.tag, 'empty points list');\n\t            }\n\t\n\t            if (points.length % 0) {\n\t                return this.parser._skipTag(this.tag, 'the number of points must be even');\n\t            }\n\t\n\t            relative = arguments.length < 2 && this.currentCommand.relative;\n\t\n\t            this.tag.addPoints(points, relative);\n\t            return true;\n\t        }\n\t\n\t        // SVG specs at https://www.w3.org/TR/SVG11/\n\t\n\t    }, {\n\t        key: '_svg',\n\t        value: function _svg() {\n\t            // Only parse the root SVG tag as main document\n\t            if (this.parser.document) {\n\t                // Handled tag\n\t                return true;\n\t            }\n\t\n\t            // Get the document size\n\t            var width = this.tag.getAttr('width');\n\t            var height = this.tag.getAttr('height');\n\t\n\t            // Invalid size\n\t            if (!width || width < 0 || !height || height < 0) {\n\t                throw new Error('Invalid document size: ' + width + ' / ' + height);\n\t            }\n\t\n\t            // Set document size\n\t            this.parser.document = {\n\t                width: width,\n\t                height: height\n\t            };\n\t\n\t            // Get document viewBox or set default to document size\n\t            var viewBox = this.tag.getAttr('viewBox', [0, 0, width, height]);\n\t\n\t            this.parser.document.viewBox = {\n\t                x: viewBox[0],\n\t                y: viewBox[1],\n\t                width: viewBox[2],\n\t                height: viewBox[3]\n\t            };\n\t\n\t            // Check inkscape version\n\t            if (this.parser.editor.name === 'inkscape') {\n\t                this.parser.editor.version = this.tag.getAttr('inkscape:version');\n\t            }\n\t\n\t            // Handled tag\n\t            return true;\n\t        }\n\t    }, {\n\t        key: '_title',\n\t        value: function _title() {\n\t            // Register the first encountered title tag as document title\n\t            if (this.parser.document && !this.parser.document.title) {\n\t                this.parser.document.title = this.tag.element.textContent;\n\t            }\n\t\n\t            // Skipped tag\n\t            return false;\n\t        }\n\t    }, {\n\t        key: '_desc',\n\t        value: function _desc() {\n\t            // Register the first encountered desc tag as document description\n\t            if (this.parser.document && !this.parser.document.description) {\n\t                this.parser.document.description = this.tag.element.textContent;\n\t            }\n\t\n\t            // Skipped tag\n\t            return false;\n\t        }\n\t    }, {\n\t        key: '_defs',\n\t        value: function _defs() {\n\t            var _this3 = this;\n\t\n\t            // Register all child element with an id attribute\n\t            this.tag.element.childNodes.forEach(function (childNode) {\n\t                childNode.id && (_this3.parser.defs[childNode.id] = childNode);\n\t            });\n\t\n\t            // Skipped tag\n\t            return false;\n\t        }\n\t    }, {\n\t        key: '_use',\n\t        value: function _use() {\n\t            // Get the target id\n\t            var target = this.tag.getAttr('xlink:href').replace(/^#/, '');\n\t\n\t            // Try to get the defined element\n\t            var element = this.parser.defs[target];\n\t\n\t            if (!element) {\n\t                return this.parser._skipTag(this.tag, 'undefined reference [' + target + ']');\n\t            }\n\t\n\t            // Parse the defined element and set new parent from <use> tag parent\n\t            var useTag = this.parser._parseElement(element, this.tag.parent);\n\t\n\t            if (!useTag) {\n\t                return this.parser._skipTag(this.tag, 'empty reference [' + target + ']');\n\t            }\n\t\n\t            // Set matrix from real parent (<use>)\n\t            useTag.setMatrix(this.tag.matrix);\n\t\n\t            // Replace the use tag with new one\n\t            this.tag.parent.addChild(useTag);\n\t\n\t            // Skipped tag\n\t            return false;\n\t        }\n\t    }, {\n\t        key: '_g',\n\t        value: function _g() {\n\t            // Set the tag layer name\n\t            this.tag.setLayerName();\n\t\n\t            // Handled tag\n\t            return true;\n\t        }\n\t    }, {\n\t        key: '_line',\n\t        value: function _line() {\n\t            // Handled tag\n\t            return this._path(['M', this.tag.getAttr('x1'), this.tag.getAttr('y1'), 'L', this.tag.getAttr('x2'), this.tag.getAttr('y2')]);\n\t        }\n\t    }, {\n\t        key: '_polyline',\n\t        value: function _polyline() {\n\t            var close = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\t\n\t            var points = this.tag.getAttr('points');\n\t            var path = ['M', points.shift(), points.shift(), 'L'];\n\t\n\t            path = path.concat(points);\n\t            close && path.push('Z');\n\t\n\t            // Handled tag\n\t            return this._path(path);\n\t        }\n\t    }, {\n\t        key: '_polygon',\n\t        value: function _polygon() {\n\t            // Handled like polyline but closed\n\t            return this._polyline(true);\n\t        }\n\t    }, {\n\t        key: '_rect',\n\t        value: function _rect() {\n\t            // Get rectangle attributes\n\t            var w = this.tag.getAttr('width');\n\t            var h = this.tag.getAttr('height');\n\t            var x = this.tag.getAttr('x', 0);\n\t            var y = this.tag.getAttr('y', 0);\n\t            var rx = this.tag.getAttr('rx', null);\n\t            var ry = this.tag.getAttr('ry', null);\n\t\n\t            // Simple rect\n\t            if (!rx && !ry) {\n\t                // Handled tag\n\t                return this._path(['M', x, y, 'h', w, 'v', h, 'h', -w, 'z']);\n\t            }\n\t\n\t            // If a properly specified value is provided for rx, but not for ry,\n\t            // then set both rx and ry to the value of rx and vis-vera...\n\t            if (rx === null) rx = ry;\n\t            if (ry === null) ry = rx;\n\t\n\t            // A negative value is an error\n\t            if (rx === null || rx === null || rx < 0 || ry < 0) {\n\t                // Skip tag\n\t                return this.parser._skipTag(this.tag, 'negative value for \"rx/ry\" not allowed');\n\t            }\n\t\n\t            // If rx is greater than half of width, then set rx to half of width.\n\t            // If ry is greater than half of height, then set ry to half of height.\n\t            if (rx > w / 2) rx = w / 2;\n\t            if (ry > h / 2) ry = h / 2;\n\t\n\t            var dx = rx * 2;\n\t            var dy = ry * 2;\n\t\n\t            // Handled tag\n\t            return this._path(['M', x + rx, y, 'h', w - dx, 'c', rx, 0, rx, ry, rx, ry, 'v', h - dy, 'c', 0, ry, -rx, ry, -rx, ry, 'h', -w + dx, 'c', -rx, 0, -rx, -ry, -rx, -ry, 'v', -h + dy, 'c', 0, 0, 0, -ry, rx, -ry, 'z']);\n\t        }\n\t    }, {\n\t        key: '_circle',\n\t        value: function _circle() {\n\t            var r = this.tag.getAttr('r', 0);\n\t\n\t            if (r <= 0) {\n\t                // Skipped tag\n\t                return false;\n\t            }\n\t\n\t            var cx = this.tag.getAttr('cx', 0);\n\t            var cy = this.tag.getAttr('cy', 0);\n\t\n\t            // Handled tag\n\t            return this._path(['M', cx - r, cy, 'A', r, r, 0, 0, 0, cx, cy + r, 'A', r, r, 0, 0, 0, cx + r, cy, 'A', r, r, 0, 0, 0, cx, cy - r, 'A', r, r, 0, 0, 0, cx - r, cy, 'Z']);\n\t        }\n\t    }, {\n\t        key: '_ellipse',\n\t        value: function _ellipse() {\n\t            var rx = this.tag.getAttr('rx', 0);\n\t            var ry = this.tag.getAttr('ry', 0);\n\t\n\t            if (rx <= 0 || ry <= 0) {\n\t                // Skipped tag\n\t                return false;\n\t            }\n\t\n\t            var cx = this.tag.getAttr('cx', 0);\n\t            var cy = this.tag.getAttr('cy', 0);\n\t\n\t            // Handled tag\n\t            return this._path(['M', cx - rx, cy, 'A', rx, ry, 0, 0, 0, cx, cy + ry, 'A', rx, ry, 0, 0, 0, cx + rx, cy, 'A', rx, ry, 0, 0, 0, cx, cy - ry, 'A', rx, ry, 0, 0, 0, cx - rx, cy, 'Z']);\n\t        }\n\t    }, {\n\t        key: '_paths',\n\t        value: function _paths(type, num, points) {\n\t            if (points.length > num) {\n\t                var handler = void 0,\n\t                    result = true;\n\t\n\t                while (result && points.length) {\n\t                    handler = this['_path' + type];\n\t                    result = handler.call(this, points.splice(0, num));\n\t                }\n\t\n\t                return result;\n\t            }\n\t\n\t            return null;\n\t        }\n\t    }, {\n\t        key: '_path',\n\t        value: function _path(path) {\n\t            var _this4 = this;\n\t\n\t            // Provided path\n\t            if (path && typeof path !== 'string') {\n\t                path = path.join(' ');\n\t            }\n\t\n\t            // Get the paths data attribute value\n\t            var dAttr = path || this.tag.getAttr('d', null);\n\t\n\t            if (!dAttr) {\n\t                // Skipped tag\n\t                return false;\n\t            }\n\t\n\t            // Split on each commands\n\t            var commands = dAttr.match(/([M|Z|L|H|V|C|S|Q|T|A]+([^M|Z|L|H|V|C|S|Q|T|A]+)?)/gi);\n\t\n\t            if (!commands) {\n\t                return this.parser._skipTag(this.tag, 'malformed \"d\" attribute');\n\t            }\n\t\n\t            // For each command...\n\t            this.currentCommand = {\n\t                raw: null,\n\t                type: null,\n\t                params: null,\n\t                relative: null\n\t            };\n\t            this.lastCommand = this.currentCommand;\n\t            this.pathData = {};\n\t\n\t            var handler = null;\n\t            var parseError = false;\n\t\n\t            commands.some(function (raw) {\n\t                // Remove trailing whitespaces\n\t                raw = raw.trim();\n\t\n\t                // Extract command char and params\n\t                _this4.currentCommand.raw = raw;\n\t                _this4.currentCommand.type = raw[0].toUpperCase();\n\t                _this4.currentCommand.params = raw.substr(1).trim();\n\t                _this4.currentCommand.relative = _this4.currentCommand.type !== raw[0];\n\t\n\t                // Get path handler from command char\n\t                handler = _this4['_path' + _this4.currentCommand.type];\n\t\n\t                if (!handler || typeof handler !== 'function') {\n\t                    _this4.parser._skipTag(_this4.tag, 'unsupported path command [' + raw[0] + ']');\n\t                    return parseError = true; // break\n\t                }\n\t\n\t                // Extract all numbers from arguments string\n\t                _this4.currentCommand.params = _this4._parseNumbers(_this4.currentCommand.params);\n\t\n\t                if (_this4.currentCommand.params === false) {\n\t                    _this4.parser._skipTag(_this4.tag, 'only numeric values are allowed in [' + _this4.currentCommand.raw + ']');\n\t                    return parseError = true; // break\n\t                }\n\t\n\t                // Execute command parser\n\t                if (!handler.call(_this4, _this4.currentCommand.params)) {\n\t                    return parseError = true; // break\n\t                }\n\t\n\t                // Update last command\n\t                _this4.lastCommand = {};\n\t\n\t                Object.keys(_this4.currentCommand).forEach(function (key) {\n\t                    _this4.lastCommand[key] = _this4.currentCommand[key];\n\t                });\n\t            });\n\t\n\t            // Skip tag\n\t            if (parseError) {\n\t                this._clearPath();\n\t                return false;\n\t            }\n\t\n\t            // Handled tag\n\t            return true;\n\t        }\n\t    }, {\n\t        key: '_pathM',\n\t        value: function _pathM(points) {\n\t            // New path\n\t            this._newPath();\n\t\n\t            // Set the current point (start of new path)\n\t            // If is followed by multiple pairs of coordinates,\n\t            // the subsequent pairs are treated as implicit lineto commands.\n\t            return this._addPoints(points);\n\t        }\n\t    }, {\n\t        key: '_pathZ',\n\t        value: function _pathZ() {\n\t            this._closePath();\n\t            return true;\n\t        }\n\t    }, {\n\t        key: '_pathL',\n\t        value: function _pathL(points) {\n\t            return this._addPoints(points);\n\t        }\n\t    }, {\n\t        key: '_pathH',\n\t        value: function _pathH(points) {\n\t            var _this5 = this;\n\t\n\t            return points.every(function (x) {\n\t                return _this5._addPoints([x, _this5.currentCommand.relative ? 0 : _this5.tag.point.y]);\n\t            });\n\t        }\n\t    }, {\n\t        key: '_pathV',\n\t        value: function _pathV(points) {\n\t            var _this6 = this;\n\t\n\t            return points.every(function (y) {\n\t                return _this6._addPoints([_this6.currentCommand.relative ? 0 : _this6.tag.point.x, y]);\n\t            });\n\t        }\n\t    }, {\n\t        key: '_pathC',\n\t        value: function _pathC(points) {\n\t            // Multiple paths\n\t            var result = this._paths('C', 6, points);\n\t\n\t            if (result !== null) {\n\t                return result;\n\t            }\n\t\n\t            // Single path\n\t            var p1 = this.tag.point;\n\t            var rl = this.currentCommand.relative;\n\t\n\t            var x1 = points[0] + (rl ? p1.x : 0);\n\t            var y1 = points[1] + (rl ? p1.y : 0);\n\t            var x2 = points[2] + (rl ? p1.x : 0);\n\t            var y2 = points[3] + (rl ? p1.y : 0);\n\t            var x = points[4] + (rl ? p1.x : 0);\n\t            var y = points[5] + (rl ? p1.y : 0);\n\t\n\t            this.pathData.x2 = x2;\n\t            this.pathData.y2 = y2;\n\t\n\t            var p2 = new _lw2.Point(x1, y1);\n\t            var p3 = new _lw2.Point(x2, y2);\n\t            var p4 = new _lw2.Point(x, y);\n\t\n\t            //console.log('C', p1, p2, p3, p4)\n\t\n\t            // p1  : starting point\n\t            // p2  : control point\n\t            // p3  : control point\n\t            // p4  : end point\n\t            var tracer = new _lw.CubicBezier(this.traceSettings);\n\t            var coords = tracer.trace({ p1: p1, p2: p2, p3: p3, p4: p4 }); // => [x,y, x,y, ...]\n\t            // let tracer = trace(CubicBezier, this.traceSettings)\n\t            // let coords = tracer({ p1, p2, p3, p4 })\n\t\n\t            // Trace the line\n\t            return this._addPoints(coords, false);\n\t        }\n\t    }, {\n\t        key: '_pathS',\n\t        value: function _pathS(points) {\n\t            // Multiple paths\n\t            var result = this._paths('S', 4, points);\n\t\n\t            if (result !== null) {\n\t                return result;\n\t            }\n\t\n\t            // Single path\n\t            var p1 = this.tag.point;\n\t            var rl = this.currentCommand.relative;\n\t\n\t            var x1 = p1.x;\n\t            var y1 = p1.y;\n\t\n\t            if (this.lastCommand.type === 'S' || this.lastCommand.type === 'C') {\n\t                x1 -= this.pathData.x2 - x1;\n\t                y1 -= this.pathData.y2 - y1;\n\t            }\n\t\n\t            var x2 = points[0] + (rl ? p1.x : 0);\n\t            var y2 = points[1] + (rl ? p1.y : 0);\n\t            var x = points[2] + (rl ? p1.x : 0);\n\t            var y = points[3] + (rl ? p1.y : 0);\n\t\n\t            this.pathData.x2 = x2;\n\t            this.pathData.y2 = y2;\n\t\n\t            var p2 = new _lw2.Point(x1, y1);\n\t            var p3 = new _lw2.Point(x2, y2);\n\t            var p4 = new _lw2.Point(x, y);\n\t\n\t            //console.log('S', p1, p2, p3, p4)\n\t\n\t            // p1  : starting point\n\t            // p2  : control point\n\t            // p3  : control point\n\t            // p4  : end point\n\t            var tracer = new _lw.CubicBezier(this.traceSettings);\n\t            var coords = tracer.trace({ p1: p1, p2: p2, p3: p3, p4: p4 }); // => [x,y, x,y, ...]\n\t            // let tracer = trace(CubicBezier, this.traceSettings)\n\t            // let coords = tracer({ p1, p2, p3, p4 })\n\t\n\t            // Trace the line\n\t            return this._addPoints(coords, false);\n\t        }\n\t    }, {\n\t        key: '_pathQ',\n\t        value: function _pathQ(points) {\n\t            // Multiple paths\n\t            var result = this._paths('Q', 4, points);\n\t\n\t            if (result !== null) {\n\t                return result;\n\t            }\n\t\n\t            // Single path\n\t            var p1 = this.tag.point;\n\t            var rl = this.currentCommand.relative;\n\t\n\t            var x1 = points[0] + (rl ? p1.x : 0);\n\t            var y1 = points[1] + (rl ? p1.y : 0);\n\t            var x = points[2] + (rl ? p1.x : 0);\n\t            var y = points[3] + (rl ? p1.y : 0);\n\t\n\t            this.pathData.x1 = x1;\n\t            this.pathData.y1 = y1;\n\t\n\t            var p2 = new _lw2.Point(x1, y1);\n\t            var p3 = new _lw2.Point(x, y);\n\t\n\t            //console.log('Q', p1, p2, p3)\n\t\n\t            // p1  : starting point\n\t            // p2  : control point\n\t            // p3  : end point\n\t            var tracer = new _lw.QuadricBezier(this.traceSettings);\n\t            var coords = tracer.trace({ p1: p1, p2: p2, p3: p3 }); // => [x,y, x,y, ...]\n\t\n\t            // Trace the line\n\t            return this._addPoints(coords, false);\n\t        }\n\t    }, {\n\t        key: '_pathT',\n\t        value: function _pathT(points) {\n\t            // Multiple paths\n\t            var result = this._paths('T', 2, points);\n\t\n\t            if (result !== null) {\n\t                return result;\n\t            }\n\t\n\t            // Single path\n\t            var p1 = this.tag.point;\n\t            var rl = this.currentCommand.relative;\n\t\n\t            var x1 = p1.x;\n\t            var y1 = p1.y;\n\t\n\t            if (this.lastCommand.type === 'Q' || this.lastCommand.type === 'T') {\n\t                x1 -= this.pathData.x1 - x1;\n\t                y1 -= this.pathData.y1 - y1;\n\t            }\n\t\n\t            var x = points[0] + (rl ? p1.x : 0);\n\t            var y = points[1] + (rl ? p1.y : 0);\n\t\n\t            this.pathData.x1 = x1;\n\t            this.pathData.y1 = y1;\n\t\n\t            var p2 = new _lw2.Point(x1, y1);\n\t            var p3 = new _lw2.Point(x, y);\n\t\n\t            //console.log('T', p1, p2, p3)\n\t\n\t            // p1  : starting point\n\t            // p2  : control point\n\t            // p3  : end point\n\t            var tracer = new _lw.QuadricBezier(this.traceSettings);\n\t            var coords = tracer.trace({ p1: p1, p2: p2, p3: p3 }); // => [x,y, x,y, ...]\n\t\n\t            // Trace the line\n\t            return this._addPoints(coords, false);\n\t        }\n\t    }, {\n\t        key: '_pathA',\n\t        value: function _pathA(points) {\n\t            // Multiple paths\n\t            var result = this._paths('A', 7, points);\n\t\n\t            if (result !== null) {\n\t                return result;\n\t            }\n\t\n\t            // Single path\n\t            var rl = this.currentCommand.relative;\n\t            var p1 = this.tag.point;\n\t            var rx = points[0];\n\t            var ry = points[1];\n\t            var angle = points[2];\n\t            var large = !!points[3];\n\t            var sweep = !!points[4];\n\t            var x = points[5] + (rl ? p1.x : 0);\n\t            var y = points[6] + (rl ? p1.y : 0);\n\t            var p2 = new _lw2.Point(x, y);\n\t\n\t            //console.log('A', p1, rx, ry, angle, large, sweep, p2)\n\t\n\t            var tracer = new _lw.Arc(this.traceSettings);\n\t            var coords = tracer.trace({ p1: p1, rx: rx, ry: ry, angle: angle, large: large, sweep: sweep, p2: p2 }); // => [x,y, x,y, ...]\n\t\n\t            // Trace the line\n\t            return this._addPoints(coords, false);\n\t        }\n\t    }]);\n\t\n\t    return TagParser;\n\t}();\n\t\n\t// Exports\n\t\n\t\n\texports.TagParser = TagParser;\n\texports.default = TagParser;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;// rev 482\n\t/********************************************************************************\n\t *                                                                              *\n\t * Author    :  Angus Johnson                                                   *\n\t * Version   :  6.2.1                                                          *\n\t * Date      :  31 October 2014                                                 *\n\t * Website   :  http://www.angusj.com                                           *\n\t * Copyright :  Angus Johnson 2010-2014                                         *\n\t *                                                                              *\n\t * License:                                                                     *\n\t * Use, modification & distribution is subject to Boost Software License Ver 1. *\n\t * http://www.boost.org/LICENSE_1_0.txt                                         *\n\t *                                                                              *\n\t * Attributions:                                                                *\n\t * The code in this library is an extension of Bala Vatti's clipping algorithm: *\n\t * \"A generic solution to polygon clipping\"                                     *\n\t * Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *\n\t * http://portal.acm.org/citation.cfm?id=129906                                 *\n\t *                                                                              *\n\t * Computer graphics and geometric modeling: implementation and algorithms      *\n\t * By Max K. Agoston                                                            *\n\t * Springer; 1 edition (January 4, 2005)                                        *\n\t * http://books.google.com/books?q=vatti+clipping+agoston                       *\n\t *                                                                              *\n\t * See also:                                                                    *\n\t * \"Polygon Offsetting by Computing Winding Numbers\"                            *\n\t * Paper no. DETC2005-85513 pp. 565-575                                         *\n\t * ASME 2005 International Design Engineering Technical Conferences             *\n\t * and Computers and Information in Engineering Conference (IDETC/CIE2005)      *\n\t * September 24-28, 2005 , Long Beach, California, USA                          *\n\t * http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *\n\t *                                                                              *\n\t *******************************************************************************/\n\t/*******************************************************************************\n\t *                                                                              *\n\t * Author    :  Timo                                                            *\n\t * Version   :  6.2.1.0                                                         *\n\t * Date      :  17 June 2016                                                 *\n\t *                                                                              *\n\t * This is a translation of the C# Clipper library to Javascript.               *\n\t * Int128 struct of C# is implemented using JSBN of Tom Wu.                     *\n\t * Because Javascript lacks support for 64-bit integers, the space              *\n\t * is a little more restricted than in C# version.                              *\n\t *                                                                              *\n\t * C# version has support for coordinate space:                                 *\n\t * +-4611686018427387903 ( sqrt(2^127 -1)/2 )                                   *\n\t * while Javascript version has support for space:                              *\n\t * +-4503599627370495 ( sqrt(2^106 -1)/2 )                                      *\n\t *                                                                              *\n\t * Tom Wu's JSBN proved to be the fastest big integer library:                  *\n\t * http://jsperf.com/big-integer-library-test                                   *\n\t *                                                                              *\n\t * This class can be made simpler when (if ever) 64-bit integer support comes.  *\n\t *                                                                              *\n\t *******************************************************************************/\n\t/*******************************************************************************\n\t *                                                                              *\n\t * Basic JavaScript BN library - subset useful for RSA encryption.              *\n\t * http://www-cs-students.stanford.edu/~tjw/jsbn/                               *\n\t * Copyright (c) 2005  Tom Wu                                                   *\n\t * All Rights Reserved.                                                         *\n\t * See \"LICENSE\" for details:                                                   *\n\t * http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE                        *\n\t *                                                                              *\n\t *******************************************************************************/\n\t(function ()\n\t{\n\t  \"use strict\";\n\t  //use_int32: When enabled 32bit ints are used instead of 64bit ints. This\n\t  //improve performance but coordinate values are limited to the range +/- 46340\n\t  var use_int32 = false;\n\t  //use_xyz: adds a Z member to IntPoint. Adds a minor cost to performance.\n\t  var use_xyz = false;\n\t  //UseLines: Enables open path clipping. Adds a very minor cost to performance.\n\t  var use_lines = true;\n\t\n\t  var ClipperLib = {};\n\t  var isNode = false;\n\t  if (typeof module !== 'undefined' && module.exports)\n\t  {\n\t    module.exports = ClipperLib;\n\t    isNode = true;\n\t  }\n\t  else\n\t  {\n\t    if (true) {\n\t      !(__WEBPACK_AMD_DEFINE_FACTORY__ = (ClipperLib), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t    }\n\t    if (typeof (document) !== \"undefined\") window.ClipperLib = ClipperLib;\n\t    else self['ClipperLib'] = ClipperLib;\n\t  }\n\t  var navigator_appName;\n\t  if (!isNode)\n\t  {\n\t    var nav = navigator.userAgent.toString().toLowerCase();\n\t    navigator_appName = navigator.appName;\n\t  }\n\t  else\n\t  {\n\t    var nav = \"chrome\"; // Node.js uses Chrome's V8 engine\n\t    navigator_appName = \"Netscape\"; // Firefox, Chrome and Safari returns \"Netscape\", so Node.js should also\n\t  }\n\t  // Browser test to speedup performance critical functions\n\t  var browser = {};\n\t  if (nav.indexOf(\"chrome\") != -1 && nav.indexOf(\"chromium\") == -1) browser.chrome = 1;\n\t  else browser.chrome = 0;\n\t  if (nav.indexOf(\"chromium\") != -1) browser.chromium = 1;\n\t  else browser.chromium = 0;\n\t  if (nav.indexOf(\"safari\") != -1 && nav.indexOf(\"chrome\") == -1 && nav.indexOf(\"chromium\") == -1) browser.safari = 1;\n\t  else browser.safari = 0;\n\t  if (nav.indexOf(\"firefox\") != -1) browser.firefox = 1;\n\t  else browser.firefox = 0;\n\t  if (nav.indexOf(\"firefox/17\") != -1) browser.firefox17 = 1;\n\t  else browser.firefox17 = 0;\n\t  if (nav.indexOf(\"firefox/15\") != -1) browser.firefox15 = 1;\n\t  else browser.firefox15 = 0;\n\t  if (nav.indexOf(\"firefox/3\") != -1) browser.firefox3 = 1;\n\t  else browser.firefox3 = 0;\n\t  if (nav.indexOf(\"opera\") != -1) browser.opera = 1;\n\t  else browser.opera = 0;\n\t  if (nav.indexOf(\"msie 10\") != -1) browser.msie10 = 1;\n\t  else browser.msie10 = 0;\n\t  if (nav.indexOf(\"msie 9\") != -1) browser.msie9 = 1;\n\t  else browser.msie9 = 0;\n\t  if (nav.indexOf(\"msie 8\") != -1) browser.msie8 = 1;\n\t  else browser.msie8 = 0;\n\t  if (nav.indexOf(\"msie 7\") != -1) browser.msie7 = 1;\n\t  else browser.msie7 = 0;\n\t  if (nav.indexOf(\"msie \") != -1) browser.msie = 1;\n\t  else browser.msie = 0;\n\t  ClipperLib.biginteger_used = null;\n\t\n\t  // Copyright (c) 2005  Tom Wu\n\t  // All Rights Reserved.\n\t  // See \"LICENSE\" for details.\n\t  // Basic JavaScript BN library - subset useful for RSA encryption.\n\t  // Bits per digit\n\t  var dbits;\n\t  // JavaScript engine analysis\n\t  var canary = 0xdeadbeefcafe;\n\t  var j_lm = ((canary & 0xffffff) == 0xefcafe);\n\t  // (public) Constructor\n\t  function BigInteger(a, b, c)\n\t  {\n\t    // This test variable can be removed,\n\t    // but at least for performance tests it is useful piece of knowledge\n\t    // This is the only ClipperLib related variable in BigInteger library\n\t    ClipperLib.biginteger_used = 1;\n\t    if (a != null)\n\t      if (\"number\" == typeof a && \"undefined\" == typeof (b)) this.fromInt(a); // faster conversion\n\t      else if (\"number\" == typeof a) this.fromNumber(a, b, c);\n\t    else if (b == null && \"string\" != typeof a) this.fromString(a, 256);\n\t    else this.fromString(a, b);\n\t  }\n\t  // return new, unset BigInteger\n\t  function nbi()\n\t  {\n\t    return new BigInteger(null,undefined,undefined);\n\t  }\n\t  // am: Compute w_j += (x*this_i), propagate carries,\n\t  // c is initial carry, returns final carry.\n\t  // c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n\t  // We need to select the fastest one that works in this environment.\n\t  // am1: use a single mult and divide to get the high bits,\n\t  // max digit bits should be 26 because\n\t  // max internal value = 2*dvalue^2-2*dvalue (< 2^53)\n\t  function am1(i, x, w, j, c, n)\n\t  {\n\t    while (--n >= 0)\n\t    {\n\t      var v = x * this[i++] + w[j] + c;\n\t      c = Math.floor(v / 0x4000000);\n\t      w[j++] = v & 0x3ffffff;\n\t    }\n\t    return c;\n\t  }\n\t  // am2 avoids a big mult-and-extract completely.\n\t  // Max digit bits should be <= 30 because we do bitwise ops\n\t  // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\n\t  function am2(i, x, w, j, c, n)\n\t  {\n\t    var xl = x & 0x7fff,\n\t      xh = x >> 15;\n\t    while (--n >= 0)\n\t    {\n\t      var l = this[i] & 0x7fff;\n\t      var h = this[i++] >> 15;\n\t      var m = xh * l + h * xl;\n\t      l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);\n\t      c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);\n\t      w[j++] = l & 0x3fffffff;\n\t    }\n\t    return c;\n\t  }\n\t  // Alternately, set max digit bits to 28 since some\n\t  // browsers slow down when dealing with 32-bit numbers.\n\t  function am3(i, x, w, j, c, n)\n\t  {\n\t    var xl = x & 0x3fff,\n\t      xh = x >> 14;\n\t    while (--n >= 0)\n\t    {\n\t      var l = this[i] & 0x3fff;\n\t      var h = this[i++] >> 14;\n\t      var m = xh * l + h * xl;\n\t      l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;\n\t      c = (l >> 28) + (m >> 14) + xh * h;\n\t      w[j++] = l & 0xfffffff;\n\t    }\n\t    return c;\n\t  }\n\t  if (j_lm && (navigator_appName == \"Microsoft Internet Explorer\"))\n\t  {\n\t    BigInteger.prototype.am = am2;\n\t    dbits = 30;\n\t  }\n\t  else if (j_lm && (navigator_appName != \"Netscape\"))\n\t  {\n\t    BigInteger.prototype.am = am1;\n\t    dbits = 26;\n\t  }\n\t  else\n\t  { // Mozilla/Netscape seems to prefer am3\n\t    BigInteger.prototype.am = am3;\n\t    dbits = 28;\n\t  }\n\t  BigInteger.prototype.DB = dbits;\n\t  BigInteger.prototype.DM = ((1 << dbits) - 1);\n\t  BigInteger.prototype.DV = (1 << dbits);\n\t  var BI_FP = 52;\n\t  BigInteger.prototype.FV = Math.pow(2, BI_FP);\n\t  BigInteger.prototype.F1 = BI_FP - dbits;\n\t  BigInteger.prototype.F2 = 2 * dbits - BI_FP;\n\t  // Digit conversions\n\t  var BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\t  var BI_RC = new Array();\n\t  var rr, vv;\n\t  rr = \"0\".charCodeAt(0);\n\t  for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\n\t  rr = \"a\".charCodeAt(0);\n\t  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\t  rr = \"A\".charCodeAt(0);\n\t  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\t\n\t  function int2char(n)\n\t  {\n\t    return BI_RM.charAt(n);\n\t  }\n\t\n\t  function intAt(s, i)\n\t  {\n\t    var c = BI_RC[s.charCodeAt(i)];\n\t    return (c == null) ? -1 : c;\n\t  }\n\t  // (protected) copy this to r\n\t  function bnpCopyTo(r)\n\t  {\n\t    for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];\n\t    r.t = this.t;\n\t    r.s = this.s;\n\t  }\n\t  // (protected) set from integer value x, -DV <= x < DV\n\t  function bnpFromInt(x)\n\t  {\n\t    this.t = 1;\n\t    this.s = (x < 0) ? -1 : 0;\n\t    if (x > 0) this[0] = x;\n\t    else if (x < -1) this[0] = x + this.DV;\n\t    else this.t = 0;\n\t  }\n\t  // return bigint initialized to value\n\t  function nbv(i)\n\t  {\n\t    var r = nbi();\n\t    r.fromInt(i);\n\t    return r;\n\t  }\n\t  // (protected) set from string and radix\n\t  function bnpFromString(s, b)\n\t  {\n\t    var k;\n\t    if (b == 16) k = 4;\n\t    else if (b == 8) k = 3;\n\t    else if (b == 256) k = 8; // byte array\n\t    else if (b == 2) k = 1;\n\t    else if (b == 32) k = 5;\n\t    else if (b == 4) k = 2;\n\t    else\n\t    {\n\t      this.fromRadix(s, b);\n\t      return;\n\t    }\n\t    this.t = 0;\n\t    this.s = 0;\n\t    var i = s.length,\n\t      mi = false,\n\t      sh = 0;\n\t    while (--i >= 0)\n\t    {\n\t      var x = (k == 8) ? s[i] & 0xff : intAt(s, i);\n\t      if (x < 0)\n\t      {\n\t        if (s.charAt(i) == \"-\") mi = true;\n\t        continue;\n\t      }\n\t      mi = false;\n\t      if (sh == 0)\n\t        this[this.t++] = x;\n\t      else if (sh + k > this.DB)\n\t      {\n\t        this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;\n\t        this[this.t++] = (x >> (this.DB - sh));\n\t      }\n\t      else\n\t        this[this.t - 1] |= x << sh;\n\t      sh += k;\n\t      if (sh >= this.DB) sh -= this.DB;\n\t    }\n\t    if (k == 8 && (s[0] & 0x80) != 0)\n\t    {\n\t      this.s = -1;\n\t      if (sh > 0) this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;\n\t    }\n\t    this.clamp();\n\t    if (mi) BigInteger.ZERO.subTo(this, this);\n\t  }\n\t  // (protected) clamp off excess high words\n\t  function bnpClamp()\n\t  {\n\t    var c = this.s & this.DM;\n\t    while (this.t > 0 && this[this.t - 1] == c)--this.t;\n\t  }\n\t  // (public) return string representation in given radix\n\t  function bnToString(b)\n\t  {\n\t    if (this.s < 0) return \"-\" + this.negate().toString(b);\n\t    var k;\n\t    if (b == 16) k = 4;\n\t    else if (b == 8) k = 3;\n\t    else if (b == 2) k = 1;\n\t    else if (b == 32) k = 5;\n\t    else if (b == 4) k = 2;\n\t    else return this.toRadix(b);\n\t    var km = (1 << k) - 1,\n\t      d, m = false,\n\t      r = \"\",\n\t      i = this.t;\n\t    var p = this.DB - (i * this.DB) % k;\n\t    if (i-- > 0)\n\t    {\n\t      if (p < this.DB && (d = this[i] >> p) > 0)\n\t      {\n\t        m = true;\n\t        r = int2char(d);\n\t      }\n\t      while (i >= 0)\n\t      {\n\t        if (p < k)\n\t        {\n\t          d = (this[i] & ((1 << p) - 1)) << (k - p);\n\t          d |= this[--i] >> (p += this.DB - k);\n\t        }\n\t        else\n\t        {\n\t          d = (this[i] >> (p -= k)) & km;\n\t          if (p <= 0)\n\t          {\n\t            p += this.DB;\n\t            --i;\n\t          }\n\t        }\n\t        if (d > 0) m = true;\n\t        if (m) r += int2char(d);\n\t      }\n\t    }\n\t    return m ? r : \"0\";\n\t  }\n\t  // (public) -this\n\t  function bnNegate()\n\t  {\n\t    var r = nbi();\n\t    BigInteger.ZERO.subTo(this, r);\n\t    return r;\n\t  }\n\t  // (public) |this|\n\t  function bnAbs()\n\t  {\n\t    return (this.s < 0) ? this.negate() : this;\n\t  }\n\t  // (public) return + if this > a, - if this < a, 0 if equal\n\t  function bnCompareTo(a)\n\t  {\n\t    var r = this.s - a.s;\n\t    if (r != 0) return r;\n\t    var i = this.t;\n\t    r = i - a.t;\n\t    if (r != 0) return (this.s < 0) ? -r : r;\n\t    while (--i >= 0)\n\t      if ((r = this[i] - a[i]) != 0) return r;\n\t    return 0;\n\t  }\n\t  // returns bit length of the integer x\n\t  function nbits(x)\n\t  {\n\t    var r = 1,\n\t      t;\n\t    if ((t = x >>> 16) != 0)\n\t    {\n\t      x = t;\n\t      r += 16;\n\t    }\n\t    if ((t = x >> 8) != 0)\n\t    {\n\t      x = t;\n\t      r += 8;\n\t    }\n\t    if ((t = x >> 4) != 0)\n\t    {\n\t      x = t;\n\t      r += 4;\n\t    }\n\t    if ((t = x >> 2) != 0)\n\t    {\n\t      x = t;\n\t      r += 2;\n\t    }\n\t    if ((t = x >> 1) != 0)\n\t    {\n\t      x = t;\n\t      r += 1;\n\t    }\n\t    return r;\n\t  }\n\t  // (public) return the number of bits in \"this\"\n\t  function bnBitLength()\n\t  {\n\t    if (this.t <= 0) return 0;\n\t    return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));\n\t  }\n\t  // (protected) r = this << n*DB\n\t  function bnpDLShiftTo(n, r)\n\t  {\n\t    var i;\n\t    for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];\n\t    for (i = n - 1; i >= 0; --i) r[i] = 0;\n\t    r.t = this.t + n;\n\t    r.s = this.s;\n\t  }\n\t  // (protected) r = this >> n*DB\n\t  function bnpDRShiftTo(n, r)\n\t  {\n\t    for (var i = n; i < this.t; ++i) r[i - n] = this[i];\n\t    r.t = Math.max(this.t - n, 0);\n\t    r.s = this.s;\n\t  }\n\t  // (protected) r = this << n\n\t  function bnpLShiftTo(n, r)\n\t  {\n\t    var bs = n % this.DB;\n\t    var cbs = this.DB - bs;\n\t    var bm = (1 << cbs) - 1;\n\t    var ds = Math.floor(n / this.DB),\n\t      c = (this.s << bs) & this.DM,\n\t      i;\n\t    for (i = this.t - 1; i >= 0; --i)\n\t    {\n\t      r[i + ds + 1] = (this[i] >> cbs) | c;\n\t      c = (this[i] & bm) << bs;\n\t    }\n\t    for (i = ds - 1; i >= 0; --i) r[i] = 0;\n\t    r[ds] = c;\n\t    r.t = this.t + ds + 1;\n\t    r.s = this.s;\n\t    r.clamp();\n\t  }\n\t  // (protected) r = this >> n\n\t  function bnpRShiftTo(n, r)\n\t  {\n\t    r.s = this.s;\n\t    var ds = Math.floor(n / this.DB);\n\t    if (ds >= this.t)\n\t    {\n\t      r.t = 0;\n\t      return;\n\t    }\n\t    var bs = n % this.DB;\n\t    var cbs = this.DB - bs;\n\t    var bm = (1 << bs) - 1;\n\t    r[0] = this[ds] >> bs;\n\t    for (var i = ds + 1; i < this.t; ++i)\n\t    {\n\t      r[i - ds - 1] |= (this[i] & bm) << cbs;\n\t      r[i - ds] = this[i] >> bs;\n\t    }\n\t    if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;\n\t    r.t = this.t - ds;\n\t    r.clamp();\n\t  }\n\t  // (protected) r = this - a\n\t  function bnpSubTo(a, r)\n\t  {\n\t    var i = 0,\n\t      c = 0,\n\t      m = Math.min(a.t, this.t);\n\t    while (i < m)\n\t    {\n\t      c += this[i] - a[i];\n\t      r[i++] = c & this.DM;\n\t      c >>= this.DB;\n\t    }\n\t    if (a.t < this.t)\n\t    {\n\t      c -= a.s;\n\t      while (i < this.t)\n\t      {\n\t        c += this[i];\n\t        r[i++] = c & this.DM;\n\t        c >>= this.DB;\n\t      }\n\t      c += this.s;\n\t    }\n\t    else\n\t    {\n\t      c += this.s;\n\t      while (i < a.t)\n\t      {\n\t        c -= a[i];\n\t        r[i++] = c & this.DM;\n\t        c >>= this.DB;\n\t      }\n\t      c -= a.s;\n\t    }\n\t    r.s = (c < 0) ? -1 : 0;\n\t    if (c < -1) r[i++] = this.DV + c;\n\t    else if (c > 0) r[i++] = c;\n\t    r.t = i;\n\t    r.clamp();\n\t  }\n\t  // (protected) r = this * a, r != this,a (HAC 14.12)\n\t  // \"this\" should be the larger one if appropriate.\n\t  function bnpMultiplyTo(a, r)\n\t  {\n\t    var x = this.abs(),\n\t      y = a.abs();\n\t    var i = x.t;\n\t    r.t = i + y.t;\n\t    while (--i >= 0) r[i] = 0;\n\t    for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);\n\t    r.s = 0;\n\t    r.clamp();\n\t    if (this.s != a.s) BigInteger.ZERO.subTo(r, r);\n\t  }\n\t  // (protected) r = this^2, r != this (HAC 14.16)\n\t  function bnpSquareTo(r)\n\t  {\n\t    var x = this.abs();\n\t    var i = r.t = 2 * x.t;\n\t    while (--i >= 0) r[i] = 0;\n\t    for (i = 0; i < x.t - 1; ++i)\n\t    {\n\t      var c = x.am(i, x[i], r, 2 * i, 0, 1);\n\t      if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV)\n\t      {\n\t        r[i + x.t] -= x.DV;\n\t        r[i + x.t + 1] = 1;\n\t      }\n\t    }\n\t    if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);\n\t    r.s = 0;\n\t    r.clamp();\n\t  }\n\t  // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n\t  // r != q, this != m.  q or r may be null.\n\t  function bnpDivRemTo(m, q, r)\n\t  {\n\t    var pm = m.abs();\n\t    if (pm.t <= 0) return;\n\t    var pt = this.abs();\n\t    if (pt.t < pm.t)\n\t    {\n\t      if (q != null) q.fromInt(0);\n\t      if (r != null) this.copyTo(r);\n\t      return;\n\t    }\n\t    if (r == null) r = nbi();\n\t    var y = nbi(),\n\t      ts = this.s,\n\t      ms = m.s;\n\t    var nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus\n\t    if (nsh > 0)\n\t    {\n\t      pm.lShiftTo(nsh, y);\n\t      pt.lShiftTo(nsh, r);\n\t    }\n\t    else\n\t    {\n\t      pm.copyTo(y);\n\t      pt.copyTo(r);\n\t    }\n\t    var ys = y.t;\n\t    var y0 = y[ys - 1];\n\t    if (y0 == 0) return;\n\t    var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);\n\t    var d1 = this.FV / yt,\n\t      d2 = (1 << this.F1) / yt,\n\t      e = 1 << this.F2;\n\t    var i = r.t,\n\t      j = i - ys,\n\t      t = (q == null) ? nbi() : q;\n\t    y.dlShiftTo(j, t);\n\t    if (r.compareTo(t) >= 0)\n\t    {\n\t      r[r.t++] = 1;\n\t      r.subTo(t, r);\n\t    }\n\t    BigInteger.ONE.dlShiftTo(ys, t);\n\t    t.subTo(y, y); // \"negative\" y so we can replace sub with am later\n\t    while (y.t < ys) y[y.t++] = 0;\n\t    while (--j >= 0)\n\t    {\n\t      // Estimate quotient digit\n\t      var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);\n\t      if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd)\n\t      { // Try it out\n\t        y.dlShiftTo(j, t);\n\t        r.subTo(t, r);\n\t        while (r[i] < --qd) r.subTo(t, r);\n\t      }\n\t    }\n\t    if (q != null)\n\t    {\n\t      r.drShiftTo(ys, q);\n\t      if (ts != ms) BigInteger.ZERO.subTo(q, q);\n\t    }\n\t    r.t = ys;\n\t    r.clamp();\n\t    if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder\n\t    if (ts < 0) BigInteger.ZERO.subTo(r, r);\n\t  }\n\t  // (public) this mod a\n\t  function bnMod(a)\n\t  {\n\t    var r = nbi();\n\t    this.abs().divRemTo(a, null, r);\n\t    if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);\n\t    return r;\n\t  }\n\t  // Modular reduction using \"classic\" algorithm\n\t  function Classic(m)\n\t  {\n\t    this.m = m;\n\t  }\n\t\n\t  function cConvert(x)\n\t  {\n\t    if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n\t    else return x;\n\t  }\n\t\n\t  function cRevert(x)\n\t  {\n\t    return x;\n\t  }\n\t\n\t  function cReduce(x)\n\t  {\n\t    x.divRemTo(this.m, null, x);\n\t  }\n\t\n\t  function cMulTo(x, y, r)\n\t  {\n\t    x.multiplyTo(y, r);\n\t    this.reduce(r);\n\t  }\n\t\n\t  function cSqrTo(x, r)\n\t  {\n\t    x.squareTo(r);\n\t    this.reduce(r);\n\t  }\n\t  Classic.prototype.convert = cConvert;\n\t  Classic.prototype.revert = cRevert;\n\t  Classic.prototype.reduce = cReduce;\n\t  Classic.prototype.mulTo = cMulTo;\n\t  Classic.prototype.sqrTo = cSqrTo;\n\t  // (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n\t  // justification:\n\t  //         xy == 1 (mod m)\n\t  //         xy =  1+km\n\t  //   xy(2-xy) = (1+km)(1-km)\n\t  // x[y(2-xy)] = 1-k^2m^2\n\t  // x[y(2-xy)] == 1 (mod m^2)\n\t  // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n\t  // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n\t  // JS multiply \"overflows\" differently from C/C++, so care is needed here.\n\t  function bnpInvDigit()\n\t  {\n\t    if (this.t < 1) return 0;\n\t    var x = this[0];\n\t    if ((x & 1) == 0) return 0;\n\t    var y = x & 3; // y == 1/x mod 2^2\n\t    y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4\n\t    y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8\n\t    y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16\n\t    // last step - calculate inverse mod DV directly;\n\t    // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n\t    y = (y * (2 - x * y % this.DV)) % this.DV; // y == 1/x mod 2^dbits\n\t    // we really want the negative inverse, and -DV < y < DV\n\t    return (y > 0) ? this.DV - y : -y;\n\t  }\n\t  // Montgomery reduction\n\t  function Montgomery(m)\n\t  {\n\t    this.m = m;\n\t    this.mp = m.invDigit();\n\t    this.mpl = this.mp & 0x7fff;\n\t    this.mph = this.mp >> 15;\n\t    this.um = (1 << (m.DB - 15)) - 1;\n\t    this.mt2 = 2 * m.t;\n\t  }\n\t  // xR mod m\n\t  function montConvert(x)\n\t  {\n\t    var r = nbi();\n\t    x.abs().dlShiftTo(this.m.t, r);\n\t    r.divRemTo(this.m, null, r);\n\t    if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);\n\t    return r;\n\t  }\n\t  // x/R mod m\n\t  function montRevert(x)\n\t  {\n\t    var r = nbi();\n\t    x.copyTo(r);\n\t    this.reduce(r);\n\t    return r;\n\t  }\n\t  // x = x/R mod m (HAC 14.32)\n\t  function montReduce(x)\n\t  {\n\t    while (x.t <= this.mt2) // pad x so am has enough room later\n\t      x[x.t++] = 0;\n\t    for (var i = 0; i < this.m.t; ++i)\n\t    {\n\t      // faster way of calculating u0 = x[i]*mp mod DV\n\t      var j = x[i] & 0x7fff;\n\t      var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;\n\t      // use am to combine the multiply-shift-add into one call\n\t      j = i + this.m.t;\n\t      x[j] += this.m.am(0, u0, x, i, 0, this.m.t);\n\t      // propagate carry\n\t      while (x[j] >= x.DV)\n\t      {\n\t        x[j] -= x.DV;\n\t        x[++j]++;\n\t      }\n\t    }\n\t    x.clamp();\n\t    x.drShiftTo(this.m.t, x);\n\t    if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n\t  }\n\t  // r = \"x^2/R mod m\"; x != r\n\t  function montSqrTo(x, r)\n\t  {\n\t    x.squareTo(r);\n\t    this.reduce(r);\n\t  }\n\t  // r = \"xy/R mod m\"; x,y != r\n\t  function montMulTo(x, y, r)\n\t  {\n\t    x.multiplyTo(y, r);\n\t    this.reduce(r);\n\t  }\n\t  Montgomery.prototype.convert = montConvert;\n\t  Montgomery.prototype.revert = montRevert;\n\t  Montgomery.prototype.reduce = montReduce;\n\t  Montgomery.prototype.mulTo = montMulTo;\n\t  Montgomery.prototype.sqrTo = montSqrTo;\n\t  // (protected) true iff this is even\n\t  function bnpIsEven()\n\t  {\n\t    return ((this.t > 0) ? (this[0] & 1) : this.s) == 0;\n\t  }\n\t  // (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\n\t  function bnpExp(e, z)\n\t  {\n\t    if (e > 0xffffffff || e < 1) return BigInteger.ONE;\n\t    var r = nbi(),\n\t      r2 = nbi(),\n\t      g = z.convert(this),\n\t      i = nbits(e) - 1;\n\t    g.copyTo(r);\n\t    while (--i >= 0)\n\t    {\n\t      z.sqrTo(r, r2);\n\t      if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);\n\t      else\n\t      {\n\t        var t = r;\n\t        r = r2;\n\t        r2 = t;\n\t      }\n\t    }\n\t    return z.revert(r);\n\t  }\n\t  // (public) this^e % m, 0 <= e < 2^32\n\t  function bnModPowInt(e, m)\n\t  {\n\t    var z;\n\t    if (e < 256 || m.isEven()) z = new Classic(m);\n\t    else z = new Montgomery(m);\n\t    return this.exp(e, z);\n\t  }\n\t  // protected\n\t  BigInteger.prototype.copyTo = bnpCopyTo;\n\t  BigInteger.prototype.fromInt = bnpFromInt;\n\t  BigInteger.prototype.fromString = bnpFromString;\n\t  BigInteger.prototype.clamp = bnpClamp;\n\t  BigInteger.prototype.dlShiftTo = bnpDLShiftTo;\n\t  BigInteger.prototype.drShiftTo = bnpDRShiftTo;\n\t  BigInteger.prototype.lShiftTo = bnpLShiftTo;\n\t  BigInteger.prototype.rShiftTo = bnpRShiftTo;\n\t  BigInteger.prototype.subTo = bnpSubTo;\n\t  BigInteger.prototype.multiplyTo = bnpMultiplyTo;\n\t  BigInteger.prototype.squareTo = bnpSquareTo;\n\t  BigInteger.prototype.divRemTo = bnpDivRemTo;\n\t  BigInteger.prototype.invDigit = bnpInvDigit;\n\t  BigInteger.prototype.isEven = bnpIsEven;\n\t  BigInteger.prototype.exp = bnpExp;\n\t  // public\n\t  BigInteger.prototype.toString = bnToString;\n\t  BigInteger.prototype.negate = bnNegate;\n\t  BigInteger.prototype.abs = bnAbs;\n\t  BigInteger.prototype.compareTo = bnCompareTo;\n\t  BigInteger.prototype.bitLength = bnBitLength;\n\t  BigInteger.prototype.mod = bnMod;\n\t  BigInteger.prototype.modPowInt = bnModPowInt;\n\t  // \"constants\"\n\t  BigInteger.ZERO = nbv(0);\n\t  BigInteger.ONE = nbv(1);\n\t  // Copyright (c) 2005-2009  Tom Wu\n\t  // All Rights Reserved.\n\t  // See \"LICENSE\" for details.\n\t  // Extended JavaScript BN functions, required for RSA private ops.\n\t  // Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\n\t  // Version 1.2: square() API, isProbablePrime fix\n\t  // (public)\n\t  function bnClone()\n\t  {\n\t    var r = nbi();\n\t    this.copyTo(r);\n\t    return r;\n\t  }\n\t  // (public) return value as integer\n\t  function bnIntValue()\n\t  {\n\t    if (this.s < 0)\n\t    {\n\t      if (this.t == 1) return this[0] - this.DV;\n\t      else if (this.t == 0) return -1;\n\t    }\n\t    else if (this.t == 1) return this[0];\n\t    else if (this.t == 0) return 0;\n\t    // assumes 16 < DB < 32\n\t    return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];\n\t  }\n\t  // (public) return value as byte\n\t  function bnByteValue()\n\t  {\n\t    return (this.t == 0) ? this.s : (this[0] << 24) >> 24;\n\t  }\n\t  // (public) return value as short (assumes DB>=16)\n\t  function bnShortValue()\n\t  {\n\t    return (this.t == 0) ? this.s : (this[0] << 16) >> 16;\n\t  }\n\t  // (protected) return x s.t. r^x < DV\n\t  function bnpChunkSize(r)\n\t  {\n\t    return Math.floor(Math.LN2 * this.DB / Math.log(r));\n\t  }\n\t  // (public) 0 if this == 0, 1 if this > 0\n\t  function bnSigNum()\n\t  {\n\t    if (this.s < 0) return -1;\n\t    else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n\t    else return 1;\n\t  }\n\t  // (protected) convert to radix string\n\t  function bnpToRadix(b)\n\t  {\n\t    if (b == null) b = 10;\n\t    if (this.signum() == 0 || b < 2 || b > 36) return \"0\";\n\t    var cs = this.chunkSize(b);\n\t    var a = Math.pow(b, cs);\n\t    var d = nbv(a),\n\t      y = nbi(),\n\t      z = nbi(),\n\t      r = \"\";\n\t    this.divRemTo(d, y, z);\n\t    while (y.signum() > 0)\n\t    {\n\t      r = (a + z.intValue()).toString(b).substr(1) + r;\n\t      y.divRemTo(d, y, z);\n\t    }\n\t    return z.intValue().toString(b) + r;\n\t  }\n\t  // (protected) convert from radix string\n\t  function bnpFromRadix(s, b)\n\t  {\n\t    this.fromInt(0);\n\t    if (b == null) b = 10;\n\t    var cs = this.chunkSize(b);\n\t    var d = Math.pow(b, cs),\n\t      mi = false,\n\t      j = 0,\n\t      w = 0;\n\t    for (var i = 0; i < s.length; ++i)\n\t    {\n\t      var x = intAt(s, i);\n\t      if (x < 0)\n\t      {\n\t        if (s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\n\t        continue;\n\t      }\n\t      w = b * w + x;\n\t      if (++j >= cs)\n\t      {\n\t        this.dMultiply(d);\n\t        this.dAddOffset(w, 0);\n\t        j = 0;\n\t        w = 0;\n\t      }\n\t    }\n\t    if (j > 0)\n\t    {\n\t      this.dMultiply(Math.pow(b, j));\n\t      this.dAddOffset(w, 0);\n\t    }\n\t    if (mi) BigInteger.ZERO.subTo(this, this);\n\t  }\n\t  // (protected) alternate constructor\n\t  function bnpFromNumber(a, b, c)\n\t  {\n\t    if (\"number\" == typeof b)\n\t    {\n\t      // new BigInteger(int,int,RNG)\n\t      if (a < 2) this.fromInt(1);\n\t      else\n\t      {\n\t        this.fromNumber(a, c);\n\t        if (!this.testBit(a - 1)) // force MSB set\n\t          this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);\n\t        if (this.isEven()) this.dAddOffset(1, 0); // force odd\n\t        while (!this.isProbablePrime(b))\n\t        {\n\t          this.dAddOffset(2, 0);\n\t          if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);\n\t        }\n\t      }\n\t    }\n\t    else\n\t    {\n\t      // new BigInteger(int,RNG)\n\t      var x = new Array(),\n\t        t = a & 7;\n\t      x.length = (a >> 3) + 1;\n\t      b.nextBytes(x);\n\t      if (t > 0) x[0] &= ((1 << t) - 1);\n\t      else x[0] = 0;\n\t      this.fromString(x, 256);\n\t    }\n\t  }\n\t  // (public) convert to bigendian byte array\n\t  function bnToByteArray()\n\t  {\n\t    var i = this.t,\n\t      r = new Array();\n\t    r[0] = this.s;\n\t    var p = this.DB - (i * this.DB) % 8,\n\t      d, k = 0;\n\t    if (i-- > 0)\n\t    {\n\t      if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)\n\t        r[k++] = d | (this.s << (this.DB - p));\n\t      while (i >= 0)\n\t      {\n\t        if (p < 8)\n\t        {\n\t          d = (this[i] & ((1 << p) - 1)) << (8 - p);\n\t          d |= this[--i] >> (p += this.DB - 8);\n\t        }\n\t        else\n\t        {\n\t          d = (this[i] >> (p -= 8)) & 0xff;\n\t          if (p <= 0)\n\t          {\n\t            p += this.DB;\n\t            --i;\n\t          }\n\t        }\n\t        if ((d & 0x80) != 0) d |= -256;\n\t        if (k == 0 && (this.s & 0x80) != (d & 0x80))++k;\n\t        if (k > 0 || d != this.s) r[k++] = d;\n\t      }\n\t    }\n\t    return r;\n\t  }\n\t\n\t  function bnEquals(a)\n\t  {\n\t    return (this.compareTo(a) == 0);\n\t  }\n\t\n\t  function bnMin(a)\n\t  {\n\t    return (this.compareTo(a) < 0) ? this : a;\n\t  }\n\t\n\t  function bnMax(a)\n\t  {\n\t    return (this.compareTo(a) > 0) ? this : a;\n\t  }\n\t  // (protected) r = this op a (bitwise)\n\t  function bnpBitwiseTo(a, op, r)\n\t  {\n\t    var i, f, m = Math.min(a.t, this.t);\n\t    for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);\n\t    if (a.t < this.t)\n\t    {\n\t      f = a.s & this.DM;\n\t      for (i = m; i < this.t; ++i) r[i] = op(this[i], f);\n\t      r.t = this.t;\n\t    }\n\t    else\n\t    {\n\t      f = this.s & this.DM;\n\t      for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);\n\t      r.t = a.t;\n\t    }\n\t    r.s = op(this.s, a.s);\n\t    r.clamp();\n\t  }\n\t  // (public) this & a\n\t  function op_and(x, y)\n\t  {\n\t    return x & y;\n\t  }\n\t\n\t  function bnAnd(a)\n\t  {\n\t    var r = nbi();\n\t    this.bitwiseTo(a, op_and, r);\n\t    return r;\n\t  }\n\t  // (public) this | a\n\t  function op_or(x, y)\n\t  {\n\t    return x | y;\n\t  }\n\t\n\t  function bnOr(a)\n\t  {\n\t    var r = nbi();\n\t    this.bitwiseTo(a, op_or, r);\n\t    return r;\n\t  }\n\t  // (public) this ^ a\n\t  function op_xor(x, y)\n\t  {\n\t    return x ^ y;\n\t  }\n\t\n\t  function bnXor(a)\n\t  {\n\t    var r = nbi();\n\t    this.bitwiseTo(a, op_xor, r);\n\t    return r;\n\t  }\n\t  // (public) this & ~a\n\t  function op_andnot(x, y)\n\t  {\n\t    return x & ~y;\n\t  }\n\t\n\t  function bnAndNot(a)\n\t  {\n\t    var r = nbi();\n\t    this.bitwiseTo(a, op_andnot, r);\n\t    return r;\n\t  }\n\t  // (public) ~this\n\t  function bnNot()\n\t  {\n\t    var r = nbi();\n\t    for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];\n\t    r.t = this.t;\n\t    r.s = ~this.s;\n\t    return r;\n\t  }\n\t  // (public) this << n\n\t  function bnShiftLeft(n)\n\t  {\n\t    var r = nbi();\n\t    if (n < 0) this.rShiftTo(-n, r);\n\t    else this.lShiftTo(n, r);\n\t    return r;\n\t  }\n\t  // (public) this >> n\n\t  function bnShiftRight(n)\n\t  {\n\t    var r = nbi();\n\t    if (n < 0) this.lShiftTo(-n, r);\n\t    else this.rShiftTo(n, r);\n\t    return r;\n\t  }\n\t  // return index of lowest 1-bit in x, x < 2^31\n\t  function lbit(x)\n\t  {\n\t    if (x == 0) return -1;\n\t    var r = 0;\n\t    if ((x & 0xffff) == 0)\n\t    {\n\t      x >>= 16;\n\t      r += 16;\n\t    }\n\t    if ((x & 0xff) == 0)\n\t    {\n\t      x >>= 8;\n\t      r += 8;\n\t    }\n\t    if ((x & 0xf) == 0)\n\t    {\n\t      x >>= 4;\n\t      r += 4;\n\t    }\n\t    if ((x & 3) == 0)\n\t    {\n\t      x >>= 2;\n\t      r += 2;\n\t    }\n\t    if ((x & 1) == 0)++r;\n\t    return r;\n\t  }\n\t  // (public) returns index of lowest 1-bit (or -1 if none)\n\t  function bnGetLowestSetBit()\n\t  {\n\t    for (var i = 0; i < this.t; ++i)\n\t      if (this[i] != 0) return i * this.DB + lbit(this[i]);\n\t    if (this.s < 0) return this.t * this.DB;\n\t    return -1;\n\t  }\n\t  // return number of 1 bits in x\n\t  function cbit(x)\n\t  {\n\t    var r = 0;\n\t    while (x != 0)\n\t    {\n\t      x &= x - 1;\n\t      ++r;\n\t    }\n\t    return r;\n\t  }\n\t  // (public) return number of set bits\n\t  function bnBitCount()\n\t  {\n\t    var r = 0,\n\t      x = this.s & this.DM;\n\t    for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);\n\t    return r;\n\t  }\n\t  // (public) true iff nth bit is set\n\t  function bnTestBit(n)\n\t  {\n\t    var j = Math.floor(n / this.DB);\n\t    if (j >= this.t) return (this.s != 0);\n\t    return ((this[j] & (1 << (n % this.DB))) != 0);\n\t  }\n\t  // (protected) this op (1<<n)\n\t  function bnpChangeBit(n, op)\n\t  {\n\t    var r = BigInteger.ONE.shiftLeft(n);\n\t    this.bitwiseTo(r, op, r);\n\t    return r;\n\t  }\n\t  // (public) this | (1<<n)\n\t  function bnSetBit(n)\n\t  {\n\t    return this.changeBit(n, op_or);\n\t  }\n\t  // (public) this & ~(1<<n)\n\t  function bnClearBit(n)\n\t  {\n\t    return this.changeBit(n, op_andnot);\n\t  }\n\t  // (public) this ^ (1<<n)\n\t  function bnFlipBit(n)\n\t  {\n\t    return this.changeBit(n, op_xor);\n\t  }\n\t  // (protected) r = this + a\n\t  function bnpAddTo(a, r)\n\t  {\n\t    var i = 0,\n\t      c = 0,\n\t      m = Math.min(a.t, this.t);\n\t    while (i < m)\n\t    {\n\t      c += this[i] + a[i];\n\t      r[i++] = c & this.DM;\n\t      c >>= this.DB;\n\t    }\n\t    if (a.t < this.t)\n\t    {\n\t      c += a.s;\n\t      while (i < this.t)\n\t      {\n\t        c += this[i];\n\t        r[i++] = c & this.DM;\n\t        c >>= this.DB;\n\t      }\n\t      c += this.s;\n\t    }\n\t    else\n\t    {\n\t      c += this.s;\n\t      while (i < a.t)\n\t      {\n\t        c += a[i];\n\t        r[i++] = c & this.DM;\n\t        c >>= this.DB;\n\t      }\n\t      c += a.s;\n\t    }\n\t    r.s = (c < 0) ? -1 : 0;\n\t    if (c > 0) r[i++] = c;\n\t    else if (c < -1) r[i++] = this.DV + c;\n\t    r.t = i;\n\t    r.clamp();\n\t  }\n\t  // (public) this + a\n\t  function bnAdd(a)\n\t  {\n\t    var r = nbi();\n\t    this.addTo(a, r);\n\t    return r;\n\t  }\n\t  // (public) this - a\n\t  function bnSubtract(a)\n\t  {\n\t    var r = nbi();\n\t    this.subTo(a, r);\n\t    return r;\n\t  }\n\t  // (public) this * a\n\t  function bnMultiply(a)\n\t  {\n\t    var r = nbi();\n\t    this.multiplyTo(a, r);\n\t    return r;\n\t  }\n\t  // (public) this^2\n\t  function bnSquare()\n\t  {\n\t    var r = nbi();\n\t    this.squareTo(r);\n\t    return r;\n\t  }\n\t  // (public) this / a\n\t  function bnDivide(a)\n\t  {\n\t    var r = nbi();\n\t    this.divRemTo(a, r, null);\n\t    return r;\n\t  }\n\t  // (public) this % a\n\t  function bnRemainder(a)\n\t  {\n\t    var r = nbi();\n\t    this.divRemTo(a, null, r);\n\t    return r;\n\t  }\n\t  // (public) [this/a,this%a]\n\t  function bnDivideAndRemainder(a)\n\t  {\n\t    var q = nbi(),\n\t      r = nbi();\n\t    this.divRemTo(a, q, r);\n\t    return new Array(q, r);\n\t  }\n\t  // (protected) this *= n, this >= 0, 1 < n < DV\n\t  function bnpDMultiply(n)\n\t  {\n\t    this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);\n\t    ++this.t;\n\t    this.clamp();\n\t  }\n\t  // (protected) this += n << w words, this >= 0\n\t  function bnpDAddOffset(n, w)\n\t  {\n\t    if (n == 0) return;\n\t    while (this.t <= w) this[this.t++] = 0;\n\t    this[w] += n;\n\t    while (this[w] >= this.DV)\n\t    {\n\t      this[w] -= this.DV;\n\t      if (++w >= this.t) this[this.t++] = 0;\n\t      ++this[w];\n\t    }\n\t  }\n\t  // A \"null\" reducer\n\t  function NullExp()\n\t  {}\n\t\n\t  function nNop(x)\n\t  {\n\t    return x;\n\t  }\n\t\n\t  function nMulTo(x, y, r)\n\t  {\n\t    x.multiplyTo(y, r);\n\t  }\n\t\n\t  function nSqrTo(x, r)\n\t  {\n\t    x.squareTo(r);\n\t  }\n\t  NullExp.prototype.convert = nNop;\n\t  NullExp.prototype.revert = nNop;\n\t  NullExp.prototype.mulTo = nMulTo;\n\t  NullExp.prototype.sqrTo = nSqrTo;\n\t  // (public) this^e\n\t  function bnPow(e)\n\t  {\n\t    return this.exp(e, new NullExp());\n\t  }\n\t  // (protected) r = lower n words of \"this * a\", a.t <= n\n\t  // \"this\" should be the larger one if appropriate.\n\t  function bnpMultiplyLowerTo(a, n, r)\n\t  {\n\t    var i = Math.min(this.t + a.t, n);\n\t    r.s = 0; // assumes a,this >= 0\n\t    r.t = i;\n\t    while (i > 0) r[--i] = 0;\n\t    var j;\n\t    for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);\n\t    for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);\n\t    r.clamp();\n\t  }\n\t  // (protected) r = \"this * a\" without lower n words, n > 0\n\t  // \"this\" should be the larger one if appropriate.\n\t  function bnpMultiplyUpperTo(a, n, r)\n\t  {\n\t    --n;\n\t    var i = r.t = this.t + a.t - n;\n\t    r.s = 0; // assumes a,this >= 0\n\t    while (--i >= 0) r[i] = 0;\n\t    for (i = Math.max(n - this.t, 0); i < a.t; ++i)\n\t      r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);\n\t    r.clamp();\n\t    r.drShiftTo(1, r);\n\t  }\n\t  // Barrett modular reduction\n\t  function Barrett(m)\n\t  {\n\t    // setup Barrett\n\t    this.r2 = nbi();\n\t    this.q3 = nbi();\n\t    BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);\n\t    this.mu = this.r2.divide(m);\n\t    this.m = m;\n\t  }\n\t\n\t  function barrettConvert(x)\n\t  {\n\t    if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);\n\t    else if (x.compareTo(this.m) < 0) return x;\n\t    else\n\t    {\n\t      var r = nbi();\n\t      x.copyTo(r);\n\t      this.reduce(r);\n\t      return r;\n\t    }\n\t  }\n\t\n\t  function barrettRevert(x)\n\t  {\n\t    return x;\n\t  }\n\t  // x = x mod m (HAC 14.42)\n\t  function barrettReduce(x)\n\t  {\n\t    x.drShiftTo(this.m.t - 1, this.r2);\n\t    if (x.t > this.m.t + 1)\n\t    {\n\t      x.t = this.m.t + 1;\n\t      x.clamp();\n\t    }\n\t    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);\n\t    this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);\n\t    while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);\n\t    x.subTo(this.r2, x);\n\t    while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n\t  }\n\t  // r = x^2 mod m; x != r\n\t  function barrettSqrTo(x, r)\n\t  {\n\t    x.squareTo(r);\n\t    this.reduce(r);\n\t  }\n\t  // r = x*y mod m; x,y != r\n\t  function barrettMulTo(x, y, r)\n\t  {\n\t    x.multiplyTo(y, r);\n\t    this.reduce(r);\n\t  }\n\t  Barrett.prototype.convert = barrettConvert;\n\t  Barrett.prototype.revert = barrettRevert;\n\t  Barrett.prototype.reduce = barrettReduce;\n\t  Barrett.prototype.mulTo = barrettMulTo;\n\t  Barrett.prototype.sqrTo = barrettSqrTo;\n\t  // (public) this^e % m (HAC 14.85)\n\t  function bnModPow(e, m)\n\t  {\n\t    var i = e.bitLength(),\n\t      k, r = nbv(1),\n\t      z;\n\t    if (i <= 0) return r;\n\t    else if (i < 18) k = 1;\n\t    else if (i < 48) k = 3;\n\t    else if (i < 144) k = 4;\n\t    else if (i < 768) k = 5;\n\t    else k = 6;\n\t    if (i < 8)\n\t      z = new Classic(m);\n\t    else if (m.isEven())\n\t      z = new Barrett(m);\n\t    else\n\t      z = new Montgomery(m);\n\t    // precomputation\n\t    var g = new Array(),\n\t      n = 3,\n\t      k1 = k - 1,\n\t      km = (1 << k) - 1;\n\t    g[1] = z.convert(this);\n\t    if (k > 1)\n\t    {\n\t      var g2 = nbi();\n\t      z.sqrTo(g[1], g2);\n\t      while (n <= km)\n\t      {\n\t        g[n] = nbi();\n\t        z.mulTo(g2, g[n - 2], g[n]);\n\t        n += 2;\n\t      }\n\t    }\n\t    var j = e.t - 1,\n\t      w, is1 = true,\n\t      r2 = nbi(),\n\t      t;\n\t    i = nbits(e[j]) - 1;\n\t    while (j >= 0)\n\t    {\n\t      if (i >= k1) w = (e[j] >> (i - k1)) & km;\n\t      else\n\t      {\n\t        w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);\n\t        if (j > 0) w |= e[j - 1] >> (this.DB + i - k1);\n\t      }\n\t      n = k;\n\t      while ((w & 1) == 0)\n\t      {\n\t        w >>= 1;\n\t        --n;\n\t      }\n\t      if ((i -= n) < 0)\n\t      {\n\t        i += this.DB;\n\t        --j;\n\t      }\n\t      if (is1)\n\t      { // ret == 1, don't bother squaring or multiplying it\n\t        g[w].copyTo(r);\n\t        is1 = false;\n\t      }\n\t      else\n\t      {\n\t        while (n > 1)\n\t        {\n\t          z.sqrTo(r, r2);\n\t          z.sqrTo(r2, r);\n\t          n -= 2;\n\t        }\n\t        if (n > 0) z.sqrTo(r, r2);\n\t        else\n\t        {\n\t          t = r;\n\t          r = r2;\n\t          r2 = t;\n\t        }\n\t        z.mulTo(r2, g[w], r);\n\t      }\n\t      while (j >= 0 && (e[j] & (1 << i)) == 0)\n\t      {\n\t        z.sqrTo(r, r2);\n\t        t = r;\n\t        r = r2;\n\t        r2 = t;\n\t        if (--i < 0)\n\t        {\n\t          i = this.DB - 1;\n\t          --j;\n\t        }\n\t      }\n\t    }\n\t    return z.revert(r);\n\t  }\n\t  // (public) gcd(this,a) (HAC 14.54)\n\t  function bnGCD(a)\n\t  {\n\t    var x = (this.s < 0) ? this.negate() : this.clone();\n\t    var y = (a.s < 0) ? a.negate() : a.clone();\n\t    if (x.compareTo(y) < 0)\n\t    {\n\t      var t = x;\n\t      x = y;\n\t      y = t;\n\t    }\n\t    var i = x.getLowestSetBit(),\n\t      g = y.getLowestSetBit();\n\t    if (g < 0) return x;\n\t    if (i < g) g = i;\n\t    if (g > 0)\n\t    {\n\t      x.rShiftTo(g, x);\n\t      y.rShiftTo(g, y);\n\t    }\n\t    while (x.signum() > 0)\n\t    {\n\t      if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);\n\t      if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);\n\t      if (x.compareTo(y) >= 0)\n\t      {\n\t        x.subTo(y, x);\n\t        x.rShiftTo(1, x);\n\t      }\n\t      else\n\t      {\n\t        y.subTo(x, y);\n\t        y.rShiftTo(1, y);\n\t      }\n\t    }\n\t    if (g > 0) y.lShiftTo(g, y);\n\t    return y;\n\t  }\n\t  // (protected) this % n, n < 2^26\n\t  function bnpModInt(n)\n\t  {\n\t    if (n <= 0) return 0;\n\t    var d = this.DV % n,\n\t      r = (this.s < 0) ? n - 1 : 0;\n\t    if (this.t > 0)\n\t      if (d == 0) r = this[0] % n;\n\t      else\n\t        for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;\n\t    return r;\n\t  }\n\t  // (public) 1/this % m (HAC 14.61)\n\t  function bnModInverse(m)\n\t  {\n\t    var ac = m.isEven();\n\t    if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n\t    var u = m.clone(),\n\t      v = this.clone();\n\t    var a = nbv(1),\n\t      b = nbv(0),\n\t      c = nbv(0),\n\t      d = nbv(1);\n\t    while (u.signum() != 0)\n\t    {\n\t      while (u.isEven())\n\t      {\n\t        u.rShiftTo(1, u);\n\t        if (ac)\n\t        {\n\t          if (!a.isEven() || !b.isEven())\n\t          {\n\t            a.addTo(this, a);\n\t            b.subTo(m, b);\n\t          }\n\t          a.rShiftTo(1, a);\n\t        }\n\t        else if (!b.isEven()) b.subTo(m, b);\n\t        b.rShiftTo(1, b);\n\t      }\n\t      while (v.isEven())\n\t      {\n\t        v.rShiftTo(1, v);\n\t        if (ac)\n\t        {\n\t          if (!c.isEven() || !d.isEven())\n\t          {\n\t            c.addTo(this, c);\n\t            d.subTo(m, d);\n\t          }\n\t          c.rShiftTo(1, c);\n\t        }\n\t        else if (!d.isEven()) d.subTo(m, d);\n\t        d.rShiftTo(1, d);\n\t      }\n\t      if (u.compareTo(v) >= 0)\n\t      {\n\t        u.subTo(v, u);\n\t        if (ac) a.subTo(c, a);\n\t        b.subTo(d, b);\n\t      }\n\t      else\n\t      {\n\t        v.subTo(u, v);\n\t        if (ac) c.subTo(a, c);\n\t        d.subTo(b, d);\n\t      }\n\t    }\n\t    if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n\t    if (d.compareTo(m) >= 0) return d.subtract(m);\n\t    if (d.signum() < 0) d.addTo(m, d);\n\t    else return d;\n\t    if (d.signum() < 0) return d.add(m);\n\t    else return d;\n\t  }\n\t  var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\n\t  var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];\n\t  // (public) test primality with certainty >= 1-.5^t\n\t  function bnIsProbablePrime(t)\n\t  {\n\t    var i, x = this.abs();\n\t    if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1])\n\t    {\n\t      for (i = 0; i < lowprimes.length; ++i)\n\t        if (x[0] == lowprimes[i]) return true;\n\t      return false;\n\t    }\n\t    if (x.isEven()) return false;\n\t    i = 1;\n\t    while (i < lowprimes.length)\n\t    {\n\t      var m = lowprimes[i],\n\t        j = i + 1;\n\t      while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n\t      m = x.modInt(m);\n\t      while (i < j)\n\t        if (m % lowprimes[i++] == 0) return false;\n\t    }\n\t    return x.millerRabin(t);\n\t  }\n\t  // (protected) true if probably prime (HAC 4.24, Miller-Rabin)\n\t  function bnpMillerRabin(t)\n\t  {\n\t    var n1 = this.subtract(BigInteger.ONE);\n\t    var k = n1.getLowestSetBit();\n\t    if (k <= 0) return false;\n\t    var r = n1.shiftRight(k);\n\t    t = (t + 1) >> 1;\n\t    if (t > lowprimes.length) t = lowprimes.length;\n\t    var a = nbi();\n\t    for (var i = 0; i < t; ++i)\n\t    {\n\t      //Pick bases at random, instead of starting at 2\n\t      a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);\n\t      var y = a.modPow(r, this);\n\t      if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0)\n\t      {\n\t        var j = 1;\n\t        while (j++ < k && y.compareTo(n1) != 0)\n\t        {\n\t          y = y.modPowInt(2, this);\n\t          if (y.compareTo(BigInteger.ONE) == 0) return false;\n\t        }\n\t        if (y.compareTo(n1) != 0) return false;\n\t      }\n\t    }\n\t    return true;\n\t  }\n\t  // protected\n\t  BigInteger.prototype.chunkSize = bnpChunkSize;\n\t  BigInteger.prototype.toRadix = bnpToRadix;\n\t  BigInteger.prototype.fromRadix = bnpFromRadix;\n\t  BigInteger.prototype.fromNumber = bnpFromNumber;\n\t  BigInteger.prototype.bitwiseTo = bnpBitwiseTo;\n\t  BigInteger.prototype.changeBit = bnpChangeBit;\n\t  BigInteger.prototype.addTo = bnpAddTo;\n\t  BigInteger.prototype.dMultiply = bnpDMultiply;\n\t  BigInteger.prototype.dAddOffset = bnpDAddOffset;\n\t  BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\n\t  BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\n\t  BigInteger.prototype.modInt = bnpModInt;\n\t  BigInteger.prototype.millerRabin = bnpMillerRabin;\n\t  // public\n\t  BigInteger.prototype.clone = bnClone;\n\t  BigInteger.prototype.intValue = bnIntValue;\n\t  BigInteger.prototype.byteValue = bnByteValue;\n\t  BigInteger.prototype.shortValue = bnShortValue;\n\t  BigInteger.prototype.signum = bnSigNum;\n\t  BigInteger.prototype.toByteArray = bnToByteArray;\n\t  BigInteger.prototype.equals = bnEquals;\n\t  BigInteger.prototype.min = bnMin;\n\t  BigInteger.prototype.max = bnMax;\n\t  BigInteger.prototype.and = bnAnd;\n\t  BigInteger.prototype.or = bnOr;\n\t  BigInteger.prototype.xor = bnXor;\n\t  BigInteger.prototype.andNot = bnAndNot;\n\t  BigInteger.prototype.not = bnNot;\n\t  BigInteger.prototype.shiftLeft = bnShiftLeft;\n\t  BigInteger.prototype.shiftRight = bnShiftRight;\n\t  BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\n\t  BigInteger.prototype.bitCount = bnBitCount;\n\t  BigInteger.prototype.testBit = bnTestBit;\n\t  BigInteger.prototype.setBit = bnSetBit;\n\t  BigInteger.prototype.clearBit = bnClearBit;\n\t  BigInteger.prototype.flipBit = bnFlipBit;\n\t  BigInteger.prototype.add = bnAdd;\n\t  BigInteger.prototype.subtract = bnSubtract;\n\t  BigInteger.prototype.multiply = bnMultiply;\n\t  BigInteger.prototype.divide = bnDivide;\n\t  BigInteger.prototype.remainder = bnRemainder;\n\t  BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\n\t  BigInteger.prototype.modPow = bnModPow;\n\t  BigInteger.prototype.modInverse = bnModInverse;\n\t  BigInteger.prototype.pow = bnPow;\n\t  BigInteger.prototype.gcd = bnGCD;\n\t  BigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n\t  // JSBN-specific extension\n\t  BigInteger.prototype.square = bnSquare;\n\t  var Int128 = BigInteger;\n\t  // BigInteger interfaces not implemented in jsbn:\n\t  // BigInteger(int signum, byte[] magnitude)\n\t  // double doubleValue()\n\t  // float floatValue()\n\t  // int hashCode()\n\t  // long longValue()\n\t  // static BigInteger valueOf(long val)\n\t  // Helper functions to make BigInteger functions callable with two parameters\n\t  // as in original C# Clipper\n\t  Int128.prototype.IsNegative = function ()\n\t  {\n\t    if (this.compareTo(Int128.ZERO) == -1) return true;\n\t    else return false;\n\t  };\n\t  Int128.op_Equality = function (val1, val2)\n\t  {\n\t    if (val1.compareTo(val2) == 0) return true;\n\t    else return false;\n\t  };\n\t  Int128.op_Inequality = function (val1, val2)\n\t  {\n\t    if (val1.compareTo(val2) != 0) return true;\n\t    else return false;\n\t  };\n\t  Int128.op_GreaterThan = function (val1, val2)\n\t  {\n\t    if (val1.compareTo(val2) > 0) return true;\n\t    else return false;\n\t  };\n\t  Int128.op_LessThan = function (val1, val2)\n\t  {\n\t    if (val1.compareTo(val2) < 0) return true;\n\t    else return false;\n\t  };\n\t  Int128.op_Addition = function (lhs, rhs)\n\t  {\n\t    return new Int128(lhs).add(new Int128(rhs));\n\t  };\n\t  Int128.op_Subtraction = function (lhs, rhs)\n\t  {\n\t    return new Int128(lhs).subtract(new Int128(rhs));\n\t  };\n\t  Int128.Int128Mul = function (lhs, rhs)\n\t  {\n\t    return new Int128(lhs).multiply(new Int128(rhs));\n\t  };\n\t  Int128.op_Division = function (lhs, rhs)\n\t  {\n\t    return lhs.divide(rhs);\n\t  };\n\t  Int128.prototype.ToDouble = function ()\n\t  {\n\t    return parseFloat(this.toString()); // This could be something faster\n\t  };\n\t  // end of Int128 section\n\t  /*\n\t  // Uncomment the following two lines if you want to use Int128 outside ClipperLib\n\t  if (typeof(document) !== \"undefined\") window.Int128 = Int128;\n\t  else self.Int128 = Int128;\n\t  */\n\t\n\t\n\t  // ---------------------------------------------\n\t  // Here starts the actual Clipper library:\n\t  // Helper function to support Inheritance in Javascript\n\t\tvar Inherit = function (ce, ce2)\n\t\t{\n\t\t\tvar p;\n\t\t\tif (typeof (Object.getOwnPropertyNames) == 'undefined')\n\t\t\t{\n\t\t\t\tfor (p in ce2.prototype)\n\t\t\t\t\tif (typeof (ce.prototype[p]) == 'undefined' || ce.prototype[p] == Object.prototype[p]) ce.prototype[p] = ce2.prototype[p];\n\t\t\t\tfor (p in ce2)\n\t\t\t\t\tif (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];\n\t\t\t\tce.$baseCtor = ce2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar props = Object.getOwnPropertyNames(ce2.prototype);\n\t\t\t\tfor (var i = 0; i < props.length; i++)\n\t\t\t\t\tif (typeof (Object.getOwnPropertyDescriptor(ce.prototype, props[i])) == 'undefined') Object.defineProperty(ce.prototype, props[i], Object.getOwnPropertyDescriptor(ce2.prototype, props[i]));\n\t\t\t\tfor (p in ce2)\n\t\t\t\t\tif (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];\n\t\t\t\tce.$baseCtor = ce2;\n\t\t\t}\n\t\t};\n\t  ClipperLib.Path = function ()\n\t  {\n\t    return [];\n\t  };\n\t  ClipperLib.Paths = function ()\n\t  {\n\t    return []; // Was previously [[]], but caused problems when pushed\n\t  };\n\t  // Preserves the calling way of original C# Clipper\n\t  // Is essential due to compatibility, because DoublePoint is public class in original C# version\n\t  ClipperLib.DoublePoint = function ()\n\t  {\n\t    var a = arguments;\n\t    this.X = 0;\n\t    this.Y = 0;\n\t    // public DoublePoint(DoublePoint dp)\n\t    // public DoublePoint(IntPoint ip)\n\t    if (a.length == 1)\n\t    {\n\t      this.X = a[0].X;\n\t      this.Y = a[0].Y;\n\t    }\n\t    else if (a.length == 2)\n\t    {\n\t      this.X = a[0];\n\t      this.Y = a[1];\n\t    }\n\t  }; // This is internal faster function when called without arguments\n\t  ClipperLib.DoublePoint0 = function ()\n\t  {\n\t    this.X = 0;\n\t    this.Y = 0;\n\t  };\n\t  // This is internal faster function when called with 1 argument (dp or ip)\n\t  ClipperLib.DoublePoint1 = function (dp)\n\t  {\n\t    this.X = dp.X;\n\t    this.Y = dp.Y;\n\t  };\n\t  // This is internal faster function when called with 2 arguments (x and y)\n\t  ClipperLib.DoublePoint2 = function (x, y)\n\t  {\n\t    this.X = x;\n\t    this.Y = y;\n\t  };\n\t  // PolyTree & PolyNode start\n\t  // -------------------------------\n\t  ClipperLib.PolyNode = function ()\n\t  {\n\t    this.m_Parent = null;\n\t    this.m_polygon = new ClipperLib.Path();\n\t    this.m_Index = 0;\n\t    this.m_jointype = 0;\n\t    this.m_endtype = 0;\n\t    this.m_Childs = [];\n\t    this.IsOpen = false;\n\t  };\n\t  ClipperLib.PolyNode.prototype.IsHoleNode = function ()\n\t  {\n\t    var result = true;\n\t    var node = this.m_Parent;\n\t    while (node !== null)\n\t    {\n\t      result = !result;\n\t      node = node.m_Parent;\n\t    }\n\t    return result;\n\t  };\n\t  ClipperLib.PolyNode.prototype.ChildCount = function ()\n\t  {\n\t    return this.m_Childs.length;\n\t  };\n\t  ClipperLib.PolyNode.prototype.Contour = function ()\n\t  {\n\t    return this.m_polygon;\n\t  };\n\t  ClipperLib.PolyNode.prototype.AddChild = function (Child)\n\t  {\n\t    var cnt = this.m_Childs.length;\n\t    this.m_Childs.push(Child);\n\t    Child.m_Parent = this;\n\t    Child.m_Index = cnt;\n\t  };\n\t  ClipperLib.PolyNode.prototype.GetNext = function ()\n\t  {\n\t    if (this.m_Childs.length > 0)\n\t      return this.m_Childs[0];\n\t    else\n\t      return this.GetNextSiblingUp();\n\t  };\n\t  ClipperLib.PolyNode.prototype.GetNextSiblingUp = function ()\n\t  {\n\t    if (this.m_Parent === null)\n\t      return null;\n\t    else if (this.m_Index == this.m_Parent.m_Childs.length - 1)\n\t      return this.m_Parent.GetNextSiblingUp();\n\t    else\n\t      return this.m_Parent.m_Childs[this.m_Index + 1];\n\t  };\n\t  ClipperLib.PolyNode.prototype.Childs = function ()\n\t  {\n\t    return this.m_Childs;\n\t  };\n\t  ClipperLib.PolyNode.prototype.Parent = function ()\n\t  {\n\t    return this.m_Parent;\n\t  };\n\t  ClipperLib.PolyNode.prototype.IsHole = function ()\n\t  {\n\t    return this.IsHoleNode();\n\t  };\n\t  // PolyTree : PolyNode\n\t  ClipperLib.PolyTree = function ()\n\t  {\n\t    this.m_AllPolys = [];\n\t    ClipperLib.PolyNode.call(this);\n\t  };\n\t  ClipperLib.PolyTree.prototype.Clear = function ()\n\t  {\n\t    for (var i = 0, ilen = this.m_AllPolys.length; i < ilen; i++)\n\t      this.m_AllPolys[i] = null;\n\t    this.m_AllPolys.length = 0;\n\t    this.m_Childs.length = 0;\n\t  };\n\t  ClipperLib.PolyTree.prototype.GetFirst = function ()\n\t  {\n\t    if (this.m_Childs.length > 0)\n\t      return this.m_Childs[0];\n\t    else\n\t      return null;\n\t  };\n\t  ClipperLib.PolyTree.prototype.Total = function ()\n\t  {\n\t\t\tvar result = this.m_AllPolys.length;\n\t\t\t//with negative offsets, ignore the hidden outer polygon ...\n\t\t\tif (result > 0 && this.m_Childs[0] != this.m_AllPolys[0]) result--;\n\t\t\treturn result;\n\t  };\n\t  Inherit(ClipperLib.PolyTree, ClipperLib.PolyNode);\n\t  // -------------------------------\n\t  // PolyTree & PolyNode end\n\t  ClipperLib.Math_Abs_Int64 = ClipperLib.Math_Abs_Int32 = ClipperLib.Math_Abs_Double = function (a)\n\t  {\n\t    return Math.abs(a);\n\t  };\n\t  ClipperLib.Math_Max_Int32_Int32 = function (a, b)\n\t  {\n\t    return Math.max(a, b);\n\t  };\n\t  /*\n\t  -----------------------------------\n\t  cast_32 speedtest: http://jsperf.com/truncate-float-to-integer/2\n\t  -----------------------------------\n\t  */\n\t  if (browser.msie || browser.opera || browser.safari) ClipperLib.Cast_Int32 = function (a)\n\t  {\n\t    return a | 0;\n\t  };\n\t  else ClipperLib.Cast_Int32 = function (a)\n\t  { // eg. browser.chrome || browser.chromium || browser.firefox\n\t    return~~ a;\n\t  };\n\t  /*\n\t  --------------------------\n\t  cast_64 speedtests: http://jsperf.com/truncate-float-to-integer\n\t  Chrome: bitwise_not_floor\n\t  Firefox17: toInteger (typeof test)\n\t  IE9: bitwise_or_floor\n\t  IE7 and IE8: to_parseint\n\t  Chromium: to_floor_or_ceil\n\t  Firefox3: to_floor_or_ceil\n\t  Firefox15: to_floor_or_ceil\n\t  Opera: to_floor_or_ceil\n\t  Safari: to_floor_or_ceil\n\t  --------------------------\n\t  */\n\t  if (browser.chrome) ClipperLib.Cast_Int64 = function (a)\n\t  {\n\t    if (a < -2147483648 || a > 2147483647)\n\t      return a < 0 ? Math.ceil(a) : Math.floor(a);\n\t    else return~~ a;\n\t  };\n\t  else if (browser.firefox && typeof (Number.toInteger) == \"function\") ClipperLib.Cast_Int64 = function (a)\n\t  {\n\t    return Number.toInteger(a);\n\t  };\n\t  else if (browser.msie7 || browser.msie8) ClipperLib.Cast_Int64 = function (a)\n\t  {\n\t    return parseInt(a, 10);\n\t  };\n\t  else if (browser.msie) ClipperLib.Cast_Int64 = function (a)\n\t  {\n\t    if (a < -2147483648 || a > 2147483647)\n\t      return a < 0 ? Math.ceil(a) : Math.floor(a);\n\t    return a | 0;\n\t  };\n\t  // eg. browser.chromium || browser.firefox || browser.opera || browser.safari\n\t  else ClipperLib.Cast_Int64 = function (a)\n\t  {\n\t    return a < 0 ? Math.ceil(a) : Math.floor(a);\n\t  };\n\t  ClipperLib.Clear = function (a)\n\t  {\n\t    a.length = 0;\n\t  };\n\t  //ClipperLib.MaxSteps = 64; // How many steps at maximum in arc in BuildArc() function\n\t  ClipperLib.PI = 3.141592653589793;\n\t  ClipperLib.PI2 = 2 * 3.141592653589793;\n\t  ClipperLib.IntPoint = function ()\n\t  {\n\t    var a = arguments,\n\t      alen = a.length;\n\t    this.X = 0;\n\t    this.Y = 0;\n\t    if (use_xyz)\n\t    {\n\t      this.Z = 0;\n\t      if (alen == 3) // public IntPoint(cInt x, cInt y, cInt z = 0)\n\t      {\n\t        this.X = a[0];\n\t        this.Y = a[1];\n\t        this.Z = a[2];\n\t      }\n\t      else if (alen == 2) // public IntPoint(cInt x, cInt y)\n\t      {\n\t        this.X = a[0];\n\t        this.Y = a[1];\n\t        this.Z = 0;\n\t      }\n\t      else if (alen == 1)\n\t      {\n\t        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n\t        {\n\t          var dp = a[0];\n\t          this.X = ClipperLib.Clipper.Round(dp.X);\n\t          this.Y = ClipperLib.Clipper.Round(dp.Y);\n\t          this.Z = 0;\n\t        }\n\t        else // public IntPoint(IntPoint pt)\n\t        {\n\t          var pt = a[0];\n\t          if (typeof (pt.Z) == \"undefined\") pt.Z = 0;\n\t          this.X = pt.X;\n\t          this.Y = pt.Y;\n\t          this.Z = pt.Z;\n\t        }\n\t      }\n\t      else // public IntPoint()\n\t      {\n\t        this.X = 0;\n\t        this.Y = 0;\n\t        this.Z = 0;\n\t      }\n\t    }\n\t    else // if (!use_xyz)\n\t    {\n\t      if (alen == 2) // public IntPoint(cInt X, cInt Y)\n\t      {\n\t        this.X = a[0];\n\t        this.Y = a[1];\n\t      }\n\t      else if (alen == 1)\n\t      {\n\t        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n\t        {\n\t          var dp = a[0];\n\t          this.X = ClipperLib.Clipper.Round(dp.X);\n\t          this.Y = ClipperLib.Clipper.Round(dp.Y);\n\t        }\n\t        else // public IntPoint(IntPoint pt)\n\t        {\n\t          var pt = a[0];\n\t          this.X = pt.X;\n\t          this.Y = pt.Y;\n\t        }\n\t      }\n\t      else // public IntPoint(IntPoint pt)\n\t      {\n\t        this.X = 0;\n\t        this.Y = 0;\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.IntPoint.op_Equality = function (a, b)\n\t  {\n\t    //return a == b;\n\t    return a.X == b.X && a.Y == b.Y;\n\t  };\n\t  ClipperLib.IntPoint.op_Inequality = function (a, b)\n\t  {\n\t    //return a != b;\n\t    return a.X != b.X || a.Y != b.Y;\n\t  };\n\t  /*\n\t  ClipperLib.IntPoint.prototype.Equals = function (obj)\n\t  {\n\t    if (obj === null)\n\t        return false;\n\t    if (obj instanceof ClipperLib.IntPoint)\n\t    {\n\t        var a = Cast(obj, ClipperLib.IntPoint);\n\t        return (this.X == a.X) && (this.Y == a.Y);\n\t    }\n\t    else\n\t        return false;\n\t  };\n\t*/\n\t  if (use_xyz)\n\t  {\n\t    ClipperLib.IntPoint0 = function ()\n\t    {\n\t      this.X = 0;\n\t      this.Y = 0;\n\t      this.Z = 0;\n\t    };\n\t    ClipperLib.IntPoint1 = function (pt)\n\t    {\n\t      this.X = pt.X;\n\t      this.Y = pt.Y;\n\t      this.Z = pt.Z;\n\t    };\n\t    ClipperLib.IntPoint1dp = function (dp)\n\t    {\n\t      this.X = ClipperLib.Clipper.Round(dp.X);\n\t      this.Y = ClipperLib.Clipper.Round(dp.Y);\n\t      this.Z = 0;\n\t    };\n\t    ClipperLib.IntPoint2 = function (x, y)\n\t    {\n\t      this.X = x;\n\t      this.Y = y;\n\t      this.Z = 0;\n\t    };\n\t    ClipperLib.IntPoint3 = function (x, y, z)\n\t    {\n\t      this.X = x;\n\t      this.Y = y;\n\t      this.Z = z;\n\t    };\n\t  }\n\t  else // if (!use_xyz)\n\t  {\n\t    ClipperLib.IntPoint0 = function ()\n\t    {\n\t      this.X = 0;\n\t      this.Y = 0;\n\t    };\n\t    ClipperLib.IntPoint1 = function (pt)\n\t    {\n\t      this.X = pt.X;\n\t      this.Y = pt.Y;\n\t    };\n\t    ClipperLib.IntPoint1dp = function (dp)\n\t    {\n\t      this.X = ClipperLib.Clipper.Round(dp.X);\n\t      this.Y = ClipperLib.Clipper.Round(dp.Y);\n\t    };\n\t    ClipperLib.IntPoint2 = function (x, y)\n\t    {\n\t      this.X = x;\n\t      this.Y = y;\n\t    };\n\t  }\n\t  ClipperLib.IntRect = function ()\n\t  {\n\t    var a = arguments,\n\t      alen = a.length;\n\t    if (alen == 4) // function (l, t, r, b)\n\t    {\n\t      this.left = a[0];\n\t      this.top = a[1];\n\t      this.right = a[2];\n\t      this.bottom = a[3];\n\t    }\n\t    else if (alen == 1) // function (ir)\n\t    {\n\t      this.left = ir.left;\n\t      this.top = ir.top;\n\t      this.right = ir.right;\n\t      this.bottom = ir.bottom;\n\t    }\n\t    else // function ()\n\t    {\n\t      this.left = 0;\n\t      this.top = 0;\n\t      this.right = 0;\n\t      this.bottom = 0;\n\t    }\n\t  };\n\t  ClipperLib.IntRect0 = function ()\n\t  {\n\t    this.left = 0;\n\t    this.top = 0;\n\t    this.right = 0;\n\t    this.bottom = 0;\n\t  };\n\t  ClipperLib.IntRect1 = function (ir)\n\t  {\n\t    this.left = ir.left;\n\t    this.top = ir.top;\n\t    this.right = ir.right;\n\t    this.bottom = ir.bottom;\n\t  };\n\t  ClipperLib.IntRect4 = function (l, t, r, b)\n\t  {\n\t    this.left = l;\n\t    this.top = t;\n\t    this.right = r;\n\t    this.bottom = b;\n\t  };\n\t  ClipperLib.ClipType = {\n\t    ctIntersection: 0,\n\t    ctUnion: 1,\n\t    ctDifference: 2,\n\t    ctXor: 3\n\t  };\n\t  ClipperLib.PolyType = {\n\t    ptSubject: 0,\n\t    ptClip: 1\n\t  };\n\t  ClipperLib.PolyFillType = {\n\t    pftEvenOdd: 0,\n\t    pftNonZero: 1,\n\t    pftPositive: 2,\n\t    pftNegative: 3\n\t  };\n\t  ClipperLib.JoinType = {\n\t    jtSquare: 0,\n\t    jtRound: 1,\n\t    jtMiter: 2\n\t  };\n\t  ClipperLib.EndType = {\n\t    etOpenSquare: 0,\n\t    etOpenRound: 1,\n\t    etOpenButt: 2,\n\t    etClosedLine: 3,\n\t    etClosedPolygon: 4\n\t  };\n\t  ClipperLib.EdgeSide = {\n\t    esLeft: 0,\n\t    esRight: 1\n\t  };\n\t  ClipperLib.Direction = {\n\t    dRightToLeft: 0,\n\t    dLeftToRight: 1\n\t  };\n\t  ClipperLib.TEdge = function ()\n\t  {\n\t    this.Bot = new ClipperLib.IntPoint();\n\t    this.Curr = new ClipperLib.IntPoint();\n\t    this.Top = new ClipperLib.IntPoint();\n\t    this.Delta = new ClipperLib.IntPoint();\n\t    this.Dx = 0;\n\t    this.PolyTyp = ClipperLib.PolyType.ptSubject;\n\t    this.Side = ClipperLib.EdgeSide.esLeft;\n\t    this.WindDelta = 0;\n\t    this.WindCnt = 0;\n\t    this.WindCnt2 = 0;\n\t    this.OutIdx = 0;\n\t    this.Next = null;\n\t    this.Prev = null;\n\t    this.NextInLML = null;\n\t    this.NextInAEL = null;\n\t    this.PrevInAEL = null;\n\t    this.NextInSEL = null;\n\t    this.PrevInSEL = null;\n\t  };\n\t  ClipperLib.IntersectNode = function ()\n\t  {\n\t    this.Edge1 = null;\n\t    this.Edge2 = null;\n\t    this.Pt = new ClipperLib.IntPoint();\n\t  };\n\t  ClipperLib.MyIntersectNodeSort = function () {};\n\t  ClipperLib.MyIntersectNodeSort.Compare = function (node1, node2)\n\t  {\n\t    var i = node2.Pt.Y - node1.Pt.Y;\n\t    if (i > 0) return 1;\n\t    else if (i < 0) return -1;\n\t    else return 0;\n\t  };\n\t\n\t  ClipperLib.LocalMinima = function ()\n\t  {\n\t    this.Y = 0;\n\t    this.LeftBound = null;\n\t    this.RightBound = null;\n\t    this.Next = null;\n\t  };\n\t  ClipperLib.Scanbeam = function ()\n\t  {\n\t    this.Y = 0;\n\t    this.Next = null;\n\t  };\n\t  ClipperLib.OutRec = function ()\n\t  {\n\t    this.Idx = 0;\n\t    this.IsHole = false;\n\t    this.IsOpen = false;\n\t    this.FirstLeft = null;\n\t    this.Pts = null;\n\t    this.BottomPt = null;\n\t    this.PolyNode = null;\n\t  };\n\t  ClipperLib.OutPt = function ()\n\t  {\n\t    this.Idx = 0;\n\t    this.Pt = new ClipperLib.IntPoint();\n\t    this.Next = null;\n\t    this.Prev = null;\n\t  };\n\t  ClipperLib.Join = function ()\n\t  {\n\t    this.OutPt1 = null;\n\t    this.OutPt2 = null;\n\t    this.OffPt = new ClipperLib.IntPoint();\n\t  };\n\t  ClipperLib.ClipperBase = function ()\n\t  {\n\t    this.m_MinimaList = null;\n\t    this.m_CurrentLM = null;\n\t    this.m_edges = new Array();\n\t    this.m_UseFullRange = false;\n\t    this.m_HasOpenPaths = false;\n\t    this.PreserveCollinear = false;\n\t    this.m_MinimaList = null;\n\t    this.m_CurrentLM = null;\n\t    this.m_UseFullRange = false;\n\t    this.m_HasOpenPaths = false;\n\t  };\n\t  // Ranges are in original C# too high for Javascript (in current state 2013 september):\n\t  // protected const double horizontal = -3.4E+38;\n\t  // internal const cInt loRange = 0x3FFFFFFF; // = 1073741823 = sqrt(2^63 -1)/2\n\t  // internal const cInt hiRange = 0x3FFFFFFFFFFFFFFFL; // = 4611686018427387903 = sqrt(2^127 -1)/2\n\t  // So had to adjust them to more suitable for Javascript.\n\t  // If JS some day supports truly 64-bit integers, then these ranges can be as in C#\n\t  // and biginteger library can be more simpler (as then 128bit can be represented as two 64bit numbers)\n\t  ClipperLib.ClipperBase.horizontal = -9007199254740992; //-2^53\n\t  ClipperLib.ClipperBase.Skip = -2;\n\t  ClipperLib.ClipperBase.Unassigned = -1;\n\t  ClipperLib.ClipperBase.tolerance = 1E-20;\n\t  if (use_int32)\n\t  {\n\t    ClipperLib.ClipperBase.loRange = 0x7FFF;\n\t    ClipperLib.ClipperBase.hiRange = 0x7FFF;\n\t  }\n\t  else\n\t  {\n\t    ClipperLib.ClipperBase.loRange = 47453132; // sqrt(2^53 -1)/2\n\t    ClipperLib.ClipperBase.hiRange = 4503599627370495; // sqrt(2^106 -1)/2\n\t  }\n\t\n\t  ClipperLib.ClipperBase.near_zero = function (val)\n\t  {\n\t    return (val > -ClipperLib.ClipperBase.tolerance) && (val < ClipperLib.ClipperBase.tolerance);\n\t  };\n\t  ClipperLib.ClipperBase.IsHorizontal = function (e)\n\t  {\n\t    return e.Delta.Y === 0;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.PointIsVertex = function (pt, pp)\n\t  {\n\t    var pp2 = pp;\n\t    do {\n\t      if (ClipperLib.IntPoint.op_Equality(pp2.Pt, pt))\n\t        return true;\n\t      pp2 = pp2.Next;\n\t    }\n\t    while (pp2 != pp)\n\t    return false;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.PointOnLineSegment = function (pt, linePt1, linePt2, UseFullRange)\n\t  {\n\t    if (UseFullRange)\n\t      return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) ||\n\t        ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) ||\n\t        (((pt.X > linePt1.X) == (pt.X < linePt2.X)) &&\n\t        ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) &&\n\t        (Int128.op_Equality(Int128.Int128Mul((pt.X - linePt1.X), (linePt2.Y - linePt1.Y)),\n\t          Int128.Int128Mul((linePt2.X - linePt1.X), (pt.Y - linePt1.Y)))));\n\t    else\n\t      return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) || ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) || (((pt.X > linePt1.X) == (pt.X < linePt2.X)) && ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) && ((pt.X - linePt1.X) * (linePt2.Y - linePt1.Y) == (linePt2.X - linePt1.X) * (pt.Y - linePt1.Y)));\n\t  };\n\t  ClipperLib.ClipperBase.prototype.PointOnPolygon = function (pt, pp, UseFullRange)\n\t  {\n\t    var pp2 = pp;\n\t    while (true)\n\t    {\n\t      if (this.PointOnLineSegment(pt, pp2.Pt, pp2.Next.Pt, UseFullRange))\n\t        return true;\n\t      pp2 = pp2.Next;\n\t      if (pp2 == pp)\n\t        break;\n\t    }\n\t    return false;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.SlopesEqual = ClipperLib.ClipperBase.SlopesEqual = function ()\n\t  {\n\t    var a = arguments,\n\t      alen = a.length;\n\t    var e1, e2, pt1, pt2, pt3, pt4, UseFullRange;\n\t    if (alen == 3) // function (e1, e2, UseFullRange)\n\t    {\n\t      e1 = a[0];\n\t      e2 = a[1];\n\t      UseFullRange = a[2];\n\t      if (UseFullRange)\n\t        return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n\t      else\n\t        return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n\t    }\n\t    else if (alen == 4) // function (pt1, pt2, pt3, UseFullRange)\n\t    {\n\t      pt1 = a[0];\n\t      pt2 = a[1];\n\t      pt3 = a[2];\n\t      UseFullRange = a[3];\n\t      if (UseFullRange)\n\t        return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n\t      else\n\t        return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n\t    }\n\t    else // function (pt1, pt2, pt3, pt4, UseFullRange)\n\t    {\n\t      pt1 = a[0];\n\t      pt2 = a[1];\n\t      pt3 = a[2];\n\t      pt4 = a[3];\n\t      UseFullRange = a[4];\n\t      if (UseFullRange)\n\t        return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n\t      else\n\t        return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n\t    }\n\t  };\n\t  ClipperLib.ClipperBase.SlopesEqual3 = function (e1, e2, UseFullRange)\n\t  {\n\t    if (UseFullRange)\n\t      return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n\t    else\n\t      return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n\t  };\n\t  ClipperLib.ClipperBase.SlopesEqual4 = function (pt1, pt2, pt3, UseFullRange)\n\t  {\n\t    if (UseFullRange)\n\t      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n\t    else\n\t      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n\t  };\n\t  ClipperLib.ClipperBase.SlopesEqual5 = function (pt1, pt2, pt3, pt4, UseFullRange)\n\t  {\n\t    if (UseFullRange)\n\t      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n\t    else\n\t      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.Clear = function ()\n\t  {\n\t    this.DisposeLocalMinimaList();\n\t    for (var i = 0, ilen = this.m_edges.length; i < ilen; ++i)\n\t    {\n\t      for (var j = 0, jlen = this.m_edges[i].length; j < jlen; ++j)\n\t        this.m_edges[i][j] = null;\n\t      ClipperLib.Clear(this.m_edges[i]);\n\t    }\n\t    ClipperLib.Clear(this.m_edges);\n\t    this.m_UseFullRange = false;\n\t    this.m_HasOpenPaths = false;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.DisposeLocalMinimaList = function ()\n\t  {\n\t    while (this.m_MinimaList !== null)\n\t    {\n\t      var tmpLm = this.m_MinimaList.Next;\n\t      this.m_MinimaList = null;\n\t      this.m_MinimaList = tmpLm;\n\t    }\n\t    this.m_CurrentLM = null;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.RangeTest = function (Pt, useFullRange)\n\t  {\n\t    if (useFullRange.Value)\n\t    {\n\t      if (Pt.X > ClipperLib.ClipperBase.hiRange || Pt.Y > ClipperLib.ClipperBase.hiRange || -Pt.X > ClipperLib.ClipperBase.hiRange || -Pt.Y > ClipperLib.ClipperBase.hiRange)\n\t        ClipperLib.Error(\"Coordinate outside allowed range in RangeTest().\");\n\t    }\n\t    else if (Pt.X > ClipperLib.ClipperBase.loRange || Pt.Y > ClipperLib.ClipperBase.loRange || -Pt.X > ClipperLib.ClipperBase.loRange || -Pt.Y > ClipperLib.ClipperBase.loRange)\n\t    {\n\t      useFullRange.Value = true;\n\t      this.RangeTest(Pt, useFullRange);\n\t    }\n\t  };\n\t  ClipperLib.ClipperBase.prototype.InitEdge = function (e, eNext, ePrev, pt)\n\t  {\n\t    e.Next = eNext;\n\t    e.Prev = ePrev;\n\t    //e.Curr = pt;\n\t    e.Curr.X = pt.X;\n\t    e.Curr.Y = pt.Y;\n\t    e.OutIdx = -1;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.InitEdge2 = function (e, polyType)\n\t  {\n\t    if (e.Curr.Y >= e.Next.Curr.Y)\n\t    {\n\t      //e.Bot = e.Curr;\n\t      e.Bot.X = e.Curr.X;\n\t      e.Bot.Y = e.Curr.Y;\n\t      //e.Top = e.Next.Curr;\n\t      e.Top.X = e.Next.Curr.X;\n\t      e.Top.Y = e.Next.Curr.Y;\n\t    }\n\t    else\n\t    {\n\t      //e.Top = e.Curr;\n\t      e.Top.X = e.Curr.X;\n\t      e.Top.Y = e.Curr.Y;\n\t      //e.Bot = e.Next.Curr;\n\t      e.Bot.X = e.Next.Curr.X;\n\t      e.Bot.Y = e.Next.Curr.Y;\n\t    }\n\t    this.SetDx(e);\n\t    e.PolyTyp = polyType;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.FindNextLocMin = function (E)\n\t  {\n\t    var E2;\n\t    for (;;)\n\t    {\n\t      while (ClipperLib.IntPoint.op_Inequality(E.Bot, E.Prev.Bot) || ClipperLib.IntPoint.op_Equality(E.Curr, E.Top))\n\t        E = E.Next;\n\t      if (E.Dx != ClipperLib.ClipperBase.horizontal && E.Prev.Dx != ClipperLib.ClipperBase.horizontal)\n\t        break;\n\t      while (E.Prev.Dx == ClipperLib.ClipperBase.horizontal)\n\t        E = E.Prev;\n\t      E2 = E;\n\t      while (E.Dx == ClipperLib.ClipperBase.horizontal)\n\t        E = E.Next;\n\t      if (E.Top.Y == E.Prev.Bot.Y)\n\t        continue;\n\t      //ie just an intermediate horz.\n\t      if (E2.Prev.Bot.X < E.Bot.X)\n\t        E = E2;\n\t      break;\n\t    }\n\t    return E;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.ProcessBound = function (E, LeftBoundIsForward)\n\t  {\n\t    var EStart;\n\t    var Result = E;\n\t    var Horz;\n\t\n\t      if (Result.OutIdx == ClipperLib.ClipperBase.Skip)\n\t      {\n\t        //check if there are edges beyond the skip edge in the bound and if so\n\t        //create another LocMin and calling ProcessBound once more ...\n\t        E = Result;\n\t        if (LeftBoundIsForward)\n\t        {\n\t          while (E.Top.Y == E.Next.Bot.Y) E = E.Next;\n\t          while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Prev;\n\t        }\n\t        else\n\t        {\n\t          while (E.Top.Y == E.Prev.Bot.Y) E = E.Prev;\n\t          while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Next;\n\t        }\n\t        if (E == Result)\n\t        {\n\t          if (LeftBoundIsForward) Result = E.Next;\n\t          else Result = E.Prev;\n\t        }\n\t        else\n\t        {\n\t          //there are more edges in the bound beyond result starting with E\n\t          if (LeftBoundIsForward)\n\t            E = Result.Next;\n\t          else\n\t            E = Result.Prev;\n\t          var locMin = new ClipperLib.LocalMinima();\n\t          locMin.Next = null;\n\t          locMin.Y = E.Bot.Y;\n\t          locMin.LeftBound = null;\n\t          locMin.RightBound = E;\n\t          E.WindDelta = 0;\n\t          Result = this.ProcessBound(E, LeftBoundIsForward);\n\t          this.InsertLocalMinima(locMin);\n\t        }\n\t        return Result;\n\t      }\n\t\n\t      if (E.Dx == ClipperLib.ClipperBase.horizontal)\n\t      {\n\t        //We need to be careful with open paths because this may not be a\n\t        //true local minima (ie E may be following a skip edge).\n\t        //Also, consecutive horz. edges may start heading left before going right.\n\t        if (LeftBoundIsForward) EStart = E.Prev;\n\t        else EStart = E.Next;\n\t        if (EStart.OutIdx != ClipperLib.ClipperBase.Skip)\n\t        {\n\t          if (EStart.Dx == ClipperLib.ClipperBase.horizontal) //ie an adjoining horizontal skip edge\n\t          {\n\t            if (EStart.Bot.X != E.Bot.X && EStart.Top.X != E.Bot.X)\n\t              this.ReverseHorizontal(E);\n\t          }\n\t          else if (EStart.Bot.X != E.Bot.X)\n\t            this.ReverseHorizontal(E);\n\t        }\n\t      }\n\t\n\t      EStart = E;\n\t      if (LeftBoundIsForward)\n\t      {\n\t        while (Result.Top.Y == Result.Next.Bot.Y && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n\t          Result = Result.Next;\n\t        if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n\t        {\n\t          //nb: at the top of a bound, horizontals are added to the bound\n\t          //only when the preceding edge attaches to the horizontal's left vertex\n\t          //unless a Skip edge is encountered when that becomes the top divide\n\t          Horz = Result;\n\t          while (Horz.Prev.Dx == ClipperLib.ClipperBase.horizontal)\n\t            Horz = Horz.Prev;\n\t          if (Horz.Prev.Top.X == Result.Next.Top.X)\n\t          {\n\t            if (!LeftBoundIsForward)\n\t              Result = Horz.Prev;\n\t          }\n\t          else if (Horz.Prev.Top.X > Result.Next.Top.X)\n\t            Result = Horz.Prev;\n\t        }\n\t        while (E != Result)\n\t        {\n\t          E.NextInLML = E.Next;\n\t          if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)\n\t            this.ReverseHorizontal(E);\n\t          E = E.Next;\n\t        }\n\t        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)\n\t          this.ReverseHorizontal(E);\n\t        Result = Result.Next;\n\t        //move to the edge just beyond current bound\n\t      }\n\t      else\n\t      {\n\t        while (Result.Top.Y == Result.Prev.Bot.Y && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)\n\t          Result = Result.Prev;\n\t        if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)\n\t        {\n\t          Horz = Result;\n\t          while (Horz.Next.Dx == ClipperLib.ClipperBase.horizontal)\n\t            Horz = Horz.Next;\n\t          if (Horz.Next.Top.X == Result.Prev.Top.X)\n\t          {\n\t            if (!LeftBoundIsForward)\n\t              Result = Horz.Next;\n\t          }\n\t          else if (Horz.Next.Top.X > Result.Prev.Top.X)\n\t            Result = Horz.Next;\n\t        }\n\t        while (E != Result)\n\t        {\n\t          E.NextInLML = E.Prev;\n\t          if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)\n\t            this.ReverseHorizontal(E);\n\t          E = E.Prev;\n\t        }\n\t        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)\n\t          this.ReverseHorizontal(E);\n\t        Result = Result.Prev;\n\t        //move to the edge just beyond current bound\n\t      }\n\t\n\t    return Result;\n\t  };\n\t\n\t  ClipperLib.ClipperBase.prototype.AddPath = function (pg, polyType, Closed)\n\t  {\n\t    if (use_lines)\n\t    {\n\t      if (!Closed && polyType == ClipperLib.PolyType.ptClip)\n\t        ClipperLib.Error(\"AddPath: Open paths must be subject.\");\n\t    }\n\t    else\n\t    {\n\t      if (!Closed)\n\t        ClipperLib.Error(\"AddPath: Open paths have been disabled.\");\n\t    }\n\t    var highI = pg.length - 1;\n\t    if (Closed)\n\t      while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[0])))\n\t    --highI;\n\t    while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[highI - 1])))\n\t    --highI;\n\t    if ((Closed && highI < 2) || (!Closed && highI < 1))\n\t      return false;\n\t    //create a new edge array ...\n\t    var edges = new Array();\n\t    for (var i = 0; i <= highI; i++)\n\t      edges.push(new ClipperLib.TEdge());\n\t    var IsFlat = true;\n\t    //1. Basic (first) edge initialization ...\n\t\n\t    //edges[1].Curr = pg[1];\n\t    edges[1].Curr.X = pg[1].X;\n\t    edges[1].Curr.Y = pg[1].Y;\n\t\n\t    var $1 = {Value: this.m_UseFullRange};\n\t    this.RangeTest(pg[0], $1);\n\t    this.m_UseFullRange = $1.Value;\n\t\n\t    $1.Value = this.m_UseFullRange;\n\t    this.RangeTest(pg[highI], $1);\n\t    this.m_UseFullRange = $1.Value;\n\t\n\t    this.InitEdge(edges[0], edges[1], edges[highI], pg[0]);\n\t    this.InitEdge(edges[highI], edges[0], edges[highI - 1], pg[highI]);\n\t    for (var i = highI - 1; i >= 1; --i)\n\t    {\n\t      $1.Value = this.m_UseFullRange;\n\t      this.RangeTest(pg[i], $1);\n\t      this.m_UseFullRange = $1.Value;\n\t\n\t      this.InitEdge(edges[i], edges[i + 1], edges[i - 1], pg[i]);\n\t    }\n\t\n\t    var eStart = edges[0];\n\t    //2. Remove duplicate vertices, and (when closed) collinear edges ...\n\t    var E = eStart,\n\t      eLoopStop = eStart;\n\t    for (;;)\n\t    {\n\t    //console.log(E.Next, eStart);\n\t    \t//nb: allows matching start and end points when not Closed ...\n\t      if (E.Curr == E.Next.Curr && (Closed || E.Next != eStart))\n\t      {\n\t        if (E == E.Next)\n\t          break;\n\t        if (E == eStart)\n\t          eStart = E.Next;\n\t        E = this.RemoveEdge(E);\n\t        eLoopStop = E;\n\t        continue;\n\t      }\n\t      if (E.Prev == E.Next)\n\t        break;\n\t      else if (Closed && ClipperLib.ClipperBase.SlopesEqual(E.Prev.Curr, E.Curr, E.Next.Curr, this.m_UseFullRange) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(E.Prev.Curr, E.Curr, E.Next.Curr)))\n\t      {\n\t        //Collinear edges are allowed for open paths but in closed paths\n\t        //the default is to merge adjacent collinear edges into a single edge.\n\t        //However, if the PreserveCollinear property is enabled, only overlapping\n\t        //collinear edges (ie spikes) will be removed from closed paths.\n\t        if (E == eStart)\n\t          eStart = E.Next;\n\t        E = this.RemoveEdge(E);\n\t        E = E.Prev;\n\t        eLoopStop = E;\n\t        continue;\n\t      }\n\t      E = E.Next;\n\t      if ((E == eLoopStop) || (!Closed && E.Next == eStart)) break;\n\t    }\n\t    if ((!Closed && (E == E.Next)) || (Closed && (E.Prev == E.Next)))\n\t      return false;\n\t    if (!Closed)\n\t    {\n\t      this.m_HasOpenPaths = true;\n\t      eStart.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n\t    }\n\t    //3. Do second stage of edge initialization ...\n\t    E = eStart;\n\t    do {\n\t      this.InitEdge2(E, polyType);\n\t      E = E.Next;\n\t      if (IsFlat && E.Curr.Y != eStart.Curr.Y)\n\t        IsFlat = false;\n\t    }\n\t    while (E != eStart)\n\t    //4. Finally, add edge bounds to LocalMinima list ...\n\t    //Totally flat paths must be handled differently when adding them\n\t    //to LocalMinima list to avoid endless loops etc ...\n\t    if (IsFlat)\n\t    {\n\t      if (Closed)\n\t        return false;\n\t      E.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n\t      if (E.Prev.Bot.X < E.Prev.Top.X)\n\t        this.ReverseHorizontal(E.Prev);\n\t      var locMin = new ClipperLib.LocalMinima();\n\t      locMin.Next = null;\n\t      locMin.Y = E.Bot.Y;\n\t      locMin.LeftBound = null;\n\t      locMin.RightBound = E;\n\t      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n\t      locMin.RightBound.WindDelta = 0;\n\t      while (E.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n\t      {\n\t        E.NextInLML = E.Next;\n\t        if (E.Bot.X != E.Prev.Top.X)\n\t          this.ReverseHorizontal(E);\n\t        E = E.Next;\n\t      }\n\t      this.InsertLocalMinima(locMin);\n\t      this.m_edges.push(edges);\n\t      return true;\n\t    }\n\t    this.m_edges.push(edges);\n\t    var leftBoundIsForward;\n\t    var EMin = null;\n\t\n\t\t\t//workaround to avoid an endless loop in the while loop below when\n\t    //open paths have matching start and end points ...\n\t    if(ClipperLib.IntPoint.op_Equality(E.Prev.Bot, E.Prev.Top))\n\t    \tE = E.Next;\n\t\n\t    for (;;)\n\t    {\n\t      E = this.FindNextLocMin(E);\n\t      if (E == EMin)\n\t        break;\n\t      else if (EMin == null)\n\t        EMin = E;\n\t      //E and E.Prev now share a local minima (left aligned if horizontal).\n\t      //Compare their slopes to find which starts which bound ...\n\t      var locMin = new ClipperLib.LocalMinima();\n\t      locMin.Next = null;\n\t      locMin.Y = E.Bot.Y;\n\t      if (E.Dx < E.Prev.Dx)\n\t      {\n\t        locMin.LeftBound = E.Prev;\n\t        locMin.RightBound = E;\n\t        leftBoundIsForward = false;\n\t        //Q.nextInLML = Q.prev\n\t      }\n\t      else\n\t      {\n\t        locMin.LeftBound = E;\n\t        locMin.RightBound = E.Prev;\n\t        leftBoundIsForward = true;\n\t        //Q.nextInLML = Q.next\n\t      }\n\t      locMin.LeftBound.Side = ClipperLib.EdgeSide.esLeft;\n\t      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n\t      if (!Closed)\n\t        locMin.LeftBound.WindDelta = 0;\n\t      else if (locMin.LeftBound.Next == locMin.RightBound)\n\t        locMin.LeftBound.WindDelta = -1;\n\t      else\n\t        locMin.LeftBound.WindDelta = 1;\n\t      locMin.RightBound.WindDelta = -locMin.LeftBound.WindDelta;\n\t      E = this.ProcessBound(locMin.LeftBound, leftBoundIsForward);\n\t      if (E.OutIdx == ClipperLib.ClipperBase.Skip)\n\t      \tE = this.ProcessBound(E, leftBoundIsForward);\n\t      var E2 = this.ProcessBound(locMin.RightBound, !leftBoundIsForward);\n\t      if (E2.OutIdx == ClipperLib.ClipperBase.Skip) E2 = this.ProcessBound(E2, !leftBoundIsForward);\n\t      if (locMin.LeftBound.OutIdx == ClipperLib.ClipperBase.Skip)\n\t        locMin.LeftBound = null;\n\t      else if (locMin.RightBound.OutIdx == ClipperLib.ClipperBase.Skip)\n\t        locMin.RightBound = null;\n\t      this.InsertLocalMinima(locMin);\n\t      if (!leftBoundIsForward)\n\t        E = E2;\n\t    }\n\t    return true;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.AddPaths = function (ppg, polyType, closed)\n\t  {\n\t    //  console.log(\"-------------------------------------------\");\n\t    //  console.log(JSON.stringify(ppg));\n\t    var result = false;\n\t    for (var i = 0, ilen = ppg.length; i < ilen; ++i)\n\t      if (this.AddPath(ppg[i], polyType, closed))\n\t        result = true;\n\t    return result;\n\t  };\n\t  //------------------------------------------------------------------------------\n\t  ClipperLib.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3 = function (pt1, pt2, pt3)\n\t  {\n\t    if ((ClipperLib.IntPoint.op_Equality(pt1, pt3)) || (ClipperLib.IntPoint.op_Equality(pt1, pt2)) ||       (ClipperLib.IntPoint.op_Equality(pt3, pt2)))\n\t\n\t   //if ((pt1 == pt3) || (pt1 == pt2) || (pt3 == pt2))\n\t   return false;\n\t\n\t    else if (pt1.X != pt3.X)\n\t      return (pt2.X > pt1.X) == (pt2.X < pt3.X);\n\t    else\n\t      return (pt2.Y > pt1.Y) == (pt2.Y < pt3.Y);\n\t  };\n\t  ClipperLib.ClipperBase.prototype.RemoveEdge = function (e)\n\t  {\n\t    //removes e from double_linked_list (but without removing from memory)\n\t    e.Prev.Next = e.Next;\n\t    e.Next.Prev = e.Prev;\n\t    var result = e.Next;\n\t    e.Prev = null; //flag as removed (see ClipperBase.Clear)\n\t    return result;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.SetDx = function (e)\n\t  {\n\t    e.Delta.X = (e.Top.X - e.Bot.X);\n\t    e.Delta.Y = (e.Top.Y - e.Bot.Y);\n\t    if (e.Delta.Y === 0) e.Dx = ClipperLib.ClipperBase.horizontal;\n\t    else e.Dx = (e.Delta.X) / (e.Delta.Y);\n\t  };\n\t  ClipperLib.ClipperBase.prototype.InsertLocalMinima = function (newLm)\n\t  {\n\t    if (this.m_MinimaList === null)\n\t    {\n\t      this.m_MinimaList = newLm;\n\t    }\n\t    else if (newLm.Y >= this.m_MinimaList.Y)\n\t    {\n\t      newLm.Next = this.m_MinimaList;\n\t      this.m_MinimaList = newLm;\n\t    }\n\t    else\n\t    {\n\t      var tmpLm = this.m_MinimaList;\n\t      while (tmpLm.Next !== null && (newLm.Y < tmpLm.Next.Y))\n\t        tmpLm = tmpLm.Next;\n\t      newLm.Next = tmpLm.Next;\n\t      tmpLm.Next = newLm;\n\t    }\n\t  };\n\t  ClipperLib.ClipperBase.prototype.PopLocalMinima = function ()\n\t  {\n\t    if (this.m_CurrentLM === null)\n\t      return;\n\t    this.m_CurrentLM = this.m_CurrentLM.Next;\n\t  };\n\t  ClipperLib.ClipperBase.prototype.ReverseHorizontal = function (e)\n\t  {\n\t    //swap horizontal edges' top and bottom x's so they follow the natural\n\t    //progression of the bounds - ie so their xbots will align with the\n\t    //adjoining lower edge. [Helpful in the ProcessHorizontal() method.]\n\t    var tmp = e.Top.X;\n\t    e.Top.X = e.Bot.X;\n\t    e.Bot.X = tmp;\n\t    if (use_xyz)\n\t    {\n\t      tmp = e.Top.Z;\n\t      e.Top.Z = e.Bot.Z;\n\t      e.Bot.Z = tmp;\n\t    }\n\t  };\n\t  ClipperLib.ClipperBase.prototype.Reset = function ()\n\t  {\n\t    this.m_CurrentLM = this.m_MinimaList;\n\t    if (this.m_CurrentLM == null)\n\t      return;\n\t    //ie nothing to process\n\t    //reset all edges ...\n\t    var lm = this.m_MinimaList;\n\t    while (lm != null)\n\t    {\n\t      var e = lm.LeftBound;\n\t      if (e != null)\n\t      {\n\t        //e.Curr = e.Bot;\n\t        e.Curr.X = e.Bot.X;\n\t        e.Curr.Y = e.Bot.Y;\n\t        e.Side = ClipperLib.EdgeSide.esLeft;\n\t        e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n\t      }\n\t      e = lm.RightBound;\n\t      if (e != null)\n\t      {\n\t        //e.Curr = e.Bot;\n\t        e.Curr.X = e.Bot.X;\n\t        e.Curr.Y = e.Bot.Y;\n\t        e.Side = ClipperLib.EdgeSide.esRight;\n\t        e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n\t      }\n\t      lm = lm.Next;\n\t    }\n\t  };\n\t  ClipperLib.Clipper = function (InitOptions) // public Clipper(int InitOptions = 0)\n\t  {\n\t    if (typeof (InitOptions) == \"undefined\") InitOptions = 0;\n\t    this.m_PolyOuts = null;\n\t    this.m_ClipType = ClipperLib.ClipType.ctIntersection;\n\t    this.m_Scanbeam = null;\n\t    this.m_ActiveEdges = null;\n\t    this.m_SortedEdges = null;\n\t    this.m_IntersectList = null;\n\t    this.m_IntersectNodeComparer = null;\n\t    this.m_ExecuteLocked = false;\n\t    this.m_ClipFillType = ClipperLib.PolyFillType.pftEvenOdd;\n\t    this.m_SubjFillType = ClipperLib.PolyFillType.pftEvenOdd;\n\t    this.m_Joins = null;\n\t    this.m_GhostJoins = null;\n\t    this.m_UsingPolyTree = false;\n\t    this.ReverseSolution = false;\n\t    this.StrictlySimple = false;\n\t    ClipperLib.ClipperBase.call(this);\n\t    this.m_Scanbeam = null;\n\t    this.m_ActiveEdges = null;\n\t    this.m_SortedEdges = null;\n\t    this.m_IntersectList = new Array();\n\t    this.m_IntersectNodeComparer = ClipperLib.MyIntersectNodeSort.Compare;\n\t    this.m_ExecuteLocked = false;\n\t    this.m_UsingPolyTree = false;\n\t    this.m_PolyOuts = new Array();\n\t    this.m_Joins = new Array();\n\t    this.m_GhostJoins = new Array();\n\t    this.ReverseSolution = (1 & InitOptions) !== 0;\n\t    this.StrictlySimple = (2 & InitOptions) !== 0;\n\t    this.PreserveCollinear = (4 & InitOptions) !== 0;\n\t    if (use_xyz)\n\t    {\n\t      this.ZFillFunction = null; // function (IntPoint vert1, IntPoint vert2, ref IntPoint intersectPt);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.ioReverseSolution = 1;\n\t  ClipperLib.Clipper.ioStrictlySimple = 2;\n\t  ClipperLib.Clipper.ioPreserveCollinear = 4;\n\t\n\t  ClipperLib.Clipper.prototype.Clear = function ()\n\t  {\n\t    if (this.m_edges.length === 0)\n\t      return;\n\t    //avoids problems with ClipperBase destructor\n\t    this.DisposeAllPolyPts();\n\t    ClipperLib.ClipperBase.prototype.Clear.call(this);\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.DisposeScanbeamList = function ()\n\t  {\n\t    while (this.m_Scanbeam !== null)\n\t    {\n\t      var sb2 = this.m_Scanbeam.Next;\n\t      this.m_Scanbeam = null;\n\t      this.m_Scanbeam = sb2;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.Reset = function ()\n\t  {\n\t    ClipperLib.ClipperBase.prototype.Reset.call(this);\n\t    this.m_Scanbeam = null;\n\t    this.m_ActiveEdges = null;\n\t    this.m_SortedEdges = null;\n\t\n\t    var lm = this.m_MinimaList;\n\t    while (lm !== null)\n\t    {\n\t      this.InsertScanbeam(lm.Y);\n\t      lm = lm.Next;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.InsertScanbeam = function (Y)\n\t  {\n\t    if (this.m_Scanbeam === null)\n\t    {\n\t      this.m_Scanbeam = new ClipperLib.Scanbeam();\n\t      this.m_Scanbeam.Next = null;\n\t      this.m_Scanbeam.Y = Y;\n\t    }\n\t    else if (Y > this.m_Scanbeam.Y)\n\t    {\n\t      var newSb = new ClipperLib.Scanbeam();\n\t      newSb.Y = Y;\n\t      newSb.Next = this.m_Scanbeam;\n\t      this.m_Scanbeam = newSb;\n\t    }\n\t    else\n\t    {\n\t      var sb2 = this.m_Scanbeam;\n\t      while (sb2.Next !== null && (Y <= sb2.Next.Y))\n\t        sb2 = sb2.Next;\n\t      if (Y == sb2.Y)\n\t        return;\n\t      //ie ignores duplicates\n\t      var newSb = new ClipperLib.Scanbeam();\n\t      newSb.Y = Y;\n\t      newSb.Next = sb2.Next;\n\t      sb2.Next = newSb;\n\t    }\n\t  };\n\t  // ************************************\n\t  ClipperLib.Clipper.prototype.Execute = function ()\n\t  {\n\t    var a = arguments,\n\t      alen = a.length,\n\t      ispolytree = a[1] instanceof ClipperLib.PolyTree;\n\t    if (alen == 4 && !ispolytree) // function (clipType, solution, subjFillType, clipFillType)\n\t    {\n\t      var clipType = a[0],\n\t        solution = a[1],\n\t        subjFillType = a[2],\n\t        clipFillType = a[3];\n\t      if (this.m_ExecuteLocked)\n\t        return false;\n\t      if (this.m_HasOpenPaths)\n\t        ClipperLib.Error(\"Error: PolyTree struct is need for open path clipping.\");\n\t      this.m_ExecuteLocked = true;\n\t      ClipperLib.Clear(solution);\n\t      this.m_SubjFillType = subjFillType;\n\t      this.m_ClipFillType = clipFillType;\n\t      this.m_ClipType = clipType;\n\t      this.m_UsingPolyTree = false;\n\t      try\n\t      {\n\t        var succeeded = this.ExecuteInternal();\n\t        //build the return polygons ...\n\t        if (succeeded) this.BuildResult(solution);\n\t      }\n\t      finally\n\t      {\n\t        this.DisposeAllPolyPts();\n\t        this.m_ExecuteLocked = false;\n\t      }\n\t      return succeeded;\n\t    }\n\t    else if (alen == 4 && ispolytree) // function (clipType, polytree, subjFillType, clipFillType)\n\t    {\n\t      var clipType = a[0],\n\t        polytree = a[1],\n\t        subjFillType = a[2],\n\t        clipFillType = a[3];\n\t      if (this.m_ExecuteLocked)\n\t        return false;\n\t      this.m_ExecuteLocked = true;\n\t      this.m_SubjFillType = subjFillType;\n\t      this.m_ClipFillType = clipFillType;\n\t      this.m_ClipType = clipType;\n\t      this.m_UsingPolyTree = true;\n\t      try\n\t      {\n\t        var succeeded = this.ExecuteInternal();\n\t        //build the return polygons ...\n\t        if (succeeded) this.BuildResult2(polytree);\n\t      }\n\t      finally\n\t      {\n\t        this.DisposeAllPolyPts();\n\t        this.m_ExecuteLocked = false;\n\t      }\n\t      return succeeded;\n\t    }\n\t    else if (alen == 2 && !ispolytree) // function (clipType, solution)\n\t    {\n\t      var clipType = a[0],\n\t        solution = a[1];\n\t      return this.Execute(clipType, solution, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n\t    }\n\t    else if (alen == 2 && ispolytree) // function (clipType, polytree)\n\t    {\n\t      var clipType = a[0],\n\t        polytree = a[1];\n\t      return this.Execute(clipType, polytree, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.FixHoleLinkage = function (outRec)\n\t  {\n\t    //skip if an outermost polygon or\n\t    //already already points to the correct FirstLeft ...\n\t    if (outRec.FirstLeft === null || (outRec.IsHole != outRec.FirstLeft.IsHole && outRec.FirstLeft.Pts !== null))\n\t      return;\n\t    var orfl = outRec.FirstLeft;\n\t    while (orfl !== null && ((orfl.IsHole == outRec.IsHole) || orfl.Pts === null))\n\t      orfl = orfl.FirstLeft;\n\t    outRec.FirstLeft = orfl;\n\t  };\n\t  ClipperLib.Clipper.prototype.ExecuteInternal = function ()\n\t  {\n\t    try\n\t    {\n\t      this.Reset();\n\t      if (this.m_CurrentLM === null)\n\t        return false;\n\t      var botY = this.PopScanbeam();\n\t      do {\n\t        this.InsertLocalMinimaIntoAEL(botY);\n\t        ClipperLib.Clear(this.m_GhostJoins);\n\t        this.ProcessHorizontals(false);\n\t        if (this.m_Scanbeam === null)\n\t          break;\n\t        var topY = this.PopScanbeam();\n\t        if (!this.ProcessIntersections(topY)) return false;\n\t\n\t        this.ProcessEdgesAtTopOfScanbeam(topY);\n\t        botY = topY;\n\t      }\n\t      while (this.m_Scanbeam !== null || this.m_CurrentLM !== null)\n\t      //fix orientations ...\n\t      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t      {\n\t        var outRec = this.m_PolyOuts[i];\n\t        if (outRec.Pts === null || outRec.IsOpen)\n\t          continue;\n\t        if ((outRec.IsHole ^ this.ReverseSolution) == (this.Area(outRec) > 0))\n\t          this.ReversePolyPtLinks(outRec.Pts);\n\t      }\n\t      this.JoinCommonEdges();\n\t      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t      {\n\t        var outRec = this.m_PolyOuts[i];\n\t        if (outRec.Pts !== null && !outRec.IsOpen)\n\t          this.FixupOutPolygon(outRec);\n\t      }\n\t      if (this.StrictlySimple)\n\t        this.DoSimplePolygons();\n\t      return true;\n\t    }\n\t    finally\n\t    {\n\t      ClipperLib.Clear(this.m_Joins);\n\t      ClipperLib.Clear(this.m_GhostJoins);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.PopScanbeam = function ()\n\t  {\n\t    var Y = this.m_Scanbeam.Y;\n\t    this.m_Scanbeam = this.m_Scanbeam.Next;\n\t    return Y;\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.DisposeAllPolyPts = function ()\n\t  {\n\t    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; ++i)\n\t      this.DisposeOutRec(i);\n\t    ClipperLib.Clear(this.m_PolyOuts);\n\t  };\n\t  ClipperLib.Clipper.prototype.DisposeOutRec = function (index)\n\t  {\n\t    var outRec = this.m_PolyOuts[index];\n\t    outRec.Pts = null;\n\t    outRec = null;\n\t    this.m_PolyOuts[index] = null;\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.AddJoin = function (Op1, Op2, OffPt)\n\t  {\n\t    var j = new ClipperLib.Join();\n\t    j.OutPt1 = Op1;\n\t    j.OutPt2 = Op2;\n\t    //j.OffPt = OffPt;\n\t    j.OffPt.X = OffPt.X;\n\t    j.OffPt.Y = OffPt.Y;\n\t    this.m_Joins.push(j);\n\t  };\n\t  ClipperLib.Clipper.prototype.AddGhostJoin = function (Op, OffPt)\n\t  {\n\t    var j = new ClipperLib.Join();\n\t    j.OutPt1 = Op;\n\t    //j.OffPt = OffPt;\n\t    j.OffPt.X = OffPt.X;\n\t    j.OffPt.Y = OffPt.Y;\n\t    this.m_GhostJoins.push(j);\n\t  };\n\t  if (use_xyz)\n\t  {\n\t    ClipperLib.Clipper.prototype.SetZ = function (pt, e1, e2)\n\t    {\n\t      if (this.ZFillFunction !== null)\n\t      {\n\t        if (pt.Z != 0 || this.ZFillFunction === null) return;\n\t        else if (ClipperLib.IntPoint.op_Equality(pt, e1.Bot)) pt.Z = e1.Bot.Z;\n\t        else if (ClipperLib.IntPoint.op_Equality(pt, e1.Top)) pt.Z = e1.Top.Z;\n\t        else if (ClipperLib.IntPoint.op_Equality(pt, e2.Bot)) pt.Z = e2.Bot.Z;\n\t        else if (ClipperLib.IntPoint.op_Equality(pt, e2.Top)) pt.Z = e2.Top.Z;\n\t        else ZFillFunction(e1.Bot, e1.Top, e2.Bot, e2.Top, pt);\n\t      }\n\t    };\n\t\n\t    //------------------------------------------------------------------------------\n\t  }\n\t\n\t  ClipperLib.Clipper.prototype.InsertLocalMinimaIntoAEL = function (botY)\n\t  {\n\t    while (this.m_CurrentLM !== null && (this.m_CurrentLM.Y == botY))\n\t    {\n\t      var lb = this.m_CurrentLM.LeftBound;\n\t      var rb = this.m_CurrentLM.RightBound;\n\t      this.PopLocalMinima();\n\t      var Op1 = null;\n\t      if (lb === null)\n\t      {\n\t        this.InsertEdgeIntoAEL(rb, null);\n\t        this.SetWindingCount(rb);\n\t        if (this.IsContributing(rb))\n\t          Op1 = this.AddOutPt(rb, rb.Bot);\n\t      }\n\t      else if (rb == null)\n\t      {\n\t        this.InsertEdgeIntoAEL(lb, null);\n\t        this.SetWindingCount(lb);\n\t        if (this.IsContributing(lb))\n\t          Op1 = this.AddOutPt(lb, lb.Bot);\n\t        this.InsertScanbeam(lb.Top.Y);\n\t      }\n\t      else\n\t      {\n\t        this.InsertEdgeIntoAEL(lb, null);\n\t        this.InsertEdgeIntoAEL(rb, lb);\n\t        this.SetWindingCount(lb);\n\t        rb.WindCnt = lb.WindCnt;\n\t        rb.WindCnt2 = lb.WindCnt2;\n\t        if (this.IsContributing(lb))\n\t          Op1 = this.AddLocalMinPoly(lb, rb, lb.Bot);\n\t        this.InsertScanbeam(lb.Top.Y);\n\t      }\n\t      if (rb != null)\n\t      {\n\t        if (ClipperLib.ClipperBase.IsHorizontal(rb))\n\t          this.AddEdgeToSEL(rb);\n\t        else\n\t          this.InsertScanbeam(rb.Top.Y);\n\t      }\n\t      if (lb == null || rb == null) continue;\n\t      //if output polygons share an Edge with a horizontal rb, they'll need joining later ...\n\t      if (Op1 !== null && ClipperLib.ClipperBase.IsHorizontal(rb) && this.m_GhostJoins.length > 0 && rb.WindDelta !== 0)\n\t      {\n\t        for (var i = 0, ilen = this.m_GhostJoins.length; i < ilen; i++)\n\t        {\n\t          //if the horizontal Rb and a 'ghost' horizontal overlap, then convert\n\t          //the 'ghost' join to a real join ready for later ...\n\t          var j = this.m_GhostJoins[i];\n\t\n\t\t\t\t\t\tif (this.HorzSegmentsOverlap(j.OutPt1.Pt.X, j.OffPt.X, rb.Bot.X, rb.Top.X))\n\t            this.AddJoin(j.OutPt1, Op1, j.OffPt);\n\t        }\n\t      }\n\t      if (lb.OutIdx >= 0 && lb.PrevInAEL !== null &&\n\t        lb.PrevInAEL.Curr.X == lb.Bot.X &&\n\t        lb.PrevInAEL.OutIdx >= 0 &&\n\t        ClipperLib.ClipperBase.SlopesEqual(lb.PrevInAEL, lb, this.m_UseFullRange) &&\n\t        lb.WindDelta !== 0 && lb.PrevInAEL.WindDelta !== 0)\n\t      {\n\t        var Op2 = this.AddOutPt(lb.PrevInAEL, lb.Bot);\n\t        this.AddJoin(Op1, Op2, lb.Top);\n\t      }\n\t      if (lb.NextInAEL != rb)\n\t      {\n\t        if (rb.OutIdx >= 0 && rb.PrevInAEL.OutIdx >= 0 &&\n\t          ClipperLib.ClipperBase.SlopesEqual(rb.PrevInAEL, rb, this.m_UseFullRange) &&\n\t          rb.WindDelta !== 0 && rb.PrevInAEL.WindDelta !== 0)\n\t        {\n\t          var Op2 = this.AddOutPt(rb.PrevInAEL, rb.Bot);\n\t          this.AddJoin(Op1, Op2, rb.Top);\n\t        }\n\t        var e = lb.NextInAEL;\n\t        if (e !== null)\n\t          while (e != rb)\n\t          {\n\t            //nb: For calculating winding counts etc, IntersectEdges() assumes\n\t            //that param1 will be to the right of param2 ABOVE the intersection ...\n\t            this.IntersectEdges(rb, e, lb.Curr, false);\n\t            //order important here\n\t            e = e.NextInAEL;\n\t          }\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.InsertEdgeIntoAEL = function (edge, startEdge)\n\t  {\n\t    if (this.m_ActiveEdges === null)\n\t    {\n\t      edge.PrevInAEL = null;\n\t      edge.NextInAEL = null;\n\t      this.m_ActiveEdges = edge;\n\t    }\n\t    else if (startEdge === null && this.E2InsertsBeforeE1(this.m_ActiveEdges, edge))\n\t    {\n\t      edge.PrevInAEL = null;\n\t      edge.NextInAEL = this.m_ActiveEdges;\n\t      this.m_ActiveEdges.PrevInAEL = edge;\n\t      this.m_ActiveEdges = edge;\n\t    }\n\t    else\n\t    {\n\t      if (startEdge === null)\n\t        startEdge = this.m_ActiveEdges;\n\t      while (startEdge.NextInAEL !== null && !this.E2InsertsBeforeE1(startEdge.NextInAEL, edge))\n\t        startEdge = startEdge.NextInAEL;\n\t      edge.NextInAEL = startEdge.NextInAEL;\n\t      if (startEdge.NextInAEL !== null)\n\t        startEdge.NextInAEL.PrevInAEL = edge;\n\t      edge.PrevInAEL = startEdge;\n\t      startEdge.NextInAEL = edge;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.E2InsertsBeforeE1 = function (e1, e2)\n\t  {\n\t    if (e2.Curr.X == e1.Curr.X)\n\t    {\n\t      if (e2.Top.Y > e1.Top.Y)\n\t        return e2.Top.X < ClipperLib.Clipper.TopX(e1, e2.Top.Y);\n\t      else\n\t        return e1.Top.X > ClipperLib.Clipper.TopX(e2, e1.Top.Y);\n\t    }\n\t    else\n\t      return e2.Curr.X < e1.Curr.X;\n\t  };\n\t  ClipperLib.Clipper.prototype.IsEvenOddFillType = function (edge)\n\t  {\n\t    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t      return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n\t    else\n\t      return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n\t  };\n\t  ClipperLib.Clipper.prototype.IsEvenOddAltFillType = function (edge)\n\t  {\n\t    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t      return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n\t    else\n\t      return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n\t  };\n\t  ClipperLib.Clipper.prototype.IsContributing = function (edge)\n\t  {\n\t    var pft, pft2;\n\t    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t    {\n\t      pft = this.m_SubjFillType;\n\t      pft2 = this.m_ClipFillType;\n\t    }\n\t    else\n\t    {\n\t      pft = this.m_ClipFillType;\n\t      pft2 = this.m_SubjFillType;\n\t    }\n\t    switch (pft)\n\t    {\n\t    case ClipperLib.PolyFillType.pftEvenOdd:\n\t      if (edge.WindDelta === 0 && edge.WindCnt != 1)\n\t        return false;\n\t      break;\n\t    case ClipperLib.PolyFillType.pftNonZero:\n\t      if (Math.abs(edge.WindCnt) != 1)\n\t        return false;\n\t      break;\n\t    case ClipperLib.PolyFillType.pftPositive:\n\t      if (edge.WindCnt != 1)\n\t        return false;\n\t      break;\n\t    default:\n\t      if (edge.WindCnt != -1)\n\t        return false;\n\t      break;\n\t    }\n\t    switch (this.m_ClipType)\n\t    {\n\t    case ClipperLib.ClipType.ctIntersection:\n\t      switch (pft2)\n\t      {\n\t      case ClipperLib.PolyFillType.pftEvenOdd:\n\t      case ClipperLib.PolyFillType.pftNonZero:\n\t        return (edge.WindCnt2 !== 0);\n\t      case ClipperLib.PolyFillType.pftPositive:\n\t        return (edge.WindCnt2 > 0);\n\t      default:\n\t        return (edge.WindCnt2 < 0);\n\t      }\n\t    case ClipperLib.ClipType.ctUnion:\n\t      switch (pft2)\n\t      {\n\t      case ClipperLib.PolyFillType.pftEvenOdd:\n\t      case ClipperLib.PolyFillType.pftNonZero:\n\t        return (edge.WindCnt2 === 0);\n\t      case ClipperLib.PolyFillType.pftPositive:\n\t        return (edge.WindCnt2 <= 0);\n\t      default:\n\t        return (edge.WindCnt2 >= 0);\n\t      }\n\t    case ClipperLib.ClipType.ctDifference:\n\t      if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t        switch (pft2)\n\t        {\n\t        case ClipperLib.PolyFillType.pftEvenOdd:\n\t        case ClipperLib.PolyFillType.pftNonZero:\n\t          return (edge.WindCnt2 === 0);\n\t        case ClipperLib.PolyFillType.pftPositive:\n\t          return (edge.WindCnt2 <= 0);\n\t        default:\n\t          return (edge.WindCnt2 >= 0);\n\t        }\n\t      else\n\t        switch (pft2)\n\t        {\n\t        case ClipperLib.PolyFillType.pftEvenOdd:\n\t        case ClipperLib.PolyFillType.pftNonZero:\n\t          return (edge.WindCnt2 !== 0);\n\t        case ClipperLib.PolyFillType.pftPositive:\n\t          return (edge.WindCnt2 > 0);\n\t        default:\n\t          return (edge.WindCnt2 < 0);\n\t        }\n\t    case ClipperLib.ClipType.ctXor:\n\t      if (edge.WindDelta === 0)\n\t        switch (pft2)\n\t        {\n\t        case ClipperLib.PolyFillType.pftEvenOdd:\n\t        case ClipperLib.PolyFillType.pftNonZero:\n\t          return (edge.WindCnt2 === 0);\n\t        case ClipperLib.PolyFillType.pftPositive:\n\t          return (edge.WindCnt2 <= 0);\n\t        default:\n\t          return (edge.WindCnt2 >= 0);\n\t        }\n\t      else\n\t        return true;\n\t    }\n\t    return true;\n\t  };\n\t  ClipperLib.Clipper.prototype.SetWindingCount = function (edge)\n\t  {\n\t    var e = edge.PrevInAEL;\n\t    //find the edge of the same polytype that immediately preceeds 'edge' in AEL\n\t    while (e !== null && ((e.PolyTyp != edge.PolyTyp) || (e.WindDelta === 0)))\n\t      e = e.PrevInAEL;\n\t    if (e === null)\n\t    {\n\t      edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n\t      edge.WindCnt2 = 0;\n\t      e = this.m_ActiveEdges;\n\t      //ie get ready to calc WindCnt2\n\t    }\n\t    else if (edge.WindDelta === 0 && this.m_ClipType != ClipperLib.ClipType.ctUnion)\n\t    {\n\t      edge.WindCnt = 1;\n\t      edge.WindCnt2 = e.WindCnt2;\n\t      e = e.NextInAEL;\n\t      //ie get ready to calc WindCnt2\n\t    }\n\t    else if (this.IsEvenOddFillType(edge))\n\t    {\n\t      //EvenOdd filling ...\n\t      if (edge.WindDelta === 0)\n\t      {\n\t        //are we inside a subj polygon ...\n\t        var Inside = true;\n\t        var e2 = e.PrevInAEL;\n\t        while (e2 !== null)\n\t        {\n\t          if (e2.PolyTyp == e.PolyTyp && e2.WindDelta !== 0)\n\t            Inside = !Inside;\n\t          e2 = e2.PrevInAEL;\n\t        }\n\t        edge.WindCnt = (Inside ? 0 : 1);\n\t      }\n\t      else\n\t      {\n\t        edge.WindCnt = edge.WindDelta;\n\t      }\n\t      edge.WindCnt2 = e.WindCnt2;\n\t      e = e.NextInAEL;\n\t      //ie get ready to calc WindCnt2\n\t    }\n\t    else\n\t    {\n\t      //nonZero, Positive or Negative filling ...\n\t      if (e.WindCnt * e.WindDelta < 0)\n\t      {\n\t        //prev edge is 'decreasing' WindCount (WC) toward zero\n\t        //so we're outside the previous polygon ...\n\t        if (Math.abs(e.WindCnt) > 1)\n\t        {\n\t          //outside prev poly but still inside another.\n\t          //when reversing direction of prev poly use the same WC\n\t          if (e.WindDelta * edge.WindDelta < 0)\n\t            edge.WindCnt = e.WindCnt;\n\t          else\n\t            edge.WindCnt = e.WindCnt + edge.WindDelta;\n\t        }\n\t        else\n\t          edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n\t      }\n\t      else\n\t      {\n\t        //prev edge is 'increasing' WindCount (WC) away from zero\n\t        //so we're inside the previous polygon ...\n\t        if (edge.WindDelta === 0)\n\t          edge.WindCnt = (e.WindCnt < 0 ? e.WindCnt - 1 : e.WindCnt + 1);\n\t        else if (e.WindDelta * edge.WindDelta < 0)\n\t          edge.WindCnt = e.WindCnt;\n\t        else\n\t          edge.WindCnt = e.WindCnt + edge.WindDelta;\n\t      }\n\t      edge.WindCnt2 = e.WindCnt2;\n\t      e = e.NextInAEL;\n\t      //ie get ready to calc WindCnt2\n\t    }\n\t    //update WindCnt2 ...\n\t    if (this.IsEvenOddAltFillType(edge))\n\t    {\n\t      //EvenOdd filling ...\n\t      while (e != edge)\n\t      {\n\t        if (e.WindDelta !== 0)\n\t          edge.WindCnt2 = (edge.WindCnt2 === 0 ? 1 : 0);\n\t        e = e.NextInAEL;\n\t      }\n\t    }\n\t    else\n\t    {\n\t      //nonZero, Positive or Negative filling ...\n\t      while (e != edge)\n\t      {\n\t        edge.WindCnt2 += e.WindDelta;\n\t        e = e.NextInAEL;\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.AddEdgeToSEL = function (edge)\n\t  {\n\t    //SEL pointers in PEdge are reused to build a list of horizontal edges.\n\t    //However, we don't need to worry about order with horizontal edge processing.\n\t    if (this.m_SortedEdges === null)\n\t    {\n\t      this.m_SortedEdges = edge;\n\t      edge.PrevInSEL = null;\n\t      edge.NextInSEL = null;\n\t    }\n\t    else\n\t    {\n\t      edge.NextInSEL = this.m_SortedEdges;\n\t      edge.PrevInSEL = null;\n\t      this.m_SortedEdges.PrevInSEL = edge;\n\t      this.m_SortedEdges = edge;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.CopyAELToSEL = function ()\n\t  {\n\t    var e = this.m_ActiveEdges;\n\t    this.m_SortedEdges = e;\n\t    while (e !== null)\n\t    {\n\t      e.PrevInSEL = e.PrevInAEL;\n\t      e.NextInSEL = e.NextInAEL;\n\t      e = e.NextInAEL;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.SwapPositionsInAEL = function (edge1, edge2)\n\t  {\n\t    //check that one or other edge hasn't already been removed from AEL ...\n\t    if (edge1.NextInAEL == edge1.PrevInAEL || edge2.NextInAEL == edge2.PrevInAEL)\n\t      return;\n\t    if (edge1.NextInAEL == edge2)\n\t    {\n\t      var next = edge2.NextInAEL;\n\t      if (next !== null)\n\t        next.PrevInAEL = edge1;\n\t      var prev = edge1.PrevInAEL;\n\t      if (prev !== null)\n\t        prev.NextInAEL = edge2;\n\t      edge2.PrevInAEL = prev;\n\t      edge2.NextInAEL = edge1;\n\t      edge1.PrevInAEL = edge2;\n\t      edge1.NextInAEL = next;\n\t    }\n\t    else if (edge2.NextInAEL == edge1)\n\t    {\n\t      var next = edge1.NextInAEL;\n\t      if (next !== null)\n\t        next.PrevInAEL = edge2;\n\t      var prev = edge2.PrevInAEL;\n\t      if (prev !== null)\n\t        prev.NextInAEL = edge1;\n\t      edge1.PrevInAEL = prev;\n\t      edge1.NextInAEL = edge2;\n\t      edge2.PrevInAEL = edge1;\n\t      edge2.NextInAEL = next;\n\t    }\n\t    else\n\t    {\n\t      var next = edge1.NextInAEL;\n\t      var prev = edge1.PrevInAEL;\n\t      edge1.NextInAEL = edge2.NextInAEL;\n\t      if (edge1.NextInAEL !== null)\n\t        edge1.NextInAEL.PrevInAEL = edge1;\n\t      edge1.PrevInAEL = edge2.PrevInAEL;\n\t      if (edge1.PrevInAEL !== null)\n\t        edge1.PrevInAEL.NextInAEL = edge1;\n\t      edge2.NextInAEL = next;\n\t      if (edge2.NextInAEL !== null)\n\t        edge2.NextInAEL.PrevInAEL = edge2;\n\t      edge2.PrevInAEL = prev;\n\t      if (edge2.PrevInAEL !== null)\n\t        edge2.PrevInAEL.NextInAEL = edge2;\n\t    }\n\t    if (edge1.PrevInAEL === null)\n\t      this.m_ActiveEdges = edge1;\n\t    else if (edge2.PrevInAEL === null)\n\t      this.m_ActiveEdges = edge2;\n\t  };\n\t  ClipperLib.Clipper.prototype.SwapPositionsInSEL = function (edge1, edge2)\n\t  {\n\t    if (edge1.NextInSEL === null && edge1.PrevInSEL === null)\n\t      return;\n\t    if (edge2.NextInSEL === null && edge2.PrevInSEL === null)\n\t      return;\n\t    if (edge1.NextInSEL == edge2)\n\t    {\n\t      var next = edge2.NextInSEL;\n\t      if (next !== null)\n\t        next.PrevInSEL = edge1;\n\t      var prev = edge1.PrevInSEL;\n\t      if (prev !== null)\n\t        prev.NextInSEL = edge2;\n\t      edge2.PrevInSEL = prev;\n\t      edge2.NextInSEL = edge1;\n\t      edge1.PrevInSEL = edge2;\n\t      edge1.NextInSEL = next;\n\t    }\n\t    else if (edge2.NextInSEL == edge1)\n\t    {\n\t      var next = edge1.NextInSEL;\n\t      if (next !== null)\n\t        next.PrevInSEL = edge2;\n\t      var prev = edge2.PrevInSEL;\n\t      if (prev !== null)\n\t        prev.NextInSEL = edge1;\n\t      edge1.PrevInSEL = prev;\n\t      edge1.NextInSEL = edge2;\n\t      edge2.PrevInSEL = edge1;\n\t      edge2.NextInSEL = next;\n\t    }\n\t    else\n\t    {\n\t      var next = edge1.NextInSEL;\n\t      var prev = edge1.PrevInSEL;\n\t      edge1.NextInSEL = edge2.NextInSEL;\n\t      if (edge1.NextInSEL !== null)\n\t        edge1.NextInSEL.PrevInSEL = edge1;\n\t      edge1.PrevInSEL = edge2.PrevInSEL;\n\t      if (edge1.PrevInSEL !== null)\n\t        edge1.PrevInSEL.NextInSEL = edge1;\n\t      edge2.NextInSEL = next;\n\t      if (edge2.NextInSEL !== null)\n\t        edge2.NextInSEL.PrevInSEL = edge2;\n\t      edge2.PrevInSEL = prev;\n\t      if (edge2.PrevInSEL !== null)\n\t        edge2.PrevInSEL.NextInSEL = edge2;\n\t    }\n\t    if (edge1.PrevInSEL === null)\n\t      this.m_SortedEdges = edge1;\n\t    else if (edge2.PrevInSEL === null)\n\t      this.m_SortedEdges = edge2;\n\t  };\n\t  ClipperLib.Clipper.prototype.AddLocalMaxPoly = function (e1, e2, pt)\n\t  {\n\t    this.AddOutPt(e1, pt);\n\t    if (e2.WindDelta == 0) this.AddOutPt(e2, pt);\n\t    if (e1.OutIdx == e2.OutIdx)\n\t    {\n\t      e1.OutIdx = -1;\n\t      e2.OutIdx = -1;\n\t    }\n\t    else if (e1.OutIdx < e2.OutIdx)\n\t      this.AppendPolygon(e1, e2);\n\t    else\n\t      this.AppendPolygon(e2, e1);\n\t  };\n\t  ClipperLib.Clipper.prototype.AddLocalMinPoly = function (e1, e2, pt)\n\t  {\n\t    var result;\n\t    var e, prevE;\n\t    if (ClipperLib.ClipperBase.IsHorizontal(e2) || (e1.Dx > e2.Dx))\n\t    {\n\t      result = this.AddOutPt(e1, pt);\n\t      e2.OutIdx = e1.OutIdx;\n\t      e1.Side = ClipperLib.EdgeSide.esLeft;\n\t      e2.Side = ClipperLib.EdgeSide.esRight;\n\t      e = e1;\n\t      if (e.PrevInAEL == e2)\n\t        prevE = e2.PrevInAEL;\n\t      else\n\t        prevE = e.PrevInAEL;\n\t    }\n\t    else\n\t    {\n\t      result = this.AddOutPt(e2, pt);\n\t      e1.OutIdx = e2.OutIdx;\n\t      e1.Side = ClipperLib.EdgeSide.esRight;\n\t      e2.Side = ClipperLib.EdgeSide.esLeft;\n\t      e = e2;\n\t      if (e.PrevInAEL == e1)\n\t        prevE = e1.PrevInAEL;\n\t      else\n\t        prevE = e.PrevInAEL;\n\t    }\n\t    if (prevE !== null && prevE.OutIdx >= 0 && (ClipperLib.Clipper.TopX(prevE, pt.Y) == ClipperLib.Clipper.TopX(e, pt.Y)) && ClipperLib.ClipperBase.SlopesEqual(e, prevE, this.m_UseFullRange) && (e.WindDelta !== 0) && (prevE.WindDelta !== 0))\n\t    {\n\t      var outPt = this.AddOutPt(prevE, pt);\n\t      this.AddJoin(result, outPt, e.Top);\n\t    }\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.prototype.CreateOutRec = function ()\n\t  {\n\t    var result = new ClipperLib.OutRec();\n\t    result.Idx = -1;\n\t    result.IsHole = false;\n\t    result.IsOpen = false;\n\t    result.FirstLeft = null;\n\t    result.Pts = null;\n\t    result.BottomPt = null;\n\t    result.PolyNode = null;\n\t    this.m_PolyOuts.push(result);\n\t    result.Idx = this.m_PolyOuts.length - 1;\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.prototype.AddOutPt = function (e, pt)\n\t  {\n\t    var ToFront = (e.Side == ClipperLib.EdgeSide.esLeft);\n\t    if (e.OutIdx < 0)\n\t    {\n\t      var outRec = this.CreateOutRec();\n\t      outRec.IsOpen = (e.WindDelta === 0);\n\t      var newOp = new ClipperLib.OutPt();\n\t      outRec.Pts = newOp;\n\t      newOp.Idx = outRec.Idx;\n\t      //newOp.Pt = pt;\n\t      newOp.Pt.X = pt.X;\n\t      newOp.Pt.Y = pt.Y;\n\t      newOp.Next = newOp;\n\t      newOp.Prev = newOp;\n\t      if (!outRec.IsOpen)\n\t        this.SetHoleState(e, outRec);\n\t      e.OutIdx = outRec.Idx;\n\t      //nb: do this after SetZ !\n\t      return newOp;\n\t    }\n\t    else\n\t    {\n\t      var outRec = this.m_PolyOuts[e.OutIdx];\n\t      //OutRec.Pts is the 'Left-most' point & OutRec.Pts.Prev is the 'Right-most'\n\t      var op = outRec.Pts;\n\t      if (ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Pt))\n\t        return op;\n\t      else if (!ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Prev.Pt))\n\t        return op.Prev;\n\t      var newOp = new ClipperLib.OutPt();\n\t      newOp.Idx = outRec.Idx;\n\t      //newOp.Pt = pt;\n\t      newOp.Pt.X = pt.X;\n\t      newOp.Pt.Y = pt.Y;\n\t      newOp.Next = op;\n\t      newOp.Prev = op.Prev;\n\t      newOp.Prev.Next = newOp;\n\t      op.Prev = newOp;\n\t      if (ToFront)\n\t        outRec.Pts = newOp;\n\t      return newOp;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.SwapPoints = function (pt1, pt2)\n\t  {\n\t    var tmp = new ClipperLib.IntPoint(pt1.Value);\n\t    //pt1.Value = pt2.Value;\n\t    pt1.Value.X = pt2.Value.X;\n\t    pt1.Value.Y = pt2.Value.Y;\n\t    //pt2.Value = tmp;\n\t    pt2.Value.X = tmp.X;\n\t    pt2.Value.Y = tmp.Y;\n\t  };\n\t  ClipperLib.Clipper.prototype.HorzSegmentsOverlap = function (seg1a, seg1b, seg2a, seg2b)\n\t\t{\n\t\t\tvar tmp;\n\t\t\tif (seg1a > seg1b)\n\t\t\t{\n\t\t\t\ttmp = seg1a;\n\t\t\t\tseg1a = seg1b;\n\t\t\t\tseg1b = tmp;\n\t\t\t}\n\t\t\tif (seg2a > seg2b)\n\t\t\t{\n\t\t\t\ttmp = seg2a;\n\t\t\t\tseg2a = seg2b;\n\t\t\t\tseg2b = tmp;\n\t\t\t}\n\t\t\treturn (seg1a < seg2b) && (seg2a < seg1b);\n\t\t}\n\t\n\t  ClipperLib.Clipper.prototype.SetHoleState = function (e, outRec)\n\t  {\n\t    var isHole = false;\n\t    var e2 = e.PrevInAEL;\n\t    while (e2 !== null)\n\t    {\n\t      if (e2.OutIdx >= 0 && e2.WindDelta != 0)\n\t      {\n\t        isHole = !isHole;\n\t        if (outRec.FirstLeft === null)\n\t          outRec.FirstLeft = this.m_PolyOuts[e2.OutIdx];\n\t      }\n\t      e2 = e2.PrevInAEL;\n\t    }\n\t    if (isHole)\n\t      outRec.IsHole = true;\n\t  };\n\t  ClipperLib.Clipper.prototype.GetDx = function (pt1, pt2)\n\t  {\n\t    if (pt1.Y == pt2.Y)\n\t      return ClipperLib.ClipperBase.horizontal;\n\t    else\n\t      return (pt2.X - pt1.X) / (pt2.Y - pt1.Y);\n\t  };\n\t  ClipperLib.Clipper.prototype.FirstIsBottomPt = function (btmPt1, btmPt2)\n\t  {\n\t    var p = btmPt1.Prev;\n\t    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))\n\t      p = p.Prev;\n\t    var dx1p = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n\t    p = btmPt1.Next;\n\t    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))\n\t      p = p.Next;\n\t    var dx1n = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n\t    p = btmPt2.Prev;\n\t    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))\n\t      p = p.Prev;\n\t    var dx2p = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n\t    p = btmPt2.Next;\n\t    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))\n\t      p = p.Next;\n\t    var dx2n = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n\t    return (dx1p >= dx2p && dx1p >= dx2n) || (dx1n >= dx2p && dx1n >= dx2n);\n\t  };\n\t  ClipperLib.Clipper.prototype.GetBottomPt = function (pp)\n\t  {\n\t    var dups = null;\n\t    var p = pp.Next;\n\t    while (p != pp)\n\t    {\n\t      if (p.Pt.Y > pp.Pt.Y)\n\t      {\n\t        pp = p;\n\t        dups = null;\n\t      }\n\t      else if (p.Pt.Y == pp.Pt.Y && p.Pt.X <= pp.Pt.X)\n\t      {\n\t        if (p.Pt.X < pp.Pt.X)\n\t        {\n\t          dups = null;\n\t          pp = p;\n\t        }\n\t        else\n\t        {\n\t          if (p.Next != pp && p.Prev != pp)\n\t            dups = p;\n\t        }\n\t      }\n\t      p = p.Next;\n\t    }\n\t    if (dups !== null)\n\t    {\n\t      //there appears to be at least 2 vertices at bottomPt so ...\n\t      while (dups != p)\n\t      {\n\t        if (!this.FirstIsBottomPt(p, dups))\n\t          pp = dups;\n\t        dups = dups.Next;\n\t        while (ClipperLib.IntPoint.op_Inequality(dups.Pt, pp.Pt))\n\t          dups = dups.Next;\n\t      }\n\t    }\n\t    return pp;\n\t  };\n\t  ClipperLib.Clipper.prototype.GetLowermostRec = function (outRec1, outRec2)\n\t  {\n\t    //work out which polygon fragment has the correct hole state ...\n\t    if (outRec1.BottomPt === null)\n\t      outRec1.BottomPt = this.GetBottomPt(outRec1.Pts);\n\t    if (outRec2.BottomPt === null)\n\t      outRec2.BottomPt = this.GetBottomPt(outRec2.Pts);\n\t    var bPt1 = outRec1.BottomPt;\n\t    var bPt2 = outRec2.BottomPt;\n\t    if (bPt1.Pt.Y > bPt2.Pt.Y)\n\t      return outRec1;\n\t    else if (bPt1.Pt.Y < bPt2.Pt.Y)\n\t      return outRec2;\n\t    else if (bPt1.Pt.X < bPt2.Pt.X)\n\t      return outRec1;\n\t    else if (bPt1.Pt.X > bPt2.Pt.X)\n\t      return outRec2;\n\t    else if (bPt1.Next == bPt1)\n\t      return outRec2;\n\t    else if (bPt2.Next == bPt2)\n\t      return outRec1;\n\t    else if (this.FirstIsBottomPt(bPt1, bPt2))\n\t      return outRec1;\n\t    else\n\t      return outRec2;\n\t  };\n\t  ClipperLib.Clipper.prototype.Param1RightOfParam2 = function (outRec1, outRec2)\n\t  {\n\t    do {\n\t      outRec1 = outRec1.FirstLeft;\n\t      if (outRec1 == outRec2)\n\t        return true;\n\t    }\n\t    while (outRec1 !== null)\n\t    return false;\n\t  };\n\t  ClipperLib.Clipper.prototype.GetOutRec = function (idx)\n\t  {\n\t    var outrec = this.m_PolyOuts[idx];\n\t    while (outrec != this.m_PolyOuts[outrec.Idx])\n\t      outrec = this.m_PolyOuts[outrec.Idx];\n\t    return outrec;\n\t  };\n\t  ClipperLib.Clipper.prototype.AppendPolygon = function (e1, e2)\n\t  {\n\t    //get the start and ends of both output polygons ...\n\t    var outRec1 = this.m_PolyOuts[e1.OutIdx];\n\t    var outRec2 = this.m_PolyOuts[e2.OutIdx];\n\t    var holeStateRec;\n\t    if (this.Param1RightOfParam2(outRec1, outRec2))\n\t      holeStateRec = outRec2;\n\t    else if (this.Param1RightOfParam2(outRec2, outRec1))\n\t      holeStateRec = outRec1;\n\t    else\n\t      holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\t    var p1_lft = outRec1.Pts;\n\t    var p1_rt = p1_lft.Prev;\n\t    var p2_lft = outRec2.Pts;\n\t    var p2_rt = p2_lft.Prev;\n\t    var side;\n\t    //join e2 poly onto e1 poly and delete pointers to e2 ...\n\t    if (e1.Side == ClipperLib.EdgeSide.esLeft)\n\t    {\n\t      if (e2.Side == ClipperLib.EdgeSide.esLeft)\n\t      {\n\t        //z y x a b c\n\t        this.ReversePolyPtLinks(p2_lft);\n\t        p2_lft.Next = p1_lft;\n\t        p1_lft.Prev = p2_lft;\n\t        p1_rt.Next = p2_rt;\n\t        p2_rt.Prev = p1_rt;\n\t        outRec1.Pts = p2_rt;\n\t      }\n\t      else\n\t      {\n\t        //x y z a b c\n\t        p2_rt.Next = p1_lft;\n\t        p1_lft.Prev = p2_rt;\n\t        p2_lft.Prev = p1_rt;\n\t        p1_rt.Next = p2_lft;\n\t        outRec1.Pts = p2_lft;\n\t      }\n\t      side = ClipperLib.EdgeSide.esLeft;\n\t    }\n\t    else\n\t    {\n\t      if (e2.Side == ClipperLib.EdgeSide.esRight)\n\t      {\n\t        //a b c z y x\n\t        this.ReversePolyPtLinks(p2_lft);\n\t        p1_rt.Next = p2_rt;\n\t        p2_rt.Prev = p1_rt;\n\t        p2_lft.Next = p1_lft;\n\t        p1_lft.Prev = p2_lft;\n\t      }\n\t      else\n\t      {\n\t        //a b c x y z\n\t        p1_rt.Next = p2_lft;\n\t        p2_lft.Prev = p1_rt;\n\t        p1_lft.Prev = p2_rt;\n\t        p2_rt.Next = p1_lft;\n\t      }\n\t      side = ClipperLib.EdgeSide.esRight;\n\t    }\n\t    outRec1.BottomPt = null;\n\t    if (holeStateRec == outRec2)\n\t    {\n\t      if (outRec2.FirstLeft != outRec1)\n\t        outRec1.FirstLeft = outRec2.FirstLeft;\n\t      outRec1.IsHole = outRec2.IsHole;\n\t    }\n\t    outRec2.Pts = null;\n\t    outRec2.BottomPt = null;\n\t    outRec2.FirstLeft = outRec1;\n\t    var OKIdx = e1.OutIdx;\n\t    var ObsoleteIdx = e2.OutIdx;\n\t    e1.OutIdx = -1;\n\t    //nb: safe because we only get here via AddLocalMaxPoly\n\t    e2.OutIdx = -1;\n\t    var e = this.m_ActiveEdges;\n\t    while (e !== null)\n\t    {\n\t      if (e.OutIdx == ObsoleteIdx)\n\t      {\n\t        e.OutIdx = OKIdx;\n\t        e.Side = side;\n\t        break;\n\t      }\n\t      e = e.NextInAEL;\n\t    }\n\t    outRec2.Idx = outRec1.Idx;\n\t  };\n\t  ClipperLib.Clipper.prototype.ReversePolyPtLinks = function (pp)\n\t  {\n\t    if (pp === null)\n\t      return;\n\t    var pp1;\n\t    var pp2;\n\t    pp1 = pp;\n\t    do {\n\t      pp2 = pp1.Next;\n\t      pp1.Next = pp1.Prev;\n\t      pp1.Prev = pp2;\n\t      pp1 = pp2;\n\t    }\n\t    while (pp1 != pp)\n\t  };\n\t  ClipperLib.Clipper.SwapSides = function (edge1, edge2)\n\t  {\n\t    var side = edge1.Side;\n\t    edge1.Side = edge2.Side;\n\t    edge2.Side = side;\n\t  };\n\t  ClipperLib.Clipper.SwapPolyIndexes = function (edge1, edge2)\n\t  {\n\t    var outIdx = edge1.OutIdx;\n\t    edge1.OutIdx = edge2.OutIdx;\n\t    edge2.OutIdx = outIdx;\n\t  };\n\t  ClipperLib.Clipper.prototype.IntersectEdges = function (e1, e2, pt)\n\t  {\n\t    //e1 will be to the left of e2 BELOW the intersection. Therefore e1 is before\n\t    //e2 in AEL except when e1 is being inserted at the intersection point ...\n\t    var e1Contributing = (e1.OutIdx >= 0);\n\t    var e2Contributing = (e2.OutIdx >= 0);\n\t\n\t    if (use_xyz)\n\t    \tthis.SetZ(pt, e1, e2);\n\t\n\t    if (use_lines)\n\t    {\n\t      //if either edge is on an OPEN path ...\n\t      if (e1.WindDelta === 0 || e2.WindDelta === 0)\n\t      {\n\t        //ignore subject-subject open path intersections UNLESS they\n\t        //are both open paths, AND they are both 'contributing maximas' ...\n\t\t\t\t\tif (e1.WindDelta == 0 && e2.WindDelta == 0) return;\n\t        //if intersecting a subj line with a subj poly ...\n\t        else if (e1.PolyTyp == e2.PolyTyp &&\n\t          e1.WindDelta != e2.WindDelta && this.m_ClipType == ClipperLib.ClipType.ctUnion)\n\t        {\n\t          if (e1.WindDelta === 0)\n\t          {\n\t            if (e2Contributing)\n\t            {\n\t              this.AddOutPt(e1, pt);\n\t              if (e1Contributing)\n\t                e1.OutIdx = -1;\n\t            }\n\t          }\n\t          else\n\t          {\n\t            if (e1Contributing)\n\t            {\n\t              this.AddOutPt(e2, pt);\n\t              if (e2Contributing)\n\t                e2.OutIdx = -1;\n\t            }\n\t          }\n\t        }\n\t        else if (e1.PolyTyp != e2.PolyTyp)\n\t        {\n\t          if ((e1.WindDelta === 0) && Math.abs(e2.WindCnt) == 1 &&\n\t            (this.m_ClipType != ClipperLib.ClipType.ctUnion || e2.WindCnt2 === 0))\n\t          {\n\t            this.AddOutPt(e1, pt);\n\t            if (e1Contributing)\n\t              e1.OutIdx = -1;\n\t          }\n\t          else if ((e2.WindDelta === 0) && (Math.abs(e1.WindCnt) == 1) &&\n\t            (this.m_ClipType != ClipperLib.ClipType.ctUnion || e1.WindCnt2 === 0))\n\t          {\n\t            this.AddOutPt(e2, pt);\n\t            if (e2Contributing)\n\t              e2.OutIdx = -1;\n\t          }\n\t        }\n\t        return;\n\t      }\n\t    }\n\t    //update winding counts...\n\t    //assumes that e1 will be to the Right of e2 ABOVE the intersection\n\t    if (e1.PolyTyp == e2.PolyTyp)\n\t    {\n\t      if (this.IsEvenOddFillType(e1))\n\t      {\n\t        var oldE1WindCnt = e1.WindCnt;\n\t        e1.WindCnt = e2.WindCnt;\n\t        e2.WindCnt = oldE1WindCnt;\n\t      }\n\t      else\n\t      {\n\t        if (e1.WindCnt + e2.WindDelta === 0)\n\t          e1.WindCnt = -e1.WindCnt;\n\t        else\n\t          e1.WindCnt += e2.WindDelta;\n\t        if (e2.WindCnt - e1.WindDelta === 0)\n\t          e2.WindCnt = -e2.WindCnt;\n\t        else\n\t          e2.WindCnt -= e1.WindDelta;\n\t      }\n\t    }\n\t    else\n\t    {\n\t      if (!this.IsEvenOddFillType(e2))\n\t        e1.WindCnt2 += e2.WindDelta;\n\t      else\n\t        e1.WindCnt2 = (e1.WindCnt2 === 0) ? 1 : 0;\n\t      if (!this.IsEvenOddFillType(e1))\n\t        e2.WindCnt2 -= e1.WindDelta;\n\t      else\n\t        e2.WindCnt2 = (e2.WindCnt2 === 0) ? 1 : 0;\n\t    }\n\t    var e1FillType, e2FillType, e1FillType2, e2FillType2;\n\t    if (e1.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t    {\n\t      e1FillType = this.m_SubjFillType;\n\t      e1FillType2 = this.m_ClipFillType;\n\t    }\n\t    else\n\t    {\n\t      e1FillType = this.m_ClipFillType;\n\t      e1FillType2 = this.m_SubjFillType;\n\t    }\n\t    if (e2.PolyTyp == ClipperLib.PolyType.ptSubject)\n\t    {\n\t      e2FillType = this.m_SubjFillType;\n\t      e2FillType2 = this.m_ClipFillType;\n\t    }\n\t    else\n\t    {\n\t      e2FillType = this.m_ClipFillType;\n\t      e2FillType2 = this.m_SubjFillType;\n\t    }\n\t    var e1Wc, e2Wc;\n\t    switch (e1FillType)\n\t    {\n\t    case ClipperLib.PolyFillType.pftPositive:\n\t      e1Wc = e1.WindCnt;\n\t      break;\n\t    case ClipperLib.PolyFillType.pftNegative:\n\t      e1Wc = -e1.WindCnt;\n\t      break;\n\t    default:\n\t      e1Wc = Math.abs(e1.WindCnt);\n\t      break;\n\t    }\n\t    switch (e2FillType)\n\t    {\n\t    case ClipperLib.PolyFillType.pftPositive:\n\t      e2Wc = e2.WindCnt;\n\t      break;\n\t    case ClipperLib.PolyFillType.pftNegative:\n\t      e2Wc = -e2.WindCnt;\n\t      break;\n\t    default:\n\t      e2Wc = Math.abs(e2.WindCnt);\n\t      break;\n\t    }\n\t    if (e1Contributing && e2Contributing)\n\t    {\n\t\t\t\tif ((e1Wc != 0 && e1Wc != 1) || (e2Wc != 0 && e2Wc != 1) ||\n\t\t\t\t(e1.PolyTyp != e2.PolyTyp && this.m_ClipType != ClipperLib.ClipType.ctXor))\n\t\t\t\t{\n\t\t\t\t\tthis.AddLocalMaxPoly(e1, e2, pt);\n\t\t\t\t}\n\t      else\n\t      {\n\t        this.AddOutPt(e1, pt);\n\t        this.AddOutPt(e2, pt);\n\t        ClipperLib.Clipper.SwapSides(e1, e2);\n\t        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n\t      }\n\t    }\n\t    else if (e1Contributing)\n\t    {\n\t      if (e2Wc === 0 || e2Wc == 1)\n\t      {\n\t        this.AddOutPt(e1, pt);\n\t        ClipperLib.Clipper.SwapSides(e1, e2);\n\t        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n\t      }\n\t    }\n\t    else if (e2Contributing)\n\t    {\n\t      if (e1Wc === 0 || e1Wc == 1)\n\t      {\n\t        this.AddOutPt(e2, pt);\n\t        ClipperLib.Clipper.SwapSides(e1, e2);\n\t        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n\t      }\n\t    }\n\t\t\telse if ( (e1Wc == 0 || e1Wc == 1) && (e2Wc == 0 || e2Wc == 1))\n\t    {\n\t      //neither edge is currently contributing ...\n\t      var e1Wc2, e2Wc2;\n\t      switch (e1FillType2)\n\t      {\n\t      case ClipperLib.PolyFillType.pftPositive:\n\t        e1Wc2 = e1.WindCnt2;\n\t        break;\n\t      case ClipperLib.PolyFillType.pftNegative:\n\t        e1Wc2 = -e1.WindCnt2;\n\t        break;\n\t      default:\n\t        e1Wc2 = Math.abs(e1.WindCnt2);\n\t        break;\n\t      }\n\t      switch (e2FillType2)\n\t      {\n\t      case ClipperLib.PolyFillType.pftPositive:\n\t        e2Wc2 = e2.WindCnt2;\n\t        break;\n\t      case ClipperLib.PolyFillType.pftNegative:\n\t        e2Wc2 = -e2.WindCnt2;\n\t        break;\n\t      default:\n\t        e2Wc2 = Math.abs(e2.WindCnt2);\n\t        break;\n\t      }\n\t      if (e1.PolyTyp != e2.PolyTyp)\n\t      {\n\t        this.AddLocalMinPoly(e1, e2, pt);\n\t      }\n\t      else if (e1Wc == 1 && e2Wc == 1)\n\t        switch (this.m_ClipType)\n\t        {\n\t        case ClipperLib.ClipType.ctIntersection:\n\t          if (e1Wc2 > 0 && e2Wc2 > 0)\n\t            this.AddLocalMinPoly(e1, e2, pt);\n\t          break;\n\t        case ClipperLib.ClipType.ctUnion:\n\t          if (e1Wc2 <= 0 && e2Wc2 <= 0)\n\t            this.AddLocalMinPoly(e1, e2, pt);\n\t          break;\n\t        case ClipperLib.ClipType.ctDifference:\n\t          if (((e1.PolyTyp == ClipperLib.PolyType.ptClip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||\n\t            ((e1.PolyTyp == ClipperLib.PolyType.ptSubject) && (e1Wc2 <= 0) && (e2Wc2 <= 0)))\n\t            this.AddLocalMinPoly(e1, e2, pt);\n\t          break;\n\t        case ClipperLib.ClipType.ctXor:\n\t          this.AddLocalMinPoly(e1, e2, pt);\n\t          break;\n\t        }\n\t      else\n\t        ClipperLib.Clipper.SwapSides(e1, e2);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.DeleteFromAEL = function (e)\n\t  {\n\t    var AelPrev = e.PrevInAEL;\n\t    var AelNext = e.NextInAEL;\n\t    if (AelPrev === null && AelNext === null && (e != this.m_ActiveEdges))\n\t      return;\n\t    //already deleted\n\t    if (AelPrev !== null)\n\t      AelPrev.NextInAEL = AelNext;\n\t    else\n\t      this.m_ActiveEdges = AelNext;\n\t    if (AelNext !== null)\n\t      AelNext.PrevInAEL = AelPrev;\n\t    e.NextInAEL = null;\n\t    e.PrevInAEL = null;\n\t  };\n\t  ClipperLib.Clipper.prototype.DeleteFromSEL = function (e)\n\t  {\n\t    var SelPrev = e.PrevInSEL;\n\t    var SelNext = e.NextInSEL;\n\t    if (SelPrev === null && SelNext === null && (e != this.m_SortedEdges))\n\t      return;\n\t    //already deleted\n\t    if (SelPrev !== null)\n\t      SelPrev.NextInSEL = SelNext;\n\t    else\n\t      this.m_SortedEdges = SelNext;\n\t    if (SelNext !== null)\n\t      SelNext.PrevInSEL = SelPrev;\n\t    e.NextInSEL = null;\n\t    e.PrevInSEL = null;\n\t  };\n\t  ClipperLib.Clipper.prototype.UpdateEdgeIntoAEL = function (e)\n\t  {\n\t    if (e.NextInLML === null)\n\t      ClipperLib.Error(\"UpdateEdgeIntoAEL: invalid call\");\n\t    var AelPrev = e.PrevInAEL;\n\t    var AelNext = e.NextInAEL;\n\t    e.NextInLML.OutIdx = e.OutIdx;\n\t    if (AelPrev !== null)\n\t      AelPrev.NextInAEL = e.NextInLML;\n\t    else\n\t      this.m_ActiveEdges = e.NextInLML;\n\t    if (AelNext !== null)\n\t      AelNext.PrevInAEL = e.NextInLML;\n\t    e.NextInLML.Side = e.Side;\n\t    e.NextInLML.WindDelta = e.WindDelta;\n\t    e.NextInLML.WindCnt = e.WindCnt;\n\t    e.NextInLML.WindCnt2 = e.WindCnt2;\n\t    e = e.NextInLML;\n\t    //    e.Curr = e.Bot;\n\t    e.Curr.X = e.Bot.X;\n\t    e.Curr.Y = e.Bot.Y;\n\t    e.PrevInAEL = AelPrev;\n\t    e.NextInAEL = AelNext;\n\t    if (!ClipperLib.ClipperBase.IsHorizontal(e))\n\t      this.InsertScanbeam(e.Top.Y);\n\t    return e;\n\t  };\n\t  ClipperLib.Clipper.prototype.ProcessHorizontals = function (isTopOfScanbeam)\n\t  {\n\t    var horzEdge = this.m_SortedEdges;\n\t    while (horzEdge !== null)\n\t    {\n\t      this.DeleteFromSEL(horzEdge);\n\t      this.ProcessHorizontal(horzEdge, isTopOfScanbeam);\n\t      horzEdge = this.m_SortedEdges;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.GetHorzDirection = function (HorzEdge, $var)\n\t  {\n\t    if (HorzEdge.Bot.X < HorzEdge.Top.X)\n\t    {\n\t        $var.Left = HorzEdge.Bot.X;\n\t        $var.Right = HorzEdge.Top.X;\n\t        $var.Dir = ClipperLib.Direction.dLeftToRight;\n\t    }\n\t    else\n\t    {\n\t        $var.Left = HorzEdge.Top.X;\n\t        $var.Right = HorzEdge.Bot.X;\n\t        $var.Dir = ClipperLib.Direction.dRightToLeft;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.ProcessHorizontal = function (horzEdge, isTopOfScanbeam)\n\t  {\n\t    var $var = {Dir: null, Left: null, Right: null};\n\t    this.GetHorzDirection(horzEdge, $var);\n\t    var dir = $var.Dir;\n\t    var horzLeft = $var.Left;\n\t    var horzRight = $var.Right;\n\t\n\t    var eLastHorz = horzEdge,\n\t      eMaxPair = null;\n\t    while (eLastHorz.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(eLastHorz.NextInLML))\n\t      eLastHorz = eLastHorz.NextInLML;\n\t    if (eLastHorz.NextInLML === null)\n\t      eMaxPair = this.GetMaximaPair(eLastHorz);\n\t    for (;;)\n\t    {\n\t      var IsLastHorz = (horzEdge == eLastHorz);\n\t      var e = this.GetNextInAEL(horzEdge, dir);\n\t      while (e !== null)\n\t      {\n\t        //Break if we've got to the end of an intermediate horizontal edge ...\n\t        //nb: Smaller Dx's are to the right of larger Dx's ABOVE the horizontal.\n\t        if (e.Curr.X == horzEdge.Top.X && horzEdge.NextInLML !== null && e.Dx < horzEdge.NextInLML.Dx)\n\t          break;\n\t        var eNext = this.GetNextInAEL(e, dir);\n\t        //saves eNext for later\n\t        if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X <= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X >= horzLeft))\n\t        {\n\t          //so far we're still in range of the horizontal Edge  but make sure\n\t          //we're at the last of consec. horizontals when matching with eMaxPair\n\t          if (e == eMaxPair && IsLastHorz)\n\t          {\n\t\t\t\t\t\t\tif (horzEdge.OutIdx >= 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\t\t\t\t\t\t\t\tvar eNextHorz = this.m_SortedEdges;\n\t\t\t\t\t\t\t\twhile (eNextHorz !== null)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (eNextHorz.OutIdx >= 0 &&\n\t\t\t\t\t\t\t\t\t\tthis.HorzSegmentsOverlap(horzEdge.Bot.X,\n\t\t\t\t\t\t\t\t\t\thorzEdge.Top.X, eNextHorz.Bot.X, eNextHorz.Top.X))\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tvar op2 = this.AddOutPt(eNextHorz, eNextHorz.Bot);\n\t\t\t\t\t\t\t\t\t\tthis.AddJoin(op2, op1, eNextHorz.Top);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\teNextHorz = eNextHorz.NextInSEL;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tthis.AddGhostJoin(op1, horzEdge.Bot);\n\t\t\t\t\t\t\t\tthis.AddLocalMaxPoly(horzEdge, eMaxPair, horzEdge.Top);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.DeleteFromAEL(horzEdge);\n\t\t\t\t\t\t\tthis.DeleteFromAEL(eMaxPair);\n\t            return;\n\t          }\n\t          else if (dir == ClipperLib.Direction.dLeftToRight)\n\t          {\n\t            var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n\t            this.IntersectEdges(horzEdge, e, Pt);\n\t          }\n\t          else\n\t          {\n\t            var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n\t            this.IntersectEdges(e, horzEdge, Pt);\n\t          }\n\t          this.SwapPositionsInAEL(horzEdge, e);\n\t        }\n\t        else if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X >= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X <= horzLeft))\n\t          break;\n\t        e = eNext;\n\t      }\n\t      //end while\n\t      if (horzEdge.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(horzEdge.NextInLML))\n\t      {\n\t        horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n\t        if (horzEdge.OutIdx >= 0)\n\t          this.AddOutPt(horzEdge, horzEdge.Bot);\n\t\n\t          var $var = {Dir: dir, Left: horzLeft, Right: horzRight};\n\t          this.GetHorzDirection(horzEdge, $var);\n\t          dir = $var.Dir;\n\t          horzLeft = $var.Left;\n\t          horzRight = $var.Right;\n\t      }\n\t      else\n\t        break;\n\t    }\n\t    //end for (;;)\n\t    if (horzEdge.NextInLML !== null)\n\t    {\n\t      if (horzEdge.OutIdx >= 0)\n\t      {\n\t        var op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\t\t\t\t\tif (isTopOfScanbeam) this.AddGhostJoin(op1, horzEdge.Bot);\n\t        horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n\t        if (horzEdge.WindDelta === 0)\n\t          return;\n\t        //nb: HorzEdge is no longer horizontal here\n\t        var ePrev = horzEdge.PrevInAEL;\n\t        var eNext = horzEdge.NextInAEL;\n\t        if (ePrev !== null && ePrev.Curr.X == horzEdge.Bot.X &&\n\t          ePrev.Curr.Y == horzEdge.Bot.Y && ePrev.WindDelta !== 0 &&\n\t          (ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&\n\t            ClipperLib.ClipperBase.SlopesEqual(horzEdge, ePrev, this.m_UseFullRange)))\n\t        {\n\t          var op2 = this.AddOutPt(ePrev, horzEdge.Bot);\n\t          this.AddJoin(op1, op2, horzEdge.Top);\n\t        }\n\t        else if (eNext !== null && eNext.Curr.X == horzEdge.Bot.X &&\n\t          eNext.Curr.Y == horzEdge.Bot.Y && eNext.WindDelta !== 0 &&\n\t          eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&\n\t          ClipperLib.ClipperBase.SlopesEqual(horzEdge, eNext, this.m_UseFullRange))\n\t        {\n\t          var op2 = this.AddOutPt(eNext, horzEdge.Bot);\n\t          this.AddJoin(op1, op2, horzEdge.Top);\n\t        }\n\t      }\n\t      else horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n\t    }\n\t  \telse\n\t    {\n\t      if (horzEdge.OutIdx >= 0)\n\t        this.AddOutPt(horzEdge, horzEdge.Top);\n\t      this.DeleteFromAEL(horzEdge);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.GetNextInAEL = function (e, Direction)\n\t  {\n\t    return Direction == ClipperLib.Direction.dLeftToRight ? e.NextInAEL : e.PrevInAEL;\n\t  };\n\t  ClipperLib.Clipper.prototype.IsMinima = function (e)\n\t  {\n\t    return e !== null && (e.Prev.NextInLML != e) && (e.Next.NextInLML != e);\n\t  };\n\t  ClipperLib.Clipper.prototype.IsMaxima = function (e, Y)\n\t  {\n\t    return (e !== null && e.Top.Y == Y && e.NextInLML === null);\n\t  };\n\t  ClipperLib.Clipper.prototype.IsIntermediate = function (e, Y)\n\t  {\n\t    return (e.Top.Y == Y && e.NextInLML !== null);\n\t  };\n\t  ClipperLib.Clipper.prototype.GetMaximaPair = function (e)\n\t  {\n\t    var result = null;\n\t    if ((ClipperLib.IntPoint.op_Equality(e.Next.Top, e.Top)) && e.Next.NextInLML === null)\n\t      result = e.Next;\n\t    else if ((ClipperLib.IntPoint.op_Equality(e.Prev.Top, e.Top)) && e.Prev.NextInLML === null)\n\t      result = e.Prev;\n\t    if (result !== null && (result.OutIdx == -2 || (result.NextInAEL == result.PrevInAEL && !ClipperLib.ClipperBase.IsHorizontal(result))))\n\t      return null;\n\t    return result;\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.ProcessIntersections = function (topY)\n\t  {\n\t    if (this.m_ActiveEdges == null)\n\t      return true;\n\t    try\n\t    {\n\t      this.BuildIntersectList(topY);\n\t      if (this.m_IntersectList.length == 0)\n\t        return true;\n\t      if (this.m_IntersectList.length == 1 || this.FixupIntersectionOrder())\n\t        this.ProcessIntersectList();\n\t      else\n\t        return false;\n\t    }\n\t    catch ($$e2)\n\t    {\n\t      this.m_SortedEdges = null;\n\t      this.m_IntersectList.length = 0;\n\t      ClipperLib.Error(\"ProcessIntersections error\");\n\t    }\n\t    this.m_SortedEdges = null;\n\t    return true;\n\t  };\n\t  ClipperLib.Clipper.prototype.BuildIntersectList = function (topY)\n\t  {\n\t    if (this.m_ActiveEdges === null)\n\t      return;\n\t    //prepare for sorting ...\n\t    var e = this.m_ActiveEdges;\n\t    //console.log(JSON.stringify(JSON.decycle( e )));\n\t    this.m_SortedEdges = e;\n\t    while (e !== null)\n\t    {\n\t      e.PrevInSEL = e.PrevInAEL;\n\t      e.NextInSEL = e.NextInAEL;\n\t      e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n\t      e = e.NextInAEL;\n\t    }\n\t    //bubblesort ...\n\t    var isModified = true;\n\t    while (isModified && this.m_SortedEdges !== null)\n\t    {\n\t      isModified = false;\n\t      e = this.m_SortedEdges;\n\t      while (e.NextInSEL !== null)\n\t      {\n\t        var eNext = e.NextInSEL;\n\t        var pt = new ClipperLib.IntPoint();\n\t        //console.log(\"e.Curr.X: \" + e.Curr.X + \" eNext.Curr.X\" + eNext.Curr.X);\n\t        if (e.Curr.X > eNext.Curr.X)\n\t        {\n\t\t\t\t\t\tthis.IntersectPoint(e, eNext, pt);\n\t          var newNode = new ClipperLib.IntersectNode();\n\t          newNode.Edge1 = e;\n\t          newNode.Edge2 = eNext;\n\t          //newNode.Pt = pt;\n\t          newNode.Pt.X = pt.X;\n\t          newNode.Pt.Y = pt.Y;\n\t          this.m_IntersectList.push(newNode);\n\t          this.SwapPositionsInSEL(e, eNext);\n\t          isModified = true;\n\t        }\n\t        else\n\t          e = eNext;\n\t      }\n\t      if (e.PrevInSEL !== null)\n\t        e.PrevInSEL.NextInSEL = null;\n\t      else\n\t        break;\n\t    }\n\t    this.m_SortedEdges = null;\n\t  };\n\t  ClipperLib.Clipper.prototype.EdgesAdjacent = function (inode)\n\t  {\n\t    return (inode.Edge1.NextInSEL == inode.Edge2) || (inode.Edge1.PrevInSEL == inode.Edge2);\n\t  };\n\t  ClipperLib.Clipper.IntersectNodeSort = function (node1, node2)\n\t  {\n\t    //the following typecast is safe because the differences in Pt.Y will\n\t    //be limited to the height of the scanbeam.\n\t    return (node2.Pt.Y - node1.Pt.Y);\n\t  };\n\t  ClipperLib.Clipper.prototype.FixupIntersectionOrder = function ()\n\t  {\n\t    //pre-condition: intersections are sorted bottom-most first.\n\t    //Now it's crucial that intersections are made only between adjacent edges,\n\t    //so to ensure this the order of intersections may need adjusting ...\n\t    this.m_IntersectList.sort(this.m_IntersectNodeComparer);\n\t    this.CopyAELToSEL();\n\t    var cnt = this.m_IntersectList.length;\n\t    for (var i = 0; i < cnt; i++)\n\t    {\n\t      if (!this.EdgesAdjacent(this.m_IntersectList[i]))\n\t      {\n\t        var j = i + 1;\n\t        while (j < cnt && !this.EdgesAdjacent(this.m_IntersectList[j]))\n\t          j++;\n\t        if (j == cnt)\n\t          return false;\n\t        var tmp = this.m_IntersectList[i];\n\t        this.m_IntersectList[i] = this.m_IntersectList[j];\n\t        this.m_IntersectList[j] = tmp;\n\t      }\n\t      this.SwapPositionsInSEL(this.m_IntersectList[i].Edge1, this.m_IntersectList[i].Edge2);\n\t    }\n\t    return true;\n\t  };\n\t  ClipperLib.Clipper.prototype.ProcessIntersectList = function ()\n\t  {\n\t    for (var i = 0, ilen = this.m_IntersectList.length; i < ilen; i++)\n\t    {\n\t      var iNode = this.m_IntersectList[i];\n\t      this.IntersectEdges(iNode.Edge1, iNode.Edge2, iNode.Pt);\n\t      this.SwapPositionsInAEL(iNode.Edge1, iNode.Edge2);\n\t    }\n\t    this.m_IntersectList.length = 0;\n\t  };\n\t  /*\n\t  --------------------------------\n\t  Round speedtest: http://jsperf.com/fastest-round\n\t  --------------------------------\n\t  */\n\t  var R1 = function (a)\n\t  {\n\t    return a < 0 ? Math.ceil(a - 0.5) : Math.round(a)\n\t  };\n\t  var R2 = function (a)\n\t  {\n\t    return a < 0 ? Math.ceil(a - 0.5) : Math.floor(a + 0.5)\n\t  };\n\t  var R3 = function (a)\n\t  {\n\t    return a < 0 ? -Math.round(Math.abs(a)) : Math.round(a)\n\t  };\n\t  var R4 = function (a)\n\t  {\n\t    if (a < 0)\n\t    {\n\t      a -= 0.5;\n\t      return a < -2147483648 ? Math.ceil(a) : a | 0;\n\t    }\n\t    else\n\t    {\n\t      a += 0.5;\n\t      return a > 2147483647 ? Math.floor(a) : a | 0;\n\t    }\n\t  };\n\t  if (browser.msie) ClipperLib.Clipper.Round = R1;\n\t  else if (browser.chromium) ClipperLib.Clipper.Round = R3;\n\t  else if (browser.safari) ClipperLib.Clipper.Round = R4;\n\t  else ClipperLib.Clipper.Round = R2; // eg. browser.chrome || browser.firefox || browser.opera\n\t  ClipperLib.Clipper.TopX = function (edge, currentY)\n\t  {\n\t    //if (edge.Bot == edge.Curr) alert (\"edge.Bot = edge.Curr\");\n\t    //if (edge.Bot == edge.Top) alert (\"edge.Bot = edge.Top\");\n\t    if (currentY == edge.Top.Y)\n\t      return edge.Top.X;\n\t    return edge.Bot.X + ClipperLib.Clipper.Round(edge.Dx * (currentY - edge.Bot.Y));\n\t  };\n\t  ClipperLib.Clipper.prototype.IntersectPoint = function (edge1, edge2, ip)\n\t  {\n\t    ip.X = 0;\n\t    ip.Y = 0;\n\t    var b1, b2;\n\t    //nb: with very large coordinate values, it's possible for SlopesEqual() to\n\t    //return false but for the edge.Dx value be equal due to double precision rounding.\n\t    if (edge1.Dx == edge2.Dx)\n\t\t\t{\n\t\t\t\tip.Y = edge1.Curr.Y;\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t\t\treturn;\n\t    }\n\t    if (edge1.Delta.X === 0)\n\t    {\n\t      ip.X = edge1.Bot.X;\n\t      if (ClipperLib.ClipperBase.IsHorizontal(edge2))\n\t      {\n\t        ip.Y = edge2.Bot.Y;\n\t      }\n\t      else\n\t      {\n\t        b2 = edge2.Bot.Y - (edge2.Bot.X / edge2.Dx);\n\t        ip.Y = ClipperLib.Clipper.Round(ip.X / edge2.Dx + b2);\n\t      }\n\t    }\n\t    else if (edge2.Delta.X === 0)\n\t    {\n\t      ip.X = edge2.Bot.X;\n\t      if (ClipperLib.ClipperBase.IsHorizontal(edge1))\n\t      {\n\t        ip.Y = edge1.Bot.Y;\n\t      }\n\t      else\n\t      {\n\t        b1 = edge1.Bot.Y - (edge1.Bot.X / edge1.Dx);\n\t        ip.Y = ClipperLib.Clipper.Round(ip.X / edge1.Dx + b1);\n\t      }\n\t    }\n\t    else\n\t    {\n\t      b1 = edge1.Bot.X - edge1.Bot.Y * edge1.Dx;\n\t      b2 = edge2.Bot.X - edge2.Bot.Y * edge2.Dx;\n\t      var q = (b2 - b1) / (edge1.Dx - edge2.Dx);\n\t      ip.Y = ClipperLib.Clipper.Round(q);\n\t      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n\t        ip.X = ClipperLib.Clipper.Round(edge1.Dx * q + b1);\n\t      else\n\t        ip.X = ClipperLib.Clipper.Round(edge2.Dx * q + b2);\n\t    }\n\t    if (ip.Y < edge1.Top.Y || ip.Y < edge2.Top.Y)\n\t    {\n\t      if (edge1.Top.Y > edge2.Top.Y)\n\t      {\n\t        ip.Y = edge1.Top.Y;\n\t        ip.X = ClipperLib.Clipper.TopX(edge2, edge1.Top.Y);\n\t        return ip.X < edge1.Top.X;\n\t      }\n\t      else\n\t        ip.Y = edge2.Top.Y;\n\t      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n\t        ip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t      else\n\t        ip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n\t    }\n\t\t\t//finally, don't allow 'ip' to be BELOW curr.Y (ie bottom of scanbeam) ...\n\t\t\tif (ip.Y > edge1.Curr.Y)\n\t\t\t{\n\t\t\t\tip.Y = edge1.Curr.Y;\n\t\t\t\t//better to use the more vertical edge to derive X ...\n\t\t\t\tif (Math.abs(edge1.Dx) > Math.abs(edge2.Dx))\n\t\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n\t\t\t\telse\n\t\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t\t}\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function (topY)\n\t  {\n\t    var e = this.m_ActiveEdges;\n\t    while (e !== null)\n\t    {\n\t      //1. process maxima, treating them as if they're 'bent' horizontal edges,\n\t      //   but exclude maxima with horizontal edges. nb: e can't be a horizontal.\n\t      var IsMaximaEdge = this.IsMaxima(e, topY);\n\t      if (IsMaximaEdge)\n\t      {\n\t        var eMaxPair = this.GetMaximaPair(e);\n\t        IsMaximaEdge = (eMaxPair === null || !ClipperLib.ClipperBase.IsHorizontal(eMaxPair));\n\t      }\n\t      if (IsMaximaEdge)\n\t      {\n\t        var ePrev = e.PrevInAEL;\n\t        this.DoMaxima(e);\n\t        if (ePrev === null)\n\t          e = this.m_ActiveEdges;\n\t        else\n\t          e = ePrev.NextInAEL;\n\t      }\n\t      else\n\t      {\n\t        //2. promote horizontal edges, otherwise update Curr.X and Curr.Y ...\n\t        if (this.IsIntermediate(e, topY) && ClipperLib.ClipperBase.IsHorizontal(e.NextInLML))\n\t        {\n\t          e = this.UpdateEdgeIntoAEL(e);\n\t          if (e.OutIdx >= 0)\n\t            this.AddOutPt(e, e.Bot);\n\t          this.AddEdgeToSEL(e);\n\t        }\n\t        else\n\t        {\n\t          e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n\t          e.Curr.Y = topY;\n\t        }\n\t        if (this.StrictlySimple)\n\t        {\n\t          var ePrev = e.PrevInAEL;\n\t          if ((e.OutIdx >= 0) && (e.WindDelta !== 0) && ePrev !== null &&\n\t            (ePrev.OutIdx >= 0) && (ePrev.Curr.X == e.Curr.X) &&\n\t            (ePrev.WindDelta !== 0))\n\t          {\n\t           \tvar ip = new ClipperLib.IntPoint(e.Curr);\n\t\n\t\t\t\t\t\t\tif(use_xyz)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tthis.SetZ(ip, ePrev, e);\n\t\t\t\t\t\t\t}\n\t\n\t            var op = this.AddOutPt(ePrev, ip);\n\t            var op2 = this.AddOutPt(e, ip);\n\t            this.AddJoin(op, op2, ip);\n\t            //StrictlySimple (type-3) join\n\t          }\n\t        }\n\t        e = e.NextInAEL;\n\t      }\n\t    }\n\t    //3. Process horizontals at the Top of the scanbeam ...\n\t    this.ProcessHorizontals(true);\n\t    //4. Promote intermediate vertices ...\n\t    e = this.m_ActiveEdges;\n\t    while (e !== null)\n\t    {\n\t      if (this.IsIntermediate(e, topY))\n\t      {\n\t        var op = null;\n\t        if (e.OutIdx >= 0)\n\t          op = this.AddOutPt(e, e.Top);\n\t        e = this.UpdateEdgeIntoAEL(e);\n\t        //if output polygons share an edge, they'll need joining later ...\n\t        var ePrev = e.PrevInAEL;\n\t        var eNext = e.NextInAEL;\n\t        if (ePrev !== null && ePrev.Curr.X == e.Bot.X &&\n\t          ePrev.Curr.Y == e.Bot.Y && op !== null &&\n\t          ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&\n\t          ClipperLib.ClipperBase.SlopesEqual(e, ePrev, this.m_UseFullRange) &&\n\t          (e.WindDelta !== 0) && (ePrev.WindDelta !== 0))\n\t        {\n\t          var op2 = this.AddOutPt(ePrev, e.Bot);\n\t          this.AddJoin(op, op2, e.Top);\n\t        }\n\t        else if (eNext !== null && eNext.Curr.X == e.Bot.X &&\n\t          eNext.Curr.Y == e.Bot.Y && op !== null &&\n\t          eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&\n\t          ClipperLib.ClipperBase.SlopesEqual(e, eNext, this.m_UseFullRange) &&\n\t          (e.WindDelta !== 0) && (eNext.WindDelta !== 0))\n\t        {\n\t          var op2 = this.AddOutPt(eNext, e.Bot);\n\t          this.AddJoin(op, op2, e.Top);\n\t        }\n\t      }\n\t      e = e.NextInAEL;\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.DoMaxima = function (e)\n\t  {\n\t    var eMaxPair = this.GetMaximaPair(e);\n\t    if (eMaxPair === null)\n\t    {\n\t      if (e.OutIdx >= 0)\n\t        this.AddOutPt(e, e.Top);\n\t      this.DeleteFromAEL(e);\n\t      return;\n\t    }\n\t    var eNext = e.NextInAEL;\n\t    var use_lines = true;\n\t    while (eNext !== null && eNext != eMaxPair)\n\t    {\n\t      this.IntersectEdges(e, eNext, e.Top);\n\t      this.SwapPositionsInAEL(e, eNext);\n\t      eNext = e.NextInAEL;\n\t    }\n\t    if (e.OutIdx == -1 && eMaxPair.OutIdx == -1)\n\t    {\n\t      this.DeleteFromAEL(e);\n\t      this.DeleteFromAEL(eMaxPair);\n\t    }\n\t    else if (e.OutIdx >= 0 && eMaxPair.OutIdx >= 0)\n\t    {\n\t    \tif (e.OutIdx >= 0) this.AddLocalMaxPoly(e, eMaxPair, e.Top);\n\t      this.DeleteFromAEL(e);\n\t      this.DeleteFromAEL(eMaxPair);\n\t    }\n\t    else if (use_lines && e.WindDelta === 0)\n\t    {\n\t      if (e.OutIdx >= 0)\n\t      {\n\t        this.AddOutPt(e, e.Top);\n\t        e.OutIdx = -1;\n\t      }\n\t      this.DeleteFromAEL(e);\n\t      if (eMaxPair.OutIdx >= 0)\n\t      {\n\t        this.AddOutPt(eMaxPair, e.Top);\n\t        eMaxPair.OutIdx = -1;\n\t      }\n\t      this.DeleteFromAEL(eMaxPair);\n\t    }\n\t    else\n\t      ClipperLib.Error(\"DoMaxima error\");\n\t  };\n\t  ClipperLib.Clipper.ReversePaths = function (polys)\n\t  {\n\t    for (var i = 0, len = polys.length; i < len; i++)\n\t      polys[i].reverse();\n\t  };\n\t  ClipperLib.Clipper.Orientation = function (poly)\n\t  {\n\t    return ClipperLib.Clipper.Area(poly) >= 0;\n\t  };\n\t  ClipperLib.Clipper.prototype.PointCount = function (pts)\n\t  {\n\t    if (pts === null)\n\t      return 0;\n\t    var result = 0;\n\t    var p = pts;\n\t    do {\n\t      result++;\n\t      p = p.Next;\n\t    }\n\t    while (p != pts)\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.prototype.BuildResult = function (polyg)\n\t  {\n\t    ClipperLib.Clear(polyg);\n\t    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t    {\n\t      var outRec = this.m_PolyOuts[i];\n\t      if (outRec.Pts === null)\n\t        continue;\n\t      var p = outRec.Pts.Prev;\n\t      var cnt = this.PointCount(p);\n\t      if (cnt < 2)\n\t        continue;\n\t      var pg = new Array(cnt);\n\t      for (var j = 0; j < cnt; j++)\n\t      {\n\t        pg[j] = p.Pt;\n\t        p = p.Prev;\n\t      }\n\t      polyg.push(pg);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.BuildResult2 = function (polytree)\n\t  {\n\t    polytree.Clear();\n\t    //add each output polygon/contour to polytree ...\n\t    //polytree.m_AllPolys.set_Capacity(this.m_PolyOuts.length);\n\t    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t    {\n\t      var outRec = this.m_PolyOuts[i];\n\t      var cnt = this.PointCount(outRec.Pts);\n\t      if ((outRec.IsOpen && cnt < 2) || (!outRec.IsOpen && cnt < 3))\n\t        continue;\n\t      this.FixHoleLinkage(outRec);\n\t      var pn = new ClipperLib.PolyNode();\n\t      polytree.m_AllPolys.push(pn);\n\t      outRec.PolyNode = pn;\n\t      pn.m_polygon.length = cnt;\n\t      var op = outRec.Pts.Prev;\n\t      for (var j = 0; j < cnt; j++)\n\t      {\n\t        pn.m_polygon[j] = op.Pt;\n\t        op = op.Prev;\n\t      }\n\t    }\n\t    //fixup PolyNode links etc ...\n\t    //polytree.m_Childs.set_Capacity(this.m_PolyOuts.length);\n\t    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t    {\n\t      var outRec = this.m_PolyOuts[i];\n\t      if (outRec.PolyNode === null)\n\t        continue;\n\t      else if (outRec.IsOpen)\n\t      {\n\t        outRec.PolyNode.IsOpen = true;\n\t        polytree.AddChild(outRec.PolyNode);\n\t      }\n\t      else if (outRec.FirstLeft !== null && outRec.FirstLeft.PolyNode != null)\n\t        outRec.FirstLeft.PolyNode.AddChild(outRec.PolyNode);\n\t      else\n\t        polytree.AddChild(outRec.PolyNode);\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.FixupOutPolygon = function (outRec)\n\t  {\n\t    //FixupOutPolygon() - removes duplicate points and simplifies consecutive\n\t    //parallel edges by removing the middle vertex.\n\t    var lastOK = null;\n\t    outRec.BottomPt = null;\n\t    var pp = outRec.Pts;\n\t    for (;;)\n\t    {\n\t      if (pp.Prev == pp || pp.Prev == pp.Next)\n\t      {\n\t        outRec.Pts = null;\n\t        return;\n\t      }\n\t      //test for duplicate points and collinear edges ...\n\t      if ((ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Next.Pt)) || (ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Prev.Pt)) ||\n\t        (ClipperLib.ClipperBase.SlopesEqual(pp.Prev.Pt, pp.Pt, pp.Next.Pt, this.m_UseFullRange) &&\n\t          (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(pp.Prev.Pt, pp.Pt, pp.Next.Pt))))\n\t      {\n\t        lastOK = null;\n\t        pp.Prev.Next = pp.Next;\n\t        pp.Next.Prev = pp.Prev;\n\t        pp = pp.Prev;\n\t      }\n\t      else if (pp == lastOK)\n\t        break;\n\t      else\n\t      {\n\t        if (lastOK === null)\n\t          lastOK = pp;\n\t        pp = pp.Next;\n\t      }\n\t    }\n\t    outRec.Pts = pp;\n\t  };\n\t  ClipperLib.Clipper.prototype.DupOutPt = function (outPt, InsertAfter)\n\t  {\n\t    var result = new ClipperLib.OutPt();\n\t    //result.Pt = outPt.Pt;\n\t    result.Pt.X = outPt.Pt.X;\n\t    result.Pt.Y = outPt.Pt.Y;\n\t    result.Idx = outPt.Idx;\n\t    if (InsertAfter)\n\t    {\n\t      result.Next = outPt.Next;\n\t      result.Prev = outPt;\n\t      outPt.Next.Prev = result;\n\t      outPt.Next = result;\n\t    }\n\t    else\n\t    {\n\t      result.Prev = outPt.Prev;\n\t      result.Next = outPt;\n\t      outPt.Prev.Next = result;\n\t      outPt.Prev = result;\n\t    }\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.prototype.GetOverlap = function (a1, a2, b1, b2, $val)\n\t  {\n\t    if (a1 < a2)\n\t    {\n\t      if (b1 < b2)\n\t      {\n\t        $val.Left = Math.max(a1, b1);\n\t        $val.Right = Math.min(a2, b2);\n\t      }\n\t      else\n\t      {\n\t        $val.Left = Math.max(a1, b2);\n\t        $val.Right = Math.min(a2, b1);\n\t      }\n\t    }\n\t    else\n\t    {\n\t      if (b1 < b2)\n\t      {\n\t        $val.Left = Math.max(a2, b1);\n\t        $val.Right = Math.min(a1, b2);\n\t      }\n\t      else\n\t      {\n\t        $val.Left = Math.max(a2, b2);\n\t        $val.Right = Math.min(a1, b1);\n\t      }\n\t    }\n\t    return $val.Left < $val.Right;\n\t  };\n\t  ClipperLib.Clipper.prototype.JoinHorz = function (op1, op1b, op2, op2b, Pt, DiscardLeft)\n\t  {\n\t    var Dir1 = (op1.Pt.X > op1b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n\t    var Dir2 = (op2.Pt.X > op2b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n\t    if (Dir1 == Dir2)\n\t      return false;\n\t    //When DiscardLeft, we want Op1b to be on the Left of Op1, otherwise we\n\t    //want Op1b to be on the Right. (And likewise with Op2 and Op2b.)\n\t    //So, to facilitate this while inserting Op1b and Op2b ...\n\t    //when DiscardLeft, make sure we're AT or RIGHT of Pt before adding Op1b,\n\t    //otherwise make sure we're AT or LEFT of Pt. (Likewise with Op2b.)\n\t    if (Dir1 == ClipperLib.Direction.dLeftToRight)\n\t    {\n\t      while (op1.Next.Pt.X <= Pt.X &&\n\t        op1.Next.Pt.X >= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)\n\t        op1 = op1.Next;\n\t      if (DiscardLeft && (op1.Pt.X != Pt.X))\n\t        op1 = op1.Next;\n\t      op1b = this.DupOutPt(op1, !DiscardLeft);\n\t      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n\t      {\n\t        op1 = op1b;\n\t        //op1.Pt = Pt;\n\t        op1.Pt.X = Pt.X;\n\t        op1.Pt.Y = Pt.Y;\n\t        op1b = this.DupOutPt(op1, !DiscardLeft);\n\t      }\n\t    }\n\t    else\n\t    {\n\t      while (op1.Next.Pt.X >= Pt.X &&\n\t        op1.Next.Pt.X <= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)\n\t        op1 = op1.Next;\n\t      if (!DiscardLeft && (op1.Pt.X != Pt.X))\n\t        op1 = op1.Next;\n\t      op1b = this.DupOutPt(op1, DiscardLeft);\n\t      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n\t      {\n\t        op1 = op1b;\n\t        //op1.Pt = Pt;\n\t        op1.Pt.X = Pt.X;\n\t        op1.Pt.Y = Pt.Y;\n\t        op1b = this.DupOutPt(op1, DiscardLeft);\n\t      }\n\t    }\n\t    if (Dir2 == ClipperLib.Direction.dLeftToRight)\n\t    {\n\t      while (op2.Next.Pt.X <= Pt.X &&\n\t        op2.Next.Pt.X >= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)\n\t        op2 = op2.Next;\n\t      if (DiscardLeft && (op2.Pt.X != Pt.X))\n\t        op2 = op2.Next;\n\t      op2b = this.DupOutPt(op2, !DiscardLeft);\n\t      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n\t      {\n\t        op2 = op2b;\n\t        //op2.Pt = Pt;\n\t        op2.Pt.X = Pt.X;\n\t        op2.Pt.Y = Pt.Y;\n\t        op2b = this.DupOutPt(op2, !DiscardLeft);\n\t      }\n\t    }\n\t    else\n\t    {\n\t      while (op2.Next.Pt.X >= Pt.X &&\n\t        op2.Next.Pt.X <= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)\n\t        op2 = op2.Next;\n\t      if (!DiscardLeft && (op2.Pt.X != Pt.X))\n\t        op2 = op2.Next;\n\t      op2b = this.DupOutPt(op2, DiscardLeft);\n\t      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n\t      {\n\t        op2 = op2b;\n\t        //op2.Pt = Pt;\n\t        op2.Pt.X = Pt.X;\n\t        op2.Pt.Y = Pt.Y;\n\t        op2b = this.DupOutPt(op2, DiscardLeft);\n\t      }\n\t    }\n\t    if ((Dir1 == ClipperLib.Direction.dLeftToRight) == DiscardLeft)\n\t    {\n\t      op1.Prev = op2;\n\t      op2.Next = op1;\n\t      op1b.Next = op2b;\n\t      op2b.Prev = op1b;\n\t    }\n\t    else\n\t    {\n\t      op1.Next = op2;\n\t      op2.Prev = op1;\n\t      op1b.Prev = op2b;\n\t      op2b.Next = op1b;\n\t    }\n\t    return true;\n\t  };\n\t  ClipperLib.Clipper.prototype.JoinPoints = function (j, outRec1, outRec2)\n\t  {\n\t    var op1 = j.OutPt1,\n\t      op1b = new ClipperLib.OutPt();\n\t    var op2 = j.OutPt2,\n\t      op2b = new ClipperLib.OutPt();\n\t    //There are 3 kinds of joins for output polygons ...\n\t    //1. Horizontal joins where Join.OutPt1 & Join.OutPt2 are a vertices anywhere\n\t    //along (horizontal) collinear edges (& Join.OffPt is on the same horizontal).\n\t    //2. Non-horizontal joins where Join.OutPt1 & Join.OutPt2 are at the same\n\t    //location at the Bottom of the overlapping segment (& Join.OffPt is above).\n\t    //3. StrictlySimple joins where edges touch but are not collinear and where\n\t    //Join.OutPt1, Join.OutPt2 & Join.OffPt all share the same point.\n\t    var isHorizontal = (j.OutPt1.Pt.Y == j.OffPt.Y);\n\t    if (isHorizontal && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt1.Pt)) && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt2.Pt)))\n\t    {\n\t      //Strictly Simple join ...\n\t\t\t\tif (outRec1 != outRec2) return false;\n\t\n\t      op1b = j.OutPt1.Next;\n\t      while (op1b != op1 && (ClipperLib.IntPoint.op_Equality(op1b.Pt, j.OffPt)))\n\t        op1b = op1b.Next;\n\t      var reverse1 = (op1b.Pt.Y > j.OffPt.Y);\n\t      op2b = j.OutPt2.Next;\n\t      while (op2b != op2 && (ClipperLib.IntPoint.op_Equality(op2b.Pt, j.OffPt)))\n\t        op2b = op2b.Next;\n\t      var reverse2 = (op2b.Pt.Y > j.OffPt.Y);\n\t      if (reverse1 == reverse2)\n\t        return false;\n\t      if (reverse1)\n\t      {\n\t        op1b = this.DupOutPt(op1, false);\n\t        op2b = this.DupOutPt(op2, true);\n\t        op1.Prev = op2;\n\t        op2.Next = op1;\n\t        op1b.Next = op2b;\n\t        op2b.Prev = op1b;\n\t        j.OutPt1 = op1;\n\t        j.OutPt2 = op1b;\n\t        return true;\n\t      }\n\t      else\n\t      {\n\t        op1b = this.DupOutPt(op1, true);\n\t        op2b = this.DupOutPt(op2, false);\n\t        op1.Next = op2;\n\t        op2.Prev = op1;\n\t        op1b.Prev = op2b;\n\t        op2b.Next = op1b;\n\t        j.OutPt1 = op1;\n\t        j.OutPt2 = op1b;\n\t        return true;\n\t      }\n\t    }\n\t    else if (isHorizontal)\n\t    {\n\t      //treat horizontal joins differently to non-horizontal joins since with\n\t      //them we're not yet sure where the overlapping is. OutPt1.Pt & OutPt2.Pt\n\t      //may be anywhere along the horizontal edge.\n\t      op1b = op1;\n\t      while (op1.Prev.Pt.Y == op1.Pt.Y && op1.Prev != op1b && op1.Prev != op2)\n\t        op1 = op1.Prev;\n\t      while (op1b.Next.Pt.Y == op1b.Pt.Y && op1b.Next != op1 && op1b.Next != op2)\n\t        op1b = op1b.Next;\n\t      if (op1b.Next == op1 || op1b.Next == op2)\n\t        return false;\n\t      //a flat 'polygon'\n\t      op2b = op2;\n\t      while (op2.Prev.Pt.Y == op2.Pt.Y && op2.Prev != op2b && op2.Prev != op1b)\n\t        op2 = op2.Prev;\n\t      while (op2b.Next.Pt.Y == op2b.Pt.Y && op2b.Next != op2 && op2b.Next != op1)\n\t        op2b = op2b.Next;\n\t      if (op2b.Next == op2 || op2b.Next == op1)\n\t        return false;\n\t      //a flat 'polygon'\n\t      //Op1 -. Op1b & Op2 -. Op2b are the extremites of the horizontal edges\n\t\n\t      var $val = {Left: null, Right: null};\n\t      if (!this.GetOverlap(op1.Pt.X, op1b.Pt.X, op2.Pt.X, op2b.Pt.X, $val))\n\t        return false;\n\t      var Left = $val.Left;\n\t      var Right = $val.Right;\n\t\n\t      //DiscardLeftSide: when overlapping edges are joined, a spike will created\n\t      //which needs to be cleaned up. However, we don't want Op1 or Op2 caught up\n\t      //on the discard Side as either may still be needed for other joins ...\n\t      var Pt = new ClipperLib.IntPoint();\n\t      var DiscardLeftSide;\n\t      if (op1.Pt.X >= Left && op1.Pt.X <= Right)\n\t      {\n\t        //Pt = op1.Pt;\n\t        Pt.X = op1.Pt.X;\n\t        Pt.Y = op1.Pt.Y;\n\t        DiscardLeftSide = (op1.Pt.X > op1b.Pt.X);\n\t      }\n\t      else if (op2.Pt.X >= Left && op2.Pt.X <= Right)\n\t      {\n\t        //Pt = op2.Pt;\n\t        Pt.X = op2.Pt.X;\n\t        Pt.Y = op2.Pt.Y;\n\t        DiscardLeftSide = (op2.Pt.X > op2b.Pt.X);\n\t      }\n\t      else if (op1b.Pt.X >= Left && op1b.Pt.X <= Right)\n\t      {\n\t        //Pt = op1b.Pt;\n\t        Pt.X = op1b.Pt.X;\n\t        Pt.Y = op1b.Pt.Y;\n\t        DiscardLeftSide = op1b.Pt.X > op1.Pt.X;\n\t      }\n\t      else\n\t      {\n\t        //Pt = op2b.Pt;\n\t        Pt.X = op2b.Pt.X;\n\t        Pt.Y = op2b.Pt.Y;\n\t        DiscardLeftSide = (op2b.Pt.X > op2.Pt.X);\n\t      }\n\t      j.OutPt1 = op1;\n\t      j.OutPt2 = op2;\n\t      return this.JoinHorz(op1, op1b, op2, op2b, Pt, DiscardLeftSide);\n\t    }\n\t    else\n\t    {\n\t      //nb: For non-horizontal joins ...\n\t      //    1. Jr.OutPt1.Pt.Y == Jr.OutPt2.Pt.Y\n\t      //    2. Jr.OutPt1.Pt > Jr.OffPt.Y\n\t      //make sure the polygons are correctly oriented ...\n\t      op1b = op1.Next;\n\t      while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))\n\t        op1b = op1b.Next;\n\t      var Reverse1 = ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange));\n\t      if (Reverse1)\n\t      {\n\t        op1b = op1.Prev;\n\t        while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))\n\t          op1b = op1b.Prev;\n\t        if ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange))\n\t          return false;\n\t      }\n\t      op2b = op2.Next;\n\t      while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))\n\t        op2b = op2b.Next;\n\t      var Reverse2 = ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange));\n\t      if (Reverse2)\n\t      {\n\t        op2b = op2.Prev;\n\t        while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))\n\t          op2b = op2b.Prev;\n\t        if ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange))\n\t          return false;\n\t      }\n\t      if ((op1b == op1) || (op2b == op2) || (op1b == op2b) ||\n\t        ((outRec1 == outRec2) && (Reverse1 == Reverse2)))\n\t        return false;\n\t      if (Reverse1)\n\t      {\n\t        op1b = this.DupOutPt(op1, false);\n\t        op2b = this.DupOutPt(op2, true);\n\t        op1.Prev = op2;\n\t        op2.Next = op1;\n\t        op1b.Next = op2b;\n\t        op2b.Prev = op1b;\n\t        j.OutPt1 = op1;\n\t        j.OutPt2 = op1b;\n\t        return true;\n\t      }\n\t      else\n\t      {\n\t        op1b = this.DupOutPt(op1, true);\n\t        op2b = this.DupOutPt(op2, false);\n\t        op1.Next = op2;\n\t        op2.Prev = op1;\n\t        op1b.Prev = op2b;\n\t        op2b.Next = op1b;\n\t        j.OutPt1 = op1;\n\t        j.OutPt2 = op1b;\n\t        return true;\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.Clipper.GetBounds = function (paths)\n\t  {\n\t    var i = 0,\n\t      cnt = paths.length;\n\t    while (i < cnt && paths[i].length == 0) i++;\n\t    if (i == cnt) return new ClipperLib.IntRect(0, 0, 0, 0);\n\t    var result = new ClipperLib.IntRect();\n\t    result.left = paths[i][0].X;\n\t    result.right = result.left;\n\t    result.top = paths[i][0].Y;\n\t    result.bottom = result.top;\n\t    for (; i < cnt; i++)\n\t      for (var j = 0, jlen = paths[i].length; j < jlen; j++)\n\t      {\n\t        if (paths[i][j].X < result.left) result.left = paths[i][j].X;\n\t        else if (paths[i][j].X > result.right) result.right = paths[i][j].X;\n\t        if (paths[i][j].Y < result.top) result.top = paths[i][j].Y;\n\t        else if (paths[i][j].Y > result.bottom) result.bottom = paths[i][j].Y;\n\t      }\n\t    return result;\n\t  }\n\t  ClipperLib.Clipper.prototype.GetBounds2 = function (ops)\n\t  {\n\t    var opStart = ops;\n\t    var result = new ClipperLib.IntRect();\n\t    result.left = ops.Pt.X;\n\t    result.right = ops.Pt.X;\n\t    result.top = ops.Pt.Y;\n\t    result.bottom = ops.Pt.Y;\n\t    ops = ops.Next;\n\t    while (ops != opStart)\n\t    {\n\t      if (ops.Pt.X < result.left)\n\t        result.left = ops.Pt.X;\n\t      if (ops.Pt.X > result.right)\n\t        result.right = ops.Pt.X;\n\t      if (ops.Pt.Y < result.top)\n\t        result.top = ops.Pt.Y;\n\t      if (ops.Pt.Y > result.bottom)\n\t        result.bottom = ops.Pt.Y;\n\t      ops = ops.Next;\n\t    }\n\t    return result;\n\t  };\n\t\n\t  ClipperLib.Clipper.PointInPolygon = function (pt, path)\n\t  {\n\t    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t\t\t//See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n\t    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n\t    var result = 0,\n\t      cnt = path.length;\n\t    if (cnt < 3)\n\t      return 0;\n\t    var ip = path[0];\n\t    for (var i = 1; i <= cnt; ++i)\n\t    {\n\t      var ipNext = (i == cnt ? path[0] : path[i]);\n\t      if (ipNext.Y == pt.Y)\n\t      {\n\t        if ((ipNext.X == pt.X) || (ip.Y == pt.Y && ((ipNext.X > pt.X) == (ip.X < pt.X))))\n\t          return -1;\n\t      }\n\t      if ((ip.Y < pt.Y) != (ipNext.Y < pt.Y))\n\t      {\n\t        if (ip.X >= pt.X)\n\t        {\n\t          if (ipNext.X > pt.X)\n\t            result = 1 - result;\n\t          else\n\t          {\n\t            var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n\t            if (d == 0)\n\t              return -1;\n\t            else if ((d > 0) == (ipNext.Y > ip.Y))\n\t              result = 1 - result;\n\t          }\n\t        }\n\t        else\n\t        {\n\t          if (ipNext.X > pt.X)\n\t          {\n\t            var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n\t            if (d == 0)\n\t              return -1;\n\t            else if ((d > 0) == (ipNext.Y > ip.Y))\n\t              result = 1 - result;\n\t          }\n\t        }\n\t      }\n\t      ip = ipNext;\n\t    }\n\t    return result;\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.PointInPolygon = function (pt, op)\n\t  {\n\t    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t\t\t//See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n\t    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n\t    var result = 0;\n\t    var startOp = op;\n\t\t\tvar ptx = pt.X, pty = pt.Y;\n\t    var poly0x = op.Pt.X, poly0y = op.Pt.Y;\n\t    do\n\t    {\n\t\t\t\top = op.Next;\n\t\t\t\tvar poly1x = op.Pt.X, poly1y = op.Pt.Y;\n\t      if (poly1y == pty)\n\t      {\n\t        if ((poly1x == ptx) || (poly0y == pty && ((poly1x > ptx) == (poly0x < ptx))))\n\t          return -1;\n\t      }\n\t      if ((poly0y < pty) != (poly1y < pty))\n\t      {\n\t        if (poly0x >= ptx)\n\t        {\n\t          if (poly1x > ptx)\n\t            result = 1 - result;\n\t          else\n\t          {\n\t            var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n\t            if (d == 0)\n\t              return -1;\n\t            if ((d > 0) == (poly1y > poly0y))\n\t              result = 1 - result;\n\t          }\n\t        }\n\t        else\n\t        {\n\t          if (poly1x > ptx)\n\t          {\n\t            var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n\t            if (d == 0)\n\t              return -1;\n\t            if ((d > 0) == (poly1y > poly0y))\n\t              result = 1 - result;\n\t          }\n\t        }\n\t      }\n\t      poly0x = poly1x;\n\t      poly0y = poly1y;\n\t    } while (startOp != op);\n\t\n\t    return result;\n\t  };\n\t\n\t  ClipperLib.Clipper.prototype.Poly2ContainsPoly1 = function (outPt1, outPt2)\n\t  {\n\t    var op = outPt1;\n\t    do\n\t    {\n\t\t\t\t//nb: PointInPolygon returns 0 if false, +1 if true, -1 if pt on polygon\n\t      var res = this.PointInPolygon(op.Pt, outPt2);\n\t      if (res >= 0)\n\t        return res > 0;\n\t      op = op.Next;\n\t    }\n\t    while (op != outPt1)\n\t    return true;\n\t  };\n\t  ClipperLib.Clipper.prototype.FixupFirstLefts1 = function (OldOutRec, NewOutRec)\n\t  {\n\t    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n\t    {\n\t\t\t\tvar outRec = this.m_PolyOuts[i];\n\t\t\t\tif (outRec.Pts == null || outRec.FirstLeft == null)\n\t\t\t\t\tcontinue;\n\t\t\t\tvar firstLeft = this.ParseFirstLeft(outRec.FirstLeft);\n\t\t\t\tif (firstLeft == OldOutRec)\n\t\t\t\t{\n\t        if (this.Poly2ContainsPoly1(outRec.Pts, NewOutRec.Pts))\n\t          outRec.FirstLeft = NewOutRec;\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.FixupFirstLefts2 = function (OldOutRec, NewOutRec)\n\t  {\n\t    for (var $i2 = 0, $t2 = this.m_PolyOuts, $l2 = $t2.length, outRec = $t2[$i2]; $i2 < $l2; $i2++, outRec = $t2[$i2])\n\t      if (outRec.FirstLeft == OldOutRec)\n\t        outRec.FirstLeft = NewOutRec;\n\t  };\n\t  ClipperLib.Clipper.ParseFirstLeft = function (FirstLeft)\n\t  {\n\t    while (FirstLeft != null && FirstLeft.Pts == null)\n\t      FirstLeft = FirstLeft.FirstLeft;\n\t    return FirstLeft;\n\t  };\n\t  ClipperLib.Clipper.prototype.JoinCommonEdges = function ()\n\t  {\n\t    for (var i = 0, ilen = this.m_Joins.length; i < ilen; i++)\n\t    {\n\t      var join = this.m_Joins[i];\n\t      var outRec1 = this.GetOutRec(join.OutPt1.Idx);\n\t      var outRec2 = this.GetOutRec(join.OutPt2.Idx);\n\t      if (outRec1.Pts == null || outRec2.Pts == null)\n\t        continue;\n\t      //get the polygon fragment with the correct hole state (FirstLeft)\n\t      //before calling JoinPoints() ...\n\t      var holeStateRec;\n\t      if (outRec1 == outRec2)\n\t        holeStateRec = outRec1;\n\t      else if (this.Param1RightOfParam2(outRec1, outRec2))\n\t        holeStateRec = outRec2;\n\t      else if (this.Param1RightOfParam2(outRec2, outRec1))\n\t        holeStateRec = outRec1;\n\t      else\n\t        holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\t\n\t      if (!this.JoinPoints(join, outRec1, outRec2)) continue;\n\t\n\t      if (outRec1 == outRec2)\n\t      {\n\t        //instead of joining two polygons, we've just created a new one by\n\t        //splitting one polygon into two.\n\t        outRec1.Pts = join.OutPt1;\n\t        outRec1.BottomPt = null;\n\t        outRec2 = this.CreateOutRec();\n\t        outRec2.Pts = join.OutPt2;\n\t        //update all OutRec2.Pts Idx's ...\n\t        this.UpdateOutPtIdxs(outRec2);\n\t        //We now need to check every OutRec.FirstLeft pointer. If it points\n\t        //to OutRec1 it may need to point to OutRec2 instead ...\n\t        if (this.m_UsingPolyTree)\n\t          for (var j = 0, jlen = this.m_PolyOuts.length; j < jlen - 1; j++)\n\t          {\n\t            var oRec = this.m_PolyOuts[j];\n\t            if (oRec.Pts == null || ClipperLib.Clipper.ParseFirstLeft(oRec.FirstLeft) != outRec1 || oRec.IsHole == outRec1.IsHole)\n\t              continue;\n\t            if (this.Poly2ContainsPoly1(oRec.Pts, join.OutPt2))\n\t              oRec.FirstLeft = outRec2;\n\t          }\n\t        if (this.Poly2ContainsPoly1(outRec2.Pts, outRec1.Pts))\n\t        {\n\t          //outRec2 is contained by outRec1 ...\n\t          outRec2.IsHole = !outRec1.IsHole;\n\t          outRec2.FirstLeft = outRec1;\n\t          //fixup FirstLeft pointers that may need reassigning to OutRec1\n\t          if (this.m_UsingPolyTree)\n\t            this.FixupFirstLefts2(outRec2, outRec1);\n\t          if ((outRec2.IsHole ^ this.ReverseSolution) == (this.Area(outRec2) > 0))\n\t            this.ReversePolyPtLinks(outRec2.Pts);\n\t        }\n\t        else if (this.Poly2ContainsPoly1(outRec1.Pts, outRec2.Pts))\n\t        {\n\t          //outRec1 is contained by outRec2 ...\n\t          outRec2.IsHole = outRec1.IsHole;\n\t          outRec1.IsHole = !outRec2.IsHole;\n\t          outRec2.FirstLeft = outRec1.FirstLeft;\n\t          outRec1.FirstLeft = outRec2;\n\t          //fixup FirstLeft pointers that may need reassigning to OutRec1\n\t          if (this.m_UsingPolyTree)\n\t            this.FixupFirstLefts2(outRec1, outRec2);\n\t          if ((outRec1.IsHole ^ this.ReverseSolution) == (this.Area(outRec1) > 0))\n\t            this.ReversePolyPtLinks(outRec1.Pts);\n\t        }\n\t        else\n\t        {\n\t          //the 2 polygons are completely separate ...\n\t          outRec2.IsHole = outRec1.IsHole;\n\t          outRec2.FirstLeft = outRec1.FirstLeft;\n\t          //fixup FirstLeft pointers that may need reassigning to OutRec2\n\t          if (this.m_UsingPolyTree)\n\t            this.FixupFirstLefts1(outRec1, outRec2);\n\t        }\n\t      }\n\t      else\n\t      {\n\t        //joined 2 polygons together ...\n\t        outRec2.Pts = null;\n\t        outRec2.BottomPt = null;\n\t        outRec2.Idx = outRec1.Idx;\n\t        outRec1.IsHole = holeStateRec.IsHole;\n\t        if (holeStateRec == outRec2)\n\t          outRec1.FirstLeft = outRec2.FirstLeft;\n\t        outRec2.FirstLeft = outRec1;\n\t        //fixup FirstLeft pointers that may need reassigning to OutRec1\n\t        if (this.m_UsingPolyTree)\n\t          this.FixupFirstLefts2(outRec2, outRec1);\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.Clipper.prototype.UpdateOutPtIdxs = function (outrec)\n\t  {\n\t    var op = outrec.Pts;\n\t    do {\n\t      op.Idx = outrec.Idx;\n\t      op = op.Prev;\n\t    }\n\t    while (op != outrec.Pts)\n\t  };\n\t  ClipperLib.Clipper.prototype.DoSimplePolygons = function ()\n\t  {\n\t    var i = 0;\n\t    while (i < this.m_PolyOuts.length)\n\t    {\n\t      var outrec = this.m_PolyOuts[i++];\n\t      var op = outrec.Pts;\n\t\t\t\tif (op == null || outrec.IsOpen)\n\t\t\t\t\tcontinue;\n\t      do //for each Pt in Polygon until duplicate found do ...\n\t      {\n\t        var op2 = op.Next;\n\t        while (op2 != outrec.Pts)\n\t        {\n\t          if ((ClipperLib.IntPoint.op_Equality(op.Pt, op2.Pt)) && op2.Next != op && op2.Prev != op)\n\t          {\n\t            //split the polygon into two ...\n\t            var op3 = op.Prev;\n\t            var op4 = op2.Prev;\n\t            op.Prev = op4;\n\t            op4.Next = op;\n\t            op2.Prev = op3;\n\t            op3.Next = op2;\n\t            outrec.Pts = op;\n\t            var outrec2 = this.CreateOutRec();\n\t            outrec2.Pts = op2;\n\t            this.UpdateOutPtIdxs(outrec2);\n\t            if (this.Poly2ContainsPoly1(outrec2.Pts, outrec.Pts))\n\t            {\n\t              //OutRec2 is contained by OutRec1 ...\n\t              outrec2.IsHole = !outrec.IsHole;\n\t              outrec2.FirstLeft = outrec;\n\t\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec2, outrec);\n\t\n\t            }\n\t            else if (this.Poly2ContainsPoly1(outrec.Pts, outrec2.Pts))\n\t            {\n\t              //OutRec1 is contained by OutRec2 ...\n\t              outrec2.IsHole = outrec.IsHole;\n\t              outrec.IsHole = !outrec2.IsHole;\n\t              outrec2.FirstLeft = outrec.FirstLeft;\n\t              outrec.FirstLeft = outrec2;\n\t              if (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec, outrec2);\n\t            }\n\t            else\n\t            {\n\t              //the 2 polygons are separate ...\n\t              outrec2.IsHole = outrec.IsHole;\n\t              outrec2.FirstLeft = outrec.FirstLeft;\n\t\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts1(outrec, outrec2);\n\t            }\n\t            op2 = op;\n\t            //ie get ready for the next iteration\n\t          }\n\t          op2 = op2.Next;\n\t        }\n\t        op = op.Next;\n\t      }\n\t      while (op != outrec.Pts)\n\t    }\n\t  };\n\t  ClipperLib.Clipper.Area = function (poly)\n\t  {\n\t    var cnt = poly.length;\n\t    if (cnt < 3)\n\t      return 0;\n\t    var a = 0;\n\t    for (var i = 0, j = cnt - 1; i < cnt; ++i)\n\t    {\n\t      a += (poly[j].X + poly[i].X) * (poly[j].Y - poly[i].Y);\n\t      j = i;\n\t    }\n\t    return -a * 0.5;\n\t  };\n\t  ClipperLib.Clipper.prototype.Area = function (outRec)\n\t  {\n\t    var op = outRec.Pts;\n\t    if (op == null)\n\t      return 0;\n\t    var a = 0;\n\t    do {\n\t      a = a + (op.Prev.Pt.X + op.Pt.X) * (op.Prev.Pt.Y - op.Pt.Y);\n\t      op = op.Next;\n\t    }\n\t    while (op != outRec.Pts)\n\t    return a * 0.5;\n\t  };\n\t  ClipperLib.Clipper.SimplifyPolygon = function (poly, fillType)\n\t  {\n\t    var result = new Array();\n\t    var c = new ClipperLib.Clipper(0);\n\t    c.StrictlySimple = true;\n\t    c.AddPath(poly, ClipperLib.PolyType.ptSubject, true);\n\t    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.SimplifyPolygons = function (polys, fillType)\n\t  {\n\t    if (typeof (fillType) == \"undefined\") fillType = ClipperLib.PolyFillType.pftEvenOdd;\n\t    var result = new Array();\n\t    var c = new ClipperLib.Clipper(0);\n\t    c.StrictlySimple = true;\n\t    c.AddPaths(polys, ClipperLib.PolyType.ptSubject, true);\n\t    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.DistanceSqrd = function (pt1, pt2)\n\t  {\n\t    var dx = (pt1.X - pt2.X);\n\t    var dy = (pt1.Y - pt2.Y);\n\t    return (dx * dx + dy * dy);\n\t  };\n\t  ClipperLib.Clipper.DistanceFromLineSqrd = function (pt, ln1, ln2)\n\t  {\n\t    //The equation of a line in general form (Ax + By + C = 0)\n\t    //given 2 points (x,y) & (x,y) is ...\n\t    //(y - y)x + (x - x)y + (y - y)x - (x - x)y = 0\n\t    //A = (y - y); B = (x - x); C = (y - y)x - (x - x)y\n\t    //perpendicular distance of point (x,y) = (Ax + By + C)/Sqrt(A + B)\n\t    //see http://en.wikipedia.org/wiki/Perpendicular_distance\n\t    var A = ln1.Y - ln2.Y;\n\t    var B = ln2.X - ln1.X;\n\t    var C = A * ln1.X + B * ln1.Y;\n\t    C = A * pt.X + B * pt.Y - C;\n\t    return (C * C) / (A * A + B * B);\n\t  };\n\t\n\t\tClipperLib.Clipper.SlopesNearCollinear = function(pt1, pt2, pt3, distSqrd)\n\t\t{\n\t\t\t//this function is more accurate when the point that's GEOMETRICALLY\n\t\t\t//between the other 2 points is the one that's tested for distance.\n\t\t\t//nb: with 'spikes', either pt1 or pt3 is geometrically between the other pts\n\t\t\tif (Math.abs(pt1.X - pt2.X) > Math.abs(pt1.Y - pt2.Y))\n\t\t\t{\n\t\t\tif ((pt1.X > pt2.X) == (pt1.X < pt3.X))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n\t\t\telse if ((pt2.X > pt1.X) == (pt2.X < pt3.X))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t\t\t\t\telse\n\t\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\tif ((pt1.Y > pt2.Y) == (pt1.Y < pt3.Y))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n\t\t\telse if ((pt2.Y > pt1.Y) == (pt2.Y < pt3.Y))\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t\t\t\t\telse\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n\t\t\t}\n\t\t}\n\t\n\t  ClipperLib.Clipper.PointsAreClose = function (pt1, pt2, distSqrd)\n\t  {\n\t    var dx = pt1.X - pt2.X;\n\t    var dy = pt1.Y - pt2.Y;\n\t    return ((dx * dx) + (dy * dy) <= distSqrd);\n\t  };\n\t  //------------------------------------------------------------------------------\n\t  ClipperLib.Clipper.ExcludeOp = function (op)\n\t  {\n\t    var result = op.Prev;\n\t    result.Next = op.Next;\n\t    op.Next.Prev = result;\n\t    result.Idx = 0;\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.CleanPolygon = function (path, distance)\n\t  {\n\t    if (typeof (distance) == \"undefined\") distance = 1.415;\n\t    //distance = proximity in units/pixels below which vertices will be stripped.\n\t    //Default ~= sqrt(2) so when adjacent vertices or semi-adjacent vertices have\n\t    //both x & y coords within 1 unit, then the second vertex will be stripped.\n\t    var cnt = path.length;\n\t    if (cnt == 0)\n\t      return new Array();\n\t    var outPts = new Array(cnt);\n\t    for (var i = 0; i < cnt; ++i)\n\t      outPts[i] = new ClipperLib.OutPt();\n\t    for (var i = 0; i < cnt; ++i)\n\t    {\n\t      outPts[i].Pt = path[i];\n\t      outPts[i].Next = outPts[(i + 1) % cnt];\n\t      outPts[i].Next.Prev = outPts[i];\n\t      outPts[i].Idx = 0;\n\t    }\n\t    var distSqrd = distance * distance;\n\t    var op = outPts[0];\n\t    while (op.Idx == 0 && op.Next != op.Prev)\n\t    {\n\t      if (ClipperLib.Clipper.PointsAreClose(op.Pt, op.Prev.Pt, distSqrd))\n\t      {\n\t        op = ClipperLib.Clipper.ExcludeOp(op);\n\t        cnt--;\n\t      }\n\t      else if (ClipperLib.Clipper.PointsAreClose(op.Prev.Pt, op.Next.Pt, distSqrd))\n\t      {\n\t        ClipperLib.Clipper.ExcludeOp(op.Next);\n\t        op = ClipperLib.Clipper.ExcludeOp(op);\n\t        cnt -= 2;\n\t      }\n\t      else if (ClipperLib.Clipper.SlopesNearCollinear(op.Prev.Pt, op.Pt, op.Next.Pt, distSqrd))\n\t      {\n\t        op = ClipperLib.Clipper.ExcludeOp(op);\n\t        cnt--;\n\t      }\n\t      else\n\t      {\n\t        op.Idx = 1;\n\t        op = op.Next;\n\t      }\n\t    }\n\t    if (cnt < 3)\n\t      cnt = 0;\n\t    var result = new Array(cnt);\n\t    for (var i = 0; i < cnt; ++i)\n\t    {\n\t      result[i] = new ClipperLib.IntPoint(op.Pt);\n\t      op = op.Next;\n\t    }\n\t    outPts = null;\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.CleanPolygons = function (polys, distance)\n\t  {\n\t    var result = new Array(polys.length);\n\t    for (var i = 0, ilen = polys.length; i < ilen; i++)\n\t      result[i] = ClipperLib.Clipper.CleanPolygon(polys[i], distance);\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.Minkowski = function (pattern, path, IsSum, IsClosed)\n\t  {\n\t    var delta = (IsClosed ? 1 : 0);\n\t    var polyCnt = pattern.length;\n\t    var pathCnt = path.length;\n\t    var result = new Array();\n\t    if (IsSum)\n\t      for (var i = 0; i < pathCnt; i++)\n\t      {\n\t        var p = new Array(polyCnt);\n\t        for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n\t          p[j] = new ClipperLib.IntPoint(path[i].X + ip.X, path[i].Y + ip.Y);\n\t        result.push(p);\n\t      }\n\t    else\n\t      for (var i = 0; i < pathCnt; i++)\n\t      {\n\t        var p = new Array(polyCnt);\n\t        for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n\t          p[j] = new ClipperLib.IntPoint(path[i].X - ip.X, path[i].Y - ip.Y);\n\t        result.push(p);\n\t      }\n\t    var quads = new Array();\n\t    for (var i = 0; i < pathCnt - 1 + delta; i++)\n\t      for (var j = 0; j < polyCnt; j++)\n\t      {\n\t        var quad = new Array();\n\t        quad.push(result[i % pathCnt][j % polyCnt]);\n\t        quad.push(result[(i + 1) % pathCnt][j % polyCnt]);\n\t        quad.push(result[(i + 1) % pathCnt][(j + 1) % polyCnt]);\n\t        quad.push(result[i % pathCnt][(j + 1) % polyCnt]);\n\t        if (!ClipperLib.Clipper.Orientation(quad))\n\t          quad.reverse();\n\t        quads.push(quad);\n\t      }\n\t\t\t\treturn quads;\n\t  };\n\t\n\t\tClipperLib.Clipper.MinkowskiSum = function(pattern, path_or_paths, pathIsClosed)\n\t\t{\n\t\t\tif(!(path_or_paths[0] instanceof Array))\n\t\t\t{\n\t\t\t\tvar path = path_or_paths;\n\t\t\t\tvar paths = ClipperLib.Clipper.Minkowski(pattern, path, true, pathIsClosed);\n\t\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\t\tc.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n\t\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\t\treturn paths;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t \t\t\tvar paths = path_or_paths;\n\t\t\t\tvar solution = new ClipperLib.Paths();\n\t\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\t\tfor (var i = 0; i < paths.length; ++i)\n\t\t\t\t{\n\t\t\t\t\tvar tmp = ClipperLib.Clipper.Minkowski(pattern, paths[i], true, pathIsClosed);\n\t\t\t\t\tc.AddPaths(tmp, ClipperLib.PolyType.ptSubject, true);\n\t\t\t\t\tif (pathIsClosed)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar path = ClipperLib.Clipper.TranslatePath(paths[i], pattern[0]);\n\t\t\t\t\t\tc.AddPath(path, ClipperLib.PolyType.ptClip, true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, solution,\n\t\t\t\t\tClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\t\treturn solution;\n\t\t\t}\n\t\t}\n\t\t//------------------------------------------------------------------------------\n\t\n\t\tClipperLib.Clipper.TranslatePath = function (path, delta)\n\t\t{\n\t\t\tvar outPath = new ClipperLib.Path();\n\t\t\tfor (var i = 0; i < path.length; i++)\n\t\t\t\toutPath.push(new ClipperLib.IntPoint(path[i].X + delta.X, path[i].Y + delta.Y));\n\t\t\treturn outPath;\n\t\t}\n\t\t//------------------------------------------------------------------------------\n\t\n\t\tClipperLib.Clipper.MinkowskiDiff = function (poly1, poly2)\n\t\t{\n\t\t\tvar paths = ClipperLib.Clipper.Minkowski(poly1, poly2, false, true);\n\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\tc.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\treturn paths;\n\t\t}\n\t\n\t  ClipperLib.Clipper.PolyTreeToPaths = function (polytree)\n\t  {\n\t    var result = new Array();\n\t    //result.set_Capacity(polytree.get_Total());\n\t    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntAny, result);\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.AddPolyNodeToPaths = function (polynode, nt, paths)\n\t  {\n\t    var match = true;\n\t    switch (nt)\n\t    {\n\t    case ClipperLib.Clipper.NodeType.ntOpen:\n\t      return;\n\t    case ClipperLib.Clipper.NodeType.ntClosed:\n\t      match = !polynode.IsOpen;\n\t      break;\n\t    default:\n\t      break;\n\t    }\n\t    if (polynode.m_polygon.length > 0 && match)\n\t      paths.push(polynode.m_polygon);\n\t    for (var $i3 = 0, $t3 = polynode.Childs(), $l3 = $t3.length, pn = $t3[$i3]; $i3 < $l3; $i3++, pn = $t3[$i3])\n\t      ClipperLib.Clipper.AddPolyNodeToPaths(pn, nt, paths);\n\t  };\n\t  ClipperLib.Clipper.OpenPathsFromPolyTree = function (polytree)\n\t  {\n\t    var result = new ClipperLib.Paths();\n\t    //result.set_Capacity(polytree.ChildCount());\n\t    for (var i = 0, ilen = polytree.ChildCount(); i < ilen; i++)\n\t      if (polytree.Childs()[i].IsOpen)\n\t        result.push(polytree.Childs()[i].m_polygon);\n\t    return result;\n\t  };\n\t  ClipperLib.Clipper.ClosedPathsFromPolyTree = function (polytree)\n\t  {\n\t    var result = new ClipperLib.Paths();\n\t    //result.set_Capacity(polytree.Total());\n\t    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntClosed, result);\n\t    return result;\n\t  };\n\t  Inherit(ClipperLib.Clipper, ClipperLib.ClipperBase);\n\t  ClipperLib.Clipper.NodeType = {\n\t    ntAny: 0,\n\t    ntOpen: 1,\n\t    ntClosed: 2\n\t  };\n\t  ClipperLib.ClipperOffset = function (miterLimit, arcTolerance)\n\t  {\n\t    if (typeof (miterLimit) == \"undefined\") miterLimit = 2;\n\t    if (typeof (arcTolerance) == \"undefined\") arcTolerance = ClipperLib.ClipperOffset.def_arc_tolerance;\n\t    this.m_destPolys = new ClipperLib.Paths();\n\t    this.m_srcPoly = new ClipperLib.Path();\n\t    this.m_destPoly = new ClipperLib.Path();\n\t    this.m_normals = new Array();\n\t    this.m_delta = 0;\n\t    this.m_sinA = 0;\n\t    this.m_sin = 0;\n\t    this.m_cos = 0;\n\t    this.m_miterLim = 0;\n\t    this.m_StepsPerRad = 0;\n\t    this.m_lowest = new ClipperLib.IntPoint();\n\t    this.m_polyNodes = new ClipperLib.PolyNode();\n\t    this.MiterLimit = miterLimit;\n\t    this.ArcTolerance = arcTolerance;\n\t    this.m_lowest.X = -1;\n\t  };\n\t  ClipperLib.ClipperOffset.two_pi = 6.28318530717959;\n\t  ClipperLib.ClipperOffset.def_arc_tolerance = 0.25;\n\t  ClipperLib.ClipperOffset.prototype.Clear = function ()\n\t  {\n\t    ClipperLib.Clear(this.m_polyNodes.Childs());\n\t    this.m_lowest.X = -1;\n\t  };\n\t  ClipperLib.ClipperOffset.Round = ClipperLib.Clipper.Round;\n\t  ClipperLib.ClipperOffset.prototype.AddPath = function (path, joinType, endType)\n\t  {\n\t    var highI = path.length - 1;\n\t    if (highI < 0)\n\t      return;\n\t    var newNode = new ClipperLib.PolyNode();\n\t    newNode.m_jointype = joinType;\n\t    newNode.m_endtype = endType;\n\t    //strip duplicate points from path and also get index to the lowest point ...\n\t    if (endType == ClipperLib.EndType.etClosedLine || endType == ClipperLib.EndType.etClosedPolygon)\n\t      while (highI > 0 && ClipperLib.IntPoint.op_Equality(path[0], path[highI]))\n\t        highI--;\n\t    //newNode.m_polygon.set_Capacity(highI + 1);\n\t    newNode.m_polygon.push(path[0]);\n\t    var j = 0,\n\t      k = 0;\n\t    for (var i = 1; i <= highI; i++)\n\t      if (ClipperLib.IntPoint.op_Inequality(newNode.m_polygon[j], path[i]))\n\t      {\n\t        j++;\n\t        newNode.m_polygon.push(path[i]);\n\t        if (path[i].Y > newNode.m_polygon[k].Y || (path[i].Y == newNode.m_polygon[k].Y && path[i].X < newNode.m_polygon[k].X))\n\t          k = j;\n\t      }\n\t    if (endType == ClipperLib.EndType.etClosedPolygon && j < 2) return;\n\t\n\t    this.m_polyNodes.AddChild(newNode);\n\t    //if this path's lowest pt is lower than all the others then update m_lowest\n\t    if (endType != ClipperLib.EndType.etClosedPolygon)\n\t      return;\n\t    if (this.m_lowest.X < 0)\n\t      this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);\n\t    else\n\t    {\n\t      var ip = this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon[this.m_lowest.Y];\n\t      if (newNode.m_polygon[k].Y > ip.Y || (newNode.m_polygon[k].Y == ip.Y && newNode.m_polygon[k].X < ip.X))\n\t        this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);\n\t    }\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.AddPaths = function (paths, joinType, endType)\n\t  {\n\t    for (var i = 0, ilen = paths.length; i < ilen; i++)\n\t      this.AddPath(paths[i], joinType, endType);\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.FixOrientations = function ()\n\t  {\n\t    //fixup orientations of all closed paths if the orientation of the\n\t    //closed path with the lowermost vertex is wrong ...\n\t    if (this.m_lowest.X >= 0 && !ClipperLib.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon))\n\t    {\n\t      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t      {\n\t        var node = this.m_polyNodes.Childs()[i];\n\t        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon || (node.m_endtype == ClipperLib.EndType.etClosedLine && ClipperLib.Clipper.Orientation(node.m_polygon)))\n\t          node.m_polygon.reverse();\n\t      }\n\t    }\n\t    else\n\t    {\n\t      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t      {\n\t        var node = this.m_polyNodes.Childs()[i];\n\t        if (node.m_endtype == ClipperLib.EndType.etClosedLine && !ClipperLib.Clipper.Orientation(node.m_polygon))\n\t          node.m_polygon.reverse();\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.ClipperOffset.GetUnitNormal = function (pt1, pt2)\n\t  {\n\t    var dx = (pt2.X - pt1.X);\n\t    var dy = (pt2.Y - pt1.Y);\n\t    if ((dx == 0) && (dy == 0))\n\t      return new ClipperLib.DoublePoint(0, 0);\n\t    var f = 1 / Math.sqrt(dx * dx + dy * dy);\n\t    dx *= f;\n\t    dy *= f;\n\t    return new ClipperLib.DoublePoint(dy, -dx);\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.DoOffset = function (delta)\n\t  {\n\t    this.m_destPolys = new Array();\n\t    this.m_delta = delta;\n\t    //if Zero offset, just copy any CLOSED polygons to m_p and return ...\n\t    if (ClipperLib.ClipperBase.near_zero(delta))\n\t    {\n\t      //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount);\n\t      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t      {\n\t        var node = this.m_polyNodes.Childs()[i];\n\t        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n\t          this.m_destPolys.push(node.m_polygon);\n\t      }\n\t      return;\n\t    }\n\t    //see offset_triginometry3.svg in the documentation folder ...\n\t    if (this.MiterLimit > 2)\n\t      this.m_miterLim = 2 / (this.MiterLimit * this.MiterLimit);\n\t    else\n\t      this.m_miterLim = 0.5;\n\t    var y;\n\t    if (this.ArcTolerance <= 0)\n\t      y = ClipperLib.ClipperOffset.def_arc_tolerance;\n\t    else if (this.ArcTolerance > Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance)\n\t      y = Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance;\n\t    else\n\t      y = this.ArcTolerance;\n\t    //see offset_triginometry2.svg in the documentation folder ...\n\t    var steps = 3.14159265358979 / Math.acos(1 - y / Math.abs(delta));\n\t    this.m_sin = Math.sin(ClipperLib.ClipperOffset.two_pi / steps);\n\t    this.m_cos = Math.cos(ClipperLib.ClipperOffset.two_pi / steps);\n\t    this.m_StepsPerRad = steps / ClipperLib.ClipperOffset.two_pi;\n\t    if (delta < 0)\n\t      this.m_sin = -this.m_sin;\n\t    //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount * 2);\n\t    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n\t    {\n\t      var node = this.m_polyNodes.Childs()[i];\n\t      this.m_srcPoly = node.m_polygon;\n\t      var len = this.m_srcPoly.length;\n\t      if (len == 0 || (delta <= 0 && (len < 3 || node.m_endtype != ClipperLib.EndType.etClosedPolygon)))\n\t        continue;\n\t      this.m_destPoly = new Array();\n\t      if (len == 1)\n\t      {\n\t        if (node.m_jointype == ClipperLib.JoinType.jtRound)\n\t        {\n\t          var X = 1,\n\t            Y = 0;\n\t          for (var j = 1; j <= steps; j++)\n\t          {\n\t            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n\t            var X2 = X;\n\t            X = X * this.m_cos - this.m_sin * Y;\n\t            Y = X2 * this.m_sin + Y * this.m_cos;\n\t          }\n\t        }\n\t        else\n\t        {\n\t          var X = -1,\n\t            Y = -1;\n\t          for (var j = 0; j < 4; ++j)\n\t          {\n\t            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n\t            if (X < 0)\n\t              X = 1;\n\t            else if (Y < 0)\n\t              Y = 1;\n\t            else\n\t              X = -1;\n\t          }\n\t        }\n\t        this.m_destPolys.push(this.m_destPoly);\n\t        continue;\n\t      }\n\t      //build m_normals ...\n\t      this.m_normals.length = 0;\n\t      //this.m_normals.set_Capacity(len);\n\t      for (var j = 0; j < len - 1; j++)\n\t        this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[j], this.m_srcPoly[j + 1]));\n\t      if (node.m_endtype == ClipperLib.EndType.etClosedLine || node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n\t        this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[len - 1], this.m_srcPoly[0]));\n\t      else\n\t        this.m_normals.push(new ClipperLib.DoublePoint(this.m_normals[len - 2]));\n\t      if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n\t      {\n\t        var k = len - 1;\n\t        for (var j = 0; j < len; j++)\n\t          k = this.OffsetPoint(j, k, node.m_jointype);\n\t        this.m_destPolys.push(this.m_destPoly);\n\t      }\n\t      else if (node.m_endtype == ClipperLib.EndType.etClosedLine)\n\t      {\n\t        var k = len - 1;\n\t        for (var j = 0; j < len; j++)\n\t          k = this.OffsetPoint(j, k, node.m_jointype);\n\t        this.m_destPolys.push(this.m_destPoly);\n\t        this.m_destPoly = new Array();\n\t        //re-build m_normals ...\n\t        var n = this.m_normals[len - 1];\n\t        for (var j = len - 1; j > 0; j--)\n\t          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n\t        this.m_normals[0] = new ClipperLib.DoublePoint(-n.X, -n.Y);\n\t        k = 0;\n\t        for (var j = len - 1; j >= 0; j--)\n\t          k = this.OffsetPoint(j, k, node.m_jointype);\n\t        this.m_destPolys.push(this.m_destPoly);\n\t      }\n\t      else\n\t      {\n\t        var k = 0;\n\t        for (var j = 1; j < len - 1; ++j)\n\t          k = this.OffsetPoint(j, k, node.m_jointype);\n\t        var pt1;\n\t        if (node.m_endtype == ClipperLib.EndType.etOpenButt)\n\t        {\n\t          var j = len - 1;\n\t          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * delta));\n\t          this.m_destPoly.push(pt1);\n\t          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X - this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y - this.m_normals[j].Y * delta));\n\t          this.m_destPoly.push(pt1);\n\t        }\n\t        else\n\t        {\n\t          var j = len - 1;\n\t          k = len - 2;\n\t          this.m_sinA = 0;\n\t          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j].X, -this.m_normals[j].Y);\n\t          if (node.m_endtype == ClipperLib.EndType.etOpenSquare)\n\t            this.DoSquare(j, k);\n\t          else\n\t            this.DoRound(j, k);\n\t        }\n\t        //re-build m_normals ...\n\t        for (var j = len - 1; j > 0; j--)\n\t          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n\t        this.m_normals[0] = new ClipperLib.DoublePoint(-this.m_normals[1].X, -this.m_normals[1].Y);\n\t        k = len - 1;\n\t        for (var j = k - 1; j > 0; --j)\n\t          k = this.OffsetPoint(j, k, node.m_jointype);\n\t        if (node.m_endtype == ClipperLib.EndType.etOpenButt)\n\t        {\n\t          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X - this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y - this.m_normals[0].Y * delta));\n\t          this.m_destPoly.push(pt1);\n\t          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + this.m_normals[0].Y * delta));\n\t          this.m_destPoly.push(pt1);\n\t        }\n\t        else\n\t        {\n\t          k = 1;\n\t          this.m_sinA = 0;\n\t          if (node.m_endtype == ClipperLib.EndType.etOpenSquare)\n\t            this.DoSquare(0, 1);\n\t          else\n\t            this.DoRound(0, 1);\n\t        }\n\t        this.m_destPolys.push(this.m_destPoly);\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.Execute = function ()\n\t  {\n\t    var a = arguments,\n\t      ispolytree = a[0] instanceof ClipperLib.PolyTree;\n\t    if (!ispolytree) // function (solution, delta)\n\t    {\n\t      var solution = a[0],\n\t        delta = a[1];\n\t      ClipperLib.Clear(solution);\n\t      this.FixOrientations();\n\t      this.DoOffset(delta);\n\t      //now clean up 'corners' ...\n\t      var clpr = new ClipperLib.Clipper(0);\n\t      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n\t      if (delta > 0)\n\t      {\n\t        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n\t      }\n\t      else\n\t      {\n\t        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n\t        var outer = new ClipperLib.Path();\n\t        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n\t        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n\t        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n\t        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n\t        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n\t        clpr.ReverseSolution = true;\n\t        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n\t        if (solution.length > 0)\n\t          solution.splice(0, 1);\n\t      }\n\t      //console.log(JSON.stringify(solution));\n\t    }\n\t    else // function (polytree, delta)\n\t    {\n\t      var solution = a[0],\n\t        delta = a[1];\n\t      solution.Clear();\n\t      this.FixOrientations();\n\t      this.DoOffset(delta);\n\t      //now clean up 'corners' ...\n\t      var clpr = new ClipperLib.Clipper(0);\n\t      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n\t      if (delta > 0)\n\t      {\n\t        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n\t      }\n\t      else\n\t      {\n\t        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n\t        var outer = new ClipperLib.Path();\n\t        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n\t        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n\t        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n\t        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n\t        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n\t        clpr.ReverseSolution = true;\n\t        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n\t        //remove the outer PolyNode rectangle ...\n\t        if (solution.ChildCount() == 1 && solution.Childs()[0].ChildCount() > 0)\n\t        {\n\t          var outerNode = solution.Childs()[0];\n\t          //solution.Childs.set_Capacity(outerNode.ChildCount);\n\t          solution.Childs()[0] = outerNode.Childs()[0];\n\t          solution.Childs()[0].m_Parent = solution;\n\t          for (var i = 1; i < outerNode.ChildCount(); i++)\n\t            solution.AddChild(outerNode.Childs()[i]);\n\t        }\n\t        else\n\t          solution.Clear();\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.OffsetPoint = function (j, k, jointype)\n\t  {\n\t\t\t//cross product ...\n\t\t\tthis.m_sinA = (this.m_normals[k].X * this.m_normals[j].Y - this.m_normals[j].X * this.m_normals[k].Y);\n\t\n\t\t\tif (Math.abs(this.m_sinA * this.m_delta) < 1.0)\n\t\t\t{\n\t\t\t\t//dot product ...\n\t\t\t\tvar cosA = (this.m_normals[k].X * this.m_normals[j].X + this.m_normals[j].Y * this.m_normals[k].Y);\n\t\t\t\tif (cosA > 0) // angle ==> 0 degrees\n\t\t\t\t{\n\t\t\t\t\tthis.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),\n\t\t\t\t\t\tClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n\t\t\t\t\treturn k;\n\t\t\t\t}\n\t\t\t\t//else angle ==> 180 degrees\n\t\t\t}\n\t    else if (this.m_sinA > 1)\n\t      this.m_sinA = 1.0;\n\t    else if (this.m_sinA < -1)\n\t      this.m_sinA = -1.0;\n\t    if (this.m_sinA * this.m_delta < 0)\n\t    {\n\t      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),\n\t        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n\t      this.m_destPoly.push(new ClipperLib.IntPoint(this.m_srcPoly[j]));\n\t      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n\t        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n\t    }\n\t    else\n\t      switch (jointype)\n\t      {\n\t      case ClipperLib.JoinType.jtMiter:\n\t        {\n\t          var r = 1 + (this.m_normals[j].X * this.m_normals[k].X + this.m_normals[j].Y * this.m_normals[k].Y);\n\t          if (r >= this.m_miterLim)\n\t            this.DoMiter(j, k, r);\n\t          else\n\t            this.DoSquare(j, k);\n\t          break;\n\t        }\n\t      case ClipperLib.JoinType.jtSquare:\n\t        this.DoSquare(j, k);\n\t        break;\n\t      case ClipperLib.JoinType.jtRound:\n\t        this.DoRound(j, k);\n\t        break;\n\t      }\n\t    k = j;\n\t    return k;\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.DoSquare = function (j, k)\n\t  {\n\t    var dx = Math.tan(Math.atan2(this.m_sinA,\n\t      this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y) / 4);\n\t    this.m_destPoly.push(new ClipperLib.IntPoint(\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[k].X - this.m_normals[k].Y * dx)),\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[k].Y + this.m_normals[k].X * dx))));\n\t    this.m_destPoly.push(new ClipperLib.IntPoint(\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[j].X + this.m_normals[j].Y * dx)),\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[j].Y - this.m_normals[j].X * dx))));\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.DoMiter = function (j, k, r)\n\t  {\n\t    var q = this.m_delta / r;\n\t    this.m_destPoly.push(new ClipperLib.IntPoint(\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + (this.m_normals[k].X + this.m_normals[j].X) * q),\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + (this.m_normals[k].Y + this.m_normals[j].Y) * q)));\n\t  };\n\t  ClipperLib.ClipperOffset.prototype.DoRound = function (j, k)\n\t  {\n\t    var a = Math.atan2(this.m_sinA,\n\t      this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y);\n\t\n\t    \tvar steps = Math.max(ClipperLib.Cast_Int32(ClipperLib.ClipperOffset.Round(this.m_StepsPerRad * Math.abs(a))), 1);\n\t\n\t    var X = this.m_normals[k].X,\n\t      Y = this.m_normals[k].Y,\n\t      X2;\n\t    for (var i = 0; i < steps; ++i)\n\t    {\n\t      this.m_destPoly.push(new ClipperLib.IntPoint(\n\t        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + X * this.m_delta),\n\t        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + Y * this.m_delta)));\n\t      X2 = X;\n\t      X = X * this.m_cos - this.m_sin * Y;\n\t      Y = X2 * this.m_sin + Y * this.m_cos;\n\t    }\n\t    this.m_destPoly.push(new ClipperLib.IntPoint(\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n\t      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n\t  };\n\t  ClipperLib.Error = function (message)\n\t  {\n\t    try\n\t    {\n\t      throw new Error(message);\n\t    }\n\t    catch (err)\n\t    {\n\t      alert(err.message);\n\t    }\n\t  };\n\t  // ---------------------------------\n\t  // JS extension by Timo 2013\n\t  ClipperLib.JS = {};\n\t  ClipperLib.JS.AreaOfPolygon = function (poly, scale)\n\t  {\n\t    if (!scale) scale = 1;\n\t    return ClipperLib.Clipper.Area(poly) / (scale * scale);\n\t  };\n\t  ClipperLib.JS.AreaOfPolygons = function (poly, scale)\n\t  {\n\t    if (!scale) scale = 1;\n\t    var area = 0;\n\t    for (var i = 0; i < poly.length; i++)\n\t    {\n\t      area += ClipperLib.Clipper.Area(poly[i]);\n\t    }\n\t    return area / (scale * scale);\n\t  };\n\t  ClipperLib.JS.BoundsOfPath = function (path, scale)\n\t  {\n\t    return ClipperLib.JS.BoundsOfPaths([path], scale);\n\t  };\n\t  ClipperLib.JS.BoundsOfPaths = function (paths, scale)\n\t  {\n\t    if (!scale) scale = 1;\n\t    var bounds = ClipperLib.Clipper.GetBounds(paths);\n\t    bounds.left /= scale;\n\t    bounds.bottom /= scale;\n\t    bounds.right /= scale;\n\t    bounds.top /= scale;\n\t    return bounds;\n\t  };\n\t  // Clean() joins vertices that are too near each other\n\t  // and causes distortion to offsetted polygons without cleaning\n\t  ClipperLib.JS.Clean = function (polygon, delta)\n\t  {\n\t    if (!(polygon instanceof Array)) return [];\n\t    var isPolygons = polygon[0] instanceof Array;\n\t    var polygon = ClipperLib.JS.Clone(polygon);\n\t    if (typeof delta != \"number\" || delta === null)\n\t    {\n\t      ClipperLib.Error(\"Delta is not a number in Clean().\");\n\t      return polygon;\n\t    }\n\t    if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || delta < 0) return polygon;\n\t    if (!isPolygons) polygon = [polygon];\n\t    var k_length = polygon.length;\n\t    var len, poly, result, d, p, j, i;\n\t    var results = [];\n\t    for (var k = 0; k < k_length; k++)\n\t    {\n\t      poly = polygon[k];\n\t      len = poly.length;\n\t      if (len === 0) continue;\n\t      else if (len < 3)\n\t      {\n\t        result = poly;\n\t        results.push(result);\n\t        continue;\n\t      }\n\t      result = poly;\n\t      d = delta * delta;\n\t      //d = Math.floor(c_delta * c_delta);\n\t      p = poly[0];\n\t      j = 1;\n\t      for (i = 1; i < len; i++)\n\t      {\n\t        if ((poly[i].X - p.X) * (poly[i].X - p.X) +\n\t          (poly[i].Y - p.Y) * (poly[i].Y - p.Y) <= d)\n\t          continue;\n\t        result[j] = poly[i];\n\t        p = poly[i];\n\t        j++;\n\t      }\n\t      p = poly[j - 1];\n\t      if ((poly[0].X - p.X) * (poly[0].X - p.X) +\n\t        (poly[0].Y - p.Y) * (poly[0].Y - p.Y) <= d)\n\t        j--;\n\t      if (j < len)\n\t        result.splice(j, len - j);\n\t      if (result.length) results.push(result);\n\t    }\n\t    if (!isPolygons && results.length) results = results[0];\n\t    else if (!isPolygons && results.length === 0) results = [];\n\t    else if (isPolygons && results.length === 0) results = [\n\t      []\n\t    ];\n\t    return results;\n\t  }\n\t  // Make deep copy of Polygons or Polygon\n\t  // so that also IntPoint objects are cloned and not only referenced\n\t  // This should be the fastest way\n\t  ClipperLib.JS.Clone = function (polygon)\n\t  {\n\t    if (!(polygon instanceof Array)) return [];\n\t    if (polygon.length === 0) return [];\n\t    else if (polygon.length == 1 && polygon[0].length === 0) return [[]];\n\t    var isPolygons = polygon[0] instanceof Array;\n\t    if (!isPolygons) polygon = [polygon];\n\t    var len = polygon.length,\n\t      plen, i, j, result;\n\t    var results = new Array(len);\n\t    for (i = 0; i < len; i++)\n\t    {\n\t      plen = polygon[i].length;\n\t      result = new Array(plen);\n\t      for (j = 0; j < plen; j++)\n\t      {\n\t        result[j] = {\n\t          X: polygon[i][j].X,\n\t          Y: polygon[i][j].Y\n\t        };\n\t      }\n\t      results[i] = result;\n\t    }\n\t    if (!isPolygons) results = results[0];\n\t    return results;\n\t  };\n\t  // Removes points that doesn't affect much to the visual appearance.\n\t  // If middle point is at or under certain distance (tolerance) of the line segment between\n\t  // start and end point, the middle point is removed.\n\t  ClipperLib.JS.Lighten = function (polygon, tolerance)\n\t  {\n\t    if (!(polygon instanceof Array)) return [];\n\t    if (typeof tolerance != \"number\" || tolerance === null)\n\t    {\n\t      ClipperLib.Error(\"Tolerance is not a number in Lighten().\")\n\t      return ClipperLib.JS.Clone(polygon);\n\t    }\n\t    if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || tolerance < 0)\n\t    {\n\t      return ClipperLib.JS.Clone(polygon);\n\t    }\n\t    if (!(polygon[0] instanceof Array)) polygon = [polygon];\n\t    var i, j, poly, k, poly2, plen, A, B, P, d, rem, addlast;\n\t    var bxax, byay, l, ax, ay;\n\t    var len = polygon.length;\n\t    var toleranceSq = tolerance * tolerance;\n\t    var results = [];\n\t    for (i = 0; i < len; i++)\n\t    {\n\t      poly = polygon[i];\n\t      plen = poly.length;\n\t      if (plen == 0) continue;\n\t      for (k = 0; k < 1000000; k++) // could be forever loop, but wiser to restrict max repeat count\n\t      {\n\t        poly2 = [];\n\t        plen = poly.length;\n\t        // the first have to added to the end, if first and last are not the same\n\t        // this way we ensure that also the actual last point can be removed if needed\n\t        if (poly[plen - 1].X != poly[0].X || poly[plen - 1].Y != poly[0].Y)\n\t        {\n\t          addlast = 1;\n\t          poly.push(\n\t          {\n\t            X: poly[0].X,\n\t            Y: poly[0].Y\n\t          });\n\t          plen = poly.length;\n\t        }\n\t        else addlast = 0;\n\t        rem = []; // Indexes of removed points\n\t        for (j = 0; j < plen - 2; j++)\n\t        {\n\t          A = poly[j]; // Start point of line segment\n\t          P = poly[j + 1]; // Middle point. This is the one to be removed.\n\t          B = poly[j + 2]; // End point of line segment\n\t          ax = A.X;\n\t          ay = A.Y;\n\t          bxax = B.X - ax;\n\t          byay = B.Y - ay;\n\t          if (bxax !== 0 || byay !== 0) // To avoid Nan, when A==P && P==B. And to avoid peaks (A==B && A!=P), which have lenght, but not area.\n\t          {\n\t            l = ((P.X - ax) * bxax + (P.Y - ay) * byay) / (bxax * bxax + byay * byay);\n\t            if (l > 1)\n\t            {\n\t              ax = B.X;\n\t              ay = B.Y;\n\t            }\n\t            else if (l > 0)\n\t            {\n\t              ax += bxax * l;\n\t              ay += byay * l;\n\t            }\n\t          }\n\t          bxax = P.X - ax;\n\t          byay = P.Y - ay;\n\t          d = bxax * bxax + byay * byay;\n\t          if (d <= toleranceSq)\n\t          {\n\t            rem[j + 1] = 1;\n\t            j++; // when removed, transfer the pointer to the next one\n\t          }\n\t        }\n\t        // add all unremoved points to poly2\n\t        poly2.push(\n\t        {\n\t          X: poly[0].X,\n\t          Y: poly[0].Y\n\t        });\n\t        for (j = 1; j < plen - 1; j++)\n\t          if (!rem[j]) poly2.push(\n\t          {\n\t            X: poly[j].X,\n\t            Y: poly[j].Y\n\t          });\n\t        poly2.push(\n\t        {\n\t          X: poly[plen - 1].X,\n\t          Y: poly[plen - 1].Y\n\t        });\n\t        // if the first point was added to the end, remove it\n\t        if (addlast) poly.pop();\n\t        // break, if there was not anymore removed points\n\t        if (!rem.length) break;\n\t        // else continue looping using poly2, to check if there are points to remove\n\t        else poly = poly2;\n\t      }\n\t      plen = poly2.length;\n\t      // remove duplicate from end, if needed\n\t      if (poly2[plen - 1].X == poly2[0].X && poly2[plen - 1].Y == poly2[0].Y)\n\t      {\n\t        poly2.pop();\n\t      }\n\t      if (poly2.length > 2) // to avoid two-point-polygons\n\t        results.push(poly2);\n\t    }\n\t    if (!(polygon[0] instanceof Array)) results = results[0];\n\t    if (typeof (results) == \"undefined\") results = [\n\t      []\n\t    ];\n\t    return results;\n\t  }\n\t  ClipperLib.JS.PerimeterOfPath = function (path, closed, scale)\n\t  {\n\t    if (typeof (path) == \"undefined\") return 0;\n\t    var sqrt = Math.sqrt;\n\t    var perimeter = 0.0;\n\t    var p1, p2, p1x = 0.0,\n\t      p1y = 0.0,\n\t      p2x = 0.0,\n\t      p2y = 0.0;\n\t    var j = path.length;\n\t    if (j < 2) return 0;\n\t    if (closed)\n\t    {\n\t      path[j] = path[0];\n\t      j++;\n\t    }\n\t    while (--j)\n\t    {\n\t      p1 = path[j];\n\t      p1x = p1.X;\n\t      p1y = p1.Y;\n\t      p2 = path[j - 1];\n\t      p2x = p2.X;\n\t      p2y = p2.Y;\n\t      perimeter += sqrt((p1x - p2x) * (p1x - p2x) + (p1y - p2y) * (p1y - p2y));\n\t    }\n\t    if (closed) path.pop();\n\t    return perimeter / scale;\n\t  };\n\t  ClipperLib.JS.PerimeterOfPaths = function (paths, closed, scale)\n\t  {\n\t    if (!scale) scale = 1;\n\t    var perimeter = 0;\n\t    for (var i = 0; i < paths.length; i++)\n\t    {\n\t      perimeter += ClipperLib.JS.PerimeterOfPath(paths[i], closed, scale);\n\t    }\n\t    return perimeter;\n\t  };\n\t  ClipperLib.JS.ScaleDownPath = function (path, scale)\n\t  {\n\t    var i, p;\n\t    if (!scale) scale = 1;\n\t    i = path.length;\n\t    while (i--)\n\t    {\n\t      p = path[i];\n\t      p.X = p.X / scale;\n\t      p.Y = p.Y / scale;\n\t    }\n\t  };\n\t  ClipperLib.JS.ScaleDownPaths = function (paths, scale)\n\t  {\n\t    var i, j, p;\n\t    if (!scale) scale = 1;\n\t    i = paths.length;\n\t    while (i--)\n\t    {\n\t      j = paths[i].length;\n\t      while (j--)\n\t      {\n\t        p = paths[i][j];\n\t        p.X = p.X / scale;\n\t        p.Y = p.Y / scale;\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.JS.ScaleUpPath = function (path, scale)\n\t  {\n\t    var i, p, round = Math.round;\n\t    if (!scale) scale = 1;\n\t    i = path.length;\n\t    while (i--)\n\t    {\n\t      p = path[i];\n\t      p.X = round(p.X * scale);\n\t      p.Y = round(p.Y * scale);\n\t    }\n\t  };\n\t  ClipperLib.JS.ScaleUpPaths = function (paths, scale)\n\t  {\n\t    var i, j, p, round = Math.round;\n\t    if (!scale) scale = 1;\n\t    i = paths.length;\n\t    while (i--)\n\t    {\n\t      j = paths[i].length;\n\t      while (j--)\n\t      {\n\t        p = paths[i][j];\n\t        p.X = round(p.X * scale);\n\t        p.Y = round(p.Y * scale);\n\t      }\n\t    }\n\t  };\n\t  ClipperLib.ExPolygons = function ()\n\t  {\n\t    return [];\n\t  }\n\t  ClipperLib.ExPolygon = function ()\n\t  {\n\t    this.outer = null;\n\t    this.holes = null;\n\t  };\n\t  ClipperLib.JS.AddOuterPolyNodeToExPolygons = function (polynode, expolygons)\n\t  {\n\t    var ep = new ClipperLib.ExPolygon();\n\t    ep.outer = polynode.Contour();\n\t    var childs = polynode.Childs();\n\t    var ilen = childs.length;\n\t    ep.holes = new Array(ilen);\n\t    var node, n, i, j, childs2, jlen;\n\t    for (i = 0; i < ilen; i++)\n\t    {\n\t      node = childs[i];\n\t      ep.holes[i] = node.Contour();\n\t      //Add outer polygons contained by (nested within) holes ...\n\t      for (j = 0, childs2 = node.Childs(), jlen = childs2.length; j < jlen; j++)\n\t      {\n\t        n = childs2[j];\n\t        ClipperLib.JS.AddOuterPolyNodeToExPolygons(n, expolygons);\n\t      }\n\t    }\n\t    expolygons.push(ep);\n\t  };\n\t  ClipperLib.JS.ExPolygonsToPaths = function (expolygons)\n\t  {\n\t    var a, i, alen, ilen;\n\t    var paths = new ClipperLib.Paths();\n\t    for (a = 0, alen = expolygons.length; a < alen; a++)\n\t    {\n\t      paths.push(expolygons[a].outer);\n\t      for (i = 0, ilen = expolygons[a].holes.length; i < ilen; i++)\n\t      {\n\t        paths.push(expolygons[a].holes[i]);\n\t      }\n\t    }\n\t    return paths;\n\t  }\n\t  ClipperLib.JS.PolyTreeToExPolygons = function (polytree)\n\t  {\n\t    var expolygons = new ClipperLib.ExPolygons();\n\t    var node, i, childs, ilen;\n\t    for (i = 0, childs = polytree.Childs(), ilen = childs.length; i < ilen; i++)\n\t    {\n\t      node = childs[i];\n\t      ClipperLib.JS.AddOuterPolyNodeToExPolygons(node, expolygons);\n\t    }\n\t    return expolygons;\n\t  };\n\t})();\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t!function(t,e){ true?module.exports=e():\"function\"==typeof define&&define.amd?define(\"SVGCurves\",[],e):\"object\"==typeof exports?exports.SVGCurves=e():t.SVGCurves=e()}(this,function(){return function(t){function e(n){if(i[n])return i[n].exports;var r=i[n]={exports:{},id:n,loaded:!1};return t[n].call(r.exports,r,r.exports,e),r.loaded=!0,r.exports}var i={};return e.m=t,e.c=i,e.p=\"\",e(0)}([function(t,e,i){t.exports=i(1)},function(t,e,i){\"use strict\";function n(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function r(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function s(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function o(t,e){return(t%e+e)%e}function h(t,e,i){return Math.min(Math.max(t,e),i)}function a(t,e){return Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2))}function u(t,e){var i=t.x*e.x+t.y*e.y,n=Math.sqrt((Math.pow(t.x,2)+Math.pow(t.y,2))*(Math.pow(e.x,2)+Math.pow(e.y,2)));return(t.x*e.y-t.y*e.x<0?-1:1)*Math.acos(i/n)}Object.defineProperty(e,\"__esModule\",{value:!0}),e.QuadricBezier=e.CubicBezier=e.Arc=void 0;var p=function t(e,i,n){null===e&&(e=Function.prototype);var r=Object.getOwnPropertyDescriptor(e,i);if(void 0===r){var s=Object.getPrototypeOf(e);return null===s?void 0:t(s,i,n)}if(\"value\"in r)return r.value;var o=r.get;if(void 0!==o)return o.call(n)},c=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e}}(),f=i(2),l=2*Math.PI,y=Math.PI/180,v=function(){function t(e){s(this,t),this.path=[],this.linear=!0,this.step=.01,this.resolution=500,this.segmentLength=.1,Object.assign(this,e||{}),this.arcLength=null,this.arcLengthMap=null}return c(t,[{key:\"_clearPath\",value:function(){this.path=[]}},{key:\"getPath\",value:function(){return this.path}},{key:\"getPointAtT\",value:function(t){return new f.Point(0,0)}},{key:\"_addPoint\",value:function(t){this.path.push(t.x,t.y)}},{key:\"_postTrace\",value:function(){}},{key:\"_approximateLength\",value:function(){var t=0,e=[],i=this.getPointAtT(0),n=void 0,r=void 0,s=void 0;for(n=0;n<this.resolution;n++)r=h(n*(1/this.resolution),0,1),s=this.getPointAtT(r),t+=a(i,s),e.push({t:r,arcLength:t}),i=s;s=this.getPointAtT(1),t+=a(i,s),e.push({t:1,arcLength:t}),Object.assign(this,{arcLength:t,arcLengthMap:e})}},{key:\"getPointAtU\",value:function(t){t=h(t,0,1);var e=t*this.arcLength,i=0,n=0,r=0;return this.arcLengthMap.every(function(t){var s=t.t,o=t.arcLength;if(o>=e){var h=o-e,a=e-n,u=a/(h+a)||0;return i=r+(s-r)*u,!1}return n=o,r=s,!0}),this.getPointAtT(i)}},{key:\"trace\",value:function(t){Object.assign(this,t||{});var e=\"getPointAtT\",i=this.step;if(this.linear){this._approximateLength();var n=Math.round(this.arcLength/this.segmentLength);e=\"getPointAtU\",i=1/n}this._clearPath();for(var r=0;r<=1;r+=i)this._addPoint(this[e](r));return this._postTrace(),this.getPath()}}]),t}(),x=function(t){function e(){return s(this,e),n(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return r(e,t),c(e,[{key:\"init\",value:function(t){if(Object.assign(this,t||{}),this.radians=o(this.angle,360)*y,this.p1.x===this.p2.x&&this.p1.y===this.p2.y)return this.path;if(this.rx=Math.abs(this.rx),this.ry=Math.abs(this.ry),0===this.rx||0===this.ry)return this.__addPoint(this.p1),this.__addPoint(this.p2),this.path;var e=(this.p1.x-this.p2.x)/2,i=(this.p1.y-this.p2.y)/2,n={x:Math.cos(this.radians)*e+Math.sin(this.radians)*i,y:-Math.sin(this.radians)*e+Math.cos(this.radians)*i},r=Math.pow(n.x,2)/Math.pow(this.rx,2)+Math.pow(n.y,2)/Math.pow(this.ry,2);r>1&&(this.rx=Math.sqrt(r)*this.rx,this.ry=Math.sqrt(r)*this.ry);var s=Math.pow(this.rx,2)*Math.pow(this.ry,2)-Math.pow(this.rx,2)*Math.pow(n.y,2)-Math.pow(this.ry,2)*Math.pow(n.x,2),h=Math.pow(this.rx,2)*Math.pow(n.y,2)+Math.pow(this.ry,2)*Math.pow(n.x,2),a=s/h;a=a<0?0:a;var p=(this.large!==this.sweep?1:-1)*Math.sqrt(a),c={x:p*(this.rx*n.y/this.ry),y:p*(-(this.ry*n.x)/this.rx)};this.center={x:Math.cos(this.radians)*c.x-Math.sin(this.radians)*c.y+(this.p1.x+this.p2.x)/2,y:Math.sin(this.radians)*c.x+Math.cos(this.radians)*c.y+(this.p1.y+this.p2.y)/2};var f={x:(n.x-c.x)/this.rx,y:(n.y-c.y)/this.ry},v={x:(-n.x-c.x)/this.rx,y:(-n.y-c.y)/this.ry};this.startAngle=u({x:1,y:0},f),this.sweepAngle=u(f,v),!this.sweep&&this.sweepAngle>0?this.sweepAngle-=l:this.sweep&&this.sweepAngle<0&&(this.sweepAngle+=l),this.sweepAngle%=l}},{key:\"trace\",value:function(t){return this.init(t),p(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),\"trace\",this).call(this)}},{key:\"getPointAtT\",value:function(t){var e=this.startAngle+this.sweepAngle*t,i=this.rx*Math.cos(e),n=this.ry*Math.sin(e);return new f.Point(Math.cos(this.radians)*i-Math.sin(this.radians)*n+this.center.x,Math.sin(this.radians)*i+Math.cos(this.radians)*n+this.center.y)}},{key:\"_postTrace\",value:function(){this._addPoint(this.p2)}}]),e}(v),d=function(t){function e(){return s(this,e),n(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return r(e,t),c(e,[{key:\"_B1\",value:function(t){return t*t*t}},{key:\"_B2\",value:function(t){return 3*t*t*(1-t)}},{key:\"_B3\",value:function(t){return 3*t*(1-t)*(1-t)}},{key:\"_B4\",value:function(t){return(1-t)*(1-t)*(1-t)}},{key:\"_C1\",value:function(t,e,i,n,r){return t*this._B1(r)+e*this._B2(r)+i*this._B3(r)+n*this._B4(r)}},{key:\"getPointAtT\",value:function(t){return new f.Point(this._C1(this.p1.x,this.p2.x,this.p3.x,this.p4.x,t),this._C1(this.p1.y,this.p2.y,this.p3.y,this.p4.y,t))}},{key:\"_addPoint\",value:function(t){this.path.unshift(t.x,t.y)}}]),e}(v),g=function(t){function e(){return s(this,e),n(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return r(e,t),c(e,[{key:\"_B1\",value:function(t){return t*t}},{key:\"_B2\",value:function(t){return 2*t*(1-t)}},{key:\"_B3\",value:function(t){return(1-t)*(1-t)}},{key:\"_C1\",value:function(t,e,i,n){return t*this._B1(n)+e*this._B2(n)+i*this._B3(n)}},{key:\"getPointAtT\",value:function(t){return new f.Point(this._C1(this.p1.x,this.p2.x,this.p3.x,t),this._C1(this.p1.y,this.p2.y,this.p3.y,t))}},{key:\"_addPoint\",value:function(t){this.path.unshift(t.x,t.y)}}]),e}(v);e.Arc=x,e.CubicBezier=d,e.QuadricBezier=g},function(t,e,i){!function(e,i){t.exports=i()}(this,function(){return function(t){function e(n){if(i[n])return i[n].exports;var r=i[n]={exports:{},id:n,loaded:!1};return t[n].call(r.exports,r,r.exports,e),r.loaded=!0,r.exports}var i={};return e.m=t,e.c=i,e.p=\"\",e(0)}([function(t,e,i){t.exports=i(1)},function(t,e){\"use strict\";function i(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}Object.defineProperty(e,\"__esModule\",{value:!0});var n=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e}}(),r=function(){function t(e,n){if(i(this,t),this.x=parseFloat(e),this.y=parseFloat(n),isNaN(this.x)||isNaN(this.y))throw console.error(\"new Point(\",e,n,\")\"),new Error(\"Invalid input: x and y params must be float.\")}return n(t,[{key:\"isEqual\",value:function(t){return this.x===t.x&&this.y===t.y}}]),t}(),s=function(){function t(){i(this,t),this.points=[],this.length=0}return n(t,[{key:\"getPoints\",value:function(){return this.points}},{key:\"getFlattenPoints\",value:function(){var t=[];return this.points.forEach(function(e){return t.push(e.x,e.y)}),t}},{key:\"getClipperPoints\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,e=[];return this.points.forEach(function(i){return e.push({X:parseInt(i.x*t),Y:parseInt(i.y*t)})}),e}},{key:\"fromClipperPoints\",value:function(t){var e=this,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return this.points=[],t.forEach(function(t){return e.addPoint(parseFloat(t.X*i),parseFloat(t.Y*i))}),this}},{key:\"getPoint\",value:function(t){return this.points[t<0?this.length+t:t]||null}},{key:\"addPoint\",value:function(t,e){this.points.push(new r(t,e)),this.length=this.points.length}},{key:\"addPoints\",value:function(t){for(var e=0,i=t.length;e<i;e+=2)this.addPoint(t[e],t[e+1])}},{key:\"isClosed\",value:function(){var t=this.getPoint(0);return t&&t.isEqual(this.getPoint(-1))}},{key:\"close\",value:function(){if(!this.isClosed()&&this.length>2){var t=this.getPoint(0);return this.addPoint(t.x,t.y),!0}return!1}},{key:\"transform\",value:function(t){this.points=this.points.map(function(e){return new r(t[0]*e.x+t[2]*e.y+t[4],t[1]*e.x+t[3]*e.y+t[5])})}}]),t}();e.Path=s,e.Point=r,e.default=s}])})}])});\n\t//# sourceMappingURL=lw.svg-curves.js.map\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// lw.svg-parser.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap d38418eff6e0b94b10b7","!function(t,n){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=n():\"function\"==typeof define&&define.amd?define(\"SVGPath\",[],n):\"object\"==typeof exports?exports.SVGPath=n():t.SVGPath=n()}(this,function(){return function(t){function n(i){if(e[i])return e[i].exports;var o=e[i]={exports:{},id:i,loaded:!1};return t[i].call(o.exports,o,o.exports,n),o.loaded=!0,o.exports}var e={};return n.m=t,n.c=e,n.p=\"\",n(0)}([function(t,n,e){t.exports=e(1)},function(t,n){\"use strict\";function e(t,n){if(!(t instanceof n))throw new TypeError(\"Cannot call a class as a function\")}Object.defineProperty(n,\"__esModule\",{value:!0});var i=function(){function t(t,n){for(var e=0;e<n.length;e++){var i=n[e];i.enumerable=i.enumerable||!1,i.configurable=!0,\"value\"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(n,e,i){return e&&t(n.prototype,e),i&&t(n,i),n}}(),o=function(){function t(n,i){if(e(this,t),this.x=parseFloat(n),this.y=parseFloat(i),isNaN(this.x)||isNaN(this.y))throw console.error(\"new Point(\",n,i,\")\"),new Error(\"Invalid input: x and y params must be float.\")}return i(t,[{key:\"isEqual\",value:function(t){return this.x===t.x&&this.y===t.y}}]),t}(),r=function(){function t(){e(this,t),this.points=[],this.length=0}return i(t,[{key:\"getPoints\",value:function(){return this.points}},{key:\"getFlattenPoints\",value:function(){var t=[];return this.points.forEach(function(n){return t.push(n.x,n.y)}),t}},{key:\"getClipperPoints\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,n=[];return this.points.forEach(function(e){return n.push({X:parseInt(e.x*t),Y:parseInt(e.y*t)})}),n}},{key:\"fromClipperPoints\",value:function(t){var n=this,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return this.points=[],t.forEach(function(t){return n.addPoint(parseFloat(t.X*e),parseFloat(t.Y*e))}),this}},{key:\"getPoint\",value:function(t){return this.points[t<0?this.length+t:t]||null}},{key:\"addPoint\",value:function(t,n){this.points.push(new o(t,n)),this.length=this.points.length}},{key:\"addPoints\",value:function(t){for(var n=0,e=t.length;n<e;n+=2)this.addPoint(t[n],t[n+1])}},{key:\"isClosed\",value:function(){var t=this.getPoint(0);return t&&t.isEqual(this.getPoint(-1))}},{key:\"close\",value:function(){if(!this.isClosed()&&this.length>2){var t=this.getPoint(0);return this.addPoint(t.x,t.y),!0}return!1}},{key:\"transform\",value:function(t){this.points=this.points.map(function(n){return new o(t[0]*n.x+t[2]*n.y+t[4],t[1]*n.x+t[3]*n.y+t[5])})}}]),t}();n.Path=r,n.Point=o,n.default=r}])});\n//# sourceMappingURL=lw.svg-path.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/lw.svg-path/dist/lw.svg-path.js\n// module id = 1\n// module chunks = 0","// Imports\r\nimport { Tag } from './tag'\r\nimport { TagParser } from './tagparser'\r\n\r\n// SVG parser class\r\nclass Parser {\r\n    // Class constructor...\r\n    constructor(settings) {\r\n        // Defaults settings\r\n        settings = settings || {}\r\n\r\n        // Init properties\r\n        this.element  = null // XML document Element object\r\n        this.editor   = null // Editor info { name, version, fingerprint }\r\n        this.document = null // Document info { width, height, viewBox }\r\n        this.defs     = null // Defined <defs> (DOM) nodes list by id\r\n        this.tags     = null // Tag objects hierarchy\r\n\r\n        // Trace settings (Arc, Bezier)\r\n        this.traceSettings = Object.assign({\r\n            linear       : true, // Linear trace mode\r\n            step         : 0.01, // Step resolution if linear mode = false\r\n            resolution   : 100,  // Number of segments we use to approximate arc length\r\n            segmentLength: 1,    // Segment length\r\n        }, settings.traceSettings || {})\r\n\r\n        // Supported tags by this lib\r\n        this.supportedTags = [\r\n            'svg', 'g', 'defs', 'use',\r\n            'line', 'polyline', 'polygon',\r\n            'rect', 'circle', 'ellipse', 'path',\r\n            'title', 'desc'\r\n        ]\r\n\r\n        // Tags list to includes/excludes\r\n        this.parseTags = settings.includes || this.supportedTags\r\n        this.skipTags  = settings.excludes || ['#text', '#comment']  // silent (no warning)\r\n\r\n        // User onTag callback ?\r\n        settings.onTag && this.onTag(settings.onTag, settings.onTagContext)\r\n    }\r\n    \r\n    // Load raw XML string, XMLDocument, Element or File object\r\n    load(input) {\r\n        // Load raw XML string\r\n        if (typeof input === 'string') {\r\n            return this.loadFromString(input)\r\n        }\r\n\r\n        // Load File object\r\n        if (input instanceof File) {\r\n            return this.loadFromFile(input)\r\n        }\r\n\r\n        // Load XMLDocument object\r\n        if (input instanceof XMLDocument) {\r\n            return this.loadFromXMLDocument(input)\r\n        }\r\n\r\n        // Load Element object\r\n        if (input instanceof Element) {\r\n            return this.loadFromElement(input)\r\n        }\r\n\r\n        // Return rejected promise with an Error object\r\n        return Promise.reject(new Error('Unsupported input format.'))\r\n    }\r\n\r\n    // Load from Element object\r\n    loadFromElement(input) {\r\n        return new Promise((resolve, reject) => {\r\n            // Bad input type\r\n            if (! (input instanceof Element)) {\r\n                reject(new Error('Input param must be a Element object.'))\r\n            }\r\n\r\n            // Parser error\r\n            if (input.nodeName === 'parsererror') { // FF\r\n                reject(new Error(input.textContent))\r\n            }\r\n\r\n            if (input.nodeName === 'html' && input.getElementsByTagName('parsererror')) { // Chrome\r\n                reject(new Error(input.getElementsByTagName('parsererror')[0].textContent))\r\n            }\r\n\r\n            // Set document element\r\n            this.element = input\r\n\r\n            // Resolve promise\r\n            resolve(input)\r\n        })\r\n    }\r\n\r\n    // Load from XMLDocument object\r\n    loadFromXMLDocument(input) {\r\n        return new Promise((resolve, reject) => {\r\n            // Bad input type\r\n            if (! (input instanceof XMLDocument)) {\r\n                reject(new Error('Input param must be a XMLDocument object.'))\r\n            }\r\n\r\n            // Load from Element...\r\n            this.loadFromElement(input.documentElement).then(resolve).catch(reject)\r\n        })\r\n    }\r\n\r\n    // Load raw XML string\r\n    loadFromString(input) {\r\n        return new Promise((resolve, reject) => {\r\n            // Bad input type\r\n            if (typeof input !== 'string') {\r\n                reject(new Error('Input param must be a string.'))\r\n            }\r\n\r\n            // Parse svg editor\r\n            this._parseEditor(input)\r\n\r\n            // Parse string as DOM object\r\n            let parser = new DOMParser()\r\n            let XMLDoc = parser.parseFromString(input, 'text/xml')\r\n\r\n            // Load from XMLDocument...\r\n            this.loadFromXMLDocument(XMLDoc).then(resolve).catch(reject)\r\n        })\r\n    }\r\n\r\n    // Try to get the svg editor from input string\r\n    _parseEditor(input) {\r\n        // Reset editor\r\n        this.editor = {\r\n            name       : 'unknown',\r\n            version    : null,\r\n            fingerprint: null\r\n        }\r\n\r\n        // Fingerprint matches\r\n        let fingerprint\r\n\r\n        // Inkscape\r\n        fingerprint = input.match(/<!-- Created with Inkscape .*-->/i)\r\n\r\n        if (fingerprint) {\r\n            this.editor.name        = 'inkscape'\r\n            this.editor.fingerprint = fingerprint[0]\r\n\r\n            return this.editor\r\n        }\r\n\r\n        // Illustrator\r\n        fingerprint = input.match(/<!-- Generator: Adobe Illustrator ([0-9\\.]+), .*-->/i)\r\n\r\n        if (fingerprint) {\r\n            this.editor.name        = 'illustrator'\r\n            this.editor.version     = fingerprint[1]\r\n            this.editor.fingerprint = fingerprint[0]\r\n\r\n            return this.editor\r\n        }\r\n\r\n        // Return default\r\n        return this.editor\r\n    }\r\n\r\n    // Load from File object\r\n    loadFromFile(input) {\r\n        return new Promise((resolve, reject) => {\r\n            // Bad input type\r\n            if (! (input instanceof File)) {\r\n                reject(new Error('Input param must be a File object.'))\r\n            }\r\n\r\n            // Create file reader\r\n            let reader = new FileReader()\r\n\r\n            // Register reader events handlers\r\n            reader.onload = event => {\r\n                this.loadFromString(event.target.result).then(resolve).catch(reject)\r\n            }\r\n\r\n            reader.onerror = event => {\r\n                reject(new Error('Error reading file : ' + input.name))\r\n            }\r\n\r\n            // Finally read input file as text\r\n            reader.readAsText(input)\r\n        })\r\n    }\r\n\r\n    // Parse the (loaded) element\r\n    parse(input) {\r\n        // Reset properties\r\n        this.document = null\r\n        this.defs     = {}\r\n        this.tags     = null\r\n\r\n        // Load input if provided\r\n        if (input) {\r\n            return new Promise((resolve, reject) => {\r\n                this.load(input).then(() => {\r\n                    resolve(this.parse())\r\n                }).catch(reject)\r\n            })\r\n        }\r\n\r\n        // Start parsing element\r\n        return new Promise((resolve, reject) => {\r\n            // If no element is loaded\r\n            if (! this.element) {\r\n                reject(new Error('No element is loaded, call the load method before.'))\r\n            }\r\n\r\n            // Parse the main Element (recursive)\r\n            this.tags = this._parseElement(this.element)\r\n\r\n            if (! this.tags) {\r\n                reject(new Error('No supported tags found.'))\r\n            }\r\n\r\n            // Apply matrix (recursive)\r\n            this.tags.applyMatrix()\r\n\r\n            // Resolve the promise\r\n            resolve(this.tags)\r\n        })\r\n    }\r\n\r\n    // On tag callback\r\n    _onTag(tag) {\r\n        //console.info('onTag:', tag)\r\n    }\r\n\r\n    // Register on tag callback\r\n    onTag(callback, context) {\r\n        this._onTag = tag => callback.call(context || this, tag)\r\n    }\r\n\r\n    // Parse the provided Element and return an Tag collection (recursive)\r\n    _parseElement(element, parent) {\r\n        // Create base tag object\r\n        let tag = new Tag(element, parent)\r\n\r\n        // Exluded tag ?\r\n        if (this.skipTags.indexOf(tag.name) !== -1) {\r\n            return null // silent\r\n        }\r\n\r\n        // Supported tag ?\r\n        if (this.parseTags.indexOf(tag.name) === -1) {\r\n            return this._skipTag(tag, 'unsupported')\r\n        }\r\n\r\n        // Parse the tag\r\n        let tagParser = new TagParser(tag, this)\r\n\r\n        if (! tagParser.parse()) {\r\n            return false\r\n        }\r\n\r\n        // Call the on tag callback\r\n        this._onTag(tag)\r\n\r\n        // Parse child nodes\r\n        let childTag\r\n\r\n        element.childNodes.forEach(childNode => {\r\n            // Parse child element\r\n            if (childTag = this._parseElement(childNode, tag)) {\r\n                tag.addChild(childTag)\r\n            }\r\n        })\r\n\r\n        // Empty group\r\n        if (['svg', 'g'].indexOf(tag.name) !== -1 && ! tag.children.length) {\r\n            return this._skipTag(tag, 'empty')\r\n        }\r\n\r\n        // Return tag object\r\n        return tag\r\n    }\r\n\r\n    // Log skip tag warning message\r\n    _skipTag(tag, message) {\r\n        console.warn('Skip tag :', message + ':', tag)\r\n        return false\r\n    }\r\n\r\n    // Log skip tag attribute warning message\r\n    _skipTagAttr(tag, attr, message) {\r\n        console.warn('Skip tag attribute :', message + ':', attr, tag)\r\n        return false\r\n    }\r\n\r\n}\r\n\r\n// Exports\r\nexport { Parser }\r\nexport default Parser\r\n\n\n\n// WEBPACK FOOTER //\n// ./parser.js","import { Path, Point } from 'lw.svg-path'\nimport clipper from 'clipper-lib'\n\nconst DEG_TO_RAD = Math.PI / 180\n\n// SVG tag class\nclass Tag {\n    // Class constructor...\n    constructor(element, parent) {\n        // Init properties\n        this.element  = element\n        this.name     = element.nodeName.toLowerCase()\n        this.parent   = parent || null\n        this.layer    = null\n        this.attrs    = {}\n        this.children = []\n        this.paths    = []\n        this.matrix   = null\n        this.path     = new Path()\n        this.point    = new Point(0, 0)\n        this.shapes   = []\n\n        // Add first path\n        this.paths.push(this.path)\n\n        // Set the matrix\n        this.setMatrix(this.parent && this.parent.matrix)\n\n        // Clone parent attributes\n        if (this.parent && (this.parent.name === 'g' || this.parent.name === 'svg')) {\n            // Inherit layer name\n            this.layer = this.parent.layer\n\n            // Inherit parent attributes\n            let excludes = ['transform', 'width', 'height']\n\n            Object.keys(this.parent.attrs).forEach(key => {\n                if (excludes.indexOf(key) === -1) {\n                    this.setAttr(key, this.parent.attrs[key])\n                }\n            })\n        }\n    }\n\n    setAttr(name, value) {\n        this.attrs[name] = value\n    }\n\n    getAttr(name, defaultValue) {\n        return this.attrs[name] !== undefined ? this.attrs[name]\n            : (defaultValue !== undefined ? defaultValue : null)\n    }\n\n    getLayerName() {\n        if (this.name === 'g') {\n            return this.getAttr('inkscape:label', this.getAttr('id', null))\n        }\n    }\n\n    setLayerName(name) {\n        if (this.name === 'g') {\n            this.layer = name || this.getLayerName()\n        }\n    }\n\n    addChild(childTag) {\n        this.children.push(childTag)\n    }\n\n    clearPath() {\n        this.path = new Path()\n    }\n\n    newPath() {\n        if (this.path.length > 0) {\n            this.clearPath()\n            this.paths.push(this.path)\n        }\n    }\n\n    closePath() {\n        return this.path.close()\n    }\n\n    addPoint(x, y, relative) {\n        // Relative from the last point\n        if (relative) {\n            x += this.point.x\n            y += this.point.y\n        }\n\n        // Add current point\n        this.path.addPoint(x, y)\n\n        // Update current point\n        this.point = this.path.getPoint(-1)\n    }\n\n    addPoints(points, relative) {\n        // For each couple of points\n        for (let i = 0, il = points.length; i < il; i += 2) {\n            this.addPoint(points[i], points[i + 1], relative)\n        }\n    }\n\n    setMatrix(matrix) {\n        this.matrix = matrix || [1, 0, 0, 1, 0, 0]\n    }\n\n    addMatrix(matrix) {\n        this.matrix = [\n            this.matrix[0] * matrix[0] + this.matrix[2] * matrix[1],\n            this.matrix[1] * matrix[0] + this.matrix[3] * matrix[1],\n            this.matrix[0] * matrix[2] + this.matrix[2] * matrix[3],\n            this.matrix[1] * matrix[2] + this.matrix[3] * matrix[3],\n            this.matrix[0] * matrix[4] + this.matrix[2] * matrix[5] + this.matrix[4],\n            this.matrix[1] * matrix[4] + this.matrix[3] * matrix[5] + this.matrix[5]\n        ]\n    }\n\n    translate(x, y) {\n        y = y === undefined ? 0 : y\n        this.addMatrix([1, 0, 0, 1, x, y])\n    }\n\n    rotate(angle, x, y) {\n        angle = angle * DEG_TO_RAD\n\n        if (arguments.length == 2) {\n            this.addMatrix([1, 0, 0, 1, x, y])\n        }\n\n        this.addMatrix([Math.cos(angle), Math.sin(angle), -Math.sin(angle), Math.cos(angle), 0, 0])\n\n        if (arguments.length == 2) {\n            this.addMatrix([1, 0, 0, 1, -x, -y])\n        }\n    }\n\n    scale(x, y) {\n        y = y === undefined ? x : y\n        this.addMatrix([x, 0, 0, y, 0, 0])\n    }\n\n    skewX(angle) {\n        this.addMatrix([1, 0, Math.tan(angle * DEG_TO_RAD), 1, 0, 0])\n    }\n\n    skewY(angle) {\n        this.addMatrix([1, Math.tan(angle * DEG_TO_RAD), 0, 1, 0, 0])\n    }\n\n    applyMatrix(matrix) {\n        matrix && this.addMatrix(matrix)\n\n        this.paths.forEach(path => {\n            path.transform(this.matrix)\n        })\n\n        this.shapes.forEach(shape => {\n            shape.outer.transform(this.matrix)\n            shape.holes.forEach(hole => {\n                hole.transform(this.matrix)\n            })\n        })\n\n        this.setMatrix(null)\n\n        this.children.forEach(tag => {\n            tag.applyMatrix(matrix)\n        })\n    }\n\n    getPaths() {\n        return this.paths\n    }\n\n    getShapes() {\n        // No shapes...\n        if (this.getAttr('fill', 'none') === 'none' || ! this.paths[0].length) {\n            return this.shapes\n        }\n\n        // Get fill rule\n        let fillRule = this.getAttr('fill-rule', 'nonzero')\n            fillRule = fillRule === 'nonzero' ? clipper.PolyFillType.pftNonZero : clipper.PolyFillType.pftEvenOdd\n\n        // Create clipper path\n        let cPolyTree    = new clipper.PolyTree()\n        let cClipper     = new clipper.Clipper()\n        let clipperScale = 10000000\n        let clipperPaths = []\n\n        this.paths.forEach(path => {\n            clipperPaths.push(path.getClipperPoints(clipperScale))\n        })\n\n        cClipper.AddPaths(clipperPaths, clipper.PolyType.ptSubject, true)\n        cClipper.Execute(clipper.ClipType.ctUnion, cPolyTree, fillRule, fillRule)\n\n        let paths     = clipper.Clipper.PolyTreeToPaths(cPolyTree)\n        let polygones = clipper.Clipper.SimplifyPolygons(paths, fillRule)\n\n        // Single path (no hole)\n        if (this.paths.length > 1) {\n            cClipper.Clear()\n            cClipper.StrictlySimple = true\n            cPolyTree = new clipper.PolyTree()\n            cClipper.AddPaths(polygones, clipper.PolyType.ptSubject, true)\n            cClipper.Execute(clipper.ClipType.ctUnion, cPolyTree, fillRule, fillRule)\n        }\n\n        // PolyTree to ExPolygons\n        let toPath     = path => new Path().fromClipperPoints(path, 1 / clipperScale)\n        let exPolygons = clipper.JS.PolyTreeToExPolygons(cPolyTree)\n        this.shapes    = exPolygons.map(exPolygon => {\n            return {\n                outer: toPath(exPolygon.outer),\n                holes: exPolygon.holes.map(toPath)\n            }\n        })\n\n        // Return shapes...\n        return this.shapes\n    }\n}\n\n// Exports\nexport { Tag }\nexport default Tag\n\n\n\n// WEBPACK FOOTER //\n// ./tag.js","import { Arc, CubicBezier, QuadricBezier } from 'lw.svg-curves'\nimport { Point, Path } from 'lw.svg-path'\n\n// SVG tag parser\nclass TagParser {\n    // Class constructor...\n    constructor(tag, parser) {\n        // Init properties\n        this.tag            = tag\n        this.parser         = parser\n        this.currentCommand = null\n        this.lastCommand    = null\n        this.pathData       = null\n        this.traceSettings  = parser.traceSettings\n    }\n\n    parse() {\n        // Get internal parser from node name\n        let handler = this['_' + this.tag.name]\n\n        // Implemented tag handler?\n        if (! handler || typeof handler !== 'function') {\n            return this.parser._skipTag(this.tag, 'not yet implemented')\n        }\n\n        // Parse tag attributes\n        this._parseTagAttrs()\n\n        // Parse tag\n        return handler.call(this)\n    }\n\n    // Parse the tag attributes\n    _parseTagAttrs() {\n        // Get tag attributes\n        let attrs = this.tag.element.attributes\n\n        if (! attrs) {\n            return null\n        }\n\n        // For each attribute\n        let attr, value, style\n\n        Object.keys(attrs).some(key => {\n            // Current attribute\n            attr = attrs[key]\n\n            // Normalize attribute value\n            value = this._normalizeTagAttr(attr)\n\n            if (value === false) {\n                return false // continue\n            }\n\n            // Special case\n            if (attr.nodeName === 'style') {\n                style = value\n            }\n            else {\n                // Set new attribute name/value\n                this.tag.setAttr(attr.nodeName, value)\n            }\n        })\n\n        // If style attribute (override tag attributes)\n        // TODO get/parse global style and override this one...\n        style && style.replace(/;$/, '').split(';').some(attr => {\n            // Current style\n            attr = attr.split(':')\n            attr = { nodeName: attr[0], nodeValue: attr[1] }\n\n            // Normalize attribute value\n            value = this._normalizeTagAttr(attr)\n\n            if (value === false) {\n                return false // continue\n            }\n\n            // Set new attribute name/value\n            this.tag.setAttr(attr.nodeName, value)\n        })\n\n        // Set inherited color\n        let colorsAttrs = ['fill', 'stroke', 'color']\n\n        colorsAttrs.forEach(attrName => {\n            if (this.tag.getAttr(attrName) === 'inherit') {\n                this.tag.setAttr(attrName, this.tag.parent.getAttr(attrName, 'none'))\n            }\n        })\n\n        // Parse viewBox attribute\n        this._parseViewBoxAttr()\n\n        // Parse transform attribute\n        this._parseTransformAttr()\n    }\n\n    // Normalize tag attribute\n    _normalizeTagAttr(attr) {\n        // Normalize whitespaces\n        let value = attr.nodeValue\n            .replace(/(\\r?\\n|\\r)+/gm, ' ') // Remove all new line chars\n            .replace(/\\s+/gm, ' ')         // Reduce multiple whitespaces\n            .trim()                        // Remove trailing whitespaces\n\n        if (! value.length) {\n            return this.parser._skipTagAttr(this.tag, attr, 'empty')\n        }\n\n        // Filters\n        switch (attr.nodeName) {\n            // Normalize size unit -> to px\n            case 'x':\n            case 'y':\n            case 'x1':\n            case 'y1':\n            case 'x2':\n            case 'y2':\n            case 'r':\n            case 'rx':\n            case 'ry':\n            case 'cx':\n            case 'cy':\n            case 'width':\n            case 'height':\n            case 'fontSize':\n            case 'strokeWidth':\n                value = this._normalizeTagAttrUnit(attr)\n            break\n\n            // Normalize points attribute\n            case 'points':\n            case 'viewBox':\n                value = this._normalizeTagAttrPoints(attr)\n            break\n\n            // Range limit to [0 - 1]\n            case 'opacity':\n            case 'fillOpacity':\n            case 'strokeOpacity':\n                value = this._normalizeTagAttrRange(attr, 0, 1)\n            break\n\n            case 'preserveAspectRatio':\n                value = this._normalizeTagAttrPreserveAspectRatio(attr)\n            break\n        }\n\n        // Return normalized value\n        return value\n    }\n\n    // Normalize attribute unit to px\n    _normalizeTagAttrUnit(attr) {\n        let stringValue = attr.nodeValue.toLowerCase()\n        let floatValue  = parseFloat(stringValue)\n\n        if (isNaN(floatValue)) {\n            return this.parser._skipTagAttr(this.tag, attr, 'only numeric value allowed')\n        }\n\n        if (stringValue.indexOf('mm') !== -1) {\n            return floatValue * 3.5433070869\n        }\n\n        if (stringValue.indexOf('cm') !== -1) {\n            return floatValue * 35.433070869\n        }\n\n        if (stringValue.indexOf('in') !== -1) {\n            return floatValue * 90.0\n        }\n\n        if (stringValue.indexOf('pt') !== -1) {\n            return floatValue * 1.25\n        }\n\n        if (stringValue.indexOf('pc') !== -1) {\n            return floatValue * 15.0\n        }\n\n        return floatValue\n    }\n\n    // Normalize points attribute\n    _normalizeTagAttrPoints(attr) {\n        let points = this._parseNumbers(attr.nodeValue)\n\n        if (points === false) {\n            return this.parser._skipTagAttr(this.tag, attr, 'only numeric values are allowed')\n        }\n\n        if (! points.length) {\n            return this.parser._skipTagAttr(this.tag, attr, 'empty points list')\n        }\n\n        if (points.length % 0) {\n            return this.parser._skipTagAttr(this.tag, attr, 'the number of points must be even')\n        }\n\n        return points\n    }\n\n    // Normalize range attribute like \"opacity\"\n    _normalizeTagAttrRange(attr, min, max) {\n        let stringValue = attr.nodeValue.trim()\n        let floatValue  = parseFloat(stringValue)\n\n        if (isNaN(floatValue)) {\n            return this.parser._skipTagAttr(this.tag, attr, 'only numeric values are allowed')\n        }\n\n        if (floatValue < min || floatValue > max) {\n            return this.parser._skipTagAttr(this.tag, attr, 'out of range [' + min + ', ' + max + ']')\n        }\n\n        return floatValue\n    }\n\n    // Parse points string as numbers array\n    _parseNumbers(points) {\n        // http://stackoverflow.com/questions/638565/parsing-scientific-notation-sensibly\n        if (typeof points === 'string') {\n            points = points.split(/([+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)?/g)\n            .filter(point => {\n                return point && ['', ','].indexOf(point.trim()) === -1\n            })\n        }\n\n        // Normalize to float values\n        points = points.map(parseFloat)\n\n        // Test if all numbers is valid\n        if (points.some(isNaN)) {\n            return false\n        }\n\n        return points\n    }\n\n    // Normalize the preserveAspectRatio attribute\n    _normalizeTagAttrPreserveAspectRatio(attr) {\n        let params = {\n            defer: false,\n            align: 'none',\n            meet : true,\n            slice: false\n        }\n\n        let rawParams = attr.nodeValue\n\n        if (rawParams.indexOf('defer') === 0) {\n            rawParams    = rawParams.substr(6)\n            params.defer = true\n        }\n\n        rawParams    = rawParams.split(' ')\n        params.align = rawParams[0]\n        params.meet  = rawParams[1] || 'meet'\n        params.meet  = params.meet === 'meet'\n        params.slice = ! params.meet\n\n        return params\n    }\n\n    // Parse viewBox attribute and set transformations\n    _parseViewBoxAttr() {\n        // Get viewBox attribute\n        let viewBox = this.tag.getAttr('viewBox', null)\n\n        // No viewBox...\n        if (viewBox === null) {\n            return null\n        }\n\n        // Update size attributes\n        let width  = this.tag.getAttr('width', viewBox[2])\n        let height = this.tag.getAttr('height', viewBox[3])\n\n        this.tag.setAttr('width' , width)\n        this.tag.setAttr('height', height)\n\n        // Scale to match viewBox\n        // TODO clip path if preserveAspectRatio.slice\n        let scaleX     = width  / viewBox[2]\n        let scaleY     = height / viewBox[3]\n        let translateX = viewBox[0]\n        let translateY = viewBox[1]\n\n        let preserveAspectRatio = this.tag.getAttr('preserveAspectRatio', 'meet xMidYMid')\n\n        if (preserveAspectRatio) {\n            let newWidth, newHeight\n\n            if (preserveAspectRatio.meet) {\n                if (scaleX > scaleY) {\n                    scaleX   = scaleY\n                    newWidth = viewBox[2] * scaleX\n                }\n                else if (scaleX < scaleY) {\n                    scaleY    = scaleX\n                    newHeight = viewBox[3] * scaleY\n                }\n            }\n            else if (preserveAspectRatio.slice) {\n                if (scaleX < scaleY) {\n                    scaleX   = scaleY\n                    newWidth = viewBox[2] * scaleX\n                }\n                else if (scaleX > scaleY) {\n                    scaleY    = scaleX\n                    newHeight = viewBox[3] * scaleY\n                }\n            }\n\n            if (newWidth !== undefined) {\n                if (preserveAspectRatio.align === 'xMidYMid') {\n                    this.tag.translate((width - newWidth) / 2, 0)\n                }\n                else if (preserveAspectRatio.align === 'xMaxYMax') {\n                    this.tag.translate(width - newWidth, 0)\n                }\n            }\n            else if (newHeight !== undefined) {\n                if (preserveAspectRatio.align === 'xMidYMid') {\n                    this.tag.translate(0, (height - newHeight) / 2)\n                }\n                else if (preserveAspectRatio.align === 'xMaxYMax') {\n                    this.tag.translate(0, height - newHeight)\n                }\n            }\n        }\n\n        this.tag.scale(scaleX, scaleY)\n        this.tag.translate(-translateX, -translateY)\n    }\n\n    // Parse transform attribute and set transformations\n    _parseTransformAttr() {\n        // Get transform attribute\n        let transformAttr = this.tag.getAttr('transform', null)\n\n        // No transformation...\n        if (transformAttr === null || ! transformAttr.length) {\n            return null\n        }\n\n        // Parse attribute (split group on closing parenthesis)\n        let transformations = transformAttr.split(')')\n\n        // Remove last entry due to last \")\" found\n        transformations.pop()\n\n        // For each transformation\n        let transform, type, params\n\n        transformations.some(raw => {\n            // Split name and value on opening parenthesis\n            transform = raw.split('(')\n\n            // Invalid parts number\n            if (transform.length !== 2) {\n                return this.parser._skipTagAttr(this.tag, transformAttr, 'malformed') // continue\n            }\n\n            type = transform[0].trim()\n\n            // Quik hack 1/2\n            let func = type\n            if (func === 'matrix') {\n                func = 'addMatrix'\n            }\n\n            // Get tag transform method\n            let tagTransform = this.tag[func]\n\n            if (typeof tagTransform !== 'function') {\n                return this.parser._skipTagAttr(this.tag, transformAttr, 'unsupported transform type :' + type)\n            }\n\n            params = transform[1].trim()\n            params = this._parseNumbers(params)\n\n            // Skip empty value\n            if (! params.length) {\n                return this.parser._skipTagAttr(this.tag, transformAttr, 'malformed transform type :' + type)\n            }\n\n            // Quik hack 2/2\n            if (func == 'addMatrix') {\n                params = [params]\n            }\n\n            // Call tag transform method like \"tag.translate(param1, ..., paramN)\"\n            tagTransform.apply(this.tag, params)\n        })\n    }\n\n    _newPath() {\n        this.tag.newPath()\n    }\n\n    _clearPath() {\n        this.tag.clearPath()\n    }\n\n    _closePath() {\n        return this.tag.closePath()\n    }\n\n    _addPoints(points, relative) {\n        if (! points.length) {\n            return this.parser._skipTag(this.tag, 'empty points list')\n        }\n\n        if (points.length % 0) {\n            return this.parser._skipTag(this.tag, 'the number of points must be even')\n        }\n\n        relative = arguments.length < 2 && this.currentCommand.relative\n\n        this.tag.addPoints(points, relative)\n        return true\n    }\n\n    // SVG specs at https://www.w3.org/TR/SVG11/\n\n    _svg() {\n        // Only parse the root SVG tag as main document\n        if (this.parser.document) {\n            // Handled tag\n            return true\n        }\n\n        // Get the document size\n        let width  = this.tag.getAttr('width')\n        let height = this.tag.getAttr('height')\n\n        // Invalid size\n        if (! width || width < 0 || ! height || height < 0) {\n            throw new Error('Invalid document size: ' + width + ' / ' + height)\n        }\n\n        // Set document size\n        this.parser.document = {\n            width : width,\n            height: height\n        }\n\n        // Get document viewBox or set default to document size\n        let viewBox = this.tag.getAttr('viewBox', [0, 0, width, height])\n\n        this.parser.document.viewBox = {\n            x     : viewBox[0],\n            y     : viewBox[1],\n            width : viewBox[2],\n            height: viewBox[3]\n        }\n\n        // Check inkscape version\n        if (this.parser.editor.name === 'inkscape') {\n            this.parser.editor.version = this.tag.getAttr('inkscape:version')\n        }\n\n        // Handled tag\n        return true\n    }\n\n    _title() {\n        // Register the first encountered title tag as document title\n        if (this.parser.document && ! this.parser.document.title) {\n            this.parser.document.title = this.tag.element.textContent\n        }\n\n        // Skipped tag\n        return false\n    }\n\n    _desc() {\n        // Register the first encountered desc tag as document description\n        if (this.parser.document && ! this.parser.document.description) {\n            this.parser.document.description = this.tag.element.textContent\n        }\n\n        // Skipped tag\n        return false\n    }\n\n    _defs() {\n        // Register all child element with an id attribute\n        this.tag.element.childNodes.forEach(childNode => {\n            childNode.id && (this.parser.defs[childNode.id] = childNode)\n        })\n\n        // Skipped tag\n        return false\n    }\n\n    _use() {\n        // Get the target id\n        let target  = this.tag.getAttr('xlink:href').replace(/^#/, '')\n\n        // Try to get the defined element\n        let element = this.parser.defs[target]\n\n        if (! element) {\n            return this.parser._skipTag(this.tag, 'undefined reference [' + target + ']')\n        }\n\n        // Parse the defined element and set new parent from <use> tag parent\n        let useTag = this.parser._parseElement(element, this.tag.parent)\n\n        if (! useTag) {\n            return this.parser._skipTag(this.tag, 'empty reference [' + target + ']')\n        }\n\n        // Set matrix from real parent (<use>)\n        useTag.setMatrix(this.tag.matrix)\n\n        // Replace the use tag with new one\n        this.tag.parent.addChild(useTag)\n\n        // Skipped tag\n        return false\n    }\n\n    _g() {\n        // Set the tag layer name\n        this.tag.setLayerName()\n\n        // Handled tag\n        return true\n    }\n\n    _line() {\n        // Handled tag\n        return this._path([\n            'M', this.tag.getAttr('x1'), this.tag.getAttr('y1'),\n            'L', this.tag.getAttr('x2'), this.tag.getAttr('y2')\n        ])\n    }\n\n    _polyline(close=false) {\n        let points = this.tag.getAttr('points')\n        let path   = ['M', points.shift(), points.shift(), 'L']\n\n        path = path.concat(points)\n        close && path.push('Z')\n\n        // Handled tag\n        return this._path(path)\n    }\n\n    _polygon() {\n        // Handled like polyline but closed\n        return this._polyline(true)\n    }\n\n    _rect() {\n        // Get rectangle attributes\n        let w  = this.tag.getAttr('width')\n        let h  = this.tag.getAttr('height')\n        let x  = this.tag.getAttr('x', 0)\n        let y  = this.tag.getAttr('y', 0)\n        let rx = this.tag.getAttr('rx', null)\n        let ry = this.tag.getAttr('ry', null)\n\n        // Simple rect\n        if (!rx && !ry) {\n            // Handled tag\n            return this._path(['M', x, y, 'h', w, 'v', h, 'h', -w, 'z'])\n        }\n\n        // If a properly specified value is provided for rx, but not for ry,\n        // then set both rx and ry to the value of rx and vis-vera...\n        if (rx === null) rx = ry\n        if (ry === null) ry = rx\n\n        // A negative value is an error\n        if (rx === null || rx === null || rx < 0 || ry < 0) {\n            // Skip tag\n            return this.parser._skipTag(this.tag, 'negative value for \"rx/ry\" not allowed')\n        }\n\n        // If rx is greater than half of width, then set rx to half of width.\n        // If ry is greater than half of height, then set ry to half of height.\n        if (rx > w / 2) rx = w / 2\n        if (ry > h / 2) ry = h / 2\n\n        let dx = rx * 2\n        let dy = ry * 2\n\n        // Handled tag\n        return this._path([\n            'M', x + rx, y,\n            'h', w - dx,\n            'c', rx, 0, rx, ry, rx, ry,\n            'v', h - dy,\n            'c', 0, ry, -rx, ry, -rx, ry,\n            'h', -w + dx,\n            'c', -rx, 0, -rx, -ry, -rx, -ry,\n            'v', -h + dy,\n            'c', 0, 0, 0, -ry, rx, -ry,\n            'z'\n        ])\n    }\n\n    _circle() {\n        let r = this.tag.getAttr('r', 0)\n\n        if (r <= 0) {\n            // Skipped tag\n            return false\n        }\n\n        let cx = this.tag.getAttr('cx', 0)\n        let cy = this.tag.getAttr('cy', 0)\n\n        // Handled tag\n        return this._path([\n            'M', cx-r, cy,\n            'A', r, r, 0, 0, 0, cx, cy+r,\n            'A', r, r, 0, 0, 0, cx+r, cy,\n            'A', r, r, 0, 0, 0, cx, cy-r,\n            'A', r, r, 0, 0, 0, cx-r, cy,\n            'Z'\n        ])\n    }\n\n    _ellipse() {\n        let rx = this.tag.getAttr('rx', 0)\n        let ry = this.tag.getAttr('ry', 0)\n\n        if (rx <= 0 || ry <= 0) {\n            // Skipped tag\n            return false\n        }\n\n        let cx = this.tag.getAttr('cx', 0)\n        let cy = this.tag.getAttr('cy', 0)\n\n        // Handled tag\n        return this._path([\n            'M', cx-rx, cy,\n            'A', rx, ry, 0, 0, 0, cx, cy+ry,\n            'A', rx, ry, 0, 0, 0, cx+rx, cy,\n            'A', rx, ry, 0, 0, 0, cx, cy-ry,\n            'A', rx, ry, 0, 0, 0, cx-rx, cy,\n            'Z'\n        ])\n    }\n\n    _paths(type, num, points) {\n        if (points.length > num) {\n            let handler, result = true\n\n            while(result && points.length) {\n                handler = this['_path' + type]\n                result  = handler.call(this, points.splice(0, num))\n            }\n\n            return result\n        }\n\n        return null\n    }\n\n    _path(path) {\n        // Provided path\n        if (path && typeof path !== 'string') {\n            path = path.join(' ')\n        }\n\n        // Get the paths data attribute value\n        let dAttr = path || this.tag.getAttr('d', null)\n\n        if (! dAttr) {\n            // Skipped tag\n            return false\n        }\n\n        // Split on each commands\n        let commands = dAttr.match(/([M|Z|L|H|V|C|S|Q|T|A]+([^M|Z|L|H|V|C|S|Q|T|A]+)?)/gi)\n\n        if (! commands) {\n            return this.parser._skipTag(this.tag, 'malformed \"d\" attribute')\n        }\n\n        // For each command...\n        this.currentCommand = {\n            raw     : null,\n            type    : null,\n            params  : null,\n            relative: null\n        }\n        this.lastCommand = this.currentCommand\n        this.pathData    = {}\n\n        let handler    = null\n        let parseError = false\n\n        commands.some(raw => {\n            // Remove trailing whitespaces\n            raw = raw.trim()\n\n            // Extract command char and params\n            this.currentCommand.raw      = raw\n            this.currentCommand.type     = raw[0].toUpperCase()\n            this.currentCommand.params   = raw.substr(1).trim()\n            this.currentCommand.relative = this.currentCommand.type !== raw[0]\n\n            // Get path handler from command char\n            handler = this['_path' + this.currentCommand.type]\n\n            if (! handler || typeof handler !== 'function') {\n                this.parser._skipTag(this.tag, 'unsupported path command [' + raw[0] + ']')\n                return parseError = true // break\n            }\n\n            // Extract all numbers from arguments string\n            this.currentCommand.params = this._parseNumbers(this.currentCommand.params)\n\n            if (this.currentCommand.params === false) {\n                this.parser._skipTag(this.tag, 'only numeric values are allowed in [' + this.currentCommand.raw + ']')\n                return parseError = true // break\n            }\n\n            // Execute command parser\n            if (! handler.call(this, this.currentCommand.params)) {\n                return parseError = true // break\n            }\n\n            // Update last command\n            this.lastCommand = {}\n\n            Object.keys(this.currentCommand).forEach(key => {\n                this.lastCommand[key] = this.currentCommand[key]\n            })\n        })\n\n        // Skip tag\n        if (parseError) {\n            this._clearPath()\n            return false\n        }\n\n        // Handled tag\n        return true\n    }\n\n    _pathM(points) {\n        // New path\n        this._newPath()\n\n        // Set the current point (start of new path)\n        // If is followed by multiple pairs of coordinates,\n        // the subsequent pairs are treated as implicit lineto commands.\n        return this._addPoints(points)\n    }\n\n    _pathZ() {\n        this._closePath()\n        return true\n    }\n\n    _pathL(points) {\n        return this._addPoints(points)\n    }\n\n    _pathH(points) {\n        return points.every(x => {\n            return this._addPoints([x, this.currentCommand.relative ? 0 : this.tag.point.y])\n        })\n    }\n\n    _pathV(points) {\n        return points.every(y => {\n            return this._addPoints([this.currentCommand.relative ? 0 : this.tag.point.x, y])\n        })\n    }\n\n    _pathC(points) {\n        // Multiple paths\n        let result = this._paths('C', 6, points)\n\n        if (result !== null) {\n            return result\n        }\n\n        // Single path\n        let p1 = this.tag.point\n        let rl = this.currentCommand.relative\n\n        let x1 = points[0] + (rl ? p1.x : 0)\n        let y1 = points[1] + (rl ? p1.y : 0)\n        let x2 = points[2] + (rl ? p1.x : 0)\n        let y2 = points[3] + (rl ? p1.y : 0)\n        let x  = points[4] + (rl ? p1.x : 0)\n        let y  = points[5] + (rl ? p1.y : 0)\n\n        this.pathData.x2 = x2\n        this.pathData.y2 = y2\n\n        let p2 = new Point(x1, y1)\n        let p3 = new Point(x2, y2)\n        let p4 = new Point(x, y)\n\n        //console.log('C', p1, p2, p3, p4)\n\n        // p1  : starting point\n        // p2  : control point\n        // p3  : control point\n        // p4  : end point\n        let tracer = new CubicBezier(this.traceSettings)\n        let coords = tracer.trace({ p1, p2, p3, p4 }) // => [x,y, x,y, ...]\n        // let tracer = trace(CubicBezier, this.traceSettings)\n        // let coords = tracer({ p1, p2, p3, p4 })\n\n        // Trace the line\n        return this._addPoints(coords, false)\n    }\n\n    _pathS(points) {\n        // Multiple paths\n        let result = this._paths('S', 4, points)\n\n        if (result !== null) {\n            return result\n        }\n\n        // Single path\n        let p1 = this.tag.point\n        let rl = this.currentCommand.relative\n\n        let x1 = p1.x\n        let y1 = p1.y\n\n        if (this.lastCommand.type === 'S' || this.lastCommand.type === 'C') {\n            x1 -= this.pathData.x2 - x1\n            y1 -= this.pathData.y2 - y1\n        }\n\n        let x2 = points[0] + (rl ? p1.x : 0)\n        let y2 = points[1] + (rl ? p1.y : 0)\n        let x  = points[2] + (rl ? p1.x : 0)\n        let y  = points[3] + (rl ? p1.y : 0)\n\n        this.pathData.x2 = x2\n        this.pathData.y2 = y2\n\n        let p2 = new Point(x1, y1)\n        let p3 = new Point(x2, y2)\n        let p4 = new Point(x, y)\n\n        //console.log('S', p1, p2, p3, p4)\n\n        // p1  : starting point\n        // p2  : control point\n        // p3  : control point\n        // p4  : end point\n        let tracer = new CubicBezier(this.traceSettings)\n        let coords = tracer.trace({ p1, p2, p3, p4 }) // => [x,y, x,y, ...]\n        // let tracer = trace(CubicBezier, this.traceSettings)\n        // let coords = tracer({ p1, p2, p3, p4 })\n\n        // Trace the line\n        return this._addPoints(coords, false)\n    }\n\n    _pathQ(points) {\n        // Multiple paths\n        let result = this._paths('Q', 4, points)\n\n        if (result !== null) {\n            return result\n        }\n\n        // Single path\n        let p1 = this.tag.point\n        let rl = this.currentCommand.relative\n\n        let x1 = points[0] + (rl ? p1.x : 0)\n        let y1 = points[1] + (rl ? p1.y : 0)\n        let x  = points[2] + (rl ? p1.x : 0)\n        let y  = points[3] + (rl ? p1.y : 0)\n\n        this.pathData.x1 = x1\n        this.pathData.y1 = y1\n\n        let p2 = new Point(x1, y1)\n        let p3 = new Point(x, y)\n\n        //console.log('Q', p1, p2, p3)\n\n        // p1  : starting point\n        // p2  : control point\n        // p3  : end point\n        let tracer = new QuadricBezier(this.traceSettings)\n        let coords = tracer.trace({ p1, p2, p3 }) // => [x,y, x,y, ...]\n\n        // Trace the line\n        return this._addPoints(coords, false)\n    }\n\n    _pathT(points) {\n        // Multiple paths\n        let result = this._paths('T', 2, points)\n\n        if (result !== null) {\n            return result\n        }\n\n        // Single path\n        let p1 = this.tag.point\n        let rl = this.currentCommand.relative\n\n        let x1 = p1.x\n        let y1 = p1.y\n\n        if (this.lastCommand.type === 'Q' || this.lastCommand.type === 'T') {\n            x1 -= this.pathData.x1 - x1\n            y1 -= this.pathData.y1 - y1\n        }\n\n        let x = points[0] + (rl ? p1.x : 0)\n        let y = points[1] + (rl ? p1.y : 0)\n\n        this.pathData.x1 = x1\n        this.pathData.y1 = y1\n\n        let p2 = new Point(x1, y1)\n        let p3 = new Point(x, y)\n\n        //console.log('T', p1, p2, p3)\n\n        // p1  : starting point\n        // p2  : control point\n        // p3  : end point\n        let tracer = new QuadricBezier(this.traceSettings)\n        let coords = tracer.trace({ p1, p2, p3 }) // => [x,y, x,y, ...]\n\n        // Trace the line\n        return this._addPoints(coords, false)\n    }\n\n    _pathA(points) {\n        // Multiple paths\n        let result = this._paths('A', 7, points)\n\n        if (result !== null) {\n            return result\n        }\n\n        // Single path\n        let rl    = this.currentCommand.relative\n        let p1    = this.tag.point\n        let rx    = points[0]\n        let ry    = points[1]\n        let angle = points[2]\n        let large = !!points[3]\n        let sweep = !!points[4]\n        let x     = points[5] + (rl ? p1.x : 0)\n        let y     = points[6] + (rl ? p1.y : 0)\n        let p2    = new Point(x, y)\n\n        //console.log('A', p1, rx, ry, angle, large, sweep, p2)\n\n        let tracer = new Arc(this.traceSettings)\n        let coords = tracer.trace({ p1, rx, ry, angle, large, sweep, p2 }) // => [x,y, x,y, ...]\n\n        // Trace the line\n        return this._addPoints(coords, false)\n    }\n}\n\n// Exports\nexport { TagParser }\nexport default TagParser\n\n\n\n// WEBPACK FOOTER //\n// ./tagparser.js","// rev 482\n/********************************************************************************\n *                                                                              *\n * Author    :  Angus Johnson                                                   *\n * Version   :  6.2.1                                                          *\n * Date      :  31 October 2014                                                 *\n * Website   :  http://www.angusj.com                                           *\n * Copyright :  Angus Johnson 2010-2014                                         *\n *                                                                              *\n * License:                                                                     *\n * Use, modification & distribution is subject to Boost Software License Ver 1. *\n * http://www.boost.org/LICENSE_1_0.txt                                         *\n *                                                                              *\n * Attributions:                                                                *\n * The code in this library is an extension of Bala Vatti's clipping algorithm: *\n * \"A generic solution to polygon clipping\"                                     *\n * Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *\n * http://portal.acm.org/citation.cfm?id=129906                                 *\n *                                                                              *\n * Computer graphics and geometric modeling: implementation and algorithms      *\n * By Max K. Agoston                                                            *\n * Springer; 1 edition (January 4, 2005)                                        *\n * http://books.google.com/books?q=vatti+clipping+agoston                       *\n *                                                                              *\n * See also:                                                                    *\n * \"Polygon Offsetting by Computing Winding Numbers\"                            *\n * Paper no. DETC2005-85513 pp. 565-575                                         *\n * ASME 2005 International Design Engineering Technical Conferences             *\n * and Computers and Information in Engineering Conference (IDETC/CIE2005)      *\n * September 24-28, 2005 , Long Beach, California, USA                          *\n * http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *\n *                                                                              *\n *******************************************************************************/\n/*******************************************************************************\n *                                                                              *\n * Author    :  Timo                                                            *\n * Version   :  6.2.1.0                                                         *\n * Date      :  17 June 2016                                                 *\n *                                                                              *\n * This is a translation of the C# Clipper library to Javascript.               *\n * Int128 struct of C# is implemented using JSBN of Tom Wu.                     *\n * Because Javascript lacks support for 64-bit integers, the space              *\n * is a little more restricted than in C# version.                              *\n *                                                                              *\n * C# version has support for coordinate space:                                 *\n * +-4611686018427387903 ( sqrt(2^127 -1)/2 )                                   *\n * while Javascript version has support for space:                              *\n * +-4503599627370495 ( sqrt(2^106 -1)/2 )                                      *\n *                                                                              *\n * Tom Wu's JSBN proved to be the fastest big integer library:                  *\n * http://jsperf.com/big-integer-library-test                                   *\n *                                                                              *\n * This class can be made simpler when (if ever) 64-bit integer support comes.  *\n *                                                                              *\n *******************************************************************************/\n/*******************************************************************************\n *                                                                              *\n * Basic JavaScript BN library - subset useful for RSA encryption.              *\n * http://www-cs-students.stanford.edu/~tjw/jsbn/                               *\n * Copyright (c) 2005  Tom Wu                                                   *\n * All Rights Reserved.                                                         *\n * See \"LICENSE\" for details:                                                   *\n * http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE                        *\n *                                                                              *\n *******************************************************************************/\n(function ()\n{\n  \"use strict\";\n  //use_int32: When enabled 32bit ints are used instead of 64bit ints. This\n  //improve performance but coordinate values are limited to the range +/- 46340\n  var use_int32 = false;\n  //use_xyz: adds a Z member to IntPoint. Adds a minor cost to performance.\n  var use_xyz = false;\n  //UseLines: Enables open path clipping. Adds a very minor cost to performance.\n  var use_lines = true;\n\n  var ClipperLib = {};\n  var isNode = false;\n  if (typeof module !== 'undefined' && module.exports)\n  {\n    module.exports = ClipperLib;\n    isNode = true;\n  }\n  else\n  {\n    if (typeof define === 'function' && define.amd) {\n      define(ClipperLib);\n    }\n    if (typeof (document) !== \"undefined\") window.ClipperLib = ClipperLib;\n    else self['ClipperLib'] = ClipperLib;\n  }\n  var navigator_appName;\n  if (!isNode)\n  {\n    var nav = navigator.userAgent.toString().toLowerCase();\n    navigator_appName = navigator.appName;\n  }\n  else\n  {\n    var nav = \"chrome\"; // Node.js uses Chrome's V8 engine\n    navigator_appName = \"Netscape\"; // Firefox, Chrome and Safari returns \"Netscape\", so Node.js should also\n  }\n  // Browser test to speedup performance critical functions\n  var browser = {};\n  if (nav.indexOf(\"chrome\") != -1 && nav.indexOf(\"chromium\") == -1) browser.chrome = 1;\n  else browser.chrome = 0;\n  if (nav.indexOf(\"chromium\") != -1) browser.chromium = 1;\n  else browser.chromium = 0;\n  if (nav.indexOf(\"safari\") != -1 && nav.indexOf(\"chrome\") == -1 && nav.indexOf(\"chromium\") == -1) browser.safari = 1;\n  else browser.safari = 0;\n  if (nav.indexOf(\"firefox\") != -1) browser.firefox = 1;\n  else browser.firefox = 0;\n  if (nav.indexOf(\"firefox/17\") != -1) browser.firefox17 = 1;\n  else browser.firefox17 = 0;\n  if (nav.indexOf(\"firefox/15\") != -1) browser.firefox15 = 1;\n  else browser.firefox15 = 0;\n  if (nav.indexOf(\"firefox/3\") != -1) browser.firefox3 = 1;\n  else browser.firefox3 = 0;\n  if (nav.indexOf(\"opera\") != -1) browser.opera = 1;\n  else browser.opera = 0;\n  if (nav.indexOf(\"msie 10\") != -1) browser.msie10 = 1;\n  else browser.msie10 = 0;\n  if (nav.indexOf(\"msie 9\") != -1) browser.msie9 = 1;\n  else browser.msie9 = 0;\n  if (nav.indexOf(\"msie 8\") != -1) browser.msie8 = 1;\n  else browser.msie8 = 0;\n  if (nav.indexOf(\"msie 7\") != -1) browser.msie7 = 1;\n  else browser.msie7 = 0;\n  if (nav.indexOf(\"msie \") != -1) browser.msie = 1;\n  else browser.msie = 0;\n  ClipperLib.biginteger_used = null;\n\n  // Copyright (c) 2005  Tom Wu\n  // All Rights Reserved.\n  // See \"LICENSE\" for details.\n  // Basic JavaScript BN library - subset useful for RSA encryption.\n  // Bits per digit\n  var dbits;\n  // JavaScript engine analysis\n  var canary = 0xdeadbeefcafe;\n  var j_lm = ((canary & 0xffffff) == 0xefcafe);\n  // (public) Constructor\n  function BigInteger(a, b, c)\n  {\n    // This test variable can be removed,\n    // but at least for performance tests it is useful piece of knowledge\n    // This is the only ClipperLib related variable in BigInteger library\n    ClipperLib.biginteger_used = 1;\n    if (a != null)\n      if (\"number\" == typeof a && \"undefined\" == typeof (b)) this.fromInt(a); // faster conversion\n      else if (\"number\" == typeof a) this.fromNumber(a, b, c);\n    else if (b == null && \"string\" != typeof a) this.fromString(a, 256);\n    else this.fromString(a, b);\n  }\n  // return new, unset BigInteger\n  function nbi()\n  {\n    return new BigInteger(null,undefined,undefined);\n  }\n  // am: Compute w_j += (x*this_i), propagate carries,\n  // c is initial carry, returns final carry.\n  // c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n  // We need to select the fastest one that works in this environment.\n  // am1: use a single mult and divide to get the high bits,\n  // max digit bits should be 26 because\n  // max internal value = 2*dvalue^2-2*dvalue (< 2^53)\n  function am1(i, x, w, j, c, n)\n  {\n    while (--n >= 0)\n    {\n      var v = x * this[i++] + w[j] + c;\n      c = Math.floor(v / 0x4000000);\n      w[j++] = v & 0x3ffffff;\n    }\n    return c;\n  }\n  // am2 avoids a big mult-and-extract completely.\n  // Max digit bits should be <= 30 because we do bitwise ops\n  // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\n  function am2(i, x, w, j, c, n)\n  {\n    var xl = x & 0x7fff,\n      xh = x >> 15;\n    while (--n >= 0)\n    {\n      var l = this[i] & 0x7fff;\n      var h = this[i++] >> 15;\n      var m = xh * l + h * xl;\n      l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);\n      c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);\n      w[j++] = l & 0x3fffffff;\n    }\n    return c;\n  }\n  // Alternately, set max digit bits to 28 since some\n  // browsers slow down when dealing with 32-bit numbers.\n  function am3(i, x, w, j, c, n)\n  {\n    var xl = x & 0x3fff,\n      xh = x >> 14;\n    while (--n >= 0)\n    {\n      var l = this[i] & 0x3fff;\n      var h = this[i++] >> 14;\n      var m = xh * l + h * xl;\n      l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;\n      c = (l >> 28) + (m >> 14) + xh * h;\n      w[j++] = l & 0xfffffff;\n    }\n    return c;\n  }\n  if (j_lm && (navigator_appName == \"Microsoft Internet Explorer\"))\n  {\n    BigInteger.prototype.am = am2;\n    dbits = 30;\n  }\n  else if (j_lm && (navigator_appName != \"Netscape\"))\n  {\n    BigInteger.prototype.am = am1;\n    dbits = 26;\n  }\n  else\n  { // Mozilla/Netscape seems to prefer am3\n    BigInteger.prototype.am = am3;\n    dbits = 28;\n  }\n  BigInteger.prototype.DB = dbits;\n  BigInteger.prototype.DM = ((1 << dbits) - 1);\n  BigInteger.prototype.DV = (1 << dbits);\n  var BI_FP = 52;\n  BigInteger.prototype.FV = Math.pow(2, BI_FP);\n  BigInteger.prototype.F1 = BI_FP - dbits;\n  BigInteger.prototype.F2 = 2 * dbits - BI_FP;\n  // Digit conversions\n  var BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n  var BI_RC = new Array();\n  var rr, vv;\n  rr = \"0\".charCodeAt(0);\n  for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\n  rr = \"a\".charCodeAt(0);\n  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n  rr = \"A\".charCodeAt(0);\n  for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\n  function int2char(n)\n  {\n    return BI_RM.charAt(n);\n  }\n\n  function intAt(s, i)\n  {\n    var c = BI_RC[s.charCodeAt(i)];\n    return (c == null) ? -1 : c;\n  }\n  // (protected) copy this to r\n  function bnpCopyTo(r)\n  {\n    for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];\n    r.t = this.t;\n    r.s = this.s;\n  }\n  // (protected) set from integer value x, -DV <= x < DV\n  function bnpFromInt(x)\n  {\n    this.t = 1;\n    this.s = (x < 0) ? -1 : 0;\n    if (x > 0) this[0] = x;\n    else if (x < -1) this[0] = x + this.DV;\n    else this.t = 0;\n  }\n  // return bigint initialized to value\n  function nbv(i)\n  {\n    var r = nbi();\n    r.fromInt(i);\n    return r;\n  }\n  // (protected) set from string and radix\n  function bnpFromString(s, b)\n  {\n    var k;\n    if (b == 16) k = 4;\n    else if (b == 8) k = 3;\n    else if (b == 256) k = 8; // byte array\n    else if (b == 2) k = 1;\n    else if (b == 32) k = 5;\n    else if (b == 4) k = 2;\n    else\n    {\n      this.fromRadix(s, b);\n      return;\n    }\n    this.t = 0;\n    this.s = 0;\n    var i = s.length,\n      mi = false,\n      sh = 0;\n    while (--i >= 0)\n    {\n      var x = (k == 8) ? s[i] & 0xff : intAt(s, i);\n      if (x < 0)\n      {\n        if (s.charAt(i) == \"-\") mi = true;\n        continue;\n      }\n      mi = false;\n      if (sh == 0)\n        this[this.t++] = x;\n      else if (sh + k > this.DB)\n      {\n        this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;\n        this[this.t++] = (x >> (this.DB - sh));\n      }\n      else\n        this[this.t - 1] |= x << sh;\n      sh += k;\n      if (sh >= this.DB) sh -= this.DB;\n    }\n    if (k == 8 && (s[0] & 0x80) != 0)\n    {\n      this.s = -1;\n      if (sh > 0) this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;\n    }\n    this.clamp();\n    if (mi) BigInteger.ZERO.subTo(this, this);\n  }\n  // (protected) clamp off excess high words\n  function bnpClamp()\n  {\n    var c = this.s & this.DM;\n    while (this.t > 0 && this[this.t - 1] == c)--this.t;\n  }\n  // (public) return string representation in given radix\n  function bnToString(b)\n  {\n    if (this.s < 0) return \"-\" + this.negate().toString(b);\n    var k;\n    if (b == 16) k = 4;\n    else if (b == 8) k = 3;\n    else if (b == 2) k = 1;\n    else if (b == 32) k = 5;\n    else if (b == 4) k = 2;\n    else return this.toRadix(b);\n    var km = (1 << k) - 1,\n      d, m = false,\n      r = \"\",\n      i = this.t;\n    var p = this.DB - (i * this.DB) % k;\n    if (i-- > 0)\n    {\n      if (p < this.DB && (d = this[i] >> p) > 0)\n      {\n        m = true;\n        r = int2char(d);\n      }\n      while (i >= 0)\n      {\n        if (p < k)\n        {\n          d = (this[i] & ((1 << p) - 1)) << (k - p);\n          d |= this[--i] >> (p += this.DB - k);\n        }\n        else\n        {\n          d = (this[i] >> (p -= k)) & km;\n          if (p <= 0)\n          {\n            p += this.DB;\n            --i;\n          }\n        }\n        if (d > 0) m = true;\n        if (m) r += int2char(d);\n      }\n    }\n    return m ? r : \"0\";\n  }\n  // (public) -this\n  function bnNegate()\n  {\n    var r = nbi();\n    BigInteger.ZERO.subTo(this, r);\n    return r;\n  }\n  // (public) |this|\n  function bnAbs()\n  {\n    return (this.s < 0) ? this.negate() : this;\n  }\n  // (public) return + if this > a, - if this < a, 0 if equal\n  function bnCompareTo(a)\n  {\n    var r = this.s - a.s;\n    if (r != 0) return r;\n    var i = this.t;\n    r = i - a.t;\n    if (r != 0) return (this.s < 0) ? -r : r;\n    while (--i >= 0)\n      if ((r = this[i] - a[i]) != 0) return r;\n    return 0;\n  }\n  // returns bit length of the integer x\n  function nbits(x)\n  {\n    var r = 1,\n      t;\n    if ((t = x >>> 16) != 0)\n    {\n      x = t;\n      r += 16;\n    }\n    if ((t = x >> 8) != 0)\n    {\n      x = t;\n      r += 8;\n    }\n    if ((t = x >> 4) != 0)\n    {\n      x = t;\n      r += 4;\n    }\n    if ((t = x >> 2) != 0)\n    {\n      x = t;\n      r += 2;\n    }\n    if ((t = x >> 1) != 0)\n    {\n      x = t;\n      r += 1;\n    }\n    return r;\n  }\n  // (public) return the number of bits in \"this\"\n  function bnBitLength()\n  {\n    if (this.t <= 0) return 0;\n    return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM));\n  }\n  // (protected) r = this << n*DB\n  function bnpDLShiftTo(n, r)\n  {\n    var i;\n    for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];\n    for (i = n - 1; i >= 0; --i) r[i] = 0;\n    r.t = this.t + n;\n    r.s = this.s;\n  }\n  // (protected) r = this >> n*DB\n  function bnpDRShiftTo(n, r)\n  {\n    for (var i = n; i < this.t; ++i) r[i - n] = this[i];\n    r.t = Math.max(this.t - n, 0);\n    r.s = this.s;\n  }\n  // (protected) r = this << n\n  function bnpLShiftTo(n, r)\n  {\n    var bs = n % this.DB;\n    var cbs = this.DB - bs;\n    var bm = (1 << cbs) - 1;\n    var ds = Math.floor(n / this.DB),\n      c = (this.s << bs) & this.DM,\n      i;\n    for (i = this.t - 1; i >= 0; --i)\n    {\n      r[i + ds + 1] = (this[i] >> cbs) | c;\n      c = (this[i] & bm) << bs;\n    }\n    for (i = ds - 1; i >= 0; --i) r[i] = 0;\n    r[ds] = c;\n    r.t = this.t + ds + 1;\n    r.s = this.s;\n    r.clamp();\n  }\n  // (protected) r = this >> n\n  function bnpRShiftTo(n, r)\n  {\n    r.s = this.s;\n    var ds = Math.floor(n / this.DB);\n    if (ds >= this.t)\n    {\n      r.t = 0;\n      return;\n    }\n    var bs = n % this.DB;\n    var cbs = this.DB - bs;\n    var bm = (1 << bs) - 1;\n    r[0] = this[ds] >> bs;\n    for (var i = ds + 1; i < this.t; ++i)\n    {\n      r[i - ds - 1] |= (this[i] & bm) << cbs;\n      r[i - ds] = this[i] >> bs;\n    }\n    if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;\n    r.t = this.t - ds;\n    r.clamp();\n  }\n  // (protected) r = this - a\n  function bnpSubTo(a, r)\n  {\n    var i = 0,\n      c = 0,\n      m = Math.min(a.t, this.t);\n    while (i < m)\n    {\n      c += this[i] - a[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n    if (a.t < this.t)\n    {\n      c -= a.s;\n      while (i < this.t)\n      {\n        c += this[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n      c += this.s;\n    }\n    else\n    {\n      c += this.s;\n      while (i < a.t)\n      {\n        c -= a[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n      c -= a.s;\n    }\n    r.s = (c < 0) ? -1 : 0;\n    if (c < -1) r[i++] = this.DV + c;\n    else if (c > 0) r[i++] = c;\n    r.t = i;\n    r.clamp();\n  }\n  // (protected) r = this * a, r != this,a (HAC 14.12)\n  // \"this\" should be the larger one if appropriate.\n  function bnpMultiplyTo(a, r)\n  {\n    var x = this.abs(),\n      y = a.abs();\n    var i = x.t;\n    r.t = i + y.t;\n    while (--i >= 0) r[i] = 0;\n    for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);\n    r.s = 0;\n    r.clamp();\n    if (this.s != a.s) BigInteger.ZERO.subTo(r, r);\n  }\n  // (protected) r = this^2, r != this (HAC 14.16)\n  function bnpSquareTo(r)\n  {\n    var x = this.abs();\n    var i = r.t = 2 * x.t;\n    while (--i >= 0) r[i] = 0;\n    for (i = 0; i < x.t - 1; ++i)\n    {\n      var c = x.am(i, x[i], r, 2 * i, 0, 1);\n      if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV)\n      {\n        r[i + x.t] -= x.DV;\n        r[i + x.t + 1] = 1;\n      }\n    }\n    if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);\n    r.s = 0;\n    r.clamp();\n  }\n  // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n  // r != q, this != m.  q or r may be null.\n  function bnpDivRemTo(m, q, r)\n  {\n    var pm = m.abs();\n    if (pm.t <= 0) return;\n    var pt = this.abs();\n    if (pt.t < pm.t)\n    {\n      if (q != null) q.fromInt(0);\n      if (r != null) this.copyTo(r);\n      return;\n    }\n    if (r == null) r = nbi();\n    var y = nbi(),\n      ts = this.s,\n      ms = m.s;\n    var nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus\n    if (nsh > 0)\n    {\n      pm.lShiftTo(nsh, y);\n      pt.lShiftTo(nsh, r);\n    }\n    else\n    {\n      pm.copyTo(y);\n      pt.copyTo(r);\n    }\n    var ys = y.t;\n    var y0 = y[ys - 1];\n    if (y0 == 0) return;\n    var yt = y0 * (1 << this.F1) + ((ys > 1) ? y[ys - 2] >> this.F2 : 0);\n    var d1 = this.FV / yt,\n      d2 = (1 << this.F1) / yt,\n      e = 1 << this.F2;\n    var i = r.t,\n      j = i - ys,\n      t = (q == null) ? nbi() : q;\n    y.dlShiftTo(j, t);\n    if (r.compareTo(t) >= 0)\n    {\n      r[r.t++] = 1;\n      r.subTo(t, r);\n    }\n    BigInteger.ONE.dlShiftTo(ys, t);\n    t.subTo(y, y); // \"negative\" y so we can replace sub with am later\n    while (y.t < ys) y[y.t++] = 0;\n    while (--j >= 0)\n    {\n      // Estimate quotient digit\n      var qd = (r[--i] == y0) ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);\n      if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd)\n      { // Try it out\n        y.dlShiftTo(j, t);\n        r.subTo(t, r);\n        while (r[i] < --qd) r.subTo(t, r);\n      }\n    }\n    if (q != null)\n    {\n      r.drShiftTo(ys, q);\n      if (ts != ms) BigInteger.ZERO.subTo(q, q);\n    }\n    r.t = ys;\n    r.clamp();\n    if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder\n    if (ts < 0) BigInteger.ZERO.subTo(r, r);\n  }\n  // (public) this mod a\n  function bnMod(a)\n  {\n    var r = nbi();\n    this.abs().divRemTo(a, null, r);\n    if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);\n    return r;\n  }\n  // Modular reduction using \"classic\" algorithm\n  function Classic(m)\n  {\n    this.m = m;\n  }\n\n  function cConvert(x)\n  {\n    if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n    else return x;\n  }\n\n  function cRevert(x)\n  {\n    return x;\n  }\n\n  function cReduce(x)\n  {\n    x.divRemTo(this.m, null, x);\n  }\n\n  function cMulTo(x, y, r)\n  {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n  }\n\n  function cSqrTo(x, r)\n  {\n    x.squareTo(r);\n    this.reduce(r);\n  }\n  Classic.prototype.convert = cConvert;\n  Classic.prototype.revert = cRevert;\n  Classic.prototype.reduce = cReduce;\n  Classic.prototype.mulTo = cMulTo;\n  Classic.prototype.sqrTo = cSqrTo;\n  // (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n  // justification:\n  //         xy == 1 (mod m)\n  //         xy =  1+km\n  //   xy(2-xy) = (1+km)(1-km)\n  // x[y(2-xy)] = 1-k^2m^2\n  // x[y(2-xy)] == 1 (mod m^2)\n  // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n  // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n  // JS multiply \"overflows\" differently from C/C++, so care is needed here.\n  function bnpInvDigit()\n  {\n    if (this.t < 1) return 0;\n    var x = this[0];\n    if ((x & 1) == 0) return 0;\n    var y = x & 3; // y == 1/x mod 2^2\n    y = (y * (2 - (x & 0xf) * y)) & 0xf; // y == 1/x mod 2^4\n    y = (y * (2 - (x & 0xff) * y)) & 0xff; // y == 1/x mod 2^8\n    y = (y * (2 - (((x & 0xffff) * y) & 0xffff))) & 0xffff; // y == 1/x mod 2^16\n    // last step - calculate inverse mod DV directly;\n    // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n    y = (y * (2 - x * y % this.DV)) % this.DV; // y == 1/x mod 2^dbits\n    // we really want the negative inverse, and -DV < y < DV\n    return (y > 0) ? this.DV - y : -y;\n  }\n  // Montgomery reduction\n  function Montgomery(m)\n  {\n    this.m = m;\n    this.mp = m.invDigit();\n    this.mpl = this.mp & 0x7fff;\n    this.mph = this.mp >> 15;\n    this.um = (1 << (m.DB - 15)) - 1;\n    this.mt2 = 2 * m.t;\n  }\n  // xR mod m\n  function montConvert(x)\n  {\n    var r = nbi();\n    x.abs().dlShiftTo(this.m.t, r);\n    r.divRemTo(this.m, null, r);\n    if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);\n    return r;\n  }\n  // x/R mod m\n  function montRevert(x)\n  {\n    var r = nbi();\n    x.copyTo(r);\n    this.reduce(r);\n    return r;\n  }\n  // x = x/R mod m (HAC 14.32)\n  function montReduce(x)\n  {\n    while (x.t <= this.mt2) // pad x so am has enough room later\n      x[x.t++] = 0;\n    for (var i = 0; i < this.m.t; ++i)\n    {\n      // faster way of calculating u0 = x[i]*mp mod DV\n      var j = x[i] & 0x7fff;\n      var u0 = (j * this.mpl + (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) & x.DM;\n      // use am to combine the multiply-shift-add into one call\n      j = i + this.m.t;\n      x[j] += this.m.am(0, u0, x, i, 0, this.m.t);\n      // propagate carry\n      while (x[j] >= x.DV)\n      {\n        x[j] -= x.DV;\n        x[++j]++;\n      }\n    }\n    x.clamp();\n    x.drShiftTo(this.m.t, x);\n    if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n  }\n  // r = \"x^2/R mod m\"; x != r\n  function montSqrTo(x, r)\n  {\n    x.squareTo(r);\n    this.reduce(r);\n  }\n  // r = \"xy/R mod m\"; x,y != r\n  function montMulTo(x, y, r)\n  {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n  }\n  Montgomery.prototype.convert = montConvert;\n  Montgomery.prototype.revert = montRevert;\n  Montgomery.prototype.reduce = montReduce;\n  Montgomery.prototype.mulTo = montMulTo;\n  Montgomery.prototype.sqrTo = montSqrTo;\n  // (protected) true iff this is even\n  function bnpIsEven()\n  {\n    return ((this.t > 0) ? (this[0] & 1) : this.s) == 0;\n  }\n  // (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\n  function bnpExp(e, z)\n  {\n    if (e > 0xffffffff || e < 1) return BigInteger.ONE;\n    var r = nbi(),\n      r2 = nbi(),\n      g = z.convert(this),\n      i = nbits(e) - 1;\n    g.copyTo(r);\n    while (--i >= 0)\n    {\n      z.sqrTo(r, r2);\n      if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);\n      else\n      {\n        var t = r;\n        r = r2;\n        r2 = t;\n      }\n    }\n    return z.revert(r);\n  }\n  // (public) this^e % m, 0 <= e < 2^32\n  function bnModPowInt(e, m)\n  {\n    var z;\n    if (e < 256 || m.isEven()) z = new Classic(m);\n    else z = new Montgomery(m);\n    return this.exp(e, z);\n  }\n  // protected\n  BigInteger.prototype.copyTo = bnpCopyTo;\n  BigInteger.prototype.fromInt = bnpFromInt;\n  BigInteger.prototype.fromString = bnpFromString;\n  BigInteger.prototype.clamp = bnpClamp;\n  BigInteger.prototype.dlShiftTo = bnpDLShiftTo;\n  BigInteger.prototype.drShiftTo = bnpDRShiftTo;\n  BigInteger.prototype.lShiftTo = bnpLShiftTo;\n  BigInteger.prototype.rShiftTo = bnpRShiftTo;\n  BigInteger.prototype.subTo = bnpSubTo;\n  BigInteger.prototype.multiplyTo = bnpMultiplyTo;\n  BigInteger.prototype.squareTo = bnpSquareTo;\n  BigInteger.prototype.divRemTo = bnpDivRemTo;\n  BigInteger.prototype.invDigit = bnpInvDigit;\n  BigInteger.prototype.isEven = bnpIsEven;\n  BigInteger.prototype.exp = bnpExp;\n  // public\n  BigInteger.prototype.toString = bnToString;\n  BigInteger.prototype.negate = bnNegate;\n  BigInteger.prototype.abs = bnAbs;\n  BigInteger.prototype.compareTo = bnCompareTo;\n  BigInteger.prototype.bitLength = bnBitLength;\n  BigInteger.prototype.mod = bnMod;\n  BigInteger.prototype.modPowInt = bnModPowInt;\n  // \"constants\"\n  BigInteger.ZERO = nbv(0);\n  BigInteger.ONE = nbv(1);\n  // Copyright (c) 2005-2009  Tom Wu\n  // All Rights Reserved.\n  // See \"LICENSE\" for details.\n  // Extended JavaScript BN functions, required for RSA private ops.\n  // Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\n  // Version 1.2: square() API, isProbablePrime fix\n  // (public)\n  function bnClone()\n  {\n    var r = nbi();\n    this.copyTo(r);\n    return r;\n  }\n  // (public) return value as integer\n  function bnIntValue()\n  {\n    if (this.s < 0)\n    {\n      if (this.t == 1) return this[0] - this.DV;\n      else if (this.t == 0) return -1;\n    }\n    else if (this.t == 1) return this[0];\n    else if (this.t == 0) return 0;\n    // assumes 16 < DB < 32\n    return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];\n  }\n  // (public) return value as byte\n  function bnByteValue()\n  {\n    return (this.t == 0) ? this.s : (this[0] << 24) >> 24;\n  }\n  // (public) return value as short (assumes DB>=16)\n  function bnShortValue()\n  {\n    return (this.t == 0) ? this.s : (this[0] << 16) >> 16;\n  }\n  // (protected) return x s.t. r^x < DV\n  function bnpChunkSize(r)\n  {\n    return Math.floor(Math.LN2 * this.DB / Math.log(r));\n  }\n  // (public) 0 if this == 0, 1 if this > 0\n  function bnSigNum()\n  {\n    if (this.s < 0) return -1;\n    else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n    else return 1;\n  }\n  // (protected) convert to radix string\n  function bnpToRadix(b)\n  {\n    if (b == null) b = 10;\n    if (this.signum() == 0 || b < 2 || b > 36) return \"0\";\n    var cs = this.chunkSize(b);\n    var a = Math.pow(b, cs);\n    var d = nbv(a),\n      y = nbi(),\n      z = nbi(),\n      r = \"\";\n    this.divRemTo(d, y, z);\n    while (y.signum() > 0)\n    {\n      r = (a + z.intValue()).toString(b).substr(1) + r;\n      y.divRemTo(d, y, z);\n    }\n    return z.intValue().toString(b) + r;\n  }\n  // (protected) convert from radix string\n  function bnpFromRadix(s, b)\n  {\n    this.fromInt(0);\n    if (b == null) b = 10;\n    var cs = this.chunkSize(b);\n    var d = Math.pow(b, cs),\n      mi = false,\n      j = 0,\n      w = 0;\n    for (var i = 0; i < s.length; ++i)\n    {\n      var x = intAt(s, i);\n      if (x < 0)\n      {\n        if (s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\n        continue;\n      }\n      w = b * w + x;\n      if (++j >= cs)\n      {\n        this.dMultiply(d);\n        this.dAddOffset(w, 0);\n        j = 0;\n        w = 0;\n      }\n    }\n    if (j > 0)\n    {\n      this.dMultiply(Math.pow(b, j));\n      this.dAddOffset(w, 0);\n    }\n    if (mi) BigInteger.ZERO.subTo(this, this);\n  }\n  // (protected) alternate constructor\n  function bnpFromNumber(a, b, c)\n  {\n    if (\"number\" == typeof b)\n    {\n      // new BigInteger(int,int,RNG)\n      if (a < 2) this.fromInt(1);\n      else\n      {\n        this.fromNumber(a, c);\n        if (!this.testBit(a - 1)) // force MSB set\n          this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);\n        if (this.isEven()) this.dAddOffset(1, 0); // force odd\n        while (!this.isProbablePrime(b))\n        {\n          this.dAddOffset(2, 0);\n          if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);\n        }\n      }\n    }\n    else\n    {\n      // new BigInteger(int,RNG)\n      var x = new Array(),\n        t = a & 7;\n      x.length = (a >> 3) + 1;\n      b.nextBytes(x);\n      if (t > 0) x[0] &= ((1 << t) - 1);\n      else x[0] = 0;\n      this.fromString(x, 256);\n    }\n  }\n  // (public) convert to bigendian byte array\n  function bnToByteArray()\n  {\n    var i = this.t,\n      r = new Array();\n    r[0] = this.s;\n    var p = this.DB - (i * this.DB) % 8,\n      d, k = 0;\n    if (i-- > 0)\n    {\n      if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)\n        r[k++] = d | (this.s << (this.DB - p));\n      while (i >= 0)\n      {\n        if (p < 8)\n        {\n          d = (this[i] & ((1 << p) - 1)) << (8 - p);\n          d |= this[--i] >> (p += this.DB - 8);\n        }\n        else\n        {\n          d = (this[i] >> (p -= 8)) & 0xff;\n          if (p <= 0)\n          {\n            p += this.DB;\n            --i;\n          }\n        }\n        if ((d & 0x80) != 0) d |= -256;\n        if (k == 0 && (this.s & 0x80) != (d & 0x80))++k;\n        if (k > 0 || d != this.s) r[k++] = d;\n      }\n    }\n    return r;\n  }\n\n  function bnEquals(a)\n  {\n    return (this.compareTo(a) == 0);\n  }\n\n  function bnMin(a)\n  {\n    return (this.compareTo(a) < 0) ? this : a;\n  }\n\n  function bnMax(a)\n  {\n    return (this.compareTo(a) > 0) ? this : a;\n  }\n  // (protected) r = this op a (bitwise)\n  function bnpBitwiseTo(a, op, r)\n  {\n    var i, f, m = Math.min(a.t, this.t);\n    for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);\n    if (a.t < this.t)\n    {\n      f = a.s & this.DM;\n      for (i = m; i < this.t; ++i) r[i] = op(this[i], f);\n      r.t = this.t;\n    }\n    else\n    {\n      f = this.s & this.DM;\n      for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);\n      r.t = a.t;\n    }\n    r.s = op(this.s, a.s);\n    r.clamp();\n  }\n  // (public) this & a\n  function op_and(x, y)\n  {\n    return x & y;\n  }\n\n  function bnAnd(a)\n  {\n    var r = nbi();\n    this.bitwiseTo(a, op_and, r);\n    return r;\n  }\n  // (public) this | a\n  function op_or(x, y)\n  {\n    return x | y;\n  }\n\n  function bnOr(a)\n  {\n    var r = nbi();\n    this.bitwiseTo(a, op_or, r);\n    return r;\n  }\n  // (public) this ^ a\n  function op_xor(x, y)\n  {\n    return x ^ y;\n  }\n\n  function bnXor(a)\n  {\n    var r = nbi();\n    this.bitwiseTo(a, op_xor, r);\n    return r;\n  }\n  // (public) this & ~a\n  function op_andnot(x, y)\n  {\n    return x & ~y;\n  }\n\n  function bnAndNot(a)\n  {\n    var r = nbi();\n    this.bitwiseTo(a, op_andnot, r);\n    return r;\n  }\n  // (public) ~this\n  function bnNot()\n  {\n    var r = nbi();\n    for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];\n    r.t = this.t;\n    r.s = ~this.s;\n    return r;\n  }\n  // (public) this << n\n  function bnShiftLeft(n)\n  {\n    var r = nbi();\n    if (n < 0) this.rShiftTo(-n, r);\n    else this.lShiftTo(n, r);\n    return r;\n  }\n  // (public) this >> n\n  function bnShiftRight(n)\n  {\n    var r = nbi();\n    if (n < 0) this.lShiftTo(-n, r);\n    else this.rShiftTo(n, r);\n    return r;\n  }\n  // return index of lowest 1-bit in x, x < 2^31\n  function lbit(x)\n  {\n    if (x == 0) return -1;\n    var r = 0;\n    if ((x & 0xffff) == 0)\n    {\n      x >>= 16;\n      r += 16;\n    }\n    if ((x & 0xff) == 0)\n    {\n      x >>= 8;\n      r += 8;\n    }\n    if ((x & 0xf) == 0)\n    {\n      x >>= 4;\n      r += 4;\n    }\n    if ((x & 3) == 0)\n    {\n      x >>= 2;\n      r += 2;\n    }\n    if ((x & 1) == 0)++r;\n    return r;\n  }\n  // (public) returns index of lowest 1-bit (or -1 if none)\n  function bnGetLowestSetBit()\n  {\n    for (var i = 0; i < this.t; ++i)\n      if (this[i] != 0) return i * this.DB + lbit(this[i]);\n    if (this.s < 0) return this.t * this.DB;\n    return -1;\n  }\n  // return number of 1 bits in x\n  function cbit(x)\n  {\n    var r = 0;\n    while (x != 0)\n    {\n      x &= x - 1;\n      ++r;\n    }\n    return r;\n  }\n  // (public) return number of set bits\n  function bnBitCount()\n  {\n    var r = 0,\n      x = this.s & this.DM;\n    for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);\n    return r;\n  }\n  // (public) true iff nth bit is set\n  function bnTestBit(n)\n  {\n    var j = Math.floor(n / this.DB);\n    if (j >= this.t) return (this.s != 0);\n    return ((this[j] & (1 << (n % this.DB))) != 0);\n  }\n  // (protected) this op (1<<n)\n  function bnpChangeBit(n, op)\n  {\n    var r = BigInteger.ONE.shiftLeft(n);\n    this.bitwiseTo(r, op, r);\n    return r;\n  }\n  // (public) this | (1<<n)\n  function bnSetBit(n)\n  {\n    return this.changeBit(n, op_or);\n  }\n  // (public) this & ~(1<<n)\n  function bnClearBit(n)\n  {\n    return this.changeBit(n, op_andnot);\n  }\n  // (public) this ^ (1<<n)\n  function bnFlipBit(n)\n  {\n    return this.changeBit(n, op_xor);\n  }\n  // (protected) r = this + a\n  function bnpAddTo(a, r)\n  {\n    var i = 0,\n      c = 0,\n      m = Math.min(a.t, this.t);\n    while (i < m)\n    {\n      c += this[i] + a[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n    if (a.t < this.t)\n    {\n      c += a.s;\n      while (i < this.t)\n      {\n        c += this[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n      c += this.s;\n    }\n    else\n    {\n      c += this.s;\n      while (i < a.t)\n      {\n        c += a[i];\n        r[i++] = c & this.DM;\n        c >>= this.DB;\n      }\n      c += a.s;\n    }\n    r.s = (c < 0) ? -1 : 0;\n    if (c > 0) r[i++] = c;\n    else if (c < -1) r[i++] = this.DV + c;\n    r.t = i;\n    r.clamp();\n  }\n  // (public) this + a\n  function bnAdd(a)\n  {\n    var r = nbi();\n    this.addTo(a, r);\n    return r;\n  }\n  // (public) this - a\n  function bnSubtract(a)\n  {\n    var r = nbi();\n    this.subTo(a, r);\n    return r;\n  }\n  // (public) this * a\n  function bnMultiply(a)\n  {\n    var r = nbi();\n    this.multiplyTo(a, r);\n    return r;\n  }\n  // (public) this^2\n  function bnSquare()\n  {\n    var r = nbi();\n    this.squareTo(r);\n    return r;\n  }\n  // (public) this / a\n  function bnDivide(a)\n  {\n    var r = nbi();\n    this.divRemTo(a, r, null);\n    return r;\n  }\n  // (public) this % a\n  function bnRemainder(a)\n  {\n    var r = nbi();\n    this.divRemTo(a, null, r);\n    return r;\n  }\n  // (public) [this/a,this%a]\n  function bnDivideAndRemainder(a)\n  {\n    var q = nbi(),\n      r = nbi();\n    this.divRemTo(a, q, r);\n    return new Array(q, r);\n  }\n  // (protected) this *= n, this >= 0, 1 < n < DV\n  function bnpDMultiply(n)\n  {\n    this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);\n    ++this.t;\n    this.clamp();\n  }\n  // (protected) this += n << w words, this >= 0\n  function bnpDAddOffset(n, w)\n  {\n    if (n == 0) return;\n    while (this.t <= w) this[this.t++] = 0;\n    this[w] += n;\n    while (this[w] >= this.DV)\n    {\n      this[w] -= this.DV;\n      if (++w >= this.t) this[this.t++] = 0;\n      ++this[w];\n    }\n  }\n  // A \"null\" reducer\n  function NullExp()\n  {}\n\n  function nNop(x)\n  {\n    return x;\n  }\n\n  function nMulTo(x, y, r)\n  {\n    x.multiplyTo(y, r);\n  }\n\n  function nSqrTo(x, r)\n  {\n    x.squareTo(r);\n  }\n  NullExp.prototype.convert = nNop;\n  NullExp.prototype.revert = nNop;\n  NullExp.prototype.mulTo = nMulTo;\n  NullExp.prototype.sqrTo = nSqrTo;\n  // (public) this^e\n  function bnPow(e)\n  {\n    return this.exp(e, new NullExp());\n  }\n  // (protected) r = lower n words of \"this * a\", a.t <= n\n  // \"this\" should be the larger one if appropriate.\n  function bnpMultiplyLowerTo(a, n, r)\n  {\n    var i = Math.min(this.t + a.t, n);\n    r.s = 0; // assumes a,this >= 0\n    r.t = i;\n    while (i > 0) r[--i] = 0;\n    var j;\n    for (j = r.t - this.t; i < j; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);\n    for (j = Math.min(a.t, n); i < j; ++i) this.am(0, a[i], r, i, 0, n - i);\n    r.clamp();\n  }\n  // (protected) r = \"this * a\" without lower n words, n > 0\n  // \"this\" should be the larger one if appropriate.\n  function bnpMultiplyUpperTo(a, n, r)\n  {\n    --n;\n    var i = r.t = this.t + a.t - n;\n    r.s = 0; // assumes a,this >= 0\n    while (--i >= 0) r[i] = 0;\n    for (i = Math.max(n - this.t, 0); i < a.t; ++i)\n      r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);\n    r.clamp();\n    r.drShiftTo(1, r);\n  }\n  // Barrett modular reduction\n  function Barrett(m)\n  {\n    // setup Barrett\n    this.r2 = nbi();\n    this.q3 = nbi();\n    BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);\n    this.mu = this.r2.divide(m);\n    this.m = m;\n  }\n\n  function barrettConvert(x)\n  {\n    if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);\n    else if (x.compareTo(this.m) < 0) return x;\n    else\n    {\n      var r = nbi();\n      x.copyTo(r);\n      this.reduce(r);\n      return r;\n    }\n  }\n\n  function barrettRevert(x)\n  {\n    return x;\n  }\n  // x = x mod m (HAC 14.42)\n  function barrettReduce(x)\n  {\n    x.drShiftTo(this.m.t - 1, this.r2);\n    if (x.t > this.m.t + 1)\n    {\n      x.t = this.m.t + 1;\n      x.clamp();\n    }\n    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);\n    this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);\n    while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);\n    x.subTo(this.r2, x);\n    while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n  }\n  // r = x^2 mod m; x != r\n  function barrettSqrTo(x, r)\n  {\n    x.squareTo(r);\n    this.reduce(r);\n  }\n  // r = x*y mod m; x,y != r\n  function barrettMulTo(x, y, r)\n  {\n    x.multiplyTo(y, r);\n    this.reduce(r);\n  }\n  Barrett.prototype.convert = barrettConvert;\n  Barrett.prototype.revert = barrettRevert;\n  Barrett.prototype.reduce = barrettReduce;\n  Barrett.prototype.mulTo = barrettMulTo;\n  Barrett.prototype.sqrTo = barrettSqrTo;\n  // (public) this^e % m (HAC 14.85)\n  function bnModPow(e, m)\n  {\n    var i = e.bitLength(),\n      k, r = nbv(1),\n      z;\n    if (i <= 0) return r;\n    else if (i < 18) k = 1;\n    else if (i < 48) k = 3;\n    else if (i < 144) k = 4;\n    else if (i < 768) k = 5;\n    else k = 6;\n    if (i < 8)\n      z = new Classic(m);\n    else if (m.isEven())\n      z = new Barrett(m);\n    else\n      z = new Montgomery(m);\n    // precomputation\n    var g = new Array(),\n      n = 3,\n      k1 = k - 1,\n      km = (1 << k) - 1;\n    g[1] = z.convert(this);\n    if (k > 1)\n    {\n      var g2 = nbi();\n      z.sqrTo(g[1], g2);\n      while (n <= km)\n      {\n        g[n] = nbi();\n        z.mulTo(g2, g[n - 2], g[n]);\n        n += 2;\n      }\n    }\n    var j = e.t - 1,\n      w, is1 = true,\n      r2 = nbi(),\n      t;\n    i = nbits(e[j]) - 1;\n    while (j >= 0)\n    {\n      if (i >= k1) w = (e[j] >> (i - k1)) & km;\n      else\n      {\n        w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);\n        if (j > 0) w |= e[j - 1] >> (this.DB + i - k1);\n      }\n      n = k;\n      while ((w & 1) == 0)\n      {\n        w >>= 1;\n        --n;\n      }\n      if ((i -= n) < 0)\n      {\n        i += this.DB;\n        --j;\n      }\n      if (is1)\n      { // ret == 1, don't bother squaring or multiplying it\n        g[w].copyTo(r);\n        is1 = false;\n      }\n      else\n      {\n        while (n > 1)\n        {\n          z.sqrTo(r, r2);\n          z.sqrTo(r2, r);\n          n -= 2;\n        }\n        if (n > 0) z.sqrTo(r, r2);\n        else\n        {\n          t = r;\n          r = r2;\n          r2 = t;\n        }\n        z.mulTo(r2, g[w], r);\n      }\n      while (j >= 0 && (e[j] & (1 << i)) == 0)\n      {\n        z.sqrTo(r, r2);\n        t = r;\n        r = r2;\n        r2 = t;\n        if (--i < 0)\n        {\n          i = this.DB - 1;\n          --j;\n        }\n      }\n    }\n    return z.revert(r);\n  }\n  // (public) gcd(this,a) (HAC 14.54)\n  function bnGCD(a)\n  {\n    var x = (this.s < 0) ? this.negate() : this.clone();\n    var y = (a.s < 0) ? a.negate() : a.clone();\n    if (x.compareTo(y) < 0)\n    {\n      var t = x;\n      x = y;\n      y = t;\n    }\n    var i = x.getLowestSetBit(),\n      g = y.getLowestSetBit();\n    if (g < 0) return x;\n    if (i < g) g = i;\n    if (g > 0)\n    {\n      x.rShiftTo(g, x);\n      y.rShiftTo(g, y);\n    }\n    while (x.signum() > 0)\n    {\n      if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);\n      if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);\n      if (x.compareTo(y) >= 0)\n      {\n        x.subTo(y, x);\n        x.rShiftTo(1, x);\n      }\n      else\n      {\n        y.subTo(x, y);\n        y.rShiftTo(1, y);\n      }\n    }\n    if (g > 0) y.lShiftTo(g, y);\n    return y;\n  }\n  // (protected) this % n, n < 2^26\n  function bnpModInt(n)\n  {\n    if (n <= 0) return 0;\n    var d = this.DV % n,\n      r = (this.s < 0) ? n - 1 : 0;\n    if (this.t > 0)\n      if (d == 0) r = this[0] % n;\n      else\n        for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;\n    return r;\n  }\n  // (public) 1/this % m (HAC 14.61)\n  function bnModInverse(m)\n  {\n    var ac = m.isEven();\n    if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n    var u = m.clone(),\n      v = this.clone();\n    var a = nbv(1),\n      b = nbv(0),\n      c = nbv(0),\n      d = nbv(1);\n    while (u.signum() != 0)\n    {\n      while (u.isEven())\n      {\n        u.rShiftTo(1, u);\n        if (ac)\n        {\n          if (!a.isEven() || !b.isEven())\n          {\n            a.addTo(this, a);\n            b.subTo(m, b);\n          }\n          a.rShiftTo(1, a);\n        }\n        else if (!b.isEven()) b.subTo(m, b);\n        b.rShiftTo(1, b);\n      }\n      while (v.isEven())\n      {\n        v.rShiftTo(1, v);\n        if (ac)\n        {\n          if (!c.isEven() || !d.isEven())\n          {\n            c.addTo(this, c);\n            d.subTo(m, d);\n          }\n          c.rShiftTo(1, c);\n        }\n        else if (!d.isEven()) d.subTo(m, d);\n        d.rShiftTo(1, d);\n      }\n      if (u.compareTo(v) >= 0)\n      {\n        u.subTo(v, u);\n        if (ac) a.subTo(c, a);\n        b.subTo(d, b);\n      }\n      else\n      {\n        v.subTo(u, v);\n        if (ac) c.subTo(a, c);\n        d.subTo(b, d);\n      }\n    }\n    if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n    if (d.compareTo(m) >= 0) return d.subtract(m);\n    if (d.signum() < 0) d.addTo(m, d);\n    else return d;\n    if (d.signum() < 0) return d.add(m);\n    else return d;\n  }\n  var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\n  var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];\n  // (public) test primality with certainty >= 1-.5^t\n  function bnIsProbablePrime(t)\n  {\n    var i, x = this.abs();\n    if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1])\n    {\n      for (i = 0; i < lowprimes.length; ++i)\n        if (x[0] == lowprimes[i]) return true;\n      return false;\n    }\n    if (x.isEven()) return false;\n    i = 1;\n    while (i < lowprimes.length)\n    {\n      var m = lowprimes[i],\n        j = i + 1;\n      while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n      m = x.modInt(m);\n      while (i < j)\n        if (m % lowprimes[i++] == 0) return false;\n    }\n    return x.millerRabin(t);\n  }\n  // (protected) true if probably prime (HAC 4.24, Miller-Rabin)\n  function bnpMillerRabin(t)\n  {\n    var n1 = this.subtract(BigInteger.ONE);\n    var k = n1.getLowestSetBit();\n    if (k <= 0) return false;\n    var r = n1.shiftRight(k);\n    t = (t + 1) >> 1;\n    if (t > lowprimes.length) t = lowprimes.length;\n    var a = nbi();\n    for (var i = 0; i < t; ++i)\n    {\n      //Pick bases at random, instead of starting at 2\n      a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);\n      var y = a.modPow(r, this);\n      if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0)\n      {\n        var j = 1;\n        while (j++ < k && y.compareTo(n1) != 0)\n        {\n          y = y.modPowInt(2, this);\n          if (y.compareTo(BigInteger.ONE) == 0) return false;\n        }\n        if (y.compareTo(n1) != 0) return false;\n      }\n    }\n    return true;\n  }\n  // protected\n  BigInteger.prototype.chunkSize = bnpChunkSize;\n  BigInteger.prototype.toRadix = bnpToRadix;\n  BigInteger.prototype.fromRadix = bnpFromRadix;\n  BigInteger.prototype.fromNumber = bnpFromNumber;\n  BigInteger.prototype.bitwiseTo = bnpBitwiseTo;\n  BigInteger.prototype.changeBit = bnpChangeBit;\n  BigInteger.prototype.addTo = bnpAddTo;\n  BigInteger.prototype.dMultiply = bnpDMultiply;\n  BigInteger.prototype.dAddOffset = bnpDAddOffset;\n  BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\n  BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\n  BigInteger.prototype.modInt = bnpModInt;\n  BigInteger.prototype.millerRabin = bnpMillerRabin;\n  // public\n  BigInteger.prototype.clone = bnClone;\n  BigInteger.prototype.intValue = bnIntValue;\n  BigInteger.prototype.byteValue = bnByteValue;\n  BigInteger.prototype.shortValue = bnShortValue;\n  BigInteger.prototype.signum = bnSigNum;\n  BigInteger.prototype.toByteArray = bnToByteArray;\n  BigInteger.prototype.equals = bnEquals;\n  BigInteger.prototype.min = bnMin;\n  BigInteger.prototype.max = bnMax;\n  BigInteger.prototype.and = bnAnd;\n  BigInteger.prototype.or = bnOr;\n  BigInteger.prototype.xor = bnXor;\n  BigInteger.prototype.andNot = bnAndNot;\n  BigInteger.prototype.not = bnNot;\n  BigInteger.prototype.shiftLeft = bnShiftLeft;\n  BigInteger.prototype.shiftRight = bnShiftRight;\n  BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\n  BigInteger.prototype.bitCount = bnBitCount;\n  BigInteger.prototype.testBit = bnTestBit;\n  BigInteger.prototype.setBit = bnSetBit;\n  BigInteger.prototype.clearBit = bnClearBit;\n  BigInteger.prototype.flipBit = bnFlipBit;\n  BigInteger.prototype.add = bnAdd;\n  BigInteger.prototype.subtract = bnSubtract;\n  BigInteger.prototype.multiply = bnMultiply;\n  BigInteger.prototype.divide = bnDivide;\n  BigInteger.prototype.remainder = bnRemainder;\n  BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\n  BigInteger.prototype.modPow = bnModPow;\n  BigInteger.prototype.modInverse = bnModInverse;\n  BigInteger.prototype.pow = bnPow;\n  BigInteger.prototype.gcd = bnGCD;\n  BigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n  // JSBN-specific extension\n  BigInteger.prototype.square = bnSquare;\n  var Int128 = BigInteger;\n  // BigInteger interfaces not implemented in jsbn:\n  // BigInteger(int signum, byte[] magnitude)\n  // double doubleValue()\n  // float floatValue()\n  // int hashCode()\n  // long longValue()\n  // static BigInteger valueOf(long val)\n  // Helper functions to make BigInteger functions callable with two parameters\n  // as in original C# Clipper\n  Int128.prototype.IsNegative = function ()\n  {\n    if (this.compareTo(Int128.ZERO) == -1) return true;\n    else return false;\n  };\n  Int128.op_Equality = function (val1, val2)\n  {\n    if (val1.compareTo(val2) == 0) return true;\n    else return false;\n  };\n  Int128.op_Inequality = function (val1, val2)\n  {\n    if (val1.compareTo(val2) != 0) return true;\n    else return false;\n  };\n  Int128.op_GreaterThan = function (val1, val2)\n  {\n    if (val1.compareTo(val2) > 0) return true;\n    else return false;\n  };\n  Int128.op_LessThan = function (val1, val2)\n  {\n    if (val1.compareTo(val2) < 0) return true;\n    else return false;\n  };\n  Int128.op_Addition = function (lhs, rhs)\n  {\n    return new Int128(lhs).add(new Int128(rhs));\n  };\n  Int128.op_Subtraction = function (lhs, rhs)\n  {\n    return new Int128(lhs).subtract(new Int128(rhs));\n  };\n  Int128.Int128Mul = function (lhs, rhs)\n  {\n    return new Int128(lhs).multiply(new Int128(rhs));\n  };\n  Int128.op_Division = function (lhs, rhs)\n  {\n    return lhs.divide(rhs);\n  };\n  Int128.prototype.ToDouble = function ()\n  {\n    return parseFloat(this.toString()); // This could be something faster\n  };\n  // end of Int128 section\n  /*\n  // Uncomment the following two lines if you want to use Int128 outside ClipperLib\n  if (typeof(document) !== \"undefined\") window.Int128 = Int128;\n  else self.Int128 = Int128;\n  */\n\n\n  // ---------------------------------------------\n  // Here starts the actual Clipper library:\n  // Helper function to support Inheritance in Javascript\n\tvar Inherit = function (ce, ce2)\n\t{\n\t\tvar p;\n\t\tif (typeof (Object.getOwnPropertyNames) == 'undefined')\n\t\t{\n\t\t\tfor (p in ce2.prototype)\n\t\t\t\tif (typeof (ce.prototype[p]) == 'undefined' || ce.prototype[p] == Object.prototype[p]) ce.prototype[p] = ce2.prototype[p];\n\t\t\tfor (p in ce2)\n\t\t\t\tif (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];\n\t\t\tce.$baseCtor = ce2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar props = Object.getOwnPropertyNames(ce2.prototype);\n\t\t\tfor (var i = 0; i < props.length; i++)\n\t\t\t\tif (typeof (Object.getOwnPropertyDescriptor(ce.prototype, props[i])) == 'undefined') Object.defineProperty(ce.prototype, props[i], Object.getOwnPropertyDescriptor(ce2.prototype, props[i]));\n\t\t\tfor (p in ce2)\n\t\t\t\tif (typeof (ce[p]) == 'undefined') ce[p] = ce2[p];\n\t\t\tce.$baseCtor = ce2;\n\t\t}\n\t};\n  ClipperLib.Path = function ()\n  {\n    return [];\n  };\n  ClipperLib.Paths = function ()\n  {\n    return []; // Was previously [[]], but caused problems when pushed\n  };\n  // Preserves the calling way of original C# Clipper\n  // Is essential due to compatibility, because DoublePoint is public class in original C# version\n  ClipperLib.DoublePoint = function ()\n  {\n    var a = arguments;\n    this.X = 0;\n    this.Y = 0;\n    // public DoublePoint(DoublePoint dp)\n    // public DoublePoint(IntPoint ip)\n    if (a.length == 1)\n    {\n      this.X = a[0].X;\n      this.Y = a[0].Y;\n    }\n    else if (a.length == 2)\n    {\n      this.X = a[0];\n      this.Y = a[1];\n    }\n  }; // This is internal faster function when called without arguments\n  ClipperLib.DoublePoint0 = function ()\n  {\n    this.X = 0;\n    this.Y = 0;\n  };\n  // This is internal faster function when called with 1 argument (dp or ip)\n  ClipperLib.DoublePoint1 = function (dp)\n  {\n    this.X = dp.X;\n    this.Y = dp.Y;\n  };\n  // This is internal faster function when called with 2 arguments (x and y)\n  ClipperLib.DoublePoint2 = function (x, y)\n  {\n    this.X = x;\n    this.Y = y;\n  };\n  // PolyTree & PolyNode start\n  // -------------------------------\n  ClipperLib.PolyNode = function ()\n  {\n    this.m_Parent = null;\n    this.m_polygon = new ClipperLib.Path();\n    this.m_Index = 0;\n    this.m_jointype = 0;\n    this.m_endtype = 0;\n    this.m_Childs = [];\n    this.IsOpen = false;\n  };\n  ClipperLib.PolyNode.prototype.IsHoleNode = function ()\n  {\n    var result = true;\n    var node = this.m_Parent;\n    while (node !== null)\n    {\n      result = !result;\n      node = node.m_Parent;\n    }\n    return result;\n  };\n  ClipperLib.PolyNode.prototype.ChildCount = function ()\n  {\n    return this.m_Childs.length;\n  };\n  ClipperLib.PolyNode.prototype.Contour = function ()\n  {\n    return this.m_polygon;\n  };\n  ClipperLib.PolyNode.prototype.AddChild = function (Child)\n  {\n    var cnt = this.m_Childs.length;\n    this.m_Childs.push(Child);\n    Child.m_Parent = this;\n    Child.m_Index = cnt;\n  };\n  ClipperLib.PolyNode.prototype.GetNext = function ()\n  {\n    if (this.m_Childs.length > 0)\n      return this.m_Childs[0];\n    else\n      return this.GetNextSiblingUp();\n  };\n  ClipperLib.PolyNode.prototype.GetNextSiblingUp = function ()\n  {\n    if (this.m_Parent === null)\n      return null;\n    else if (this.m_Index == this.m_Parent.m_Childs.length - 1)\n      return this.m_Parent.GetNextSiblingUp();\n    else\n      return this.m_Parent.m_Childs[this.m_Index + 1];\n  };\n  ClipperLib.PolyNode.prototype.Childs = function ()\n  {\n    return this.m_Childs;\n  };\n  ClipperLib.PolyNode.prototype.Parent = function ()\n  {\n    return this.m_Parent;\n  };\n  ClipperLib.PolyNode.prototype.IsHole = function ()\n  {\n    return this.IsHoleNode();\n  };\n  // PolyTree : PolyNode\n  ClipperLib.PolyTree = function ()\n  {\n    this.m_AllPolys = [];\n    ClipperLib.PolyNode.call(this);\n  };\n  ClipperLib.PolyTree.prototype.Clear = function ()\n  {\n    for (var i = 0, ilen = this.m_AllPolys.length; i < ilen; i++)\n      this.m_AllPolys[i] = null;\n    this.m_AllPolys.length = 0;\n    this.m_Childs.length = 0;\n  };\n  ClipperLib.PolyTree.prototype.GetFirst = function ()\n  {\n    if (this.m_Childs.length > 0)\n      return this.m_Childs[0];\n    else\n      return null;\n  };\n  ClipperLib.PolyTree.prototype.Total = function ()\n  {\n\t\tvar result = this.m_AllPolys.length;\n\t\t//with negative offsets, ignore the hidden outer polygon ...\n\t\tif (result > 0 && this.m_Childs[0] != this.m_AllPolys[0]) result--;\n\t\treturn result;\n  };\n  Inherit(ClipperLib.PolyTree, ClipperLib.PolyNode);\n  // -------------------------------\n  // PolyTree & PolyNode end\n  ClipperLib.Math_Abs_Int64 = ClipperLib.Math_Abs_Int32 = ClipperLib.Math_Abs_Double = function (a)\n  {\n    return Math.abs(a);\n  };\n  ClipperLib.Math_Max_Int32_Int32 = function (a, b)\n  {\n    return Math.max(a, b);\n  };\n  /*\n  -----------------------------------\n  cast_32 speedtest: http://jsperf.com/truncate-float-to-integer/2\n  -----------------------------------\n  */\n  if (browser.msie || browser.opera || browser.safari) ClipperLib.Cast_Int32 = function (a)\n  {\n    return a | 0;\n  };\n  else ClipperLib.Cast_Int32 = function (a)\n  { // eg. browser.chrome || browser.chromium || browser.firefox\n    return~~ a;\n  };\n  /*\n  --------------------------\n  cast_64 speedtests: http://jsperf.com/truncate-float-to-integer\n  Chrome: bitwise_not_floor\n  Firefox17: toInteger (typeof test)\n  IE9: bitwise_or_floor\n  IE7 and IE8: to_parseint\n  Chromium: to_floor_or_ceil\n  Firefox3: to_floor_or_ceil\n  Firefox15: to_floor_or_ceil\n  Opera: to_floor_or_ceil\n  Safari: to_floor_or_ceil\n  --------------------------\n  */\n  if (browser.chrome) ClipperLib.Cast_Int64 = function (a)\n  {\n    if (a < -2147483648 || a > 2147483647)\n      return a < 0 ? Math.ceil(a) : Math.floor(a);\n    else return~~ a;\n  };\n  else if (browser.firefox && typeof (Number.toInteger) == \"function\") ClipperLib.Cast_Int64 = function (a)\n  {\n    return Number.toInteger(a);\n  };\n  else if (browser.msie7 || browser.msie8) ClipperLib.Cast_Int64 = function (a)\n  {\n    return parseInt(a, 10);\n  };\n  else if (browser.msie) ClipperLib.Cast_Int64 = function (a)\n  {\n    if (a < -2147483648 || a > 2147483647)\n      return a < 0 ? Math.ceil(a) : Math.floor(a);\n    return a | 0;\n  };\n  // eg. browser.chromium || browser.firefox || browser.opera || browser.safari\n  else ClipperLib.Cast_Int64 = function (a)\n  {\n    return a < 0 ? Math.ceil(a) : Math.floor(a);\n  };\n  ClipperLib.Clear = function (a)\n  {\n    a.length = 0;\n  };\n  //ClipperLib.MaxSteps = 64; // How many steps at maximum in arc in BuildArc() function\n  ClipperLib.PI = 3.141592653589793;\n  ClipperLib.PI2 = 2 * 3.141592653589793;\n  ClipperLib.IntPoint = function ()\n  {\n    var a = arguments,\n      alen = a.length;\n    this.X = 0;\n    this.Y = 0;\n    if (use_xyz)\n    {\n      this.Z = 0;\n      if (alen == 3) // public IntPoint(cInt x, cInt y, cInt z = 0)\n      {\n        this.X = a[0];\n        this.Y = a[1];\n        this.Z = a[2];\n      }\n      else if (alen == 2) // public IntPoint(cInt x, cInt y)\n      {\n        this.X = a[0];\n        this.Y = a[1];\n        this.Z = 0;\n      }\n      else if (alen == 1)\n      {\n        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n        {\n          var dp = a[0];\n          this.X = ClipperLib.Clipper.Round(dp.X);\n          this.Y = ClipperLib.Clipper.Round(dp.Y);\n          this.Z = 0;\n        }\n        else // public IntPoint(IntPoint pt)\n        {\n          var pt = a[0];\n          if (typeof (pt.Z) == \"undefined\") pt.Z = 0;\n          this.X = pt.X;\n          this.Y = pt.Y;\n          this.Z = pt.Z;\n        }\n      }\n      else // public IntPoint()\n      {\n        this.X = 0;\n        this.Y = 0;\n        this.Z = 0;\n      }\n    }\n    else // if (!use_xyz)\n    {\n      if (alen == 2) // public IntPoint(cInt X, cInt Y)\n      {\n        this.X = a[0];\n        this.Y = a[1];\n      }\n      else if (alen == 1)\n      {\n        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n        {\n          var dp = a[0];\n          this.X = ClipperLib.Clipper.Round(dp.X);\n          this.Y = ClipperLib.Clipper.Round(dp.Y);\n        }\n        else // public IntPoint(IntPoint pt)\n        {\n          var pt = a[0];\n          this.X = pt.X;\n          this.Y = pt.Y;\n        }\n      }\n      else // public IntPoint(IntPoint pt)\n      {\n        this.X = 0;\n        this.Y = 0;\n      }\n    }\n  };\n  ClipperLib.IntPoint.op_Equality = function (a, b)\n  {\n    //return a == b;\n    return a.X == b.X && a.Y == b.Y;\n  };\n  ClipperLib.IntPoint.op_Inequality = function (a, b)\n  {\n    //return a != b;\n    return a.X != b.X || a.Y != b.Y;\n  };\n  /*\n  ClipperLib.IntPoint.prototype.Equals = function (obj)\n  {\n    if (obj === null)\n        return false;\n    if (obj instanceof ClipperLib.IntPoint)\n    {\n        var a = Cast(obj, ClipperLib.IntPoint);\n        return (this.X == a.X) && (this.Y == a.Y);\n    }\n    else\n        return false;\n  };\n*/\n  if (use_xyz)\n  {\n    ClipperLib.IntPoint0 = function ()\n    {\n      this.X = 0;\n      this.Y = 0;\n      this.Z = 0;\n    };\n    ClipperLib.IntPoint1 = function (pt)\n    {\n      this.X = pt.X;\n      this.Y = pt.Y;\n      this.Z = pt.Z;\n    };\n    ClipperLib.IntPoint1dp = function (dp)\n    {\n      this.X = ClipperLib.Clipper.Round(dp.X);\n      this.Y = ClipperLib.Clipper.Round(dp.Y);\n      this.Z = 0;\n    };\n    ClipperLib.IntPoint2 = function (x, y)\n    {\n      this.X = x;\n      this.Y = y;\n      this.Z = 0;\n    };\n    ClipperLib.IntPoint3 = function (x, y, z)\n    {\n      this.X = x;\n      this.Y = y;\n      this.Z = z;\n    };\n  }\n  else // if (!use_xyz)\n  {\n    ClipperLib.IntPoint0 = function ()\n    {\n      this.X = 0;\n      this.Y = 0;\n    };\n    ClipperLib.IntPoint1 = function (pt)\n    {\n      this.X = pt.X;\n      this.Y = pt.Y;\n    };\n    ClipperLib.IntPoint1dp = function (dp)\n    {\n      this.X = ClipperLib.Clipper.Round(dp.X);\n      this.Y = ClipperLib.Clipper.Round(dp.Y);\n    };\n    ClipperLib.IntPoint2 = function (x, y)\n    {\n      this.X = x;\n      this.Y = y;\n    };\n  }\n  ClipperLib.IntRect = function ()\n  {\n    var a = arguments,\n      alen = a.length;\n    if (alen == 4) // function (l, t, r, b)\n    {\n      this.left = a[0];\n      this.top = a[1];\n      this.right = a[2];\n      this.bottom = a[3];\n    }\n    else if (alen == 1) // function (ir)\n    {\n      this.left = ir.left;\n      this.top = ir.top;\n      this.right = ir.right;\n      this.bottom = ir.bottom;\n    }\n    else // function ()\n    {\n      this.left = 0;\n      this.top = 0;\n      this.right = 0;\n      this.bottom = 0;\n    }\n  };\n  ClipperLib.IntRect0 = function ()\n  {\n    this.left = 0;\n    this.top = 0;\n    this.right = 0;\n    this.bottom = 0;\n  };\n  ClipperLib.IntRect1 = function (ir)\n  {\n    this.left = ir.left;\n    this.top = ir.top;\n    this.right = ir.right;\n    this.bottom = ir.bottom;\n  };\n  ClipperLib.IntRect4 = function (l, t, r, b)\n  {\n    this.left = l;\n    this.top = t;\n    this.right = r;\n    this.bottom = b;\n  };\n  ClipperLib.ClipType = {\n    ctIntersection: 0,\n    ctUnion: 1,\n    ctDifference: 2,\n    ctXor: 3\n  };\n  ClipperLib.PolyType = {\n    ptSubject: 0,\n    ptClip: 1\n  };\n  ClipperLib.PolyFillType = {\n    pftEvenOdd: 0,\n    pftNonZero: 1,\n    pftPositive: 2,\n    pftNegative: 3\n  };\n  ClipperLib.JoinType = {\n    jtSquare: 0,\n    jtRound: 1,\n    jtMiter: 2\n  };\n  ClipperLib.EndType = {\n    etOpenSquare: 0,\n    etOpenRound: 1,\n    etOpenButt: 2,\n    etClosedLine: 3,\n    etClosedPolygon: 4\n  };\n  ClipperLib.EdgeSide = {\n    esLeft: 0,\n    esRight: 1\n  };\n  ClipperLib.Direction = {\n    dRightToLeft: 0,\n    dLeftToRight: 1\n  };\n  ClipperLib.TEdge = function ()\n  {\n    this.Bot = new ClipperLib.IntPoint();\n    this.Curr = new ClipperLib.IntPoint();\n    this.Top = new ClipperLib.IntPoint();\n    this.Delta = new ClipperLib.IntPoint();\n    this.Dx = 0;\n    this.PolyTyp = ClipperLib.PolyType.ptSubject;\n    this.Side = ClipperLib.EdgeSide.esLeft;\n    this.WindDelta = 0;\n    this.WindCnt = 0;\n    this.WindCnt2 = 0;\n    this.OutIdx = 0;\n    this.Next = null;\n    this.Prev = null;\n    this.NextInLML = null;\n    this.NextInAEL = null;\n    this.PrevInAEL = null;\n    this.NextInSEL = null;\n    this.PrevInSEL = null;\n  };\n  ClipperLib.IntersectNode = function ()\n  {\n    this.Edge1 = null;\n    this.Edge2 = null;\n    this.Pt = new ClipperLib.IntPoint();\n  };\n  ClipperLib.MyIntersectNodeSort = function () {};\n  ClipperLib.MyIntersectNodeSort.Compare = function (node1, node2)\n  {\n    var i = node2.Pt.Y - node1.Pt.Y;\n    if (i > 0) return 1;\n    else if (i < 0) return -1;\n    else return 0;\n  };\n\n  ClipperLib.LocalMinima = function ()\n  {\n    this.Y = 0;\n    this.LeftBound = null;\n    this.RightBound = null;\n    this.Next = null;\n  };\n  ClipperLib.Scanbeam = function ()\n  {\n    this.Y = 0;\n    this.Next = null;\n  };\n  ClipperLib.OutRec = function ()\n  {\n    this.Idx = 0;\n    this.IsHole = false;\n    this.IsOpen = false;\n    this.FirstLeft = null;\n    this.Pts = null;\n    this.BottomPt = null;\n    this.PolyNode = null;\n  };\n  ClipperLib.OutPt = function ()\n  {\n    this.Idx = 0;\n    this.Pt = new ClipperLib.IntPoint();\n    this.Next = null;\n    this.Prev = null;\n  };\n  ClipperLib.Join = function ()\n  {\n    this.OutPt1 = null;\n    this.OutPt2 = null;\n    this.OffPt = new ClipperLib.IntPoint();\n  };\n  ClipperLib.ClipperBase = function ()\n  {\n    this.m_MinimaList = null;\n    this.m_CurrentLM = null;\n    this.m_edges = new Array();\n    this.m_UseFullRange = false;\n    this.m_HasOpenPaths = false;\n    this.PreserveCollinear = false;\n    this.m_MinimaList = null;\n    this.m_CurrentLM = null;\n    this.m_UseFullRange = false;\n    this.m_HasOpenPaths = false;\n  };\n  // Ranges are in original C# too high for Javascript (in current state 2013 september):\n  // protected const double horizontal = -3.4E+38;\n  // internal const cInt loRange = 0x3FFFFFFF; // = 1073741823 = sqrt(2^63 -1)/2\n  // internal const cInt hiRange = 0x3FFFFFFFFFFFFFFFL; // = 4611686018427387903 = sqrt(2^127 -1)/2\n  // So had to adjust them to more suitable for Javascript.\n  // If JS some day supports truly 64-bit integers, then these ranges can be as in C#\n  // and biginteger library can be more simpler (as then 128bit can be represented as two 64bit numbers)\n  ClipperLib.ClipperBase.horizontal = -9007199254740992; //-2^53\n  ClipperLib.ClipperBase.Skip = -2;\n  ClipperLib.ClipperBase.Unassigned = -1;\n  ClipperLib.ClipperBase.tolerance = 1E-20;\n  if (use_int32)\n  {\n    ClipperLib.ClipperBase.loRange = 0x7FFF;\n    ClipperLib.ClipperBase.hiRange = 0x7FFF;\n  }\n  else\n  {\n    ClipperLib.ClipperBase.loRange = 47453132; // sqrt(2^53 -1)/2\n    ClipperLib.ClipperBase.hiRange = 4503599627370495; // sqrt(2^106 -1)/2\n  }\n\n  ClipperLib.ClipperBase.near_zero = function (val)\n  {\n    return (val > -ClipperLib.ClipperBase.tolerance) && (val < ClipperLib.ClipperBase.tolerance);\n  };\n  ClipperLib.ClipperBase.IsHorizontal = function (e)\n  {\n    return e.Delta.Y === 0;\n  };\n  ClipperLib.ClipperBase.prototype.PointIsVertex = function (pt, pp)\n  {\n    var pp2 = pp;\n    do {\n      if (ClipperLib.IntPoint.op_Equality(pp2.Pt, pt))\n        return true;\n      pp2 = pp2.Next;\n    }\n    while (pp2 != pp)\n    return false;\n  };\n  ClipperLib.ClipperBase.prototype.PointOnLineSegment = function (pt, linePt1, linePt2, UseFullRange)\n  {\n    if (UseFullRange)\n      return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) ||\n        ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) ||\n        (((pt.X > linePt1.X) == (pt.X < linePt2.X)) &&\n        ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) &&\n        (Int128.op_Equality(Int128.Int128Mul((pt.X - linePt1.X), (linePt2.Y - linePt1.Y)),\n          Int128.Int128Mul((linePt2.X - linePt1.X), (pt.Y - linePt1.Y)))));\n    else\n      return ((pt.X == linePt1.X) && (pt.Y == linePt1.Y)) || ((pt.X == linePt2.X) && (pt.Y == linePt2.Y)) || (((pt.X > linePt1.X) == (pt.X < linePt2.X)) && ((pt.Y > linePt1.Y) == (pt.Y < linePt2.Y)) && ((pt.X - linePt1.X) * (linePt2.Y - linePt1.Y) == (linePt2.X - linePt1.X) * (pt.Y - linePt1.Y)));\n  };\n  ClipperLib.ClipperBase.prototype.PointOnPolygon = function (pt, pp, UseFullRange)\n  {\n    var pp2 = pp;\n    while (true)\n    {\n      if (this.PointOnLineSegment(pt, pp2.Pt, pp2.Next.Pt, UseFullRange))\n        return true;\n      pp2 = pp2.Next;\n      if (pp2 == pp)\n        break;\n    }\n    return false;\n  };\n  ClipperLib.ClipperBase.prototype.SlopesEqual = ClipperLib.ClipperBase.SlopesEqual = function ()\n  {\n    var a = arguments,\n      alen = a.length;\n    var e1, e2, pt1, pt2, pt3, pt4, UseFullRange;\n    if (alen == 3) // function (e1, e2, UseFullRange)\n    {\n      e1 = a[0];\n      e2 = a[1];\n      UseFullRange = a[2];\n      if (UseFullRange)\n        return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n      else\n        return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n    }\n    else if (alen == 4) // function (pt1, pt2, pt3, UseFullRange)\n    {\n      pt1 = a[0];\n      pt2 = a[1];\n      pt3 = a[2];\n      UseFullRange = a[3];\n      if (UseFullRange)\n        return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n      else\n        return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n    }\n    else // function (pt1, pt2, pt3, pt4, UseFullRange)\n    {\n      pt1 = a[0];\n      pt2 = a[1];\n      pt3 = a[2];\n      pt4 = a[3];\n      UseFullRange = a[4];\n      if (UseFullRange)\n        return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n      else\n        return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n    }\n  };\n  ClipperLib.ClipperBase.SlopesEqual3 = function (e1, e2, UseFullRange)\n  {\n    if (UseFullRange)\n      return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));\n    else\n      return ClipperLib.Cast_Int64((e1.Delta.Y) * (e2.Delta.X)) == ClipperLib.Cast_Int64((e1.Delta.X) * (e2.Delta.Y));\n  };\n  ClipperLib.ClipperBase.SlopesEqual4 = function (pt1, pt2, pt3, UseFullRange)\n  {\n    if (UseFullRange)\n      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));\n    else\n      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n  };\n  ClipperLib.ClipperBase.SlopesEqual5 = function (pt1, pt2, pt3, pt4, UseFullRange)\n  {\n    if (UseFullRange)\n      return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));\n    else\n      return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n  };\n  ClipperLib.ClipperBase.prototype.Clear = function ()\n  {\n    this.DisposeLocalMinimaList();\n    for (var i = 0, ilen = this.m_edges.length; i < ilen; ++i)\n    {\n      for (var j = 0, jlen = this.m_edges[i].length; j < jlen; ++j)\n        this.m_edges[i][j] = null;\n      ClipperLib.Clear(this.m_edges[i]);\n    }\n    ClipperLib.Clear(this.m_edges);\n    this.m_UseFullRange = false;\n    this.m_HasOpenPaths = false;\n  };\n  ClipperLib.ClipperBase.prototype.DisposeLocalMinimaList = function ()\n  {\n    while (this.m_MinimaList !== null)\n    {\n      var tmpLm = this.m_MinimaList.Next;\n      this.m_MinimaList = null;\n      this.m_MinimaList = tmpLm;\n    }\n    this.m_CurrentLM = null;\n  };\n  ClipperLib.ClipperBase.prototype.RangeTest = function (Pt, useFullRange)\n  {\n    if (useFullRange.Value)\n    {\n      if (Pt.X > ClipperLib.ClipperBase.hiRange || Pt.Y > ClipperLib.ClipperBase.hiRange || -Pt.X > ClipperLib.ClipperBase.hiRange || -Pt.Y > ClipperLib.ClipperBase.hiRange)\n        ClipperLib.Error(\"Coordinate outside allowed range in RangeTest().\");\n    }\n    else if (Pt.X > ClipperLib.ClipperBase.loRange || Pt.Y > ClipperLib.ClipperBase.loRange || -Pt.X > ClipperLib.ClipperBase.loRange || -Pt.Y > ClipperLib.ClipperBase.loRange)\n    {\n      useFullRange.Value = true;\n      this.RangeTest(Pt, useFullRange);\n    }\n  };\n  ClipperLib.ClipperBase.prototype.InitEdge = function (e, eNext, ePrev, pt)\n  {\n    e.Next = eNext;\n    e.Prev = ePrev;\n    //e.Curr = pt;\n    e.Curr.X = pt.X;\n    e.Curr.Y = pt.Y;\n    e.OutIdx = -1;\n  };\n  ClipperLib.ClipperBase.prototype.InitEdge2 = function (e, polyType)\n  {\n    if (e.Curr.Y >= e.Next.Curr.Y)\n    {\n      //e.Bot = e.Curr;\n      e.Bot.X = e.Curr.X;\n      e.Bot.Y = e.Curr.Y;\n      //e.Top = e.Next.Curr;\n      e.Top.X = e.Next.Curr.X;\n      e.Top.Y = e.Next.Curr.Y;\n    }\n    else\n    {\n      //e.Top = e.Curr;\n      e.Top.X = e.Curr.X;\n      e.Top.Y = e.Curr.Y;\n      //e.Bot = e.Next.Curr;\n      e.Bot.X = e.Next.Curr.X;\n      e.Bot.Y = e.Next.Curr.Y;\n    }\n    this.SetDx(e);\n    e.PolyTyp = polyType;\n  };\n  ClipperLib.ClipperBase.prototype.FindNextLocMin = function (E)\n  {\n    var E2;\n    for (;;)\n    {\n      while (ClipperLib.IntPoint.op_Inequality(E.Bot, E.Prev.Bot) || ClipperLib.IntPoint.op_Equality(E.Curr, E.Top))\n        E = E.Next;\n      if (E.Dx != ClipperLib.ClipperBase.horizontal && E.Prev.Dx != ClipperLib.ClipperBase.horizontal)\n        break;\n      while (E.Prev.Dx == ClipperLib.ClipperBase.horizontal)\n        E = E.Prev;\n      E2 = E;\n      while (E.Dx == ClipperLib.ClipperBase.horizontal)\n        E = E.Next;\n      if (E.Top.Y == E.Prev.Bot.Y)\n        continue;\n      //ie just an intermediate horz.\n      if (E2.Prev.Bot.X < E.Bot.X)\n        E = E2;\n      break;\n    }\n    return E;\n  };\n  ClipperLib.ClipperBase.prototype.ProcessBound = function (E, LeftBoundIsForward)\n  {\n    var EStart;\n    var Result = E;\n    var Horz;\n\n      if (Result.OutIdx == ClipperLib.ClipperBase.Skip)\n      {\n        //check if there are edges beyond the skip edge in the bound and if so\n        //create another LocMin and calling ProcessBound once more ...\n        E = Result;\n        if (LeftBoundIsForward)\n        {\n          while (E.Top.Y == E.Next.Bot.Y) E = E.Next;\n          while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Prev;\n        }\n        else\n        {\n          while (E.Top.Y == E.Prev.Bot.Y) E = E.Prev;\n          while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) E = E.Next;\n        }\n        if (E == Result)\n        {\n          if (LeftBoundIsForward) Result = E.Next;\n          else Result = E.Prev;\n        }\n        else\n        {\n          //there are more edges in the bound beyond result starting with E\n          if (LeftBoundIsForward)\n            E = Result.Next;\n          else\n            E = Result.Prev;\n          var locMin = new ClipperLib.LocalMinima();\n          locMin.Next = null;\n          locMin.Y = E.Bot.Y;\n          locMin.LeftBound = null;\n          locMin.RightBound = E;\n          E.WindDelta = 0;\n          Result = this.ProcessBound(E, LeftBoundIsForward);\n          this.InsertLocalMinima(locMin);\n        }\n        return Result;\n      }\n\n      if (E.Dx == ClipperLib.ClipperBase.horizontal)\n      {\n        //We need to be careful with open paths because this may not be a\n        //true local minima (ie E may be following a skip edge).\n        //Also, consecutive horz. edges may start heading left before going right.\n        if (LeftBoundIsForward) EStart = E.Prev;\n        else EStart = E.Next;\n        if (EStart.OutIdx != ClipperLib.ClipperBase.Skip)\n        {\n          if (EStart.Dx == ClipperLib.ClipperBase.horizontal) //ie an adjoining horizontal skip edge\n          {\n            if (EStart.Bot.X != E.Bot.X && EStart.Top.X != E.Bot.X)\n              this.ReverseHorizontal(E);\n          }\n          else if (EStart.Bot.X != E.Bot.X)\n            this.ReverseHorizontal(E);\n        }\n      }\n\n      EStart = E;\n      if (LeftBoundIsForward)\n      {\n        while (Result.Top.Y == Result.Next.Bot.Y && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n          Result = Result.Next;\n        if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n        {\n          //nb: at the top of a bound, horizontals are added to the bound\n          //only when the preceding edge attaches to the horizontal's left vertex\n          //unless a Skip edge is encountered when that becomes the top divide\n          Horz = Result;\n          while (Horz.Prev.Dx == ClipperLib.ClipperBase.horizontal)\n            Horz = Horz.Prev;\n          if (Horz.Prev.Top.X == Result.Next.Top.X)\n          {\n            if (!LeftBoundIsForward)\n              Result = Horz.Prev;\n          }\n          else if (Horz.Prev.Top.X > Result.Next.Top.X)\n            Result = Horz.Prev;\n        }\n        while (E != Result)\n        {\n          E.NextInLML = E.Next;\n          if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)\n            this.ReverseHorizontal(E);\n          E = E.Next;\n        }\n        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X)\n          this.ReverseHorizontal(E);\n        Result = Result.Next;\n        //move to the edge just beyond current bound\n      }\n      else\n      {\n        while (Result.Top.Y == Result.Prev.Bot.Y && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)\n          Result = Result.Prev;\n        if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip)\n        {\n          Horz = Result;\n          while (Horz.Next.Dx == ClipperLib.ClipperBase.horizontal)\n            Horz = Horz.Next;\n          if (Horz.Next.Top.X == Result.Prev.Top.X)\n          {\n            if (!LeftBoundIsForward)\n              Result = Horz.Next;\n          }\n          else if (Horz.Next.Top.X > Result.Prev.Top.X)\n            Result = Horz.Next;\n        }\n        while (E != Result)\n        {\n          E.NextInLML = E.Prev;\n          if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)\n            this.ReverseHorizontal(E);\n          E = E.Prev;\n        }\n        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X)\n          this.ReverseHorizontal(E);\n        Result = Result.Prev;\n        //move to the edge just beyond current bound\n      }\n\n    return Result;\n  };\n\n  ClipperLib.ClipperBase.prototype.AddPath = function (pg, polyType, Closed)\n  {\n    if (use_lines)\n    {\n      if (!Closed && polyType == ClipperLib.PolyType.ptClip)\n        ClipperLib.Error(\"AddPath: Open paths must be subject.\");\n    }\n    else\n    {\n      if (!Closed)\n        ClipperLib.Error(\"AddPath: Open paths have been disabled.\");\n    }\n    var highI = pg.length - 1;\n    if (Closed)\n      while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[0])))\n    --highI;\n    while (highI > 0 && (ClipperLib.IntPoint.op_Equality(pg[highI], pg[highI - 1])))\n    --highI;\n    if ((Closed && highI < 2) || (!Closed && highI < 1))\n      return false;\n    //create a new edge array ...\n    var edges = new Array();\n    for (var i = 0; i <= highI; i++)\n      edges.push(new ClipperLib.TEdge());\n    var IsFlat = true;\n    //1. Basic (first) edge initialization ...\n\n    //edges[1].Curr = pg[1];\n    edges[1].Curr.X = pg[1].X;\n    edges[1].Curr.Y = pg[1].Y;\n\n    var $1 = {Value: this.m_UseFullRange};\n    this.RangeTest(pg[0], $1);\n    this.m_UseFullRange = $1.Value;\n\n    $1.Value = this.m_UseFullRange;\n    this.RangeTest(pg[highI], $1);\n    this.m_UseFullRange = $1.Value;\n\n    this.InitEdge(edges[0], edges[1], edges[highI], pg[0]);\n    this.InitEdge(edges[highI], edges[0], edges[highI - 1], pg[highI]);\n    for (var i = highI - 1; i >= 1; --i)\n    {\n      $1.Value = this.m_UseFullRange;\n      this.RangeTest(pg[i], $1);\n      this.m_UseFullRange = $1.Value;\n\n      this.InitEdge(edges[i], edges[i + 1], edges[i - 1], pg[i]);\n    }\n\n    var eStart = edges[0];\n    //2. Remove duplicate vertices, and (when closed) collinear edges ...\n    var E = eStart,\n      eLoopStop = eStart;\n    for (;;)\n    {\n    //console.log(E.Next, eStart);\n    \t//nb: allows matching start and end points when not Closed ...\n      if (E.Curr == E.Next.Curr && (Closed || E.Next != eStart))\n      {\n        if (E == E.Next)\n          break;\n        if (E == eStart)\n          eStart = E.Next;\n        E = this.RemoveEdge(E);\n        eLoopStop = E;\n        continue;\n      }\n      if (E.Prev == E.Next)\n        break;\n      else if (Closed && ClipperLib.ClipperBase.SlopesEqual(E.Prev.Curr, E.Curr, E.Next.Curr, this.m_UseFullRange) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(E.Prev.Curr, E.Curr, E.Next.Curr)))\n      {\n        //Collinear edges are allowed for open paths but in closed paths\n        //the default is to merge adjacent collinear edges into a single edge.\n        //However, if the PreserveCollinear property is enabled, only overlapping\n        //collinear edges (ie spikes) will be removed from closed paths.\n        if (E == eStart)\n          eStart = E.Next;\n        E = this.RemoveEdge(E);\n        E = E.Prev;\n        eLoopStop = E;\n        continue;\n      }\n      E = E.Next;\n      if ((E == eLoopStop) || (!Closed && E.Next == eStart)) break;\n    }\n    if ((!Closed && (E == E.Next)) || (Closed && (E.Prev == E.Next)))\n      return false;\n    if (!Closed)\n    {\n      this.m_HasOpenPaths = true;\n      eStart.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n    }\n    //3. Do second stage of edge initialization ...\n    E = eStart;\n    do {\n      this.InitEdge2(E, polyType);\n      E = E.Next;\n      if (IsFlat && E.Curr.Y != eStart.Curr.Y)\n        IsFlat = false;\n    }\n    while (E != eStart)\n    //4. Finally, add edge bounds to LocalMinima list ...\n    //Totally flat paths must be handled differently when adding them\n    //to LocalMinima list to avoid endless loops etc ...\n    if (IsFlat)\n    {\n      if (Closed)\n        return false;\n      E.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n      if (E.Prev.Bot.X < E.Prev.Top.X)\n        this.ReverseHorizontal(E.Prev);\n      var locMin = new ClipperLib.LocalMinima();\n      locMin.Next = null;\n      locMin.Y = E.Bot.Y;\n      locMin.LeftBound = null;\n      locMin.RightBound = E;\n      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n      locMin.RightBound.WindDelta = 0;\n      while (E.Next.OutIdx != ClipperLib.ClipperBase.Skip)\n      {\n        E.NextInLML = E.Next;\n        if (E.Bot.X != E.Prev.Top.X)\n          this.ReverseHorizontal(E);\n        E = E.Next;\n      }\n      this.InsertLocalMinima(locMin);\n      this.m_edges.push(edges);\n      return true;\n    }\n    this.m_edges.push(edges);\n    var leftBoundIsForward;\n    var EMin = null;\n\n\t\t//workaround to avoid an endless loop in the while loop below when\n    //open paths have matching start and end points ...\n    if(ClipperLib.IntPoint.op_Equality(E.Prev.Bot, E.Prev.Top))\n    \tE = E.Next;\n\n    for (;;)\n    {\n      E = this.FindNextLocMin(E);\n      if (E == EMin)\n        break;\n      else if (EMin == null)\n        EMin = E;\n      //E and E.Prev now share a local minima (left aligned if horizontal).\n      //Compare their slopes to find which starts which bound ...\n      var locMin = new ClipperLib.LocalMinima();\n      locMin.Next = null;\n      locMin.Y = E.Bot.Y;\n      if (E.Dx < E.Prev.Dx)\n      {\n        locMin.LeftBound = E.Prev;\n        locMin.RightBound = E;\n        leftBoundIsForward = false;\n        //Q.nextInLML = Q.prev\n      }\n      else\n      {\n        locMin.LeftBound = E;\n        locMin.RightBound = E.Prev;\n        leftBoundIsForward = true;\n        //Q.nextInLML = Q.next\n      }\n      locMin.LeftBound.Side = ClipperLib.EdgeSide.esLeft;\n      locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n      if (!Closed)\n        locMin.LeftBound.WindDelta = 0;\n      else if (locMin.LeftBound.Next == locMin.RightBound)\n        locMin.LeftBound.WindDelta = -1;\n      else\n        locMin.LeftBound.WindDelta = 1;\n      locMin.RightBound.WindDelta = -locMin.LeftBound.WindDelta;\n      E = this.ProcessBound(locMin.LeftBound, leftBoundIsForward);\n      if (E.OutIdx == ClipperLib.ClipperBase.Skip)\n      \tE = this.ProcessBound(E, leftBoundIsForward);\n      var E2 = this.ProcessBound(locMin.RightBound, !leftBoundIsForward);\n      if (E2.OutIdx == ClipperLib.ClipperBase.Skip) E2 = this.ProcessBound(E2, !leftBoundIsForward);\n      if (locMin.LeftBound.OutIdx == ClipperLib.ClipperBase.Skip)\n        locMin.LeftBound = null;\n      else if (locMin.RightBound.OutIdx == ClipperLib.ClipperBase.Skip)\n        locMin.RightBound = null;\n      this.InsertLocalMinima(locMin);\n      if (!leftBoundIsForward)\n        E = E2;\n    }\n    return true;\n  };\n  ClipperLib.ClipperBase.prototype.AddPaths = function (ppg, polyType, closed)\n  {\n    //  console.log(\"-------------------------------------------\");\n    //  console.log(JSON.stringify(ppg));\n    var result = false;\n    for (var i = 0, ilen = ppg.length; i < ilen; ++i)\n      if (this.AddPath(ppg[i], polyType, closed))\n        result = true;\n    return result;\n  };\n  //------------------------------------------------------------------------------\n  ClipperLib.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3 = function (pt1, pt2, pt3)\n  {\n    if ((ClipperLib.IntPoint.op_Equality(pt1, pt3)) || (ClipperLib.IntPoint.op_Equality(pt1, pt2)) ||       (ClipperLib.IntPoint.op_Equality(pt3, pt2)))\n\n   //if ((pt1 == pt3) || (pt1 == pt2) || (pt3 == pt2))\n   return false;\n\n    else if (pt1.X != pt3.X)\n      return (pt2.X > pt1.X) == (pt2.X < pt3.X);\n    else\n      return (pt2.Y > pt1.Y) == (pt2.Y < pt3.Y);\n  };\n  ClipperLib.ClipperBase.prototype.RemoveEdge = function (e)\n  {\n    //removes e from double_linked_list (but without removing from memory)\n    e.Prev.Next = e.Next;\n    e.Next.Prev = e.Prev;\n    var result = e.Next;\n    e.Prev = null; //flag as removed (see ClipperBase.Clear)\n    return result;\n  };\n  ClipperLib.ClipperBase.prototype.SetDx = function (e)\n  {\n    e.Delta.X = (e.Top.X - e.Bot.X);\n    e.Delta.Y = (e.Top.Y - e.Bot.Y);\n    if (e.Delta.Y === 0) e.Dx = ClipperLib.ClipperBase.horizontal;\n    else e.Dx = (e.Delta.X) / (e.Delta.Y);\n  };\n  ClipperLib.ClipperBase.prototype.InsertLocalMinima = function (newLm)\n  {\n    if (this.m_MinimaList === null)\n    {\n      this.m_MinimaList = newLm;\n    }\n    else if (newLm.Y >= this.m_MinimaList.Y)\n    {\n      newLm.Next = this.m_MinimaList;\n      this.m_MinimaList = newLm;\n    }\n    else\n    {\n      var tmpLm = this.m_MinimaList;\n      while (tmpLm.Next !== null && (newLm.Y < tmpLm.Next.Y))\n        tmpLm = tmpLm.Next;\n      newLm.Next = tmpLm.Next;\n      tmpLm.Next = newLm;\n    }\n  };\n  ClipperLib.ClipperBase.prototype.PopLocalMinima = function ()\n  {\n    if (this.m_CurrentLM === null)\n      return;\n    this.m_CurrentLM = this.m_CurrentLM.Next;\n  };\n  ClipperLib.ClipperBase.prototype.ReverseHorizontal = function (e)\n  {\n    //swap horizontal edges' top and bottom x's so they follow the natural\n    //progression of the bounds - ie so their xbots will align with the\n    //adjoining lower edge. [Helpful in the ProcessHorizontal() method.]\n    var tmp = e.Top.X;\n    e.Top.X = e.Bot.X;\n    e.Bot.X = tmp;\n    if (use_xyz)\n    {\n      tmp = e.Top.Z;\n      e.Top.Z = e.Bot.Z;\n      e.Bot.Z = tmp;\n    }\n  };\n  ClipperLib.ClipperBase.prototype.Reset = function ()\n  {\n    this.m_CurrentLM = this.m_MinimaList;\n    if (this.m_CurrentLM == null)\n      return;\n    //ie nothing to process\n    //reset all edges ...\n    var lm = this.m_MinimaList;\n    while (lm != null)\n    {\n      var e = lm.LeftBound;\n      if (e != null)\n      {\n        //e.Curr = e.Bot;\n        e.Curr.X = e.Bot.X;\n        e.Curr.Y = e.Bot.Y;\n        e.Side = ClipperLib.EdgeSide.esLeft;\n        e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n      }\n      e = lm.RightBound;\n      if (e != null)\n      {\n        //e.Curr = e.Bot;\n        e.Curr.X = e.Bot.X;\n        e.Curr.Y = e.Bot.Y;\n        e.Side = ClipperLib.EdgeSide.esRight;\n        e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n      }\n      lm = lm.Next;\n    }\n  };\n  ClipperLib.Clipper = function (InitOptions) // public Clipper(int InitOptions = 0)\n  {\n    if (typeof (InitOptions) == \"undefined\") InitOptions = 0;\n    this.m_PolyOuts = null;\n    this.m_ClipType = ClipperLib.ClipType.ctIntersection;\n    this.m_Scanbeam = null;\n    this.m_ActiveEdges = null;\n    this.m_SortedEdges = null;\n    this.m_IntersectList = null;\n    this.m_IntersectNodeComparer = null;\n    this.m_ExecuteLocked = false;\n    this.m_ClipFillType = ClipperLib.PolyFillType.pftEvenOdd;\n    this.m_SubjFillType = ClipperLib.PolyFillType.pftEvenOdd;\n    this.m_Joins = null;\n    this.m_GhostJoins = null;\n    this.m_UsingPolyTree = false;\n    this.ReverseSolution = false;\n    this.StrictlySimple = false;\n    ClipperLib.ClipperBase.call(this);\n    this.m_Scanbeam = null;\n    this.m_ActiveEdges = null;\n    this.m_SortedEdges = null;\n    this.m_IntersectList = new Array();\n    this.m_IntersectNodeComparer = ClipperLib.MyIntersectNodeSort.Compare;\n    this.m_ExecuteLocked = false;\n    this.m_UsingPolyTree = false;\n    this.m_PolyOuts = new Array();\n    this.m_Joins = new Array();\n    this.m_GhostJoins = new Array();\n    this.ReverseSolution = (1 & InitOptions) !== 0;\n    this.StrictlySimple = (2 & InitOptions) !== 0;\n    this.PreserveCollinear = (4 & InitOptions) !== 0;\n    if (use_xyz)\n    {\n      this.ZFillFunction = null; // function (IntPoint vert1, IntPoint vert2, ref IntPoint intersectPt);\n    }\n  };\n  ClipperLib.Clipper.ioReverseSolution = 1;\n  ClipperLib.Clipper.ioStrictlySimple = 2;\n  ClipperLib.Clipper.ioPreserveCollinear = 4;\n\n  ClipperLib.Clipper.prototype.Clear = function ()\n  {\n    if (this.m_edges.length === 0)\n      return;\n    //avoids problems with ClipperBase destructor\n    this.DisposeAllPolyPts();\n    ClipperLib.ClipperBase.prototype.Clear.call(this);\n  };\n\n  ClipperLib.Clipper.prototype.DisposeScanbeamList = function ()\n  {\n    while (this.m_Scanbeam !== null)\n    {\n      var sb2 = this.m_Scanbeam.Next;\n      this.m_Scanbeam = null;\n      this.m_Scanbeam = sb2;\n    }\n  };\n  ClipperLib.Clipper.prototype.Reset = function ()\n  {\n    ClipperLib.ClipperBase.prototype.Reset.call(this);\n    this.m_Scanbeam = null;\n    this.m_ActiveEdges = null;\n    this.m_SortedEdges = null;\n\n    var lm = this.m_MinimaList;\n    while (lm !== null)\n    {\n      this.InsertScanbeam(lm.Y);\n      lm = lm.Next;\n    }\n  };\n  ClipperLib.Clipper.prototype.InsertScanbeam = function (Y)\n  {\n    if (this.m_Scanbeam === null)\n    {\n      this.m_Scanbeam = new ClipperLib.Scanbeam();\n      this.m_Scanbeam.Next = null;\n      this.m_Scanbeam.Y = Y;\n    }\n    else if (Y > this.m_Scanbeam.Y)\n    {\n      var newSb = new ClipperLib.Scanbeam();\n      newSb.Y = Y;\n      newSb.Next = this.m_Scanbeam;\n      this.m_Scanbeam = newSb;\n    }\n    else\n    {\n      var sb2 = this.m_Scanbeam;\n      while (sb2.Next !== null && (Y <= sb2.Next.Y))\n        sb2 = sb2.Next;\n      if (Y == sb2.Y)\n        return;\n      //ie ignores duplicates\n      var newSb = new ClipperLib.Scanbeam();\n      newSb.Y = Y;\n      newSb.Next = sb2.Next;\n      sb2.Next = newSb;\n    }\n  };\n  // ************************************\n  ClipperLib.Clipper.prototype.Execute = function ()\n  {\n    var a = arguments,\n      alen = a.length,\n      ispolytree = a[1] instanceof ClipperLib.PolyTree;\n    if (alen == 4 && !ispolytree) // function (clipType, solution, subjFillType, clipFillType)\n    {\n      var clipType = a[0],\n        solution = a[1],\n        subjFillType = a[2],\n        clipFillType = a[3];\n      if (this.m_ExecuteLocked)\n        return false;\n      if (this.m_HasOpenPaths)\n        ClipperLib.Error(\"Error: PolyTree struct is need for open path clipping.\");\n      this.m_ExecuteLocked = true;\n      ClipperLib.Clear(solution);\n      this.m_SubjFillType = subjFillType;\n      this.m_ClipFillType = clipFillType;\n      this.m_ClipType = clipType;\n      this.m_UsingPolyTree = false;\n      try\n      {\n        var succeeded = this.ExecuteInternal();\n        //build the return polygons ...\n        if (succeeded) this.BuildResult(solution);\n      }\n      finally\n      {\n        this.DisposeAllPolyPts();\n        this.m_ExecuteLocked = false;\n      }\n      return succeeded;\n    }\n    else if (alen == 4 && ispolytree) // function (clipType, polytree, subjFillType, clipFillType)\n    {\n      var clipType = a[0],\n        polytree = a[1],\n        subjFillType = a[2],\n        clipFillType = a[3];\n      if (this.m_ExecuteLocked)\n        return false;\n      this.m_ExecuteLocked = true;\n      this.m_SubjFillType = subjFillType;\n      this.m_ClipFillType = clipFillType;\n      this.m_ClipType = clipType;\n      this.m_UsingPolyTree = true;\n      try\n      {\n        var succeeded = this.ExecuteInternal();\n        //build the return polygons ...\n        if (succeeded) this.BuildResult2(polytree);\n      }\n      finally\n      {\n        this.DisposeAllPolyPts();\n        this.m_ExecuteLocked = false;\n      }\n      return succeeded;\n    }\n    else if (alen == 2 && !ispolytree) // function (clipType, solution)\n    {\n      var clipType = a[0],\n        solution = a[1];\n      return this.Execute(clipType, solution, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n    }\n    else if (alen == 2 && ispolytree) // function (clipType, polytree)\n    {\n      var clipType = a[0],\n        polytree = a[1];\n      return this.Execute(clipType, polytree, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n    }\n  };\n  ClipperLib.Clipper.prototype.FixHoleLinkage = function (outRec)\n  {\n    //skip if an outermost polygon or\n    //already already points to the correct FirstLeft ...\n    if (outRec.FirstLeft === null || (outRec.IsHole != outRec.FirstLeft.IsHole && outRec.FirstLeft.Pts !== null))\n      return;\n    var orfl = outRec.FirstLeft;\n    while (orfl !== null && ((orfl.IsHole == outRec.IsHole) || orfl.Pts === null))\n      orfl = orfl.FirstLeft;\n    outRec.FirstLeft = orfl;\n  };\n  ClipperLib.Clipper.prototype.ExecuteInternal = function ()\n  {\n    try\n    {\n      this.Reset();\n      if (this.m_CurrentLM === null)\n        return false;\n      var botY = this.PopScanbeam();\n      do {\n        this.InsertLocalMinimaIntoAEL(botY);\n        ClipperLib.Clear(this.m_GhostJoins);\n        this.ProcessHorizontals(false);\n        if (this.m_Scanbeam === null)\n          break;\n        var topY = this.PopScanbeam();\n        if (!this.ProcessIntersections(topY)) return false;\n\n        this.ProcessEdgesAtTopOfScanbeam(topY);\n        botY = topY;\n      }\n      while (this.m_Scanbeam !== null || this.m_CurrentLM !== null)\n      //fix orientations ...\n      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n      {\n        var outRec = this.m_PolyOuts[i];\n        if (outRec.Pts === null || outRec.IsOpen)\n          continue;\n        if ((outRec.IsHole ^ this.ReverseSolution) == (this.Area(outRec) > 0))\n          this.ReversePolyPtLinks(outRec.Pts);\n      }\n      this.JoinCommonEdges();\n      for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n      {\n        var outRec = this.m_PolyOuts[i];\n        if (outRec.Pts !== null && !outRec.IsOpen)\n          this.FixupOutPolygon(outRec);\n      }\n      if (this.StrictlySimple)\n        this.DoSimplePolygons();\n      return true;\n    }\n    finally\n    {\n      ClipperLib.Clear(this.m_Joins);\n      ClipperLib.Clear(this.m_GhostJoins);\n    }\n  };\n  ClipperLib.Clipper.prototype.PopScanbeam = function ()\n  {\n    var Y = this.m_Scanbeam.Y;\n    this.m_Scanbeam = this.m_Scanbeam.Next;\n    return Y;\n  };\n\n  ClipperLib.Clipper.prototype.DisposeAllPolyPts = function ()\n  {\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; ++i)\n      this.DisposeOutRec(i);\n    ClipperLib.Clear(this.m_PolyOuts);\n  };\n  ClipperLib.Clipper.prototype.DisposeOutRec = function (index)\n  {\n    var outRec = this.m_PolyOuts[index];\n    outRec.Pts = null;\n    outRec = null;\n    this.m_PolyOuts[index] = null;\n  };\n\n  ClipperLib.Clipper.prototype.AddJoin = function (Op1, Op2, OffPt)\n  {\n    var j = new ClipperLib.Join();\n    j.OutPt1 = Op1;\n    j.OutPt2 = Op2;\n    //j.OffPt = OffPt;\n    j.OffPt.X = OffPt.X;\n    j.OffPt.Y = OffPt.Y;\n    this.m_Joins.push(j);\n  };\n  ClipperLib.Clipper.prototype.AddGhostJoin = function (Op, OffPt)\n  {\n    var j = new ClipperLib.Join();\n    j.OutPt1 = Op;\n    //j.OffPt = OffPt;\n    j.OffPt.X = OffPt.X;\n    j.OffPt.Y = OffPt.Y;\n    this.m_GhostJoins.push(j);\n  };\n  if (use_xyz)\n  {\n    ClipperLib.Clipper.prototype.SetZ = function (pt, e1, e2)\n    {\n      if (this.ZFillFunction !== null)\n      {\n        if (pt.Z != 0 || this.ZFillFunction === null) return;\n        else if (ClipperLib.IntPoint.op_Equality(pt, e1.Bot)) pt.Z = e1.Bot.Z;\n        else if (ClipperLib.IntPoint.op_Equality(pt, e1.Top)) pt.Z = e1.Top.Z;\n        else if (ClipperLib.IntPoint.op_Equality(pt, e2.Bot)) pt.Z = e2.Bot.Z;\n        else if (ClipperLib.IntPoint.op_Equality(pt, e2.Top)) pt.Z = e2.Top.Z;\n        else ZFillFunction(e1.Bot, e1.Top, e2.Bot, e2.Top, pt);\n      }\n    };\n\n    //------------------------------------------------------------------------------\n  }\n\n  ClipperLib.Clipper.prototype.InsertLocalMinimaIntoAEL = function (botY)\n  {\n    while (this.m_CurrentLM !== null && (this.m_CurrentLM.Y == botY))\n    {\n      var lb = this.m_CurrentLM.LeftBound;\n      var rb = this.m_CurrentLM.RightBound;\n      this.PopLocalMinima();\n      var Op1 = null;\n      if (lb === null)\n      {\n        this.InsertEdgeIntoAEL(rb, null);\n        this.SetWindingCount(rb);\n        if (this.IsContributing(rb))\n          Op1 = this.AddOutPt(rb, rb.Bot);\n      }\n      else if (rb == null)\n      {\n        this.InsertEdgeIntoAEL(lb, null);\n        this.SetWindingCount(lb);\n        if (this.IsContributing(lb))\n          Op1 = this.AddOutPt(lb, lb.Bot);\n        this.InsertScanbeam(lb.Top.Y);\n      }\n      else\n      {\n        this.InsertEdgeIntoAEL(lb, null);\n        this.InsertEdgeIntoAEL(rb, lb);\n        this.SetWindingCount(lb);\n        rb.WindCnt = lb.WindCnt;\n        rb.WindCnt2 = lb.WindCnt2;\n        if (this.IsContributing(lb))\n          Op1 = this.AddLocalMinPoly(lb, rb, lb.Bot);\n        this.InsertScanbeam(lb.Top.Y);\n      }\n      if (rb != null)\n      {\n        if (ClipperLib.ClipperBase.IsHorizontal(rb))\n          this.AddEdgeToSEL(rb);\n        else\n          this.InsertScanbeam(rb.Top.Y);\n      }\n      if (lb == null || rb == null) continue;\n      //if output polygons share an Edge with a horizontal rb, they'll need joining later ...\n      if (Op1 !== null && ClipperLib.ClipperBase.IsHorizontal(rb) && this.m_GhostJoins.length > 0 && rb.WindDelta !== 0)\n      {\n        for (var i = 0, ilen = this.m_GhostJoins.length; i < ilen; i++)\n        {\n          //if the horizontal Rb and a 'ghost' horizontal overlap, then convert\n          //the 'ghost' join to a real join ready for later ...\n          var j = this.m_GhostJoins[i];\n\n\t\t\t\t\tif (this.HorzSegmentsOverlap(j.OutPt1.Pt.X, j.OffPt.X, rb.Bot.X, rb.Top.X))\n            this.AddJoin(j.OutPt1, Op1, j.OffPt);\n        }\n      }\n      if (lb.OutIdx >= 0 && lb.PrevInAEL !== null &&\n        lb.PrevInAEL.Curr.X == lb.Bot.X &&\n        lb.PrevInAEL.OutIdx >= 0 &&\n        ClipperLib.ClipperBase.SlopesEqual(lb.PrevInAEL, lb, this.m_UseFullRange) &&\n        lb.WindDelta !== 0 && lb.PrevInAEL.WindDelta !== 0)\n      {\n        var Op2 = this.AddOutPt(lb.PrevInAEL, lb.Bot);\n        this.AddJoin(Op1, Op2, lb.Top);\n      }\n      if (lb.NextInAEL != rb)\n      {\n        if (rb.OutIdx >= 0 && rb.PrevInAEL.OutIdx >= 0 &&\n          ClipperLib.ClipperBase.SlopesEqual(rb.PrevInAEL, rb, this.m_UseFullRange) &&\n          rb.WindDelta !== 0 && rb.PrevInAEL.WindDelta !== 0)\n        {\n          var Op2 = this.AddOutPt(rb.PrevInAEL, rb.Bot);\n          this.AddJoin(Op1, Op2, rb.Top);\n        }\n        var e = lb.NextInAEL;\n        if (e !== null)\n          while (e != rb)\n          {\n            //nb: For calculating winding counts etc, IntersectEdges() assumes\n            //that param1 will be to the right of param2 ABOVE the intersection ...\n            this.IntersectEdges(rb, e, lb.Curr, false);\n            //order important here\n            e = e.NextInAEL;\n          }\n      }\n    }\n  };\n  ClipperLib.Clipper.prototype.InsertEdgeIntoAEL = function (edge, startEdge)\n  {\n    if (this.m_ActiveEdges === null)\n    {\n      edge.PrevInAEL = null;\n      edge.NextInAEL = null;\n      this.m_ActiveEdges = edge;\n    }\n    else if (startEdge === null && this.E2InsertsBeforeE1(this.m_ActiveEdges, edge))\n    {\n      edge.PrevInAEL = null;\n      edge.NextInAEL = this.m_ActiveEdges;\n      this.m_ActiveEdges.PrevInAEL = edge;\n      this.m_ActiveEdges = edge;\n    }\n    else\n    {\n      if (startEdge === null)\n        startEdge = this.m_ActiveEdges;\n      while (startEdge.NextInAEL !== null && !this.E2InsertsBeforeE1(startEdge.NextInAEL, edge))\n        startEdge = startEdge.NextInAEL;\n      edge.NextInAEL = startEdge.NextInAEL;\n      if (startEdge.NextInAEL !== null)\n        startEdge.NextInAEL.PrevInAEL = edge;\n      edge.PrevInAEL = startEdge;\n      startEdge.NextInAEL = edge;\n    }\n  };\n  ClipperLib.Clipper.prototype.E2InsertsBeforeE1 = function (e1, e2)\n  {\n    if (e2.Curr.X == e1.Curr.X)\n    {\n      if (e2.Top.Y > e1.Top.Y)\n        return e2.Top.X < ClipperLib.Clipper.TopX(e1, e2.Top.Y);\n      else\n        return e1.Top.X > ClipperLib.Clipper.TopX(e2, e1.Top.Y);\n    }\n    else\n      return e2.Curr.X < e1.Curr.X;\n  };\n  ClipperLib.Clipper.prototype.IsEvenOddFillType = function (edge)\n  {\n    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n      return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n    else\n      return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n  };\n  ClipperLib.Clipper.prototype.IsEvenOddAltFillType = function (edge)\n  {\n    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n      return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n    else\n      return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n  };\n  ClipperLib.Clipper.prototype.IsContributing = function (edge)\n  {\n    var pft, pft2;\n    if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n    {\n      pft = this.m_SubjFillType;\n      pft2 = this.m_ClipFillType;\n    }\n    else\n    {\n      pft = this.m_ClipFillType;\n      pft2 = this.m_SubjFillType;\n    }\n    switch (pft)\n    {\n    case ClipperLib.PolyFillType.pftEvenOdd:\n      if (edge.WindDelta === 0 && edge.WindCnt != 1)\n        return false;\n      break;\n    case ClipperLib.PolyFillType.pftNonZero:\n      if (Math.abs(edge.WindCnt) != 1)\n        return false;\n      break;\n    case ClipperLib.PolyFillType.pftPositive:\n      if (edge.WindCnt != 1)\n        return false;\n      break;\n    default:\n      if (edge.WindCnt != -1)\n        return false;\n      break;\n    }\n    switch (this.m_ClipType)\n    {\n    case ClipperLib.ClipType.ctIntersection:\n      switch (pft2)\n      {\n      case ClipperLib.PolyFillType.pftEvenOdd:\n      case ClipperLib.PolyFillType.pftNonZero:\n        return (edge.WindCnt2 !== 0);\n      case ClipperLib.PolyFillType.pftPositive:\n        return (edge.WindCnt2 > 0);\n      default:\n        return (edge.WindCnt2 < 0);\n      }\n    case ClipperLib.ClipType.ctUnion:\n      switch (pft2)\n      {\n      case ClipperLib.PolyFillType.pftEvenOdd:\n      case ClipperLib.PolyFillType.pftNonZero:\n        return (edge.WindCnt2 === 0);\n      case ClipperLib.PolyFillType.pftPositive:\n        return (edge.WindCnt2 <= 0);\n      default:\n        return (edge.WindCnt2 >= 0);\n      }\n    case ClipperLib.ClipType.ctDifference:\n      if (edge.PolyTyp == ClipperLib.PolyType.ptSubject)\n        switch (pft2)\n        {\n        case ClipperLib.PolyFillType.pftEvenOdd:\n        case ClipperLib.PolyFillType.pftNonZero:\n          return (edge.WindCnt2 === 0);\n        case ClipperLib.PolyFillType.pftPositive:\n          return (edge.WindCnt2 <= 0);\n        default:\n          return (edge.WindCnt2 >= 0);\n        }\n      else\n        switch (pft2)\n        {\n        case ClipperLib.PolyFillType.pftEvenOdd:\n        case ClipperLib.PolyFillType.pftNonZero:\n          return (edge.WindCnt2 !== 0);\n        case ClipperLib.PolyFillType.pftPositive:\n          return (edge.WindCnt2 > 0);\n        default:\n          return (edge.WindCnt2 < 0);\n        }\n    case ClipperLib.ClipType.ctXor:\n      if (edge.WindDelta === 0)\n        switch (pft2)\n        {\n        case ClipperLib.PolyFillType.pftEvenOdd:\n        case ClipperLib.PolyFillType.pftNonZero:\n          return (edge.WindCnt2 === 0);\n        case ClipperLib.PolyFillType.pftPositive:\n          return (edge.WindCnt2 <= 0);\n        default:\n          return (edge.WindCnt2 >= 0);\n        }\n      else\n        return true;\n    }\n    return true;\n  };\n  ClipperLib.Clipper.prototype.SetWindingCount = function (edge)\n  {\n    var e = edge.PrevInAEL;\n    //find the edge of the same polytype that immediately preceeds 'edge' in AEL\n    while (e !== null && ((e.PolyTyp != edge.PolyTyp) || (e.WindDelta === 0)))\n      e = e.PrevInAEL;\n    if (e === null)\n    {\n      edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n      edge.WindCnt2 = 0;\n      e = this.m_ActiveEdges;\n      //ie get ready to calc WindCnt2\n    }\n    else if (edge.WindDelta === 0 && this.m_ClipType != ClipperLib.ClipType.ctUnion)\n    {\n      edge.WindCnt = 1;\n      edge.WindCnt2 = e.WindCnt2;\n      e = e.NextInAEL;\n      //ie get ready to calc WindCnt2\n    }\n    else if (this.IsEvenOddFillType(edge))\n    {\n      //EvenOdd filling ...\n      if (edge.WindDelta === 0)\n      {\n        //are we inside a subj polygon ...\n        var Inside = true;\n        var e2 = e.PrevInAEL;\n        while (e2 !== null)\n        {\n          if (e2.PolyTyp == e.PolyTyp && e2.WindDelta !== 0)\n            Inside = !Inside;\n          e2 = e2.PrevInAEL;\n        }\n        edge.WindCnt = (Inside ? 0 : 1);\n      }\n      else\n      {\n        edge.WindCnt = edge.WindDelta;\n      }\n      edge.WindCnt2 = e.WindCnt2;\n      e = e.NextInAEL;\n      //ie get ready to calc WindCnt2\n    }\n    else\n    {\n      //nonZero, Positive or Negative filling ...\n      if (e.WindCnt * e.WindDelta < 0)\n      {\n        //prev edge is 'decreasing' WindCount (WC) toward zero\n        //so we're outside the previous polygon ...\n        if (Math.abs(e.WindCnt) > 1)\n        {\n          //outside prev poly but still inside another.\n          //when reversing direction of prev poly use the same WC\n          if (e.WindDelta * edge.WindDelta < 0)\n            edge.WindCnt = e.WindCnt;\n          else\n            edge.WindCnt = e.WindCnt + edge.WindDelta;\n        }\n        else\n          edge.WindCnt = (edge.WindDelta === 0 ? 1 : edge.WindDelta);\n      }\n      else\n      {\n        //prev edge is 'increasing' WindCount (WC) away from zero\n        //so we're inside the previous polygon ...\n        if (edge.WindDelta === 0)\n          edge.WindCnt = (e.WindCnt < 0 ? e.WindCnt - 1 : e.WindCnt + 1);\n        else if (e.WindDelta * edge.WindDelta < 0)\n          edge.WindCnt = e.WindCnt;\n        else\n          edge.WindCnt = e.WindCnt + edge.WindDelta;\n      }\n      edge.WindCnt2 = e.WindCnt2;\n      e = e.NextInAEL;\n      //ie get ready to calc WindCnt2\n    }\n    //update WindCnt2 ...\n    if (this.IsEvenOddAltFillType(edge))\n    {\n      //EvenOdd filling ...\n      while (e != edge)\n      {\n        if (e.WindDelta !== 0)\n          edge.WindCnt2 = (edge.WindCnt2 === 0 ? 1 : 0);\n        e = e.NextInAEL;\n      }\n    }\n    else\n    {\n      //nonZero, Positive or Negative filling ...\n      while (e != edge)\n      {\n        edge.WindCnt2 += e.WindDelta;\n        e = e.NextInAEL;\n      }\n    }\n  };\n  ClipperLib.Clipper.prototype.AddEdgeToSEL = function (edge)\n  {\n    //SEL pointers in PEdge are reused to build a list of horizontal edges.\n    //However, we don't need to worry about order with horizontal edge processing.\n    if (this.m_SortedEdges === null)\n    {\n      this.m_SortedEdges = edge;\n      edge.PrevInSEL = null;\n      edge.NextInSEL = null;\n    }\n    else\n    {\n      edge.NextInSEL = this.m_SortedEdges;\n      edge.PrevInSEL = null;\n      this.m_SortedEdges.PrevInSEL = edge;\n      this.m_SortedEdges = edge;\n    }\n  };\n  ClipperLib.Clipper.prototype.CopyAELToSEL = function ()\n  {\n    var e = this.m_ActiveEdges;\n    this.m_SortedEdges = e;\n    while (e !== null)\n    {\n      e.PrevInSEL = e.PrevInAEL;\n      e.NextInSEL = e.NextInAEL;\n      e = e.NextInAEL;\n    }\n  };\n  ClipperLib.Clipper.prototype.SwapPositionsInAEL = function (edge1, edge2)\n  {\n    //check that one or other edge hasn't already been removed from AEL ...\n    if (edge1.NextInAEL == edge1.PrevInAEL || edge2.NextInAEL == edge2.PrevInAEL)\n      return;\n    if (edge1.NextInAEL == edge2)\n    {\n      var next = edge2.NextInAEL;\n      if (next !== null)\n        next.PrevInAEL = edge1;\n      var prev = edge1.PrevInAEL;\n      if (prev !== null)\n        prev.NextInAEL = edge2;\n      edge2.PrevInAEL = prev;\n      edge2.NextInAEL = edge1;\n      edge1.PrevInAEL = edge2;\n      edge1.NextInAEL = next;\n    }\n    else if (edge2.NextInAEL == edge1)\n    {\n      var next = edge1.NextInAEL;\n      if (next !== null)\n        next.PrevInAEL = edge2;\n      var prev = edge2.PrevInAEL;\n      if (prev !== null)\n        prev.NextInAEL = edge1;\n      edge1.PrevInAEL = prev;\n      edge1.NextInAEL = edge2;\n      edge2.PrevInAEL = edge1;\n      edge2.NextInAEL = next;\n    }\n    else\n    {\n      var next = edge1.NextInAEL;\n      var prev = edge1.PrevInAEL;\n      edge1.NextInAEL = edge2.NextInAEL;\n      if (edge1.NextInAEL !== null)\n        edge1.NextInAEL.PrevInAEL = edge1;\n      edge1.PrevInAEL = edge2.PrevInAEL;\n      if (edge1.PrevInAEL !== null)\n        edge1.PrevInAEL.NextInAEL = edge1;\n      edge2.NextInAEL = next;\n      if (edge2.NextInAEL !== null)\n        edge2.NextInAEL.PrevInAEL = edge2;\n      edge2.PrevInAEL = prev;\n      if (edge2.PrevInAEL !== null)\n        edge2.PrevInAEL.NextInAEL = edge2;\n    }\n    if (edge1.PrevInAEL === null)\n      this.m_ActiveEdges = edge1;\n    else if (edge2.PrevInAEL === null)\n      this.m_ActiveEdges = edge2;\n  };\n  ClipperLib.Clipper.prototype.SwapPositionsInSEL = function (edge1, edge2)\n  {\n    if (edge1.NextInSEL === null && edge1.PrevInSEL === null)\n      return;\n    if (edge2.NextInSEL === null && edge2.PrevInSEL === null)\n      return;\n    if (edge1.NextInSEL == edge2)\n    {\n      var next = edge2.NextInSEL;\n      if (next !== null)\n        next.PrevInSEL = edge1;\n      var prev = edge1.PrevInSEL;\n      if (prev !== null)\n        prev.NextInSEL = edge2;\n      edge2.PrevInSEL = prev;\n      edge2.NextInSEL = edge1;\n      edge1.PrevInSEL = edge2;\n      edge1.NextInSEL = next;\n    }\n    else if (edge2.NextInSEL == edge1)\n    {\n      var next = edge1.NextInSEL;\n      if (next !== null)\n        next.PrevInSEL = edge2;\n      var prev = edge2.PrevInSEL;\n      if (prev !== null)\n        prev.NextInSEL = edge1;\n      edge1.PrevInSEL = prev;\n      edge1.NextInSEL = edge2;\n      edge2.PrevInSEL = edge1;\n      edge2.NextInSEL = next;\n    }\n    else\n    {\n      var next = edge1.NextInSEL;\n      var prev = edge1.PrevInSEL;\n      edge1.NextInSEL = edge2.NextInSEL;\n      if (edge1.NextInSEL !== null)\n        edge1.NextInSEL.PrevInSEL = edge1;\n      edge1.PrevInSEL = edge2.PrevInSEL;\n      if (edge1.PrevInSEL !== null)\n        edge1.PrevInSEL.NextInSEL = edge1;\n      edge2.NextInSEL = next;\n      if (edge2.NextInSEL !== null)\n        edge2.NextInSEL.PrevInSEL = edge2;\n      edge2.PrevInSEL = prev;\n      if (edge2.PrevInSEL !== null)\n        edge2.PrevInSEL.NextInSEL = edge2;\n    }\n    if (edge1.PrevInSEL === null)\n      this.m_SortedEdges = edge1;\n    else if (edge2.PrevInSEL === null)\n      this.m_SortedEdges = edge2;\n  };\n  ClipperLib.Clipper.prototype.AddLocalMaxPoly = function (e1, e2, pt)\n  {\n    this.AddOutPt(e1, pt);\n    if (e2.WindDelta == 0) this.AddOutPt(e2, pt);\n    if (e1.OutIdx == e2.OutIdx)\n    {\n      e1.OutIdx = -1;\n      e2.OutIdx = -1;\n    }\n    else if (e1.OutIdx < e2.OutIdx)\n      this.AppendPolygon(e1, e2);\n    else\n      this.AppendPolygon(e2, e1);\n  };\n  ClipperLib.Clipper.prototype.AddLocalMinPoly = function (e1, e2, pt)\n  {\n    var result;\n    var e, prevE;\n    if (ClipperLib.ClipperBase.IsHorizontal(e2) || (e1.Dx > e2.Dx))\n    {\n      result = this.AddOutPt(e1, pt);\n      e2.OutIdx = e1.OutIdx;\n      e1.Side = ClipperLib.EdgeSide.esLeft;\n      e2.Side = ClipperLib.EdgeSide.esRight;\n      e = e1;\n      if (e.PrevInAEL == e2)\n        prevE = e2.PrevInAEL;\n      else\n        prevE = e.PrevInAEL;\n    }\n    else\n    {\n      result = this.AddOutPt(e2, pt);\n      e1.OutIdx = e2.OutIdx;\n      e1.Side = ClipperLib.EdgeSide.esRight;\n      e2.Side = ClipperLib.EdgeSide.esLeft;\n      e = e2;\n      if (e.PrevInAEL == e1)\n        prevE = e1.PrevInAEL;\n      else\n        prevE = e.PrevInAEL;\n    }\n    if (prevE !== null && prevE.OutIdx >= 0 && (ClipperLib.Clipper.TopX(prevE, pt.Y) == ClipperLib.Clipper.TopX(e, pt.Y)) && ClipperLib.ClipperBase.SlopesEqual(e, prevE, this.m_UseFullRange) && (e.WindDelta !== 0) && (prevE.WindDelta !== 0))\n    {\n      var outPt = this.AddOutPt(prevE, pt);\n      this.AddJoin(result, outPt, e.Top);\n    }\n    return result;\n  };\n  ClipperLib.Clipper.prototype.CreateOutRec = function ()\n  {\n    var result = new ClipperLib.OutRec();\n    result.Idx = -1;\n    result.IsHole = false;\n    result.IsOpen = false;\n    result.FirstLeft = null;\n    result.Pts = null;\n    result.BottomPt = null;\n    result.PolyNode = null;\n    this.m_PolyOuts.push(result);\n    result.Idx = this.m_PolyOuts.length - 1;\n    return result;\n  };\n  ClipperLib.Clipper.prototype.AddOutPt = function (e, pt)\n  {\n    var ToFront = (e.Side == ClipperLib.EdgeSide.esLeft);\n    if (e.OutIdx < 0)\n    {\n      var outRec = this.CreateOutRec();\n      outRec.IsOpen = (e.WindDelta === 0);\n      var newOp = new ClipperLib.OutPt();\n      outRec.Pts = newOp;\n      newOp.Idx = outRec.Idx;\n      //newOp.Pt = pt;\n      newOp.Pt.X = pt.X;\n      newOp.Pt.Y = pt.Y;\n      newOp.Next = newOp;\n      newOp.Prev = newOp;\n      if (!outRec.IsOpen)\n        this.SetHoleState(e, outRec);\n      e.OutIdx = outRec.Idx;\n      //nb: do this after SetZ !\n      return newOp;\n    }\n    else\n    {\n      var outRec = this.m_PolyOuts[e.OutIdx];\n      //OutRec.Pts is the 'Left-most' point & OutRec.Pts.Prev is the 'Right-most'\n      var op = outRec.Pts;\n      if (ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Pt))\n        return op;\n      else if (!ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Prev.Pt))\n        return op.Prev;\n      var newOp = new ClipperLib.OutPt();\n      newOp.Idx = outRec.Idx;\n      //newOp.Pt = pt;\n      newOp.Pt.X = pt.X;\n      newOp.Pt.Y = pt.Y;\n      newOp.Next = op;\n      newOp.Prev = op.Prev;\n      newOp.Prev.Next = newOp;\n      op.Prev = newOp;\n      if (ToFront)\n        outRec.Pts = newOp;\n      return newOp;\n    }\n  };\n  ClipperLib.Clipper.prototype.SwapPoints = function (pt1, pt2)\n  {\n    var tmp = new ClipperLib.IntPoint(pt1.Value);\n    //pt1.Value = pt2.Value;\n    pt1.Value.X = pt2.Value.X;\n    pt1.Value.Y = pt2.Value.Y;\n    //pt2.Value = tmp;\n    pt2.Value.X = tmp.X;\n    pt2.Value.Y = tmp.Y;\n  };\n  ClipperLib.Clipper.prototype.HorzSegmentsOverlap = function (seg1a, seg1b, seg2a, seg2b)\n\t{\n\t\tvar tmp;\n\t\tif (seg1a > seg1b)\n\t\t{\n\t\t\ttmp = seg1a;\n\t\t\tseg1a = seg1b;\n\t\t\tseg1b = tmp;\n\t\t}\n\t\tif (seg2a > seg2b)\n\t\t{\n\t\t\ttmp = seg2a;\n\t\t\tseg2a = seg2b;\n\t\t\tseg2b = tmp;\n\t\t}\n\t\treturn (seg1a < seg2b) && (seg2a < seg1b);\n\t}\n\n  ClipperLib.Clipper.prototype.SetHoleState = function (e, outRec)\n  {\n    var isHole = false;\n    var e2 = e.PrevInAEL;\n    while (e2 !== null)\n    {\n      if (e2.OutIdx >= 0 && e2.WindDelta != 0)\n      {\n        isHole = !isHole;\n        if (outRec.FirstLeft === null)\n          outRec.FirstLeft = this.m_PolyOuts[e2.OutIdx];\n      }\n      e2 = e2.PrevInAEL;\n    }\n    if (isHole)\n      outRec.IsHole = true;\n  };\n  ClipperLib.Clipper.prototype.GetDx = function (pt1, pt2)\n  {\n    if (pt1.Y == pt2.Y)\n      return ClipperLib.ClipperBase.horizontal;\n    else\n      return (pt2.X - pt1.X) / (pt2.Y - pt1.Y);\n  };\n  ClipperLib.Clipper.prototype.FirstIsBottomPt = function (btmPt1, btmPt2)\n  {\n    var p = btmPt1.Prev;\n    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))\n      p = p.Prev;\n    var dx1p = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n    p = btmPt1.Next;\n    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt)) && (p != btmPt1))\n      p = p.Next;\n    var dx1n = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n    p = btmPt2.Prev;\n    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))\n      p = p.Prev;\n    var dx2p = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n    p = btmPt2.Next;\n    while ((ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt)) && (p != btmPt2))\n      p = p.Next;\n    var dx2n = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n    return (dx1p >= dx2p && dx1p >= dx2n) || (dx1n >= dx2p && dx1n >= dx2n);\n  };\n  ClipperLib.Clipper.prototype.GetBottomPt = function (pp)\n  {\n    var dups = null;\n    var p = pp.Next;\n    while (p != pp)\n    {\n      if (p.Pt.Y > pp.Pt.Y)\n      {\n        pp = p;\n        dups = null;\n      }\n      else if (p.Pt.Y == pp.Pt.Y && p.Pt.X <= pp.Pt.X)\n      {\n        if (p.Pt.X < pp.Pt.X)\n        {\n          dups = null;\n          pp = p;\n        }\n        else\n        {\n          if (p.Next != pp && p.Prev != pp)\n            dups = p;\n        }\n      }\n      p = p.Next;\n    }\n    if (dups !== null)\n    {\n      //there appears to be at least 2 vertices at bottomPt so ...\n      while (dups != p)\n      {\n        if (!this.FirstIsBottomPt(p, dups))\n          pp = dups;\n        dups = dups.Next;\n        while (ClipperLib.IntPoint.op_Inequality(dups.Pt, pp.Pt))\n          dups = dups.Next;\n      }\n    }\n    return pp;\n  };\n  ClipperLib.Clipper.prototype.GetLowermostRec = function (outRec1, outRec2)\n  {\n    //work out which polygon fragment has the correct hole state ...\n    if (outRec1.BottomPt === null)\n      outRec1.BottomPt = this.GetBottomPt(outRec1.Pts);\n    if (outRec2.BottomPt === null)\n      outRec2.BottomPt = this.GetBottomPt(outRec2.Pts);\n    var bPt1 = outRec1.BottomPt;\n    var bPt2 = outRec2.BottomPt;\n    if (bPt1.Pt.Y > bPt2.Pt.Y)\n      return outRec1;\n    else if (bPt1.Pt.Y < bPt2.Pt.Y)\n      return outRec2;\n    else if (bPt1.Pt.X < bPt2.Pt.X)\n      return outRec1;\n    else if (bPt1.Pt.X > bPt2.Pt.X)\n      return outRec2;\n    else if (bPt1.Next == bPt1)\n      return outRec2;\n    else if (bPt2.Next == bPt2)\n      return outRec1;\n    else if (this.FirstIsBottomPt(bPt1, bPt2))\n      return outRec1;\n    else\n      return outRec2;\n  };\n  ClipperLib.Clipper.prototype.Param1RightOfParam2 = function (outRec1, outRec2)\n  {\n    do {\n      outRec1 = outRec1.FirstLeft;\n      if (outRec1 == outRec2)\n        return true;\n    }\n    while (outRec1 !== null)\n    return false;\n  };\n  ClipperLib.Clipper.prototype.GetOutRec = function (idx)\n  {\n    var outrec = this.m_PolyOuts[idx];\n    while (outrec != this.m_PolyOuts[outrec.Idx])\n      outrec = this.m_PolyOuts[outrec.Idx];\n    return outrec;\n  };\n  ClipperLib.Clipper.prototype.AppendPolygon = function (e1, e2)\n  {\n    //get the start and ends of both output polygons ...\n    var outRec1 = this.m_PolyOuts[e1.OutIdx];\n    var outRec2 = this.m_PolyOuts[e2.OutIdx];\n    var holeStateRec;\n    if (this.Param1RightOfParam2(outRec1, outRec2))\n      holeStateRec = outRec2;\n    else if (this.Param1RightOfParam2(outRec2, outRec1))\n      holeStateRec = outRec1;\n    else\n      holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n    var p1_lft = outRec1.Pts;\n    var p1_rt = p1_lft.Prev;\n    var p2_lft = outRec2.Pts;\n    var p2_rt = p2_lft.Prev;\n    var side;\n    //join e2 poly onto e1 poly and delete pointers to e2 ...\n    if (e1.Side == ClipperLib.EdgeSide.esLeft)\n    {\n      if (e2.Side == ClipperLib.EdgeSide.esLeft)\n      {\n        //z y x a b c\n        this.ReversePolyPtLinks(p2_lft);\n        p2_lft.Next = p1_lft;\n        p1_lft.Prev = p2_lft;\n        p1_rt.Next = p2_rt;\n        p2_rt.Prev = p1_rt;\n        outRec1.Pts = p2_rt;\n      }\n      else\n      {\n        //x y z a b c\n        p2_rt.Next = p1_lft;\n        p1_lft.Prev = p2_rt;\n        p2_lft.Prev = p1_rt;\n        p1_rt.Next = p2_lft;\n        outRec1.Pts = p2_lft;\n      }\n      side = ClipperLib.EdgeSide.esLeft;\n    }\n    else\n    {\n      if (e2.Side == ClipperLib.EdgeSide.esRight)\n      {\n        //a b c z y x\n        this.ReversePolyPtLinks(p2_lft);\n        p1_rt.Next = p2_rt;\n        p2_rt.Prev = p1_rt;\n        p2_lft.Next = p1_lft;\n        p1_lft.Prev = p2_lft;\n      }\n      else\n      {\n        //a b c x y z\n        p1_rt.Next = p2_lft;\n        p2_lft.Prev = p1_rt;\n        p1_lft.Prev = p2_rt;\n        p2_rt.Next = p1_lft;\n      }\n      side = ClipperLib.EdgeSide.esRight;\n    }\n    outRec1.BottomPt = null;\n    if (holeStateRec == outRec2)\n    {\n      if (outRec2.FirstLeft != outRec1)\n        outRec1.FirstLeft = outRec2.FirstLeft;\n      outRec1.IsHole = outRec2.IsHole;\n    }\n    outRec2.Pts = null;\n    outRec2.BottomPt = null;\n    outRec2.FirstLeft = outRec1;\n    var OKIdx = e1.OutIdx;\n    var ObsoleteIdx = e2.OutIdx;\n    e1.OutIdx = -1;\n    //nb: safe because we only get here via AddLocalMaxPoly\n    e2.OutIdx = -1;\n    var e = this.m_ActiveEdges;\n    while (e !== null)\n    {\n      if (e.OutIdx == ObsoleteIdx)\n      {\n        e.OutIdx = OKIdx;\n        e.Side = side;\n        break;\n      }\n      e = e.NextInAEL;\n    }\n    outRec2.Idx = outRec1.Idx;\n  };\n  ClipperLib.Clipper.prototype.ReversePolyPtLinks = function (pp)\n  {\n    if (pp === null)\n      return;\n    var pp1;\n    var pp2;\n    pp1 = pp;\n    do {\n      pp2 = pp1.Next;\n      pp1.Next = pp1.Prev;\n      pp1.Prev = pp2;\n      pp1 = pp2;\n    }\n    while (pp1 != pp)\n  };\n  ClipperLib.Clipper.SwapSides = function (edge1, edge2)\n  {\n    var side = edge1.Side;\n    edge1.Side = edge2.Side;\n    edge2.Side = side;\n  };\n  ClipperLib.Clipper.SwapPolyIndexes = function (edge1, edge2)\n  {\n    var outIdx = edge1.OutIdx;\n    edge1.OutIdx = edge2.OutIdx;\n    edge2.OutIdx = outIdx;\n  };\n  ClipperLib.Clipper.prototype.IntersectEdges = function (e1, e2, pt)\n  {\n    //e1 will be to the left of e2 BELOW the intersection. Therefore e1 is before\n    //e2 in AEL except when e1 is being inserted at the intersection point ...\n    var e1Contributing = (e1.OutIdx >= 0);\n    var e2Contributing = (e2.OutIdx >= 0);\n\n    if (use_xyz)\n    \tthis.SetZ(pt, e1, e2);\n\n    if (use_lines)\n    {\n      //if either edge is on an OPEN path ...\n      if (e1.WindDelta === 0 || e2.WindDelta === 0)\n      {\n        //ignore subject-subject open path intersections UNLESS they\n        //are both open paths, AND they are both 'contributing maximas' ...\n\t\t\t\tif (e1.WindDelta == 0 && e2.WindDelta == 0) return;\n        //if intersecting a subj line with a subj poly ...\n        else if (e1.PolyTyp == e2.PolyTyp &&\n          e1.WindDelta != e2.WindDelta && this.m_ClipType == ClipperLib.ClipType.ctUnion)\n        {\n          if (e1.WindDelta === 0)\n          {\n            if (e2Contributing)\n            {\n              this.AddOutPt(e1, pt);\n              if (e1Contributing)\n                e1.OutIdx = -1;\n            }\n          }\n          else\n          {\n            if (e1Contributing)\n            {\n              this.AddOutPt(e2, pt);\n              if (e2Contributing)\n                e2.OutIdx = -1;\n            }\n          }\n        }\n        else if (e1.PolyTyp != e2.PolyTyp)\n        {\n          if ((e1.WindDelta === 0) && Math.abs(e2.WindCnt) == 1 &&\n            (this.m_ClipType != ClipperLib.ClipType.ctUnion || e2.WindCnt2 === 0))\n          {\n            this.AddOutPt(e1, pt);\n            if (e1Contributing)\n              e1.OutIdx = -1;\n          }\n          else if ((e2.WindDelta === 0) && (Math.abs(e1.WindCnt) == 1) &&\n            (this.m_ClipType != ClipperLib.ClipType.ctUnion || e1.WindCnt2 === 0))\n          {\n            this.AddOutPt(e2, pt);\n            if (e2Contributing)\n              e2.OutIdx = -1;\n          }\n        }\n        return;\n      }\n    }\n    //update winding counts...\n    //assumes that e1 will be to the Right of e2 ABOVE the intersection\n    if (e1.PolyTyp == e2.PolyTyp)\n    {\n      if (this.IsEvenOddFillType(e1))\n      {\n        var oldE1WindCnt = e1.WindCnt;\n        e1.WindCnt = e2.WindCnt;\n        e2.WindCnt = oldE1WindCnt;\n      }\n      else\n      {\n        if (e1.WindCnt + e2.WindDelta === 0)\n          e1.WindCnt = -e1.WindCnt;\n        else\n          e1.WindCnt += e2.WindDelta;\n        if (e2.WindCnt - e1.WindDelta === 0)\n          e2.WindCnt = -e2.WindCnt;\n        else\n          e2.WindCnt -= e1.WindDelta;\n      }\n    }\n    else\n    {\n      if (!this.IsEvenOddFillType(e2))\n        e1.WindCnt2 += e2.WindDelta;\n      else\n        e1.WindCnt2 = (e1.WindCnt2 === 0) ? 1 : 0;\n      if (!this.IsEvenOddFillType(e1))\n        e2.WindCnt2 -= e1.WindDelta;\n      else\n        e2.WindCnt2 = (e2.WindCnt2 === 0) ? 1 : 0;\n    }\n    var e1FillType, e2FillType, e1FillType2, e2FillType2;\n    if (e1.PolyTyp == ClipperLib.PolyType.ptSubject)\n    {\n      e1FillType = this.m_SubjFillType;\n      e1FillType2 = this.m_ClipFillType;\n    }\n    else\n    {\n      e1FillType = this.m_ClipFillType;\n      e1FillType2 = this.m_SubjFillType;\n    }\n    if (e2.PolyTyp == ClipperLib.PolyType.ptSubject)\n    {\n      e2FillType = this.m_SubjFillType;\n      e2FillType2 = this.m_ClipFillType;\n    }\n    else\n    {\n      e2FillType = this.m_ClipFillType;\n      e2FillType2 = this.m_SubjFillType;\n    }\n    var e1Wc, e2Wc;\n    switch (e1FillType)\n    {\n    case ClipperLib.PolyFillType.pftPositive:\n      e1Wc = e1.WindCnt;\n      break;\n    case ClipperLib.PolyFillType.pftNegative:\n      e1Wc = -e1.WindCnt;\n      break;\n    default:\n      e1Wc = Math.abs(e1.WindCnt);\n      break;\n    }\n    switch (e2FillType)\n    {\n    case ClipperLib.PolyFillType.pftPositive:\n      e2Wc = e2.WindCnt;\n      break;\n    case ClipperLib.PolyFillType.pftNegative:\n      e2Wc = -e2.WindCnt;\n      break;\n    default:\n      e2Wc = Math.abs(e2.WindCnt);\n      break;\n    }\n    if (e1Contributing && e2Contributing)\n    {\n\t\t\tif ((e1Wc != 0 && e1Wc != 1) || (e2Wc != 0 && e2Wc != 1) ||\n\t\t\t(e1.PolyTyp != e2.PolyTyp && this.m_ClipType != ClipperLib.ClipType.ctXor))\n\t\t\t{\n\t\t\t\tthis.AddLocalMaxPoly(e1, e2, pt);\n\t\t\t}\n      else\n      {\n        this.AddOutPt(e1, pt);\n        this.AddOutPt(e2, pt);\n        ClipperLib.Clipper.SwapSides(e1, e2);\n        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n      }\n    }\n    else if (e1Contributing)\n    {\n      if (e2Wc === 0 || e2Wc == 1)\n      {\n        this.AddOutPt(e1, pt);\n        ClipperLib.Clipper.SwapSides(e1, e2);\n        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n      }\n    }\n    else if (e2Contributing)\n    {\n      if (e1Wc === 0 || e1Wc == 1)\n      {\n        this.AddOutPt(e2, pt);\n        ClipperLib.Clipper.SwapSides(e1, e2);\n        ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n      }\n    }\n\t\telse if ( (e1Wc == 0 || e1Wc == 1) && (e2Wc == 0 || e2Wc == 1))\n    {\n      //neither edge is currently contributing ...\n      var e1Wc2, e2Wc2;\n      switch (e1FillType2)\n      {\n      case ClipperLib.PolyFillType.pftPositive:\n        e1Wc2 = e1.WindCnt2;\n        break;\n      case ClipperLib.PolyFillType.pftNegative:\n        e1Wc2 = -e1.WindCnt2;\n        break;\n      default:\n        e1Wc2 = Math.abs(e1.WindCnt2);\n        break;\n      }\n      switch (e2FillType2)\n      {\n      case ClipperLib.PolyFillType.pftPositive:\n        e2Wc2 = e2.WindCnt2;\n        break;\n      case ClipperLib.PolyFillType.pftNegative:\n        e2Wc2 = -e2.WindCnt2;\n        break;\n      default:\n        e2Wc2 = Math.abs(e2.WindCnt2);\n        break;\n      }\n      if (e1.PolyTyp != e2.PolyTyp)\n      {\n        this.AddLocalMinPoly(e1, e2, pt);\n      }\n      else if (e1Wc == 1 && e2Wc == 1)\n        switch (this.m_ClipType)\n        {\n        case ClipperLib.ClipType.ctIntersection:\n          if (e1Wc2 > 0 && e2Wc2 > 0)\n            this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        case ClipperLib.ClipType.ctUnion:\n          if (e1Wc2 <= 0 && e2Wc2 <= 0)\n            this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        case ClipperLib.ClipType.ctDifference:\n          if (((e1.PolyTyp == ClipperLib.PolyType.ptClip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||\n            ((e1.PolyTyp == ClipperLib.PolyType.ptSubject) && (e1Wc2 <= 0) && (e2Wc2 <= 0)))\n            this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        case ClipperLib.ClipType.ctXor:\n          this.AddLocalMinPoly(e1, e2, pt);\n          break;\n        }\n      else\n        ClipperLib.Clipper.SwapSides(e1, e2);\n    }\n  };\n  ClipperLib.Clipper.prototype.DeleteFromAEL = function (e)\n  {\n    var AelPrev = e.PrevInAEL;\n    var AelNext = e.NextInAEL;\n    if (AelPrev === null && AelNext === null && (e != this.m_ActiveEdges))\n      return;\n    //already deleted\n    if (AelPrev !== null)\n      AelPrev.NextInAEL = AelNext;\n    else\n      this.m_ActiveEdges = AelNext;\n    if (AelNext !== null)\n      AelNext.PrevInAEL = AelPrev;\n    e.NextInAEL = null;\n    e.PrevInAEL = null;\n  };\n  ClipperLib.Clipper.prototype.DeleteFromSEL = function (e)\n  {\n    var SelPrev = e.PrevInSEL;\n    var SelNext = e.NextInSEL;\n    if (SelPrev === null && SelNext === null && (e != this.m_SortedEdges))\n      return;\n    //already deleted\n    if (SelPrev !== null)\n      SelPrev.NextInSEL = SelNext;\n    else\n      this.m_SortedEdges = SelNext;\n    if (SelNext !== null)\n      SelNext.PrevInSEL = SelPrev;\n    e.NextInSEL = null;\n    e.PrevInSEL = null;\n  };\n  ClipperLib.Clipper.prototype.UpdateEdgeIntoAEL = function (e)\n  {\n    if (e.NextInLML === null)\n      ClipperLib.Error(\"UpdateEdgeIntoAEL: invalid call\");\n    var AelPrev = e.PrevInAEL;\n    var AelNext = e.NextInAEL;\n    e.NextInLML.OutIdx = e.OutIdx;\n    if (AelPrev !== null)\n      AelPrev.NextInAEL = e.NextInLML;\n    else\n      this.m_ActiveEdges = e.NextInLML;\n    if (AelNext !== null)\n      AelNext.PrevInAEL = e.NextInLML;\n    e.NextInLML.Side = e.Side;\n    e.NextInLML.WindDelta = e.WindDelta;\n    e.NextInLML.WindCnt = e.WindCnt;\n    e.NextInLML.WindCnt2 = e.WindCnt2;\n    e = e.NextInLML;\n    //    e.Curr = e.Bot;\n    e.Curr.X = e.Bot.X;\n    e.Curr.Y = e.Bot.Y;\n    e.PrevInAEL = AelPrev;\n    e.NextInAEL = AelNext;\n    if (!ClipperLib.ClipperBase.IsHorizontal(e))\n      this.InsertScanbeam(e.Top.Y);\n    return e;\n  };\n  ClipperLib.Clipper.prototype.ProcessHorizontals = function (isTopOfScanbeam)\n  {\n    var horzEdge = this.m_SortedEdges;\n    while (horzEdge !== null)\n    {\n      this.DeleteFromSEL(horzEdge);\n      this.ProcessHorizontal(horzEdge, isTopOfScanbeam);\n      horzEdge = this.m_SortedEdges;\n    }\n  };\n  ClipperLib.Clipper.prototype.GetHorzDirection = function (HorzEdge, $var)\n  {\n    if (HorzEdge.Bot.X < HorzEdge.Top.X)\n    {\n        $var.Left = HorzEdge.Bot.X;\n        $var.Right = HorzEdge.Top.X;\n        $var.Dir = ClipperLib.Direction.dLeftToRight;\n    }\n    else\n    {\n        $var.Left = HorzEdge.Top.X;\n        $var.Right = HorzEdge.Bot.X;\n        $var.Dir = ClipperLib.Direction.dRightToLeft;\n    }\n  };\n  ClipperLib.Clipper.prototype.ProcessHorizontal = function (horzEdge, isTopOfScanbeam)\n  {\n    var $var = {Dir: null, Left: null, Right: null};\n    this.GetHorzDirection(horzEdge, $var);\n    var dir = $var.Dir;\n    var horzLeft = $var.Left;\n    var horzRight = $var.Right;\n\n    var eLastHorz = horzEdge,\n      eMaxPair = null;\n    while (eLastHorz.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(eLastHorz.NextInLML))\n      eLastHorz = eLastHorz.NextInLML;\n    if (eLastHorz.NextInLML === null)\n      eMaxPair = this.GetMaximaPair(eLastHorz);\n    for (;;)\n    {\n      var IsLastHorz = (horzEdge == eLastHorz);\n      var e = this.GetNextInAEL(horzEdge, dir);\n      while (e !== null)\n      {\n        //Break if we've got to the end of an intermediate horizontal edge ...\n        //nb: Smaller Dx's are to the right of larger Dx's ABOVE the horizontal.\n        if (e.Curr.X == horzEdge.Top.X && horzEdge.NextInLML !== null && e.Dx < horzEdge.NextInLML.Dx)\n          break;\n        var eNext = this.GetNextInAEL(e, dir);\n        //saves eNext for later\n        if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X <= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X >= horzLeft))\n        {\n          //so far we're still in range of the horizontal Edge  but make sure\n          //we're at the last of consec. horizontals when matching with eMaxPair\n          if (e == eMaxPair && IsLastHorz)\n          {\n\t\t\t\t\t\tif (horzEdge.OutIdx >= 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\t\t\t\t\t\t\tvar eNextHorz = this.m_SortedEdges;\n\t\t\t\t\t\t\twhile (eNextHorz !== null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (eNextHorz.OutIdx >= 0 &&\n\t\t\t\t\t\t\t\t\tthis.HorzSegmentsOverlap(horzEdge.Bot.X,\n\t\t\t\t\t\t\t\t\thorzEdge.Top.X, eNextHorz.Bot.X, eNextHorz.Top.X))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tvar op2 = this.AddOutPt(eNextHorz, eNextHorz.Bot);\n\t\t\t\t\t\t\t\t\tthis.AddJoin(op2, op1, eNextHorz.Top);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\teNextHorz = eNextHorz.NextInSEL;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.AddGhostJoin(op1, horzEdge.Bot);\n\t\t\t\t\t\t\tthis.AddLocalMaxPoly(horzEdge, eMaxPair, horzEdge.Top);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.DeleteFromAEL(horzEdge);\n\t\t\t\t\t\tthis.DeleteFromAEL(eMaxPair);\n            return;\n          }\n          else if (dir == ClipperLib.Direction.dLeftToRight)\n          {\n            var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n            this.IntersectEdges(horzEdge, e, Pt);\n          }\n          else\n          {\n            var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n            this.IntersectEdges(e, horzEdge, Pt);\n          }\n          this.SwapPositionsInAEL(horzEdge, e);\n        }\n        else if ((dir == ClipperLib.Direction.dLeftToRight && e.Curr.X >= horzRight) || (dir == ClipperLib.Direction.dRightToLeft && e.Curr.X <= horzLeft))\n          break;\n        e = eNext;\n      }\n      //end while\n      if (horzEdge.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(horzEdge.NextInLML))\n      {\n        horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n        if (horzEdge.OutIdx >= 0)\n          this.AddOutPt(horzEdge, horzEdge.Bot);\n\n          var $var = {Dir: dir, Left: horzLeft, Right: horzRight};\n          this.GetHorzDirection(horzEdge, $var);\n          dir = $var.Dir;\n          horzLeft = $var.Left;\n          horzRight = $var.Right;\n      }\n      else\n        break;\n    }\n    //end for (;;)\n    if (horzEdge.NextInLML !== null)\n    {\n      if (horzEdge.OutIdx >= 0)\n      {\n        var op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n\t\t\t\tif (isTopOfScanbeam) this.AddGhostJoin(op1, horzEdge.Bot);\n        horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n        if (horzEdge.WindDelta === 0)\n          return;\n        //nb: HorzEdge is no longer horizontal here\n        var ePrev = horzEdge.PrevInAEL;\n        var eNext = horzEdge.NextInAEL;\n        if (ePrev !== null && ePrev.Curr.X == horzEdge.Bot.X &&\n          ePrev.Curr.Y == horzEdge.Bot.Y && ePrev.WindDelta !== 0 &&\n          (ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&\n            ClipperLib.ClipperBase.SlopesEqual(horzEdge, ePrev, this.m_UseFullRange)))\n        {\n          var op2 = this.AddOutPt(ePrev, horzEdge.Bot);\n          this.AddJoin(op1, op2, horzEdge.Top);\n        }\n        else if (eNext !== null && eNext.Curr.X == horzEdge.Bot.X &&\n          eNext.Curr.Y == horzEdge.Bot.Y && eNext.WindDelta !== 0 &&\n          eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&\n          ClipperLib.ClipperBase.SlopesEqual(horzEdge, eNext, this.m_UseFullRange))\n        {\n          var op2 = this.AddOutPt(eNext, horzEdge.Bot);\n          this.AddJoin(op1, op2, horzEdge.Top);\n        }\n      }\n      else horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n    }\n  \telse\n    {\n      if (horzEdge.OutIdx >= 0)\n        this.AddOutPt(horzEdge, horzEdge.Top);\n      this.DeleteFromAEL(horzEdge);\n    }\n  };\n  ClipperLib.Clipper.prototype.GetNextInAEL = function (e, Direction)\n  {\n    return Direction == ClipperLib.Direction.dLeftToRight ? e.NextInAEL : e.PrevInAEL;\n  };\n  ClipperLib.Clipper.prototype.IsMinima = function (e)\n  {\n    return e !== null && (e.Prev.NextInLML != e) && (e.Next.NextInLML != e);\n  };\n  ClipperLib.Clipper.prototype.IsMaxima = function (e, Y)\n  {\n    return (e !== null && e.Top.Y == Y && e.NextInLML === null);\n  };\n  ClipperLib.Clipper.prototype.IsIntermediate = function (e, Y)\n  {\n    return (e.Top.Y == Y && e.NextInLML !== null);\n  };\n  ClipperLib.Clipper.prototype.GetMaximaPair = function (e)\n  {\n    var result = null;\n    if ((ClipperLib.IntPoint.op_Equality(e.Next.Top, e.Top)) && e.Next.NextInLML === null)\n      result = e.Next;\n    else if ((ClipperLib.IntPoint.op_Equality(e.Prev.Top, e.Top)) && e.Prev.NextInLML === null)\n      result = e.Prev;\n    if (result !== null && (result.OutIdx == -2 || (result.NextInAEL == result.PrevInAEL && !ClipperLib.ClipperBase.IsHorizontal(result))))\n      return null;\n    return result;\n  };\n\n  ClipperLib.Clipper.prototype.ProcessIntersections = function (topY)\n  {\n    if (this.m_ActiveEdges == null)\n      return true;\n    try\n    {\n      this.BuildIntersectList(topY);\n      if (this.m_IntersectList.length == 0)\n        return true;\n      if (this.m_IntersectList.length == 1 || this.FixupIntersectionOrder())\n        this.ProcessIntersectList();\n      else\n        return false;\n    }\n    catch ($$e2)\n    {\n      this.m_SortedEdges = null;\n      this.m_IntersectList.length = 0;\n      ClipperLib.Error(\"ProcessIntersections error\");\n    }\n    this.m_SortedEdges = null;\n    return true;\n  };\n  ClipperLib.Clipper.prototype.BuildIntersectList = function (topY)\n  {\n    if (this.m_ActiveEdges === null)\n      return;\n    //prepare for sorting ...\n    var e = this.m_ActiveEdges;\n    //console.log(JSON.stringify(JSON.decycle( e )));\n    this.m_SortedEdges = e;\n    while (e !== null)\n    {\n      e.PrevInSEL = e.PrevInAEL;\n      e.NextInSEL = e.NextInAEL;\n      e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n      e = e.NextInAEL;\n    }\n    //bubblesort ...\n    var isModified = true;\n    while (isModified && this.m_SortedEdges !== null)\n    {\n      isModified = false;\n      e = this.m_SortedEdges;\n      while (e.NextInSEL !== null)\n      {\n        var eNext = e.NextInSEL;\n        var pt = new ClipperLib.IntPoint();\n        //console.log(\"e.Curr.X: \" + e.Curr.X + \" eNext.Curr.X\" + eNext.Curr.X);\n        if (e.Curr.X > eNext.Curr.X)\n        {\n\t\t\t\t\tthis.IntersectPoint(e, eNext, pt);\n          var newNode = new ClipperLib.IntersectNode();\n          newNode.Edge1 = e;\n          newNode.Edge2 = eNext;\n          //newNode.Pt = pt;\n          newNode.Pt.X = pt.X;\n          newNode.Pt.Y = pt.Y;\n          this.m_IntersectList.push(newNode);\n          this.SwapPositionsInSEL(e, eNext);\n          isModified = true;\n        }\n        else\n          e = eNext;\n      }\n      if (e.PrevInSEL !== null)\n        e.PrevInSEL.NextInSEL = null;\n      else\n        break;\n    }\n    this.m_SortedEdges = null;\n  };\n  ClipperLib.Clipper.prototype.EdgesAdjacent = function (inode)\n  {\n    return (inode.Edge1.NextInSEL == inode.Edge2) || (inode.Edge1.PrevInSEL == inode.Edge2);\n  };\n  ClipperLib.Clipper.IntersectNodeSort = function (node1, node2)\n  {\n    //the following typecast is safe because the differences in Pt.Y will\n    //be limited to the height of the scanbeam.\n    return (node2.Pt.Y - node1.Pt.Y);\n  };\n  ClipperLib.Clipper.prototype.FixupIntersectionOrder = function ()\n  {\n    //pre-condition: intersections are sorted bottom-most first.\n    //Now it's crucial that intersections are made only between adjacent edges,\n    //so to ensure this the order of intersections may need adjusting ...\n    this.m_IntersectList.sort(this.m_IntersectNodeComparer);\n    this.CopyAELToSEL();\n    var cnt = this.m_IntersectList.length;\n    for (var i = 0; i < cnt; i++)\n    {\n      if (!this.EdgesAdjacent(this.m_IntersectList[i]))\n      {\n        var j = i + 1;\n        while (j < cnt && !this.EdgesAdjacent(this.m_IntersectList[j]))\n          j++;\n        if (j == cnt)\n          return false;\n        var tmp = this.m_IntersectList[i];\n        this.m_IntersectList[i] = this.m_IntersectList[j];\n        this.m_IntersectList[j] = tmp;\n      }\n      this.SwapPositionsInSEL(this.m_IntersectList[i].Edge1, this.m_IntersectList[i].Edge2);\n    }\n    return true;\n  };\n  ClipperLib.Clipper.prototype.ProcessIntersectList = function ()\n  {\n    for (var i = 0, ilen = this.m_IntersectList.length; i < ilen; i++)\n    {\n      var iNode = this.m_IntersectList[i];\n      this.IntersectEdges(iNode.Edge1, iNode.Edge2, iNode.Pt);\n      this.SwapPositionsInAEL(iNode.Edge1, iNode.Edge2);\n    }\n    this.m_IntersectList.length = 0;\n  };\n  /*\n  --------------------------------\n  Round speedtest: http://jsperf.com/fastest-round\n  --------------------------------\n  */\n  var R1 = function (a)\n  {\n    return a < 0 ? Math.ceil(a - 0.5) : Math.round(a)\n  };\n  var R2 = function (a)\n  {\n    return a < 0 ? Math.ceil(a - 0.5) : Math.floor(a + 0.5)\n  };\n  var R3 = function (a)\n  {\n    return a < 0 ? -Math.round(Math.abs(a)) : Math.round(a)\n  };\n  var R4 = function (a)\n  {\n    if (a < 0)\n    {\n      a -= 0.5;\n      return a < -2147483648 ? Math.ceil(a) : a | 0;\n    }\n    else\n    {\n      a += 0.5;\n      return a > 2147483647 ? Math.floor(a) : a | 0;\n    }\n  };\n  if (browser.msie) ClipperLib.Clipper.Round = R1;\n  else if (browser.chromium) ClipperLib.Clipper.Round = R3;\n  else if (browser.safari) ClipperLib.Clipper.Round = R4;\n  else ClipperLib.Clipper.Round = R2; // eg. browser.chrome || browser.firefox || browser.opera\n  ClipperLib.Clipper.TopX = function (edge, currentY)\n  {\n    //if (edge.Bot == edge.Curr) alert (\"edge.Bot = edge.Curr\");\n    //if (edge.Bot == edge.Top) alert (\"edge.Bot = edge.Top\");\n    if (currentY == edge.Top.Y)\n      return edge.Top.X;\n    return edge.Bot.X + ClipperLib.Clipper.Round(edge.Dx * (currentY - edge.Bot.Y));\n  };\n  ClipperLib.Clipper.prototype.IntersectPoint = function (edge1, edge2, ip)\n  {\n    ip.X = 0;\n    ip.Y = 0;\n    var b1, b2;\n    //nb: with very large coordinate values, it's possible for SlopesEqual() to\n    //return false but for the edge.Dx value be equal due to double precision rounding.\n    if (edge1.Dx == edge2.Dx)\n\t\t{\n\t\t\tip.Y = edge1.Curr.Y;\n\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t\treturn;\n    }\n    if (edge1.Delta.X === 0)\n    {\n      ip.X = edge1.Bot.X;\n      if (ClipperLib.ClipperBase.IsHorizontal(edge2))\n      {\n        ip.Y = edge2.Bot.Y;\n      }\n      else\n      {\n        b2 = edge2.Bot.Y - (edge2.Bot.X / edge2.Dx);\n        ip.Y = ClipperLib.Clipper.Round(ip.X / edge2.Dx + b2);\n      }\n    }\n    else if (edge2.Delta.X === 0)\n    {\n      ip.X = edge2.Bot.X;\n      if (ClipperLib.ClipperBase.IsHorizontal(edge1))\n      {\n        ip.Y = edge1.Bot.Y;\n      }\n      else\n      {\n        b1 = edge1.Bot.Y - (edge1.Bot.X / edge1.Dx);\n        ip.Y = ClipperLib.Clipper.Round(ip.X / edge1.Dx + b1);\n      }\n    }\n    else\n    {\n      b1 = edge1.Bot.X - edge1.Bot.Y * edge1.Dx;\n      b2 = edge2.Bot.X - edge2.Bot.Y * edge2.Dx;\n      var q = (b2 - b1) / (edge1.Dx - edge2.Dx);\n      ip.Y = ClipperLib.Clipper.Round(q);\n      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n        ip.X = ClipperLib.Clipper.Round(edge1.Dx * q + b1);\n      else\n        ip.X = ClipperLib.Clipper.Round(edge2.Dx * q + b2);\n    }\n    if (ip.Y < edge1.Top.Y || ip.Y < edge2.Top.Y)\n    {\n      if (edge1.Top.Y > edge2.Top.Y)\n      {\n        ip.Y = edge1.Top.Y;\n        ip.X = ClipperLib.Clipper.TopX(edge2, edge1.Top.Y);\n        return ip.X < edge1.Top.X;\n      }\n      else\n        ip.Y = edge2.Top.Y;\n      if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx))\n        ip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n      else\n        ip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n    }\n\t\t//finally, don't allow 'ip' to be BELOW curr.Y (ie bottom of scanbeam) ...\n\t\tif (ip.Y > edge1.Curr.Y)\n\t\t{\n\t\t\tip.Y = edge1.Curr.Y;\n\t\t\t//better to use the more vertical edge to derive X ...\n\t\t\tif (Math.abs(edge1.Dx) > Math.abs(edge2.Dx))\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n\t\t\telse\n\t\t\t\tip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);\n\t\t}\n  };\n\n  ClipperLib.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function (topY)\n  {\n    var e = this.m_ActiveEdges;\n    while (e !== null)\n    {\n      //1. process maxima, treating them as if they're 'bent' horizontal edges,\n      //   but exclude maxima with horizontal edges. nb: e can't be a horizontal.\n      var IsMaximaEdge = this.IsMaxima(e, topY);\n      if (IsMaximaEdge)\n      {\n        var eMaxPair = this.GetMaximaPair(e);\n        IsMaximaEdge = (eMaxPair === null || !ClipperLib.ClipperBase.IsHorizontal(eMaxPair));\n      }\n      if (IsMaximaEdge)\n      {\n        var ePrev = e.PrevInAEL;\n        this.DoMaxima(e);\n        if (ePrev === null)\n          e = this.m_ActiveEdges;\n        else\n          e = ePrev.NextInAEL;\n      }\n      else\n      {\n        //2. promote horizontal edges, otherwise update Curr.X and Curr.Y ...\n        if (this.IsIntermediate(e, topY) && ClipperLib.ClipperBase.IsHorizontal(e.NextInLML))\n        {\n          e = this.UpdateEdgeIntoAEL(e);\n          if (e.OutIdx >= 0)\n            this.AddOutPt(e, e.Bot);\n          this.AddEdgeToSEL(e);\n        }\n        else\n        {\n          e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n          e.Curr.Y = topY;\n        }\n        if (this.StrictlySimple)\n        {\n          var ePrev = e.PrevInAEL;\n          if ((e.OutIdx >= 0) && (e.WindDelta !== 0) && ePrev !== null &&\n            (ePrev.OutIdx >= 0) && (ePrev.Curr.X == e.Curr.X) &&\n            (ePrev.WindDelta !== 0))\n          {\n           \tvar ip = new ClipperLib.IntPoint(e.Curr);\n\n\t\t\t\t\t\tif(use_xyz)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthis.SetZ(ip, ePrev, e);\n\t\t\t\t\t\t}\n\n            var op = this.AddOutPt(ePrev, ip);\n            var op2 = this.AddOutPt(e, ip);\n            this.AddJoin(op, op2, ip);\n            //StrictlySimple (type-3) join\n          }\n        }\n        e = e.NextInAEL;\n      }\n    }\n    //3. Process horizontals at the Top of the scanbeam ...\n    this.ProcessHorizontals(true);\n    //4. Promote intermediate vertices ...\n    e = this.m_ActiveEdges;\n    while (e !== null)\n    {\n      if (this.IsIntermediate(e, topY))\n      {\n        var op = null;\n        if (e.OutIdx >= 0)\n          op = this.AddOutPt(e, e.Top);\n        e = this.UpdateEdgeIntoAEL(e);\n        //if output polygons share an edge, they'll need joining later ...\n        var ePrev = e.PrevInAEL;\n        var eNext = e.NextInAEL;\n        if (ePrev !== null && ePrev.Curr.X == e.Bot.X &&\n          ePrev.Curr.Y == e.Bot.Y && op !== null &&\n          ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y &&\n          ClipperLib.ClipperBase.SlopesEqual(e, ePrev, this.m_UseFullRange) &&\n          (e.WindDelta !== 0) && (ePrev.WindDelta !== 0))\n        {\n          var op2 = this.AddOutPt(ePrev, e.Bot);\n          this.AddJoin(op, op2, e.Top);\n        }\n        else if (eNext !== null && eNext.Curr.X == e.Bot.X &&\n          eNext.Curr.Y == e.Bot.Y && op !== null &&\n          eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y &&\n          ClipperLib.ClipperBase.SlopesEqual(e, eNext, this.m_UseFullRange) &&\n          (e.WindDelta !== 0) && (eNext.WindDelta !== 0))\n        {\n          var op2 = this.AddOutPt(eNext, e.Bot);\n          this.AddJoin(op, op2, e.Top);\n        }\n      }\n      e = e.NextInAEL;\n    }\n  };\n  ClipperLib.Clipper.prototype.DoMaxima = function (e)\n  {\n    var eMaxPair = this.GetMaximaPair(e);\n    if (eMaxPair === null)\n    {\n      if (e.OutIdx >= 0)\n        this.AddOutPt(e, e.Top);\n      this.DeleteFromAEL(e);\n      return;\n    }\n    var eNext = e.NextInAEL;\n    var use_lines = true;\n    while (eNext !== null && eNext != eMaxPair)\n    {\n      this.IntersectEdges(e, eNext, e.Top);\n      this.SwapPositionsInAEL(e, eNext);\n      eNext = e.NextInAEL;\n    }\n    if (e.OutIdx == -1 && eMaxPair.OutIdx == -1)\n    {\n      this.DeleteFromAEL(e);\n      this.DeleteFromAEL(eMaxPair);\n    }\n    else if (e.OutIdx >= 0 && eMaxPair.OutIdx >= 0)\n    {\n    \tif (e.OutIdx >= 0) this.AddLocalMaxPoly(e, eMaxPair, e.Top);\n      this.DeleteFromAEL(e);\n      this.DeleteFromAEL(eMaxPair);\n    }\n    else if (use_lines && e.WindDelta === 0)\n    {\n      if (e.OutIdx >= 0)\n      {\n        this.AddOutPt(e, e.Top);\n        e.OutIdx = -1;\n      }\n      this.DeleteFromAEL(e);\n      if (eMaxPair.OutIdx >= 0)\n      {\n        this.AddOutPt(eMaxPair, e.Top);\n        eMaxPair.OutIdx = -1;\n      }\n      this.DeleteFromAEL(eMaxPair);\n    }\n    else\n      ClipperLib.Error(\"DoMaxima error\");\n  };\n  ClipperLib.Clipper.ReversePaths = function (polys)\n  {\n    for (var i = 0, len = polys.length; i < len; i++)\n      polys[i].reverse();\n  };\n  ClipperLib.Clipper.Orientation = function (poly)\n  {\n    return ClipperLib.Clipper.Area(poly) >= 0;\n  };\n  ClipperLib.Clipper.prototype.PointCount = function (pts)\n  {\n    if (pts === null)\n      return 0;\n    var result = 0;\n    var p = pts;\n    do {\n      result++;\n      p = p.Next;\n    }\n    while (p != pts)\n    return result;\n  };\n  ClipperLib.Clipper.prototype.BuildResult = function (polyg)\n  {\n    ClipperLib.Clear(polyg);\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n      var outRec = this.m_PolyOuts[i];\n      if (outRec.Pts === null)\n        continue;\n      var p = outRec.Pts.Prev;\n      var cnt = this.PointCount(p);\n      if (cnt < 2)\n        continue;\n      var pg = new Array(cnt);\n      for (var j = 0; j < cnt; j++)\n      {\n        pg[j] = p.Pt;\n        p = p.Prev;\n      }\n      polyg.push(pg);\n    }\n  };\n  ClipperLib.Clipper.prototype.BuildResult2 = function (polytree)\n  {\n    polytree.Clear();\n    //add each output polygon/contour to polytree ...\n    //polytree.m_AllPolys.set_Capacity(this.m_PolyOuts.length);\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n      var outRec = this.m_PolyOuts[i];\n      var cnt = this.PointCount(outRec.Pts);\n      if ((outRec.IsOpen && cnt < 2) || (!outRec.IsOpen && cnt < 3))\n        continue;\n      this.FixHoleLinkage(outRec);\n      var pn = new ClipperLib.PolyNode();\n      polytree.m_AllPolys.push(pn);\n      outRec.PolyNode = pn;\n      pn.m_polygon.length = cnt;\n      var op = outRec.Pts.Prev;\n      for (var j = 0; j < cnt; j++)\n      {\n        pn.m_polygon[j] = op.Pt;\n        op = op.Prev;\n      }\n    }\n    //fixup PolyNode links etc ...\n    //polytree.m_Childs.set_Capacity(this.m_PolyOuts.length);\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n      var outRec = this.m_PolyOuts[i];\n      if (outRec.PolyNode === null)\n        continue;\n      else if (outRec.IsOpen)\n      {\n        outRec.PolyNode.IsOpen = true;\n        polytree.AddChild(outRec.PolyNode);\n      }\n      else if (outRec.FirstLeft !== null && outRec.FirstLeft.PolyNode != null)\n        outRec.FirstLeft.PolyNode.AddChild(outRec.PolyNode);\n      else\n        polytree.AddChild(outRec.PolyNode);\n    }\n  };\n  ClipperLib.Clipper.prototype.FixupOutPolygon = function (outRec)\n  {\n    //FixupOutPolygon() - removes duplicate points and simplifies consecutive\n    //parallel edges by removing the middle vertex.\n    var lastOK = null;\n    outRec.BottomPt = null;\n    var pp = outRec.Pts;\n    for (;;)\n    {\n      if (pp.Prev == pp || pp.Prev == pp.Next)\n      {\n        outRec.Pts = null;\n        return;\n      }\n      //test for duplicate points and collinear edges ...\n      if ((ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Next.Pt)) || (ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Prev.Pt)) ||\n        (ClipperLib.ClipperBase.SlopesEqual(pp.Prev.Pt, pp.Pt, pp.Next.Pt, this.m_UseFullRange) &&\n          (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(pp.Prev.Pt, pp.Pt, pp.Next.Pt))))\n      {\n        lastOK = null;\n        pp.Prev.Next = pp.Next;\n        pp.Next.Prev = pp.Prev;\n        pp = pp.Prev;\n      }\n      else if (pp == lastOK)\n        break;\n      else\n      {\n        if (lastOK === null)\n          lastOK = pp;\n        pp = pp.Next;\n      }\n    }\n    outRec.Pts = pp;\n  };\n  ClipperLib.Clipper.prototype.DupOutPt = function (outPt, InsertAfter)\n  {\n    var result = new ClipperLib.OutPt();\n    //result.Pt = outPt.Pt;\n    result.Pt.X = outPt.Pt.X;\n    result.Pt.Y = outPt.Pt.Y;\n    result.Idx = outPt.Idx;\n    if (InsertAfter)\n    {\n      result.Next = outPt.Next;\n      result.Prev = outPt;\n      outPt.Next.Prev = result;\n      outPt.Next = result;\n    }\n    else\n    {\n      result.Prev = outPt.Prev;\n      result.Next = outPt;\n      outPt.Prev.Next = result;\n      outPt.Prev = result;\n    }\n    return result;\n  };\n  ClipperLib.Clipper.prototype.GetOverlap = function (a1, a2, b1, b2, $val)\n  {\n    if (a1 < a2)\n    {\n      if (b1 < b2)\n      {\n        $val.Left = Math.max(a1, b1);\n        $val.Right = Math.min(a2, b2);\n      }\n      else\n      {\n        $val.Left = Math.max(a1, b2);\n        $val.Right = Math.min(a2, b1);\n      }\n    }\n    else\n    {\n      if (b1 < b2)\n      {\n        $val.Left = Math.max(a2, b1);\n        $val.Right = Math.min(a1, b2);\n      }\n      else\n      {\n        $val.Left = Math.max(a2, b2);\n        $val.Right = Math.min(a1, b1);\n      }\n    }\n    return $val.Left < $val.Right;\n  };\n  ClipperLib.Clipper.prototype.JoinHorz = function (op1, op1b, op2, op2b, Pt, DiscardLeft)\n  {\n    var Dir1 = (op1.Pt.X > op1b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n    var Dir2 = (op2.Pt.X > op2b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight);\n    if (Dir1 == Dir2)\n      return false;\n    //When DiscardLeft, we want Op1b to be on the Left of Op1, otherwise we\n    //want Op1b to be on the Right. (And likewise with Op2 and Op2b.)\n    //So, to facilitate this while inserting Op1b and Op2b ...\n    //when DiscardLeft, make sure we're AT or RIGHT of Pt before adding Op1b,\n    //otherwise make sure we're AT or LEFT of Pt. (Likewise with Op2b.)\n    if (Dir1 == ClipperLib.Direction.dLeftToRight)\n    {\n      while (op1.Next.Pt.X <= Pt.X &&\n        op1.Next.Pt.X >= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)\n        op1 = op1.Next;\n      if (DiscardLeft && (op1.Pt.X != Pt.X))\n        op1 = op1.Next;\n      op1b = this.DupOutPt(op1, !DiscardLeft);\n      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n      {\n        op1 = op1b;\n        //op1.Pt = Pt;\n        op1.Pt.X = Pt.X;\n        op1.Pt.Y = Pt.Y;\n        op1b = this.DupOutPt(op1, !DiscardLeft);\n      }\n    }\n    else\n    {\n      while (op1.Next.Pt.X >= Pt.X &&\n        op1.Next.Pt.X <= op1.Pt.X && op1.Next.Pt.Y == Pt.Y)\n        op1 = op1.Next;\n      if (!DiscardLeft && (op1.Pt.X != Pt.X))\n        op1 = op1.Next;\n      op1b = this.DupOutPt(op1, DiscardLeft);\n      if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt))\n      {\n        op1 = op1b;\n        //op1.Pt = Pt;\n        op1.Pt.X = Pt.X;\n        op1.Pt.Y = Pt.Y;\n        op1b = this.DupOutPt(op1, DiscardLeft);\n      }\n    }\n    if (Dir2 == ClipperLib.Direction.dLeftToRight)\n    {\n      while (op2.Next.Pt.X <= Pt.X &&\n        op2.Next.Pt.X >= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)\n        op2 = op2.Next;\n      if (DiscardLeft && (op2.Pt.X != Pt.X))\n        op2 = op2.Next;\n      op2b = this.DupOutPt(op2, !DiscardLeft);\n      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n      {\n        op2 = op2b;\n        //op2.Pt = Pt;\n        op2.Pt.X = Pt.X;\n        op2.Pt.Y = Pt.Y;\n        op2b = this.DupOutPt(op2, !DiscardLeft);\n      }\n    }\n    else\n    {\n      while (op2.Next.Pt.X >= Pt.X &&\n        op2.Next.Pt.X <= op2.Pt.X && op2.Next.Pt.Y == Pt.Y)\n        op2 = op2.Next;\n      if (!DiscardLeft && (op2.Pt.X != Pt.X))\n        op2 = op2.Next;\n      op2b = this.DupOutPt(op2, DiscardLeft);\n      if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt))\n      {\n        op2 = op2b;\n        //op2.Pt = Pt;\n        op2.Pt.X = Pt.X;\n        op2.Pt.Y = Pt.Y;\n        op2b = this.DupOutPt(op2, DiscardLeft);\n      }\n    }\n    if ((Dir1 == ClipperLib.Direction.dLeftToRight) == DiscardLeft)\n    {\n      op1.Prev = op2;\n      op2.Next = op1;\n      op1b.Next = op2b;\n      op2b.Prev = op1b;\n    }\n    else\n    {\n      op1.Next = op2;\n      op2.Prev = op1;\n      op1b.Prev = op2b;\n      op2b.Next = op1b;\n    }\n    return true;\n  };\n  ClipperLib.Clipper.prototype.JoinPoints = function (j, outRec1, outRec2)\n  {\n    var op1 = j.OutPt1,\n      op1b = new ClipperLib.OutPt();\n    var op2 = j.OutPt2,\n      op2b = new ClipperLib.OutPt();\n    //There are 3 kinds of joins for output polygons ...\n    //1. Horizontal joins where Join.OutPt1 & Join.OutPt2 are a vertices anywhere\n    //along (horizontal) collinear edges (& Join.OffPt is on the same horizontal).\n    //2. Non-horizontal joins where Join.OutPt1 & Join.OutPt2 are at the same\n    //location at the Bottom of the overlapping segment (& Join.OffPt is above).\n    //3. StrictlySimple joins where edges touch but are not collinear and where\n    //Join.OutPt1, Join.OutPt2 & Join.OffPt all share the same point.\n    var isHorizontal = (j.OutPt1.Pt.Y == j.OffPt.Y);\n    if (isHorizontal && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt1.Pt)) && (ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt2.Pt)))\n    {\n      //Strictly Simple join ...\n\t\t\tif (outRec1 != outRec2) return false;\n\n      op1b = j.OutPt1.Next;\n      while (op1b != op1 && (ClipperLib.IntPoint.op_Equality(op1b.Pt, j.OffPt)))\n        op1b = op1b.Next;\n      var reverse1 = (op1b.Pt.Y > j.OffPt.Y);\n      op2b = j.OutPt2.Next;\n      while (op2b != op2 && (ClipperLib.IntPoint.op_Equality(op2b.Pt, j.OffPt)))\n        op2b = op2b.Next;\n      var reverse2 = (op2b.Pt.Y > j.OffPt.Y);\n      if (reverse1 == reverse2)\n        return false;\n      if (reverse1)\n      {\n        op1b = this.DupOutPt(op1, false);\n        op2b = this.DupOutPt(op2, true);\n        op1.Prev = op2;\n        op2.Next = op1;\n        op1b.Next = op2b;\n        op2b.Prev = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      }\n      else\n      {\n        op1b = this.DupOutPt(op1, true);\n        op2b = this.DupOutPt(op2, false);\n        op1.Next = op2;\n        op2.Prev = op1;\n        op1b.Prev = op2b;\n        op2b.Next = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      }\n    }\n    else if (isHorizontal)\n    {\n      //treat horizontal joins differently to non-horizontal joins since with\n      //them we're not yet sure where the overlapping is. OutPt1.Pt & OutPt2.Pt\n      //may be anywhere along the horizontal edge.\n      op1b = op1;\n      while (op1.Prev.Pt.Y == op1.Pt.Y && op1.Prev != op1b && op1.Prev != op2)\n        op1 = op1.Prev;\n      while (op1b.Next.Pt.Y == op1b.Pt.Y && op1b.Next != op1 && op1b.Next != op2)\n        op1b = op1b.Next;\n      if (op1b.Next == op1 || op1b.Next == op2)\n        return false;\n      //a flat 'polygon'\n      op2b = op2;\n      while (op2.Prev.Pt.Y == op2.Pt.Y && op2.Prev != op2b && op2.Prev != op1b)\n        op2 = op2.Prev;\n      while (op2b.Next.Pt.Y == op2b.Pt.Y && op2b.Next != op2 && op2b.Next != op1)\n        op2b = op2b.Next;\n      if (op2b.Next == op2 || op2b.Next == op1)\n        return false;\n      //a flat 'polygon'\n      //Op1 -. Op1b & Op2 -. Op2b are the extremites of the horizontal edges\n\n      var $val = {Left: null, Right: null};\n      if (!this.GetOverlap(op1.Pt.X, op1b.Pt.X, op2.Pt.X, op2b.Pt.X, $val))\n        return false;\n      var Left = $val.Left;\n      var Right = $val.Right;\n\n      //DiscardLeftSide: when overlapping edges are joined, a spike will created\n      //which needs to be cleaned up. However, we don't want Op1 or Op2 caught up\n      //on the discard Side as either may still be needed for other joins ...\n      var Pt = new ClipperLib.IntPoint();\n      var DiscardLeftSide;\n      if (op1.Pt.X >= Left && op1.Pt.X <= Right)\n      {\n        //Pt = op1.Pt;\n        Pt.X = op1.Pt.X;\n        Pt.Y = op1.Pt.Y;\n        DiscardLeftSide = (op1.Pt.X > op1b.Pt.X);\n      }\n      else if (op2.Pt.X >= Left && op2.Pt.X <= Right)\n      {\n        //Pt = op2.Pt;\n        Pt.X = op2.Pt.X;\n        Pt.Y = op2.Pt.Y;\n        DiscardLeftSide = (op2.Pt.X > op2b.Pt.X);\n      }\n      else if (op1b.Pt.X >= Left && op1b.Pt.X <= Right)\n      {\n        //Pt = op1b.Pt;\n        Pt.X = op1b.Pt.X;\n        Pt.Y = op1b.Pt.Y;\n        DiscardLeftSide = op1b.Pt.X > op1.Pt.X;\n      }\n      else\n      {\n        //Pt = op2b.Pt;\n        Pt.X = op2b.Pt.X;\n        Pt.Y = op2b.Pt.Y;\n        DiscardLeftSide = (op2b.Pt.X > op2.Pt.X);\n      }\n      j.OutPt1 = op1;\n      j.OutPt2 = op2;\n      return this.JoinHorz(op1, op1b, op2, op2b, Pt, DiscardLeftSide);\n    }\n    else\n    {\n      //nb: For non-horizontal joins ...\n      //    1. Jr.OutPt1.Pt.Y == Jr.OutPt2.Pt.Y\n      //    2. Jr.OutPt1.Pt > Jr.OffPt.Y\n      //make sure the polygons are correctly oriented ...\n      op1b = op1.Next;\n      while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))\n        op1b = op1b.Next;\n      var Reverse1 = ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange));\n      if (Reverse1)\n      {\n        op1b = op1.Prev;\n        while ((ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt)) && (op1b != op1))\n          op1b = op1b.Prev;\n        if ((op1b.Pt.Y > op1.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange))\n          return false;\n      }\n      op2b = op2.Next;\n      while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))\n        op2b = op2b.Next;\n      var Reverse2 = ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange));\n      if (Reverse2)\n      {\n        op2b = op2.Prev;\n        while ((ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt)) && (op2b != op2))\n          op2b = op2b.Prev;\n        if ((op2b.Pt.Y > op2.Pt.Y) || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange))\n          return false;\n      }\n      if ((op1b == op1) || (op2b == op2) || (op1b == op2b) ||\n        ((outRec1 == outRec2) && (Reverse1 == Reverse2)))\n        return false;\n      if (Reverse1)\n      {\n        op1b = this.DupOutPt(op1, false);\n        op2b = this.DupOutPt(op2, true);\n        op1.Prev = op2;\n        op2.Next = op1;\n        op1b.Next = op2b;\n        op2b.Prev = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      }\n      else\n      {\n        op1b = this.DupOutPt(op1, true);\n        op2b = this.DupOutPt(op2, false);\n        op1.Next = op2;\n        op2.Prev = op1;\n        op1b.Prev = op2b;\n        op2b.Next = op1b;\n        j.OutPt1 = op1;\n        j.OutPt2 = op1b;\n        return true;\n      }\n    }\n  };\n  ClipperLib.Clipper.GetBounds = function (paths)\n  {\n    var i = 0,\n      cnt = paths.length;\n    while (i < cnt && paths[i].length == 0) i++;\n    if (i == cnt) return new ClipperLib.IntRect(0, 0, 0, 0);\n    var result = new ClipperLib.IntRect();\n    result.left = paths[i][0].X;\n    result.right = result.left;\n    result.top = paths[i][0].Y;\n    result.bottom = result.top;\n    for (; i < cnt; i++)\n      for (var j = 0, jlen = paths[i].length; j < jlen; j++)\n      {\n        if (paths[i][j].X < result.left) result.left = paths[i][j].X;\n        else if (paths[i][j].X > result.right) result.right = paths[i][j].X;\n        if (paths[i][j].Y < result.top) result.top = paths[i][j].Y;\n        else if (paths[i][j].Y > result.bottom) result.bottom = paths[i][j].Y;\n      }\n    return result;\n  }\n  ClipperLib.Clipper.prototype.GetBounds2 = function (ops)\n  {\n    var opStart = ops;\n    var result = new ClipperLib.IntRect();\n    result.left = ops.Pt.X;\n    result.right = ops.Pt.X;\n    result.top = ops.Pt.Y;\n    result.bottom = ops.Pt.Y;\n    ops = ops.Next;\n    while (ops != opStart)\n    {\n      if (ops.Pt.X < result.left)\n        result.left = ops.Pt.X;\n      if (ops.Pt.X > result.right)\n        result.right = ops.Pt.X;\n      if (ops.Pt.Y < result.top)\n        result.top = ops.Pt.Y;\n      if (ops.Pt.Y > result.bottom)\n        result.bottom = ops.Pt.Y;\n      ops = ops.Next;\n    }\n    return result;\n  };\n\n  ClipperLib.Clipper.PointInPolygon = function (pt, path)\n  {\n    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t\t//See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n    var result = 0,\n      cnt = path.length;\n    if (cnt < 3)\n      return 0;\n    var ip = path[0];\n    for (var i = 1; i <= cnt; ++i)\n    {\n      var ipNext = (i == cnt ? path[0] : path[i]);\n      if (ipNext.Y == pt.Y)\n      {\n        if ((ipNext.X == pt.X) || (ip.Y == pt.Y && ((ipNext.X > pt.X) == (ip.X < pt.X))))\n          return -1;\n      }\n      if ((ip.Y < pt.Y) != (ipNext.Y < pt.Y))\n      {\n        if (ip.X >= pt.X)\n        {\n          if (ipNext.X > pt.X)\n            result = 1 - result;\n          else\n          {\n            var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n            if (d == 0)\n              return -1;\n            else if ((d > 0) == (ipNext.Y > ip.Y))\n              result = 1 - result;\n          }\n        }\n        else\n        {\n          if (ipNext.X > pt.X)\n          {\n            var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n            if (d == 0)\n              return -1;\n            else if ((d > 0) == (ipNext.Y > ip.Y))\n              result = 1 - result;\n          }\n        }\n      }\n      ip = ipNext;\n    }\n    return result;\n  };\n\n  ClipperLib.Clipper.prototype.PointInPolygon = function (pt, op)\n  {\n    //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n\t\t//See \"The Point in Polygon Problem for Arbitrary Polygons\" by Hormann & Agathos\n    //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n    var result = 0;\n    var startOp = op;\n\t\tvar ptx = pt.X, pty = pt.Y;\n    var poly0x = op.Pt.X, poly0y = op.Pt.Y;\n    do\n    {\n\t\t\top = op.Next;\n\t\t\tvar poly1x = op.Pt.X, poly1y = op.Pt.Y;\n      if (poly1y == pty)\n      {\n        if ((poly1x == ptx) || (poly0y == pty && ((poly1x > ptx) == (poly0x < ptx))))\n          return -1;\n      }\n      if ((poly0y < pty) != (poly1y < pty))\n      {\n        if (poly0x >= ptx)\n        {\n          if (poly1x > ptx)\n            result = 1 - result;\n          else\n          {\n            var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n            if (d == 0)\n              return -1;\n            if ((d > 0) == (poly1y > poly0y))\n              result = 1 - result;\n          }\n        }\n        else\n        {\n          if (poly1x > ptx)\n          {\n            var d = (poly0x - ptx) * (poly1y - pty) - (poly1x - ptx) * (poly0y - pty);\n            if (d == 0)\n              return -1;\n            if ((d > 0) == (poly1y > poly0y))\n              result = 1 - result;\n          }\n        }\n      }\n      poly0x = poly1x;\n      poly0y = poly1y;\n    } while (startOp != op);\n\n    return result;\n  };\n\n  ClipperLib.Clipper.prototype.Poly2ContainsPoly1 = function (outPt1, outPt2)\n  {\n    var op = outPt1;\n    do\n    {\n\t\t\t//nb: PointInPolygon returns 0 if false, +1 if true, -1 if pt on polygon\n      var res = this.PointInPolygon(op.Pt, outPt2);\n      if (res >= 0)\n        return res > 0;\n      op = op.Next;\n    }\n    while (op != outPt1)\n    return true;\n  };\n  ClipperLib.Clipper.prototype.FixupFirstLefts1 = function (OldOutRec, NewOutRec)\n  {\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++)\n    {\n\t\t\tvar outRec = this.m_PolyOuts[i];\n\t\t\tif (outRec.Pts == null || outRec.FirstLeft == null)\n\t\t\t\tcontinue;\n\t\t\tvar firstLeft = this.ParseFirstLeft(outRec.FirstLeft);\n\t\t\tif (firstLeft == OldOutRec)\n\t\t\t{\n        if (this.Poly2ContainsPoly1(outRec.Pts, NewOutRec.Pts))\n          outRec.FirstLeft = NewOutRec;\n      }\n    }\n  };\n  ClipperLib.Clipper.prototype.FixupFirstLefts2 = function (OldOutRec, NewOutRec)\n  {\n    for (var $i2 = 0, $t2 = this.m_PolyOuts, $l2 = $t2.length, outRec = $t2[$i2]; $i2 < $l2; $i2++, outRec = $t2[$i2])\n      if (outRec.FirstLeft == OldOutRec)\n        outRec.FirstLeft = NewOutRec;\n  };\n  ClipperLib.Clipper.ParseFirstLeft = function (FirstLeft)\n  {\n    while (FirstLeft != null && FirstLeft.Pts == null)\n      FirstLeft = FirstLeft.FirstLeft;\n    return FirstLeft;\n  };\n  ClipperLib.Clipper.prototype.JoinCommonEdges = function ()\n  {\n    for (var i = 0, ilen = this.m_Joins.length; i < ilen; i++)\n    {\n      var join = this.m_Joins[i];\n      var outRec1 = this.GetOutRec(join.OutPt1.Idx);\n      var outRec2 = this.GetOutRec(join.OutPt2.Idx);\n      if (outRec1.Pts == null || outRec2.Pts == null)\n        continue;\n      //get the polygon fragment with the correct hole state (FirstLeft)\n      //before calling JoinPoints() ...\n      var holeStateRec;\n      if (outRec1 == outRec2)\n        holeStateRec = outRec1;\n      else if (this.Param1RightOfParam2(outRec1, outRec2))\n        holeStateRec = outRec2;\n      else if (this.Param1RightOfParam2(outRec2, outRec1))\n        holeStateRec = outRec1;\n      else\n        holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n\n      if (!this.JoinPoints(join, outRec1, outRec2)) continue;\n\n      if (outRec1 == outRec2)\n      {\n        //instead of joining two polygons, we've just created a new one by\n        //splitting one polygon into two.\n        outRec1.Pts = join.OutPt1;\n        outRec1.BottomPt = null;\n        outRec2 = this.CreateOutRec();\n        outRec2.Pts = join.OutPt2;\n        //update all OutRec2.Pts Idx's ...\n        this.UpdateOutPtIdxs(outRec2);\n        //We now need to check every OutRec.FirstLeft pointer. If it points\n        //to OutRec1 it may need to point to OutRec2 instead ...\n        if (this.m_UsingPolyTree)\n          for (var j = 0, jlen = this.m_PolyOuts.length; j < jlen - 1; j++)\n          {\n            var oRec = this.m_PolyOuts[j];\n            if (oRec.Pts == null || ClipperLib.Clipper.ParseFirstLeft(oRec.FirstLeft) != outRec1 || oRec.IsHole == outRec1.IsHole)\n              continue;\n            if (this.Poly2ContainsPoly1(oRec.Pts, join.OutPt2))\n              oRec.FirstLeft = outRec2;\n          }\n        if (this.Poly2ContainsPoly1(outRec2.Pts, outRec1.Pts))\n        {\n          //outRec2 is contained by outRec1 ...\n          outRec2.IsHole = !outRec1.IsHole;\n          outRec2.FirstLeft = outRec1;\n          //fixup FirstLeft pointers that may need reassigning to OutRec1\n          if (this.m_UsingPolyTree)\n            this.FixupFirstLefts2(outRec2, outRec1);\n          if ((outRec2.IsHole ^ this.ReverseSolution) == (this.Area(outRec2) > 0))\n            this.ReversePolyPtLinks(outRec2.Pts);\n        }\n        else if (this.Poly2ContainsPoly1(outRec1.Pts, outRec2.Pts))\n        {\n          //outRec1 is contained by outRec2 ...\n          outRec2.IsHole = outRec1.IsHole;\n          outRec1.IsHole = !outRec2.IsHole;\n          outRec2.FirstLeft = outRec1.FirstLeft;\n          outRec1.FirstLeft = outRec2;\n          //fixup FirstLeft pointers that may need reassigning to OutRec1\n          if (this.m_UsingPolyTree)\n            this.FixupFirstLefts2(outRec1, outRec2);\n          if ((outRec1.IsHole ^ this.ReverseSolution) == (this.Area(outRec1) > 0))\n            this.ReversePolyPtLinks(outRec1.Pts);\n        }\n        else\n        {\n          //the 2 polygons are completely separate ...\n          outRec2.IsHole = outRec1.IsHole;\n          outRec2.FirstLeft = outRec1.FirstLeft;\n          //fixup FirstLeft pointers that may need reassigning to OutRec2\n          if (this.m_UsingPolyTree)\n            this.FixupFirstLefts1(outRec1, outRec2);\n        }\n      }\n      else\n      {\n        //joined 2 polygons together ...\n        outRec2.Pts = null;\n        outRec2.BottomPt = null;\n        outRec2.Idx = outRec1.Idx;\n        outRec1.IsHole = holeStateRec.IsHole;\n        if (holeStateRec == outRec2)\n          outRec1.FirstLeft = outRec2.FirstLeft;\n        outRec2.FirstLeft = outRec1;\n        //fixup FirstLeft pointers that may need reassigning to OutRec1\n        if (this.m_UsingPolyTree)\n          this.FixupFirstLefts2(outRec2, outRec1);\n      }\n    }\n  };\n  ClipperLib.Clipper.prototype.UpdateOutPtIdxs = function (outrec)\n  {\n    var op = outrec.Pts;\n    do {\n      op.Idx = outrec.Idx;\n      op = op.Prev;\n    }\n    while (op != outrec.Pts)\n  };\n  ClipperLib.Clipper.prototype.DoSimplePolygons = function ()\n  {\n    var i = 0;\n    while (i < this.m_PolyOuts.length)\n    {\n      var outrec = this.m_PolyOuts[i++];\n      var op = outrec.Pts;\n\t\t\tif (op == null || outrec.IsOpen)\n\t\t\t\tcontinue;\n      do //for each Pt in Polygon until duplicate found do ...\n      {\n        var op2 = op.Next;\n        while (op2 != outrec.Pts)\n        {\n          if ((ClipperLib.IntPoint.op_Equality(op.Pt, op2.Pt)) && op2.Next != op && op2.Prev != op)\n          {\n            //split the polygon into two ...\n            var op3 = op.Prev;\n            var op4 = op2.Prev;\n            op.Prev = op4;\n            op4.Next = op;\n            op2.Prev = op3;\n            op3.Next = op2;\n            outrec.Pts = op;\n            var outrec2 = this.CreateOutRec();\n            outrec2.Pts = op2;\n            this.UpdateOutPtIdxs(outrec2);\n            if (this.Poly2ContainsPoly1(outrec2.Pts, outrec.Pts))\n            {\n              //OutRec2 is contained by OutRec1 ...\n              outrec2.IsHole = !outrec.IsHole;\n              outrec2.FirstLeft = outrec;\n\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec2, outrec);\n\n            }\n            else if (this.Poly2ContainsPoly1(outrec.Pts, outrec2.Pts))\n            {\n              //OutRec1 is contained by OutRec2 ...\n              outrec2.IsHole = outrec.IsHole;\n              outrec.IsHole = !outrec2.IsHole;\n              outrec2.FirstLeft = outrec.FirstLeft;\n              outrec.FirstLeft = outrec2;\n              if (this.m_UsingPolyTree) this.FixupFirstLefts2(outrec, outrec2);\n            }\n            else\n            {\n              //the 2 polygons are separate ...\n              outrec2.IsHole = outrec.IsHole;\n              outrec2.FirstLeft = outrec.FirstLeft;\n\t\t\t\t\t\t\tif (this.m_UsingPolyTree) this.FixupFirstLefts1(outrec, outrec2);\n            }\n            op2 = op;\n            //ie get ready for the next iteration\n          }\n          op2 = op2.Next;\n        }\n        op = op.Next;\n      }\n      while (op != outrec.Pts)\n    }\n  };\n  ClipperLib.Clipper.Area = function (poly)\n  {\n    var cnt = poly.length;\n    if (cnt < 3)\n      return 0;\n    var a = 0;\n    for (var i = 0, j = cnt - 1; i < cnt; ++i)\n    {\n      a += (poly[j].X + poly[i].X) * (poly[j].Y - poly[i].Y);\n      j = i;\n    }\n    return -a * 0.5;\n  };\n  ClipperLib.Clipper.prototype.Area = function (outRec)\n  {\n    var op = outRec.Pts;\n    if (op == null)\n      return 0;\n    var a = 0;\n    do {\n      a = a + (op.Prev.Pt.X + op.Pt.X) * (op.Prev.Pt.Y - op.Pt.Y);\n      op = op.Next;\n    }\n    while (op != outRec.Pts)\n    return a * 0.5;\n  };\n  ClipperLib.Clipper.SimplifyPolygon = function (poly, fillType)\n  {\n    var result = new Array();\n    var c = new ClipperLib.Clipper(0);\n    c.StrictlySimple = true;\n    c.AddPath(poly, ClipperLib.PolyType.ptSubject, true);\n    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n    return result;\n  };\n  ClipperLib.Clipper.SimplifyPolygons = function (polys, fillType)\n  {\n    if (typeof (fillType) == \"undefined\") fillType = ClipperLib.PolyFillType.pftEvenOdd;\n    var result = new Array();\n    var c = new ClipperLib.Clipper(0);\n    c.StrictlySimple = true;\n    c.AddPaths(polys, ClipperLib.PolyType.ptSubject, true);\n    c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n    return result;\n  };\n  ClipperLib.Clipper.DistanceSqrd = function (pt1, pt2)\n  {\n    var dx = (pt1.X - pt2.X);\n    var dy = (pt1.Y - pt2.Y);\n    return (dx * dx + dy * dy);\n  };\n  ClipperLib.Clipper.DistanceFromLineSqrd = function (pt, ln1, ln2)\n  {\n    //The equation of a line in general form (Ax + By + C = 0)\n    //given 2 points (x,y) & (x,y) is ...\n    //(y - y)x + (x - x)y + (y - y)x - (x - x)y = 0\n    //A = (y - y); B = (x - x); C = (y - y)x - (x - x)y\n    //perpendicular distance of point (x,y) = (Ax + By + C)/Sqrt(A + B)\n    //see http://en.wikipedia.org/wiki/Perpendicular_distance\n    var A = ln1.Y - ln2.Y;\n    var B = ln2.X - ln1.X;\n    var C = A * ln1.X + B * ln1.Y;\n    C = A * pt.X + B * pt.Y - C;\n    return (C * C) / (A * A + B * B);\n  };\n\n\tClipperLib.Clipper.SlopesNearCollinear = function(pt1, pt2, pt3, distSqrd)\n\t{\n\t\t//this function is more accurate when the point that's GEOMETRICALLY\n\t\t//between the other 2 points is the one that's tested for distance.\n\t\t//nb: with 'spikes', either pt1 or pt3 is geometrically between the other pts\n\t\tif (Math.abs(pt1.X - pt2.X) > Math.abs(pt1.Y - pt2.Y))\n\t\t{\n\t\tif ((pt1.X > pt2.X) == (pt1.X < pt3.X))\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n\t\telse if ((pt2.X > pt1.X) == (pt2.X < pt3.X))\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t\t\t\telse\n\t\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n\t\t}\n\t\telse\n\t\t{\n\t\tif ((pt1.Y > pt2.Y) == (pt1.Y < pt3.Y))\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt1, pt2, pt3) < distSqrd;\n\t\telse if ((pt2.Y > pt1.Y) == (pt2.Y < pt3.Y))\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n\t\t\t\telse\n\t\t\treturn ClipperLib.Clipper.DistanceFromLineSqrd(pt3, pt1, pt2) < distSqrd;\n\t\t}\n\t}\n\n  ClipperLib.Clipper.PointsAreClose = function (pt1, pt2, distSqrd)\n  {\n    var dx = pt1.X - pt2.X;\n    var dy = pt1.Y - pt2.Y;\n    return ((dx * dx) + (dy * dy) <= distSqrd);\n  };\n  //------------------------------------------------------------------------------\n  ClipperLib.Clipper.ExcludeOp = function (op)\n  {\n    var result = op.Prev;\n    result.Next = op.Next;\n    op.Next.Prev = result;\n    result.Idx = 0;\n    return result;\n  };\n  ClipperLib.Clipper.CleanPolygon = function (path, distance)\n  {\n    if (typeof (distance) == \"undefined\") distance = 1.415;\n    //distance = proximity in units/pixels below which vertices will be stripped.\n    //Default ~= sqrt(2) so when adjacent vertices or semi-adjacent vertices have\n    //both x & y coords within 1 unit, then the second vertex will be stripped.\n    var cnt = path.length;\n    if (cnt == 0)\n      return new Array();\n    var outPts = new Array(cnt);\n    for (var i = 0; i < cnt; ++i)\n      outPts[i] = new ClipperLib.OutPt();\n    for (var i = 0; i < cnt; ++i)\n    {\n      outPts[i].Pt = path[i];\n      outPts[i].Next = outPts[(i + 1) % cnt];\n      outPts[i].Next.Prev = outPts[i];\n      outPts[i].Idx = 0;\n    }\n    var distSqrd = distance * distance;\n    var op = outPts[0];\n    while (op.Idx == 0 && op.Next != op.Prev)\n    {\n      if (ClipperLib.Clipper.PointsAreClose(op.Pt, op.Prev.Pt, distSqrd))\n      {\n        op = ClipperLib.Clipper.ExcludeOp(op);\n        cnt--;\n      }\n      else if (ClipperLib.Clipper.PointsAreClose(op.Prev.Pt, op.Next.Pt, distSqrd))\n      {\n        ClipperLib.Clipper.ExcludeOp(op.Next);\n        op = ClipperLib.Clipper.ExcludeOp(op);\n        cnt -= 2;\n      }\n      else if (ClipperLib.Clipper.SlopesNearCollinear(op.Prev.Pt, op.Pt, op.Next.Pt, distSqrd))\n      {\n        op = ClipperLib.Clipper.ExcludeOp(op);\n        cnt--;\n      }\n      else\n      {\n        op.Idx = 1;\n        op = op.Next;\n      }\n    }\n    if (cnt < 3)\n      cnt = 0;\n    var result = new Array(cnt);\n    for (var i = 0; i < cnt; ++i)\n    {\n      result[i] = new ClipperLib.IntPoint(op.Pt);\n      op = op.Next;\n    }\n    outPts = null;\n    return result;\n  };\n  ClipperLib.Clipper.CleanPolygons = function (polys, distance)\n  {\n    var result = new Array(polys.length);\n    for (var i = 0, ilen = polys.length; i < ilen; i++)\n      result[i] = ClipperLib.Clipper.CleanPolygon(polys[i], distance);\n    return result;\n  };\n  ClipperLib.Clipper.Minkowski = function (pattern, path, IsSum, IsClosed)\n  {\n    var delta = (IsClosed ? 1 : 0);\n    var polyCnt = pattern.length;\n    var pathCnt = path.length;\n    var result = new Array();\n    if (IsSum)\n      for (var i = 0; i < pathCnt; i++)\n      {\n        var p = new Array(polyCnt);\n        for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n          p[j] = new ClipperLib.IntPoint(path[i].X + ip.X, path[i].Y + ip.Y);\n        result.push(p);\n      }\n    else\n      for (var i = 0; i < pathCnt; i++)\n      {\n        var p = new Array(polyCnt);\n        for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j])\n          p[j] = new ClipperLib.IntPoint(path[i].X - ip.X, path[i].Y - ip.Y);\n        result.push(p);\n      }\n    var quads = new Array();\n    for (var i = 0; i < pathCnt - 1 + delta; i++)\n      for (var j = 0; j < polyCnt; j++)\n      {\n        var quad = new Array();\n        quad.push(result[i % pathCnt][j % polyCnt]);\n        quad.push(result[(i + 1) % pathCnt][j % polyCnt]);\n        quad.push(result[(i + 1) % pathCnt][(j + 1) % polyCnt]);\n        quad.push(result[i % pathCnt][(j + 1) % polyCnt]);\n        if (!ClipperLib.Clipper.Orientation(quad))\n          quad.reverse();\n        quads.push(quad);\n      }\n\t\t\treturn quads;\n  };\n\n\tClipperLib.Clipper.MinkowskiSum = function(pattern, path_or_paths, pathIsClosed)\n\t{\n\t\tif(!(path_or_paths[0] instanceof Array))\n\t\t{\n\t\t\tvar path = path_or_paths;\n\t\t\tvar paths = ClipperLib.Clipper.Minkowski(pattern, path, true, pathIsClosed);\n\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\tc.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\treturn paths;\n\t\t}\n\t\telse\n\t\t{\n \t\t\tvar paths = path_or_paths;\n\t\t\tvar solution = new ClipperLib.Paths();\n\t\t\tvar c = new ClipperLib.Clipper();\n\t\t\tfor (var i = 0; i < paths.length; ++i)\n\t\t\t{\n\t\t\t\tvar tmp = ClipperLib.Clipper.Minkowski(pattern, paths[i], true, pathIsClosed);\n\t\t\t\tc.AddPaths(tmp, ClipperLib.PolyType.ptSubject, true);\n\t\t\t\tif (pathIsClosed)\n\t\t\t\t{\n\t\t\t\t\tvar path = ClipperLib.Clipper.TranslatePath(paths[i], pattern[0]);\n\t\t\t\t\tc.AddPath(path, ClipperLib.PolyType.ptClip, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tc.Execute(ClipperLib.ClipType.ctUnion, solution,\n\t\t\t\tClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\t\treturn solution;\n\t\t}\n\t}\n\t//------------------------------------------------------------------------------\n\n\tClipperLib.Clipper.TranslatePath = function (path, delta)\n\t{\n\t\tvar outPath = new ClipperLib.Path();\n\t\tfor (var i = 0; i < path.length; i++)\n\t\t\toutPath.push(new ClipperLib.IntPoint(path[i].X + delta.X, path[i].Y + delta.Y));\n\t\treturn outPath;\n\t}\n\t//------------------------------------------------------------------------------\n\n\tClipperLib.Clipper.MinkowskiDiff = function (poly1, poly2)\n\t{\n\t\tvar paths = ClipperLib.Clipper.Minkowski(poly1, poly2, false, true);\n\t\tvar c = new ClipperLib.Clipper();\n\t\tc.AddPaths(paths, ClipperLib.PolyType.ptSubject, true);\n\t\tc.Execute(ClipperLib.ClipType.ctUnion, paths, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n\t\treturn paths;\n\t}\n\n  ClipperLib.Clipper.PolyTreeToPaths = function (polytree)\n  {\n    var result = new Array();\n    //result.set_Capacity(polytree.get_Total());\n    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntAny, result);\n    return result;\n  };\n  ClipperLib.Clipper.AddPolyNodeToPaths = function (polynode, nt, paths)\n  {\n    var match = true;\n    switch (nt)\n    {\n    case ClipperLib.Clipper.NodeType.ntOpen:\n      return;\n    case ClipperLib.Clipper.NodeType.ntClosed:\n      match = !polynode.IsOpen;\n      break;\n    default:\n      break;\n    }\n    if (polynode.m_polygon.length > 0 && match)\n      paths.push(polynode.m_polygon);\n    for (var $i3 = 0, $t3 = polynode.Childs(), $l3 = $t3.length, pn = $t3[$i3]; $i3 < $l3; $i3++, pn = $t3[$i3])\n      ClipperLib.Clipper.AddPolyNodeToPaths(pn, nt, paths);\n  };\n  ClipperLib.Clipper.OpenPathsFromPolyTree = function (polytree)\n  {\n    var result = new ClipperLib.Paths();\n    //result.set_Capacity(polytree.ChildCount());\n    for (var i = 0, ilen = polytree.ChildCount(); i < ilen; i++)\n      if (polytree.Childs()[i].IsOpen)\n        result.push(polytree.Childs()[i].m_polygon);\n    return result;\n  };\n  ClipperLib.Clipper.ClosedPathsFromPolyTree = function (polytree)\n  {\n    var result = new ClipperLib.Paths();\n    //result.set_Capacity(polytree.Total());\n    ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntClosed, result);\n    return result;\n  };\n  Inherit(ClipperLib.Clipper, ClipperLib.ClipperBase);\n  ClipperLib.Clipper.NodeType = {\n    ntAny: 0,\n    ntOpen: 1,\n    ntClosed: 2\n  };\n  ClipperLib.ClipperOffset = function (miterLimit, arcTolerance)\n  {\n    if (typeof (miterLimit) == \"undefined\") miterLimit = 2;\n    if (typeof (arcTolerance) == \"undefined\") arcTolerance = ClipperLib.ClipperOffset.def_arc_tolerance;\n    this.m_destPolys = new ClipperLib.Paths();\n    this.m_srcPoly = new ClipperLib.Path();\n    this.m_destPoly = new ClipperLib.Path();\n    this.m_normals = new Array();\n    this.m_delta = 0;\n    this.m_sinA = 0;\n    this.m_sin = 0;\n    this.m_cos = 0;\n    this.m_miterLim = 0;\n    this.m_StepsPerRad = 0;\n    this.m_lowest = new ClipperLib.IntPoint();\n    this.m_polyNodes = new ClipperLib.PolyNode();\n    this.MiterLimit = miterLimit;\n    this.ArcTolerance = arcTolerance;\n    this.m_lowest.X = -1;\n  };\n  ClipperLib.ClipperOffset.two_pi = 6.28318530717959;\n  ClipperLib.ClipperOffset.def_arc_tolerance = 0.25;\n  ClipperLib.ClipperOffset.prototype.Clear = function ()\n  {\n    ClipperLib.Clear(this.m_polyNodes.Childs());\n    this.m_lowest.X = -1;\n  };\n  ClipperLib.ClipperOffset.Round = ClipperLib.Clipper.Round;\n  ClipperLib.ClipperOffset.prototype.AddPath = function (path, joinType, endType)\n  {\n    var highI = path.length - 1;\n    if (highI < 0)\n      return;\n    var newNode = new ClipperLib.PolyNode();\n    newNode.m_jointype = joinType;\n    newNode.m_endtype = endType;\n    //strip duplicate points from path and also get index to the lowest point ...\n    if (endType == ClipperLib.EndType.etClosedLine || endType == ClipperLib.EndType.etClosedPolygon)\n      while (highI > 0 && ClipperLib.IntPoint.op_Equality(path[0], path[highI]))\n        highI--;\n    //newNode.m_polygon.set_Capacity(highI + 1);\n    newNode.m_polygon.push(path[0]);\n    var j = 0,\n      k = 0;\n    for (var i = 1; i <= highI; i++)\n      if (ClipperLib.IntPoint.op_Inequality(newNode.m_polygon[j], path[i]))\n      {\n        j++;\n        newNode.m_polygon.push(path[i]);\n        if (path[i].Y > newNode.m_polygon[k].Y || (path[i].Y == newNode.m_polygon[k].Y && path[i].X < newNode.m_polygon[k].X))\n          k = j;\n      }\n    if (endType == ClipperLib.EndType.etClosedPolygon && j < 2) return;\n\n    this.m_polyNodes.AddChild(newNode);\n    //if this path's lowest pt is lower than all the others then update m_lowest\n    if (endType != ClipperLib.EndType.etClosedPolygon)\n      return;\n    if (this.m_lowest.X < 0)\n      this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);\n    else\n    {\n      var ip = this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon[this.m_lowest.Y];\n      if (newNode.m_polygon[k].Y > ip.Y || (newNode.m_polygon[k].Y == ip.Y && newNode.m_polygon[k].X < ip.X))\n        this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);\n    }\n  };\n  ClipperLib.ClipperOffset.prototype.AddPaths = function (paths, joinType, endType)\n  {\n    for (var i = 0, ilen = paths.length; i < ilen; i++)\n      this.AddPath(paths[i], joinType, endType);\n  };\n  ClipperLib.ClipperOffset.prototype.FixOrientations = function ()\n  {\n    //fixup orientations of all closed paths if the orientation of the\n    //closed path with the lowermost vertex is wrong ...\n    if (this.m_lowest.X >= 0 && !ClipperLib.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon))\n    {\n      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n      {\n        var node = this.m_polyNodes.Childs()[i];\n        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon || (node.m_endtype == ClipperLib.EndType.etClosedLine && ClipperLib.Clipper.Orientation(node.m_polygon)))\n          node.m_polygon.reverse();\n      }\n    }\n    else\n    {\n      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n      {\n        var node = this.m_polyNodes.Childs()[i];\n        if (node.m_endtype == ClipperLib.EndType.etClosedLine && !ClipperLib.Clipper.Orientation(node.m_polygon))\n          node.m_polygon.reverse();\n      }\n    }\n  };\n  ClipperLib.ClipperOffset.GetUnitNormal = function (pt1, pt2)\n  {\n    var dx = (pt2.X - pt1.X);\n    var dy = (pt2.Y - pt1.Y);\n    if ((dx == 0) && (dy == 0))\n      return new ClipperLib.DoublePoint(0, 0);\n    var f = 1 / Math.sqrt(dx * dx + dy * dy);\n    dx *= f;\n    dy *= f;\n    return new ClipperLib.DoublePoint(dy, -dx);\n  };\n  ClipperLib.ClipperOffset.prototype.DoOffset = function (delta)\n  {\n    this.m_destPolys = new Array();\n    this.m_delta = delta;\n    //if Zero offset, just copy any CLOSED polygons to m_p and return ...\n    if (ClipperLib.ClipperBase.near_zero(delta))\n    {\n      //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount);\n      for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n      {\n        var node = this.m_polyNodes.Childs()[i];\n        if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n          this.m_destPolys.push(node.m_polygon);\n      }\n      return;\n    }\n    //see offset_triginometry3.svg in the documentation folder ...\n    if (this.MiterLimit > 2)\n      this.m_miterLim = 2 / (this.MiterLimit * this.MiterLimit);\n    else\n      this.m_miterLim = 0.5;\n    var y;\n    if (this.ArcTolerance <= 0)\n      y = ClipperLib.ClipperOffset.def_arc_tolerance;\n    else if (this.ArcTolerance > Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance)\n      y = Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance;\n    else\n      y = this.ArcTolerance;\n    //see offset_triginometry2.svg in the documentation folder ...\n    var steps = 3.14159265358979 / Math.acos(1 - y / Math.abs(delta));\n    this.m_sin = Math.sin(ClipperLib.ClipperOffset.two_pi / steps);\n    this.m_cos = Math.cos(ClipperLib.ClipperOffset.two_pi / steps);\n    this.m_StepsPerRad = steps / ClipperLib.ClipperOffset.two_pi;\n    if (delta < 0)\n      this.m_sin = -this.m_sin;\n    //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount * 2);\n    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++)\n    {\n      var node = this.m_polyNodes.Childs()[i];\n      this.m_srcPoly = node.m_polygon;\n      var len = this.m_srcPoly.length;\n      if (len == 0 || (delta <= 0 && (len < 3 || node.m_endtype != ClipperLib.EndType.etClosedPolygon)))\n        continue;\n      this.m_destPoly = new Array();\n      if (len == 1)\n      {\n        if (node.m_jointype == ClipperLib.JoinType.jtRound)\n        {\n          var X = 1,\n            Y = 0;\n          for (var j = 1; j <= steps; j++)\n          {\n            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n            var X2 = X;\n            X = X * this.m_cos - this.m_sin * Y;\n            Y = X2 * this.m_sin + Y * this.m_cos;\n          }\n        }\n        else\n        {\n          var X = -1,\n            Y = -1;\n          for (var j = 0; j < 4; ++j)\n          {\n            this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n            if (X < 0)\n              X = 1;\n            else if (Y < 0)\n              Y = 1;\n            else\n              X = -1;\n          }\n        }\n        this.m_destPolys.push(this.m_destPoly);\n        continue;\n      }\n      //build m_normals ...\n      this.m_normals.length = 0;\n      //this.m_normals.set_Capacity(len);\n      for (var j = 0; j < len - 1; j++)\n        this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[j], this.m_srcPoly[j + 1]));\n      if (node.m_endtype == ClipperLib.EndType.etClosedLine || node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n        this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[len - 1], this.m_srcPoly[0]));\n      else\n        this.m_normals.push(new ClipperLib.DoublePoint(this.m_normals[len - 2]));\n      if (node.m_endtype == ClipperLib.EndType.etClosedPolygon)\n      {\n        var k = len - 1;\n        for (var j = 0; j < len; j++)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        this.m_destPolys.push(this.m_destPoly);\n      }\n      else if (node.m_endtype == ClipperLib.EndType.etClosedLine)\n      {\n        var k = len - 1;\n        for (var j = 0; j < len; j++)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        this.m_destPolys.push(this.m_destPoly);\n        this.m_destPoly = new Array();\n        //re-build m_normals ...\n        var n = this.m_normals[len - 1];\n        for (var j = len - 1; j > 0; j--)\n          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n        this.m_normals[0] = new ClipperLib.DoublePoint(-n.X, -n.Y);\n        k = 0;\n        for (var j = len - 1; j >= 0; j--)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        this.m_destPolys.push(this.m_destPoly);\n      }\n      else\n      {\n        var k = 0;\n        for (var j = 1; j < len - 1; ++j)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        var pt1;\n        if (node.m_endtype == ClipperLib.EndType.etOpenButt)\n        {\n          var j = len - 1;\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * delta));\n          this.m_destPoly.push(pt1);\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X - this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y - this.m_normals[j].Y * delta));\n          this.m_destPoly.push(pt1);\n        }\n        else\n        {\n          var j = len - 1;\n          k = len - 2;\n          this.m_sinA = 0;\n          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j].X, -this.m_normals[j].Y);\n          if (node.m_endtype == ClipperLib.EndType.etOpenSquare)\n            this.DoSquare(j, k);\n          else\n            this.DoRound(j, k);\n        }\n        //re-build m_normals ...\n        for (var j = len - 1; j > 0; j--)\n          this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n        this.m_normals[0] = new ClipperLib.DoublePoint(-this.m_normals[1].X, -this.m_normals[1].Y);\n        k = len - 1;\n        for (var j = k - 1; j > 0; --j)\n          k = this.OffsetPoint(j, k, node.m_jointype);\n        if (node.m_endtype == ClipperLib.EndType.etOpenButt)\n        {\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X - this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y - this.m_normals[0].Y * delta));\n          this.m_destPoly.push(pt1);\n          pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + this.m_normals[0].Y * delta));\n          this.m_destPoly.push(pt1);\n        }\n        else\n        {\n          k = 1;\n          this.m_sinA = 0;\n          if (node.m_endtype == ClipperLib.EndType.etOpenSquare)\n            this.DoSquare(0, 1);\n          else\n            this.DoRound(0, 1);\n        }\n        this.m_destPolys.push(this.m_destPoly);\n      }\n    }\n  };\n  ClipperLib.ClipperOffset.prototype.Execute = function ()\n  {\n    var a = arguments,\n      ispolytree = a[0] instanceof ClipperLib.PolyTree;\n    if (!ispolytree) // function (solution, delta)\n    {\n      var solution = a[0],\n        delta = a[1];\n      ClipperLib.Clear(solution);\n      this.FixOrientations();\n      this.DoOffset(delta);\n      //now clean up 'corners' ...\n      var clpr = new ClipperLib.Clipper(0);\n      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n      if (delta > 0)\n      {\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n      }\n      else\n      {\n        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n        var outer = new ClipperLib.Path();\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n        clpr.ReverseSolution = true;\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n        if (solution.length > 0)\n          solution.splice(0, 1);\n      }\n      //console.log(JSON.stringify(solution));\n    }\n    else // function (polytree, delta)\n    {\n      var solution = a[0],\n        delta = a[1];\n      solution.Clear();\n      this.FixOrientations();\n      this.DoOffset(delta);\n      //now clean up 'corners' ...\n      var clpr = new ClipperLib.Clipper(0);\n      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n      if (delta > 0)\n      {\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n      }\n      else\n      {\n        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n        var outer = new ClipperLib.Path();\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n        clpr.ReverseSolution = true;\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n        //remove the outer PolyNode rectangle ...\n        if (solution.ChildCount() == 1 && solution.Childs()[0].ChildCount() > 0)\n        {\n          var outerNode = solution.Childs()[0];\n          //solution.Childs.set_Capacity(outerNode.ChildCount);\n          solution.Childs()[0] = outerNode.Childs()[0];\n          solution.Childs()[0].m_Parent = solution;\n          for (var i = 1; i < outerNode.ChildCount(); i++)\n            solution.AddChild(outerNode.Childs()[i]);\n        }\n        else\n          solution.Clear();\n      }\n    }\n  };\n  ClipperLib.ClipperOffset.prototype.OffsetPoint = function (j, k, jointype)\n  {\n\t\t//cross product ...\n\t\tthis.m_sinA = (this.m_normals[k].X * this.m_normals[j].Y - this.m_normals[j].X * this.m_normals[k].Y);\n\n\t\tif (Math.abs(this.m_sinA * this.m_delta) < 1.0)\n\t\t{\n\t\t\t//dot product ...\n\t\t\tvar cosA = (this.m_normals[k].X * this.m_normals[j].X + this.m_normals[j].Y * this.m_normals[k].Y);\n\t\t\tif (cosA > 0) // angle ==> 0 degrees\n\t\t\t{\n\t\t\t\tthis.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),\n\t\t\t\t\tClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n\t\t\t\treturn k;\n\t\t\t}\n\t\t\t//else angle ==> 180 degrees\n\t\t}\n    else if (this.m_sinA > 1)\n      this.m_sinA = 1.0;\n    else if (this.m_sinA < -1)\n      this.m_sinA = -1.0;\n    if (this.m_sinA * this.m_delta < 0)\n    {\n      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta),\n        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n      this.m_destPoly.push(new ClipperLib.IntPoint(this.m_srcPoly[j]));\n      this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n    }\n    else\n      switch (jointype)\n      {\n      case ClipperLib.JoinType.jtMiter:\n        {\n          var r = 1 + (this.m_normals[j].X * this.m_normals[k].X + this.m_normals[j].Y * this.m_normals[k].Y);\n          if (r >= this.m_miterLim)\n            this.DoMiter(j, k, r);\n          else\n            this.DoSquare(j, k);\n          break;\n        }\n      case ClipperLib.JoinType.jtSquare:\n        this.DoSquare(j, k);\n        break;\n      case ClipperLib.JoinType.jtRound:\n        this.DoRound(j, k);\n        break;\n      }\n    k = j;\n    return k;\n  };\n  ClipperLib.ClipperOffset.prototype.DoSquare = function (j, k)\n  {\n    var dx = Math.tan(Math.atan2(this.m_sinA,\n      this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y) / 4);\n    this.m_destPoly.push(new ClipperLib.IntPoint(\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[k].X - this.m_normals[k].Y * dx)),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[k].Y + this.m_normals[k].X * dx))));\n    this.m_destPoly.push(new ClipperLib.IntPoint(\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[j].X + this.m_normals[j].Y * dx)),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[j].Y - this.m_normals[j].X * dx))));\n  };\n  ClipperLib.ClipperOffset.prototype.DoMiter = function (j, k, r)\n  {\n    var q = this.m_delta / r;\n    this.m_destPoly.push(new ClipperLib.IntPoint(\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + (this.m_normals[k].X + this.m_normals[j].X) * q),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + (this.m_normals[k].Y + this.m_normals[j].Y) * q)));\n  };\n  ClipperLib.ClipperOffset.prototype.DoRound = function (j, k)\n  {\n    var a = Math.atan2(this.m_sinA,\n      this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y);\n\n    \tvar steps = Math.max(ClipperLib.Cast_Int32(ClipperLib.ClipperOffset.Round(this.m_StepsPerRad * Math.abs(a))), 1);\n\n    var X = this.m_normals[k].X,\n      Y = this.m_normals[k].Y,\n      X2;\n    for (var i = 0; i < steps; ++i)\n    {\n      this.m_destPoly.push(new ClipperLib.IntPoint(\n        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + X * this.m_delta),\n        ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + Y * this.m_delta)));\n      X2 = X;\n      X = X * this.m_cos - this.m_sin * Y;\n      Y = X2 * this.m_sin + Y * this.m_cos;\n    }\n    this.m_destPoly.push(new ClipperLib.IntPoint(\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta),\n      ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n  };\n  ClipperLib.Error = function (message)\n  {\n    try\n    {\n      throw new Error(message);\n    }\n    catch (err)\n    {\n      alert(err.message);\n    }\n  };\n  // ---------------------------------\n  // JS extension by Timo 2013\n  ClipperLib.JS = {};\n  ClipperLib.JS.AreaOfPolygon = function (poly, scale)\n  {\n    if (!scale) scale = 1;\n    return ClipperLib.Clipper.Area(poly) / (scale * scale);\n  };\n  ClipperLib.JS.AreaOfPolygons = function (poly, scale)\n  {\n    if (!scale) scale = 1;\n    var area = 0;\n    for (var i = 0; i < poly.length; i++)\n    {\n      area += ClipperLib.Clipper.Area(poly[i]);\n    }\n    return area / (scale * scale);\n  };\n  ClipperLib.JS.BoundsOfPath = function (path, scale)\n  {\n    return ClipperLib.JS.BoundsOfPaths([path], scale);\n  };\n  ClipperLib.JS.BoundsOfPaths = function (paths, scale)\n  {\n    if (!scale) scale = 1;\n    var bounds = ClipperLib.Clipper.GetBounds(paths);\n    bounds.left /= scale;\n    bounds.bottom /= scale;\n    bounds.right /= scale;\n    bounds.top /= scale;\n    return bounds;\n  };\n  // Clean() joins vertices that are too near each other\n  // and causes distortion to offsetted polygons without cleaning\n  ClipperLib.JS.Clean = function (polygon, delta)\n  {\n    if (!(polygon instanceof Array)) return [];\n    var isPolygons = polygon[0] instanceof Array;\n    var polygon = ClipperLib.JS.Clone(polygon);\n    if (typeof delta != \"number\" || delta === null)\n    {\n      ClipperLib.Error(\"Delta is not a number in Clean().\");\n      return polygon;\n    }\n    if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || delta < 0) return polygon;\n    if (!isPolygons) polygon = [polygon];\n    var k_length = polygon.length;\n    var len, poly, result, d, p, j, i;\n    var results = [];\n    for (var k = 0; k < k_length; k++)\n    {\n      poly = polygon[k];\n      len = poly.length;\n      if (len === 0) continue;\n      else if (len < 3)\n      {\n        result = poly;\n        results.push(result);\n        continue;\n      }\n      result = poly;\n      d = delta * delta;\n      //d = Math.floor(c_delta * c_delta);\n      p = poly[0];\n      j = 1;\n      for (i = 1; i < len; i++)\n      {\n        if ((poly[i].X - p.X) * (poly[i].X - p.X) +\n          (poly[i].Y - p.Y) * (poly[i].Y - p.Y) <= d)\n          continue;\n        result[j] = poly[i];\n        p = poly[i];\n        j++;\n      }\n      p = poly[j - 1];\n      if ((poly[0].X - p.X) * (poly[0].X - p.X) +\n        (poly[0].Y - p.Y) * (poly[0].Y - p.Y) <= d)\n        j--;\n      if (j < len)\n        result.splice(j, len - j);\n      if (result.length) results.push(result);\n    }\n    if (!isPolygons && results.length) results = results[0];\n    else if (!isPolygons && results.length === 0) results = [];\n    else if (isPolygons && results.length === 0) results = [\n      []\n    ];\n    return results;\n  }\n  // Make deep copy of Polygons or Polygon\n  // so that also IntPoint objects are cloned and not only referenced\n  // This should be the fastest way\n  ClipperLib.JS.Clone = function (polygon)\n  {\n    if (!(polygon instanceof Array)) return [];\n    if (polygon.length === 0) return [];\n    else if (polygon.length == 1 && polygon[0].length === 0) return [[]];\n    var isPolygons = polygon[0] instanceof Array;\n    if (!isPolygons) polygon = [polygon];\n    var len = polygon.length,\n      plen, i, j, result;\n    var results = new Array(len);\n    for (i = 0; i < len; i++)\n    {\n      plen = polygon[i].length;\n      result = new Array(plen);\n      for (j = 0; j < plen; j++)\n      {\n        result[j] = {\n          X: polygon[i][j].X,\n          Y: polygon[i][j].Y\n        };\n      }\n      results[i] = result;\n    }\n    if (!isPolygons) results = results[0];\n    return results;\n  };\n  // Removes points that doesn't affect much to the visual appearance.\n  // If middle point is at or under certain distance (tolerance) of the line segment between\n  // start and end point, the middle point is removed.\n  ClipperLib.JS.Lighten = function (polygon, tolerance)\n  {\n    if (!(polygon instanceof Array)) return [];\n    if (typeof tolerance != \"number\" || tolerance === null)\n    {\n      ClipperLib.Error(\"Tolerance is not a number in Lighten().\")\n      return ClipperLib.JS.Clone(polygon);\n    }\n    if (polygon.length === 0 || (polygon.length == 1 && polygon[0].length === 0) || tolerance < 0)\n    {\n      return ClipperLib.JS.Clone(polygon);\n    }\n    if (!(polygon[0] instanceof Array)) polygon = [polygon];\n    var i, j, poly, k, poly2, plen, A, B, P, d, rem, addlast;\n    var bxax, byay, l, ax, ay;\n    var len = polygon.length;\n    var toleranceSq = tolerance * tolerance;\n    var results = [];\n    for (i = 0; i < len; i++)\n    {\n      poly = polygon[i];\n      plen = poly.length;\n      if (plen == 0) continue;\n      for (k = 0; k < 1000000; k++) // could be forever loop, but wiser to restrict max repeat count\n      {\n        poly2 = [];\n        plen = poly.length;\n        // the first have to added to the end, if first and last are not the same\n        // this way we ensure that also the actual last point can be removed if needed\n        if (poly[plen - 1].X != poly[0].X || poly[plen - 1].Y != poly[0].Y)\n        {\n          addlast = 1;\n          poly.push(\n          {\n            X: poly[0].X,\n            Y: poly[0].Y\n          });\n          plen = poly.length;\n        }\n        else addlast = 0;\n        rem = []; // Indexes of removed points\n        for (j = 0; j < plen - 2; j++)\n        {\n          A = poly[j]; // Start point of line segment\n          P = poly[j + 1]; // Middle point. This is the one to be removed.\n          B = poly[j + 2]; // End point of line segment\n          ax = A.X;\n          ay = A.Y;\n          bxax = B.X - ax;\n          byay = B.Y - ay;\n          if (bxax !== 0 || byay !== 0) // To avoid Nan, when A==P && P==B. And to avoid peaks (A==B && A!=P), which have lenght, but not area.\n          {\n            l = ((P.X - ax) * bxax + (P.Y - ay) * byay) / (bxax * bxax + byay * byay);\n            if (l > 1)\n            {\n              ax = B.X;\n              ay = B.Y;\n            }\n            else if (l > 0)\n            {\n              ax += bxax * l;\n              ay += byay * l;\n            }\n          }\n          bxax = P.X - ax;\n          byay = P.Y - ay;\n          d = bxax * bxax + byay * byay;\n          if (d <= toleranceSq)\n          {\n            rem[j + 1] = 1;\n            j++; // when removed, transfer the pointer to the next one\n          }\n        }\n        // add all unremoved points to poly2\n        poly2.push(\n        {\n          X: poly[0].X,\n          Y: poly[0].Y\n        });\n        for (j = 1; j < plen - 1; j++)\n          if (!rem[j]) poly2.push(\n          {\n            X: poly[j].X,\n            Y: poly[j].Y\n          });\n        poly2.push(\n        {\n          X: poly[plen - 1].X,\n          Y: poly[plen - 1].Y\n        });\n        // if the first point was added to the end, remove it\n        if (addlast) poly.pop();\n        // break, if there was not anymore removed points\n        if (!rem.length) break;\n        // else continue looping using poly2, to check if there are points to remove\n        else poly = poly2;\n      }\n      plen = poly2.length;\n      // remove duplicate from end, if needed\n      if (poly2[plen - 1].X == poly2[0].X && poly2[plen - 1].Y == poly2[0].Y)\n      {\n        poly2.pop();\n      }\n      if (poly2.length > 2) // to avoid two-point-polygons\n        results.push(poly2);\n    }\n    if (!(polygon[0] instanceof Array)) results = results[0];\n    if (typeof (results) == \"undefined\") results = [\n      []\n    ];\n    return results;\n  }\n  ClipperLib.JS.PerimeterOfPath = function (path, closed, scale)\n  {\n    if (typeof (path) == \"undefined\") return 0;\n    var sqrt = Math.sqrt;\n    var perimeter = 0.0;\n    var p1, p2, p1x = 0.0,\n      p1y = 0.0,\n      p2x = 0.0,\n      p2y = 0.0;\n    var j = path.length;\n    if (j < 2) return 0;\n    if (closed)\n    {\n      path[j] = path[0];\n      j++;\n    }\n    while (--j)\n    {\n      p1 = path[j];\n      p1x = p1.X;\n      p1y = p1.Y;\n      p2 = path[j - 1];\n      p2x = p2.X;\n      p2y = p2.Y;\n      perimeter += sqrt((p1x - p2x) * (p1x - p2x) + (p1y - p2y) * (p1y - p2y));\n    }\n    if (closed) path.pop();\n    return perimeter / scale;\n  };\n  ClipperLib.JS.PerimeterOfPaths = function (paths, closed, scale)\n  {\n    if (!scale) scale = 1;\n    var perimeter = 0;\n    for (var i = 0; i < paths.length; i++)\n    {\n      perimeter += ClipperLib.JS.PerimeterOfPath(paths[i], closed, scale);\n    }\n    return perimeter;\n  };\n  ClipperLib.JS.ScaleDownPath = function (path, scale)\n  {\n    var i, p;\n    if (!scale) scale = 1;\n    i = path.length;\n    while (i--)\n    {\n      p = path[i];\n      p.X = p.X / scale;\n      p.Y = p.Y / scale;\n    }\n  };\n  ClipperLib.JS.ScaleDownPaths = function (paths, scale)\n  {\n    var i, j, p;\n    if (!scale) scale = 1;\n    i = paths.length;\n    while (i--)\n    {\n      j = paths[i].length;\n      while (j--)\n      {\n        p = paths[i][j];\n        p.X = p.X / scale;\n        p.Y = p.Y / scale;\n      }\n    }\n  };\n  ClipperLib.JS.ScaleUpPath = function (path, scale)\n  {\n    var i, p, round = Math.round;\n    if (!scale) scale = 1;\n    i = path.length;\n    while (i--)\n    {\n      p = path[i];\n      p.X = round(p.X * scale);\n      p.Y = round(p.Y * scale);\n    }\n  };\n  ClipperLib.JS.ScaleUpPaths = function (paths, scale)\n  {\n    var i, j, p, round = Math.round;\n    if (!scale) scale = 1;\n    i = paths.length;\n    while (i--)\n    {\n      j = paths[i].length;\n      while (j--)\n      {\n        p = paths[i][j];\n        p.X = round(p.X * scale);\n        p.Y = round(p.Y * scale);\n      }\n    }\n  };\n  ClipperLib.ExPolygons = function ()\n  {\n    return [];\n  }\n  ClipperLib.ExPolygon = function ()\n  {\n    this.outer = null;\n    this.holes = null;\n  };\n  ClipperLib.JS.AddOuterPolyNodeToExPolygons = function (polynode, expolygons)\n  {\n    var ep = new ClipperLib.ExPolygon();\n    ep.outer = polynode.Contour();\n    var childs = polynode.Childs();\n    var ilen = childs.length;\n    ep.holes = new Array(ilen);\n    var node, n, i, j, childs2, jlen;\n    for (i = 0; i < ilen; i++)\n    {\n      node = childs[i];\n      ep.holes[i] = node.Contour();\n      //Add outer polygons contained by (nested within) holes ...\n      for (j = 0, childs2 = node.Childs(), jlen = childs2.length; j < jlen; j++)\n      {\n        n = childs2[j];\n        ClipperLib.JS.AddOuterPolyNodeToExPolygons(n, expolygons);\n      }\n    }\n    expolygons.push(ep);\n  };\n  ClipperLib.JS.ExPolygonsToPaths = function (expolygons)\n  {\n    var a, i, alen, ilen;\n    var paths = new ClipperLib.Paths();\n    for (a = 0, alen = expolygons.length; a < alen; a++)\n    {\n      paths.push(expolygons[a].outer);\n      for (i = 0, ilen = expolygons[a].holes.length; i < ilen; i++)\n      {\n        paths.push(expolygons[a].holes[i]);\n      }\n    }\n    return paths;\n  }\n  ClipperLib.JS.PolyTreeToExPolygons = function (polytree)\n  {\n    var expolygons = new ClipperLib.ExPolygons();\n    var node, i, childs, ilen;\n    for (i = 0, childs = polytree.Childs(), ilen = childs.length; i < ilen; i++)\n    {\n      node = childs[i];\n      ClipperLib.JS.AddOuterPolyNodeToExPolygons(node, expolygons);\n    }\n    return expolygons;\n  };\n})();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/clipper-lib/clipper.js\n// module id = 5\n// module chunks = 0","!function(t,e){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=e():\"function\"==typeof define&&define.amd?define(\"SVGCurves\",[],e):\"object\"==typeof exports?exports.SVGCurves=e():t.SVGCurves=e()}(this,function(){return function(t){function e(n){if(i[n])return i[n].exports;var r=i[n]={exports:{},id:n,loaded:!1};return t[n].call(r.exports,r,r.exports,e),r.loaded=!0,r.exports}var i={};return e.m=t,e.c=i,e.p=\"\",e(0)}([function(t,e,i){t.exports=i(1)},function(t,e,i){\"use strict\";function n(t,e){if(!t)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!e||\"object\"!=typeof e&&\"function\"!=typeof e?t:e}function r(t,e){if(\"function\"!=typeof e&&null!==e)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function s(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}function o(t,e){return(t%e+e)%e}function h(t,e,i){return Math.min(Math.max(t,e),i)}function a(t,e){return Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2))}function u(t,e){var i=t.x*e.x+t.y*e.y,n=Math.sqrt((Math.pow(t.x,2)+Math.pow(t.y,2))*(Math.pow(e.x,2)+Math.pow(e.y,2)));return(t.x*e.y-t.y*e.x<0?-1:1)*Math.acos(i/n)}Object.defineProperty(e,\"__esModule\",{value:!0}),e.QuadricBezier=e.CubicBezier=e.Arc=void 0;var p=function t(e,i,n){null===e&&(e=Function.prototype);var r=Object.getOwnPropertyDescriptor(e,i);if(void 0===r){var s=Object.getPrototypeOf(e);return null===s?void 0:t(s,i,n)}if(\"value\"in r)return r.value;var o=r.get;if(void 0!==o)return o.call(n)},c=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e}}(),f=i(2),l=2*Math.PI,y=Math.PI/180,v=function(){function t(e){s(this,t),this.path=[],this.linear=!0,this.step=.01,this.resolution=500,this.segmentLength=.1,Object.assign(this,e||{}),this.arcLength=null,this.arcLengthMap=null}return c(t,[{key:\"_clearPath\",value:function(){this.path=[]}},{key:\"getPath\",value:function(){return this.path}},{key:\"getPointAtT\",value:function(t){return new f.Point(0,0)}},{key:\"_addPoint\",value:function(t){this.path.push(t.x,t.y)}},{key:\"_postTrace\",value:function(){}},{key:\"_approximateLength\",value:function(){var t=0,e=[],i=this.getPointAtT(0),n=void 0,r=void 0,s=void 0;for(n=0;n<this.resolution;n++)r=h(n*(1/this.resolution),0,1),s=this.getPointAtT(r),t+=a(i,s),e.push({t:r,arcLength:t}),i=s;s=this.getPointAtT(1),t+=a(i,s),e.push({t:1,arcLength:t}),Object.assign(this,{arcLength:t,arcLengthMap:e})}},{key:\"getPointAtU\",value:function(t){t=h(t,0,1);var e=t*this.arcLength,i=0,n=0,r=0;return this.arcLengthMap.every(function(t){var s=t.t,o=t.arcLength;if(o>=e){var h=o-e,a=e-n,u=a/(h+a)||0;return i=r+(s-r)*u,!1}return n=o,r=s,!0}),this.getPointAtT(i)}},{key:\"trace\",value:function(t){Object.assign(this,t||{});var e=\"getPointAtT\",i=this.step;if(this.linear){this._approximateLength();var n=Math.round(this.arcLength/this.segmentLength);e=\"getPointAtU\",i=1/n}this._clearPath();for(var r=0;r<=1;r+=i)this._addPoint(this[e](r));return this._postTrace(),this.getPath()}}]),t}(),x=function(t){function e(){return s(this,e),n(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return r(e,t),c(e,[{key:\"init\",value:function(t){if(Object.assign(this,t||{}),this.radians=o(this.angle,360)*y,this.p1.x===this.p2.x&&this.p1.y===this.p2.y)return this.path;if(this.rx=Math.abs(this.rx),this.ry=Math.abs(this.ry),0===this.rx||0===this.ry)return this.__addPoint(this.p1),this.__addPoint(this.p2),this.path;var e=(this.p1.x-this.p2.x)/2,i=(this.p1.y-this.p2.y)/2,n={x:Math.cos(this.radians)*e+Math.sin(this.radians)*i,y:-Math.sin(this.radians)*e+Math.cos(this.radians)*i},r=Math.pow(n.x,2)/Math.pow(this.rx,2)+Math.pow(n.y,2)/Math.pow(this.ry,2);r>1&&(this.rx=Math.sqrt(r)*this.rx,this.ry=Math.sqrt(r)*this.ry);var s=Math.pow(this.rx,2)*Math.pow(this.ry,2)-Math.pow(this.rx,2)*Math.pow(n.y,2)-Math.pow(this.ry,2)*Math.pow(n.x,2),h=Math.pow(this.rx,2)*Math.pow(n.y,2)+Math.pow(this.ry,2)*Math.pow(n.x,2),a=s/h;a=a<0?0:a;var p=(this.large!==this.sweep?1:-1)*Math.sqrt(a),c={x:p*(this.rx*n.y/this.ry),y:p*(-(this.ry*n.x)/this.rx)};this.center={x:Math.cos(this.radians)*c.x-Math.sin(this.radians)*c.y+(this.p1.x+this.p2.x)/2,y:Math.sin(this.radians)*c.x+Math.cos(this.radians)*c.y+(this.p1.y+this.p2.y)/2};var f={x:(n.x-c.x)/this.rx,y:(n.y-c.y)/this.ry},v={x:(-n.x-c.x)/this.rx,y:(-n.y-c.y)/this.ry};this.startAngle=u({x:1,y:0},f),this.sweepAngle=u(f,v),!this.sweep&&this.sweepAngle>0?this.sweepAngle-=l:this.sweep&&this.sweepAngle<0&&(this.sweepAngle+=l),this.sweepAngle%=l}},{key:\"trace\",value:function(t){return this.init(t),p(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),\"trace\",this).call(this)}},{key:\"getPointAtT\",value:function(t){var e=this.startAngle+this.sweepAngle*t,i=this.rx*Math.cos(e),n=this.ry*Math.sin(e);return new f.Point(Math.cos(this.radians)*i-Math.sin(this.radians)*n+this.center.x,Math.sin(this.radians)*i+Math.cos(this.radians)*n+this.center.y)}},{key:\"_postTrace\",value:function(){this._addPoint(this.p2)}}]),e}(v),d=function(t){function e(){return s(this,e),n(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return r(e,t),c(e,[{key:\"_B1\",value:function(t){return t*t*t}},{key:\"_B2\",value:function(t){return 3*t*t*(1-t)}},{key:\"_B3\",value:function(t){return 3*t*(1-t)*(1-t)}},{key:\"_B4\",value:function(t){return(1-t)*(1-t)*(1-t)}},{key:\"_C1\",value:function(t,e,i,n,r){return t*this._B1(r)+e*this._B2(r)+i*this._B3(r)+n*this._B4(r)}},{key:\"getPointAtT\",value:function(t){return new f.Point(this._C1(this.p1.x,this.p2.x,this.p3.x,this.p4.x,t),this._C1(this.p1.y,this.p2.y,this.p3.y,this.p4.y,t))}},{key:\"_addPoint\",value:function(t){this.path.unshift(t.x,t.y)}}]),e}(v),g=function(t){function e(){return s(this,e),n(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return r(e,t),c(e,[{key:\"_B1\",value:function(t){return t*t}},{key:\"_B2\",value:function(t){return 2*t*(1-t)}},{key:\"_B3\",value:function(t){return(1-t)*(1-t)}},{key:\"_C1\",value:function(t,e,i,n){return t*this._B1(n)+e*this._B2(n)+i*this._B3(n)}},{key:\"getPointAtT\",value:function(t){return new f.Point(this._C1(this.p1.x,this.p2.x,this.p3.x,t),this._C1(this.p1.y,this.p2.y,this.p3.y,t))}},{key:\"_addPoint\",value:function(t){this.path.unshift(t.x,t.y)}}]),e}(v);e.Arc=x,e.CubicBezier=d,e.QuadricBezier=g},function(t,e,i){!function(e,i){t.exports=i()}(this,function(){return function(t){function e(n){if(i[n])return i[n].exports;var r=i[n]={exports:{},id:n,loaded:!1};return t[n].call(r.exports,r,r.exports,e),r.loaded=!0,r.exports}var i={};return e.m=t,e.c=i,e.p=\"\",e(0)}([function(t,e,i){t.exports=i(1)},function(t,e){\"use strict\";function i(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}Object.defineProperty(e,\"__esModule\",{value:!0});var n=function(){function t(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}return function(e,i,n){return i&&t(e.prototype,i),n&&t(e,n),e}}(),r=function(){function t(e,n){if(i(this,t),this.x=parseFloat(e),this.y=parseFloat(n),isNaN(this.x)||isNaN(this.y))throw console.error(\"new Point(\",e,n,\")\"),new Error(\"Invalid input: x and y params must be float.\")}return n(t,[{key:\"isEqual\",value:function(t){return this.x===t.x&&this.y===t.y}}]),t}(),s=function(){function t(){i(this,t),this.points=[],this.length=0}return n(t,[{key:\"getPoints\",value:function(){return this.points}},{key:\"getFlattenPoints\",value:function(){var t=[];return this.points.forEach(function(e){return t.push(e.x,e.y)}),t}},{key:\"getClipperPoints\",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,e=[];return this.points.forEach(function(i){return e.push({X:parseInt(i.x*t),Y:parseInt(i.y*t)})}),e}},{key:\"fromClipperPoints\",value:function(t){var e=this,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return this.points=[],t.forEach(function(t){return e.addPoint(parseFloat(t.X*i),parseFloat(t.Y*i))}),this}},{key:\"getPoint\",value:function(t){return this.points[t<0?this.length+t:t]||null}},{key:\"addPoint\",value:function(t,e){this.points.push(new r(t,e)),this.length=this.points.length}},{key:\"addPoints\",value:function(t){for(var e=0,i=t.length;e<i;e+=2)this.addPoint(t[e],t[e+1])}},{key:\"isClosed\",value:function(){var t=this.getPoint(0);return t&&t.isEqual(this.getPoint(-1))}},{key:\"close\",value:function(){if(!this.isClosed()&&this.length>2){var t=this.getPoint(0);return this.addPoint(t.x,t.y),!0}return!1}},{key:\"transform\",value:function(t){this.points=this.points.map(function(e){return new r(t[0]*e.x+t[2]*e.y+t[4],t[1]*e.x+t[3]*e.y+t[5])})}}]),t}();e.Path=s,e.Point=r,e.default=s}])})}])});\n//# sourceMappingURL=lw.svg-curves.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/lw.svg-curves/dist/lw.svg-curves.js\n// module id = 6\n// module chunks = 0"],"sourceRoot":""}